/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/ansi-html/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ansi-html/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),

/***/ "./node_modules/core-js/fn/set-immediate.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/fn/set-immediate.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/modules/_core.js").setImmediate;


/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.2' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_invoke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_task.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");
var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js");
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),

/***/ "./node_modules/html-entities/index.js":
/*!*********************************************!*\
  !*** ./node_modules/html-entities/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(/*! ./lib/xml-entities.js */ "./node_modules/html-entities/lib/xml-entities.js"),
  Html4Entities: __webpack_require__(/*! ./lib/html4-entities.js */ "./node_modules/html-entities/lib/html4-entities.js"),
  Html5Entities: __webpack_require__(/*! ./lib/html5-entities.js */ "./node_modules/html-entities/lib/html5-entities.js"),
  AllHtmlEntities: __webpack_require__(/*! ./lib/html5-entities.js */ "./node_modules/html-entities/lib/html5-entities.js")
};


/***/ }),

/***/ "./node_modules/html-entities/lib/html4-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html4-entities.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),

/***/ "./node_modules/html-entities/lib/html5-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html5-entities.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),

/***/ "./node_modules/html-entities/lib/xml-entities.js":
/*!********************************************************!*\
  !*** ./node_modules/html-entities/lib/xml-entities.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),

/***/ "./node_modules/image-q/dist/esm/basicAPI.js":
/*!***************************************************!*\
  !*** ./node_modules/image-q/dist/esm/basicAPI.js ***!
  \***************************************************/
/*! exports provided: buildPaletteSync, buildPalette, applyPaletteSync, applyPalette */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildPaletteSync", function() { return buildPaletteSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildPalette", function() { return buildPalette; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPaletteSync", function() { return applyPaletteSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPalette", function() { return applyPalette; });
/* harmony import */ var core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/fn/set-immediate */ "./node_modules/core-js/fn/set-immediate.js");
/* harmony import */ var core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _distance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distance */ "./node_modules/image-q/dist/esm/distance/index.js");
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./image */ "./node_modules/image-q/dist/esm/image/index.js");
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./palette */ "./node_modules/image-q/dist/esm/palette/index.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * helper.ts - part of Image Quantization Library
 */




function buildPaletteSync(images, { colorDistanceFormula, paletteQuantization, colors } = {}) {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
    images.forEach(image => paletteQuantizer.sample(image));
    return paletteQuantizer.quantizeSync();
}
async function buildPalette(images, { colorDistanceFormula, paletteQuantization, colors, onProgress } = {}) {
    return new Promise((resolve, reject) => {
        const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
        const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
        images.forEach(image => paletteQuantizer.sample(image));
        let palette;
        let timerId;
        const iterator = paletteQuantizer.quantize();
        const next = () => {
            try {
                const result = iterator.next();
                if (result.done) {
                    resolve(palette);
                }
                else {
                    if (result.value.palette)
                        palette = result.value.palette;
                    if (onProgress)
                        onProgress(result.value.progress);
                    timerId = core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__(next);
                }
            }
            catch (error) {
                clearTimeout(timerId);
                reject(error);
            }
        };
        timerId = core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__(next);
    });
}
function applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
    return imageQuantizer.quantizeSync(image, palette);
}
async function applyPalette(image, palette, { colorDistanceFormula, imageQuantization, onProgress } = {}) {
    return new Promise((resolve, reject) => {
        const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
        const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
        let outPointContainer;
        let timerId;
        const iterator = imageQuantizer.quantize(image, palette);
        const next = () => {
            try {
                const result = iterator.next();
                if (result.done) {
                    resolve(outPointContainer);
                }
                else {
                    if (result.value.pointContainer)
                        outPointContainer = result.value.pointContainer;
                    if (onProgress)
                        onProgress(result.value.progress);
                    timerId = core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__(next);
                }
            }
            catch (error) {
                clearTimeout(timerId);
                reject(error);
            }
        };
        timerId = core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__(next);
    });
}
function colorDistanceFormulaToColorDistance(colorDistanceFormula = 'euclidean-bt709') {
    switch (colorDistanceFormula) {
        case 'cie94-graphic-arts': return new _distance__WEBPACK_IMPORTED_MODULE_1__["CIE94GraphicArts"]();
        case 'cie94-textiles': return new _distance__WEBPACK_IMPORTED_MODULE_1__["CIE94Textiles"]();
        case 'ciede2000': return new _distance__WEBPACK_IMPORTED_MODULE_1__["CIEDE2000"]();
        case 'color-metric': return new _distance__WEBPACK_IMPORTED_MODULE_1__["CMetric"]();
        case 'euclidean': return new _distance__WEBPACK_IMPORTED_MODULE_1__["Euclidean"]();
        case 'euclidean-bt709': return new _distance__WEBPACK_IMPORTED_MODULE_1__["EuclideanBT709"]();
        case 'euclidean-bt709-noalpha': return new _distance__WEBPACK_IMPORTED_MODULE_1__["EuclideanBT709NoAlpha"]();
        case 'manhattan': return new _distance__WEBPACK_IMPORTED_MODULE_1__["Manhattan"]();
        case 'manhattan-bt709': return new _distance__WEBPACK_IMPORTED_MODULE_1__["ManhattanBT709"]();
        case 'manhattan-nommyde': return new _distance__WEBPACK_IMPORTED_MODULE_1__["ManhattanNommyde"]();
        case 'pngquant': return new _distance__WEBPACK_IMPORTED_MODULE_1__["PNGQuant"]();
        default: throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
    }
}
function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = 'floyd-steinberg') {
    switch (imageQuantization) {
        case 'nearest': return new _image__WEBPACK_IMPORTED_MODULE_2__["NearestColor"](distanceCalculator);
        case 'riemersma': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionRiemersma"](distanceCalculator);
        case 'floyd-steinberg': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].FloydSteinberg);
        case 'false-floyd-steinberg': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].FalseFloydSteinberg);
        case 'stucki': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].Stucki);
        case 'atkinson': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].Atkinson);
        case 'jarvis': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].Jarvis);
        case 'burkes': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].Burkes);
        case 'sierra': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].Sierra);
        case 'two-sierra': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].TwoSierra);
        case 'sierra-lite': return new _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"].SierraLite);
        default: throw new Error(`Unknown imageQuantization ${imageQuantization}`);
    }
}
function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = 'wuquant', colors = 256) {
    switch (paletteQuantization) {
        case 'neuquant': return new _palette__WEBPACK_IMPORTED_MODULE_3__["NeuQuant"](distanceCalculator, colors);
        case 'rgbquant': return new _palette__WEBPACK_IMPORTED_MODULE_3__["RGBQuant"](distanceCalculator, colors);
        case 'wuquant': return new _palette__WEBPACK_IMPORTED_MODULE_3__["WuQuant"](distanceCalculator, colors);
        case 'neuquant-float': return new _palette__WEBPACK_IMPORTED_MODULE_3__["NeuQuantFloat"](distanceCalculator, colors);
        default: throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
    }
}
//# sourceMappingURL=basicAPI.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/constants/bt709.js":
/*!**********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/constants/bt709.js ***!
  \**********************************************************/
/*! exports provided: Y, x, y */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y", function() { return Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return y; });
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */
/**
 * sRGB (based on ITU-R Recommendation BT.709)
 * http://en.wikipedia.org/wiki/SRGB
 */
var Y;
(function (Y) {
    Y[Y["RED"] = 0.2126] = "RED";
    Y[Y["GREEN"] = 0.7152] = "GREEN";
    Y[Y["BLUE"] = 0.0722] = "BLUE";
    Y[Y["WHITE"] = 1] = "WHITE";
})(Y || (Y = {}));
// tslint:disable-next-line:naming-convention
var x;
(function (x) {
    x[x["RED"] = 0.64] = "RED";
    x[x["GREEN"] = 0.3] = "GREEN";
    x[x["BLUE"] = 0.15] = "BLUE";
    x[x["WHITE"] = 0.3127] = "WHITE";
})(x || (x = {}));
// tslint:disable-next-line:naming-convention
var y;
(function (y) {
    y[y["RED"] = 0.33] = "RED";
    y[y["GREEN"] = 0.6] = "GREEN";
    y[y["BLUE"] = 0.06] = "BLUE";
    y[y["WHITE"] = 0.329] = "WHITE";
})(y || (y = {}));
//# sourceMappingURL=bt709.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/constants/index.js ***!
  \**********************************************************/
/*! exports provided: bt709 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bt709__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bt709 */ "./node_modules/image-q/dist/esm/constants/bt709.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "bt709", function() { return _bt709__WEBPACK_IMPORTED_MODULE_0__; });
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/conversion/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/conversion/index.js ***!
  \***********************************************************/
/*! exports provided: rgb2xyz, rgb2hsl, rgb2lab, lab2xyz, lab2rgb, xyz2lab, xyz2rgb */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rgb2xyz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rgb2xyz */ "./node_modules/image-q/dist/esm/conversion/rgb2xyz.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb2xyz", function() { return _rgb2xyz__WEBPACK_IMPORTED_MODULE_0__["rgb2xyz"]; });

/* harmony import */ var _rgb2hsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb2hsl */ "./node_modules/image-q/dist/esm/conversion/rgb2hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb2hsl", function() { return _rgb2hsl__WEBPACK_IMPORTED_MODULE_1__["rgb2hsl"]; });

/* harmony import */ var _rgb2lab__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rgb2lab */ "./node_modules/image-q/dist/esm/conversion/rgb2lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb2lab", function() { return _rgb2lab__WEBPACK_IMPORTED_MODULE_2__["rgb2lab"]; });

/* harmony import */ var _lab2xyz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lab2xyz */ "./node_modules/image-q/dist/esm/conversion/lab2xyz.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab2xyz", function() { return _lab2xyz__WEBPACK_IMPORTED_MODULE_3__["lab2xyz"]; });

/* harmony import */ var _lab2rgb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lab2rgb */ "./node_modules/image-q/dist/esm/conversion/lab2rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab2rgb", function() { return _lab2rgb__WEBPACK_IMPORTED_MODULE_4__["lab2rgb"]; });

/* harmony import */ var _xyz2lab__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xyz2lab */ "./node_modules/image-q/dist/esm/conversion/xyz2lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xyz2lab", function() { return _xyz2lab__WEBPACK_IMPORTED_MODULE_5__["xyz2lab"]; });

/* harmony import */ var _xyz2rgb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./xyz2rgb */ "./node_modules/image-q/dist/esm/conversion/xyz2rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xyz2rgb", function() { return _xyz2rgb__WEBPACK_IMPORTED_MODULE_6__["xyz2rgb"]; });

/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/conversion/lab2rgb.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/conversion/lab2rgb.js ***!
  \*************************************************************/
/*! exports provided: lab2rgb */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lab2rgb", function() { return lab2rgb; });
/* harmony import */ var _lab2xyz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lab2xyz */ "./node_modules/image-q/dist/esm/conversion/lab2xyz.js");
/* harmony import */ var _xyz2rgb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xyz2rgb */ "./node_modules/image-q/dist/esm/conversion/xyz2rgb.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */


// tslint:disable-next-line:naming-convention
function lab2rgb(L, a, b) {
    const xyz = Object(_lab2xyz__WEBPACK_IMPORTED_MODULE_0__["lab2xyz"])(L, a, b);
    return Object(_xyz2rgb__WEBPACK_IMPORTED_MODULE_1__["xyz2rgb"])(xyz.x, xyz.y, xyz.z);
}
//# sourceMappingURL=lab2rgb.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/conversion/lab2xyz.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/conversion/lab2xyz.js ***!
  \*************************************************************/
/*! exports provided: lab2xyz */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lab2xyz", function() { return lab2xyz; });
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */
const refX = 0.95047; // ref_X =  95.047   Observer= 2, Illuminant = D65
const refY = 1.00000; // ref_Y = 100.000
const refZ = 1.08883; // ref_Z = 108.883
function pivot(n) {
    return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
}
// tslint:disable-next-line:naming-convention
function lab2xyz(L, a, b) {
    const y = (L + 16) / 116;
    const x = a / 500 + y;
    const z = y - b / 200;
    return {
        x: refX * pivot(x),
        y: refY * pivot(y),
        z: refZ * pivot(z),
    };
}
//# sourceMappingURL=lab2xyz.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/conversion/rgb2hsl.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/conversion/rgb2hsl.js ***!
  \*************************************************************/
/*! exports provided: rgb2hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2hsl", function() { return rgb2hsl; });
/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */

/**
 * Calculate HSL from RGB
 * Hue is in degrees [0..360]
 * Lightness: [0..1]
 * Saturation: [0..1]
 * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/
 */
function rgb2hsl(r, g, b) {
    const min = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__["min3"])(r, g, b);
    const max = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__["max3"])(r, g, b);
    const delta = max - min;
    const l = (min + max) / 510;
    let s = 0;
    if (l > 0 && l < 1)
        s = delta / (l < 0.5 ? (max + min) : (510 - max - min));
    let h = 0;
    if (delta > 0) {
        if (max === r) {
            h = (g - b) / delta;
        }
        else if (max === g) {
            h = (2 + (b - r) / delta);
        }
        else {
            h = (4 + (r - g) / delta);
        }
        h *= 60;
        if (h < 0)
            h += 360;
    }
    return { h, s, l };
}
//# sourceMappingURL=rgb2hsl.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/conversion/rgb2lab.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/conversion/rgb2lab.js ***!
  \*************************************************************/
/*! exports provided: rgb2lab */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2lab", function() { return rgb2lab; });
/* harmony import */ var _rgb2xyz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rgb2xyz */ "./node_modules/image-q/dist/esm/conversion/rgb2xyz.js");
/* harmony import */ var _xyz2lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xyz2lab */ "./node_modules/image-q/dist/esm/conversion/xyz2lab.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */


function rgb2lab(r, g, b) {
    const xyz = Object(_rgb2xyz__WEBPACK_IMPORTED_MODULE_0__["rgb2xyz"])(r, g, b);
    return Object(_xyz2lab__WEBPACK_IMPORTED_MODULE_1__["xyz2lab"])(xyz.x, xyz.y, xyz.z);
}
//# sourceMappingURL=rgb2lab.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/conversion/rgb2xyz.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/conversion/rgb2xyz.js ***!
  \*************************************************************/
/*! exports provided: rgb2xyz */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2xyz", function() { return rgb2xyz; });
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */
function correctGamma(n) {
    return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
}
function rgb2xyz(r, g, b) {
    // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation
    r = correctGamma(r / 255);
    g = correctGamma(g / 255);
    b = correctGamma(b / 255);
    // Observer. = 2, Illuminant = D65
    return {
        x: r * 0.4124 + g * 0.3576 + b * 0.1805,
        y: r * 0.2126 + g * 0.7152 + b * 0.0722,
        z: r * 0.0193 + g * 0.1192 + b * 0.9505,
    };
}
//# sourceMappingURL=rgb2xyz.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/conversion/xyz2lab.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/conversion/xyz2lab.js ***!
  \*************************************************************/
/*! exports provided: xyz2lab */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyz2lab", function() { return xyz2lab; });
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */
const refX = 0.95047; // ref_X =  95.047   Observer= 2, Illuminant= D65
const refY = 1.00000; // ref_Y = 100.000
const refZ = 1.08883; // ref_Z = 108.883
function pivot(n) {
    return n > 0.008856 ? Math.pow(n, 1 / 3) : (7.787 * n + 16 / 116);
}
function xyz2lab(x, y, z) {
    x = pivot(x / refX);
    y = pivot(y / refY);
    z = pivot(z / refZ);
    if ((116 * y) - 16 < 0)
        throw new Error('xxx');
    return {
        L: Math.max(0, (116 * y) - 16),
        a: 500 * (x - y),
        b: 200 * (y - z),
    };
}
//# sourceMappingURL=xyz2lab.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/conversion/xyz2rgb.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/conversion/xyz2rgb.js ***!
  \*************************************************************/
/*! exports provided: xyz2rgb */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyz2rgb", function() { return xyz2rgb; });
/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */

// gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation
function correctGamma(n) {
    return n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
}
function xyz2rgb(x, y, z) {
    // Observer. = 2, Illuminant = D65
    const r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986);
    const g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415);
    const b = correctGamma(x * 0.0557 + y * -0.2040 + z * 1.0570);
    return {
        r: Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__["inRange0to255Rounded"])(r * 255),
        g: Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__["inRange0to255Rounded"])(g * 255),
        b: Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__["inRange0to255Rounded"])(b * 255),
    };
}
//# sourceMappingURL=xyz2rgb.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/distance/cie94.js":
/*!*********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/distance/cie94.js ***!
  \*********************************************************/
/*! exports provided: AbstractCIE94, CIE94Textiles, CIE94GraphicArts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractCIE94", function() { return AbstractCIE94; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CIE94Textiles", function() { return CIE94Textiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CIE94GraphicArts", function() { return CIE94GraphicArts; });
/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ "./node_modules/image-q/dist/esm/distance/distanceCalculator.js");
/* harmony import */ var _conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conversion/rgb2lab */ "./node_modules/image-q/dist/esm/conversion/rgb2lab.js");
/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */



/**
 * CIE94 method of delta-e
 * http://en.wikipedia.org/wiki/Color_difference#CIE94
 */
class AbstractCIE94 extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__["AbstractDistanceCalculator"] {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const lab1 = Object(_conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__["rgb2lab"])(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(r1 * this._whitePoint.r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(g1 * this._whitePoint.g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(b1 * this._whitePoint.b));
        const lab2 = Object(_conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__["rgb2lab"])(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(r2 * this._whitePoint.r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(g2 * this._whitePoint.g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(b2 * this._whitePoint.b));
        const dL = lab1.L - lab2.L;
        const dA = lab1.a - lab2.a;
        const dB = lab1.b - lab2.b;
        const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
        const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
        const dC = c1 - c2;
        let deltaH = dA * dA + dB * dB - dC * dC;
        deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
        const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
        // TODO: add alpha channel support
        return Math.sqrt(Math.pow(dL / this._Kl, 2) +
            Math.pow(dC / (1.0 + this._K1 * c1), 2) +
            Math.pow(deltaH / (1.0 + this._K2 * c1), 2) +
            Math.pow(dAlpha, 2));
    }
}
class CIE94Textiles extends AbstractCIE94 {
    _setDefaults() {
        this._Kl = 2.0;
        this._K1 = 0.048;
        this._K2 = 0.014;
        this._kA = 0.25 * 50 / 255;
    }
}
class CIE94GraphicArts extends AbstractCIE94 {
    _setDefaults() {
        this._Kl = 1.0;
        this._K1 = 0.045;
        this._K2 = 0.015;
        this._kA = 0.25 * 100 / 255;
    }
}
//# sourceMappingURL=cie94.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/distance/ciede2000.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/distance/ciede2000.js ***!
  \*************************************************************/
/*! exports provided: CIEDE2000 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CIEDE2000", function() { return CIEDE2000; });
/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ "./node_modules/image-q/dist/esm/distance/distanceCalculator.js");
/* harmony import */ var _conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conversion/rgb2lab */ "./node_modules/image-q/dist/esm/conversion/rgb2lab.js");
/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */



// tslint:disable:variable-name
// tslint:disable:naming-convention
/**
 * CIEDE2000 algorithm - Adapted from Sharma et al's MATLAB implementation at
 * http://www.ece.rochester.edu/~gsharma/ciede2000/
 */
class CIEDE2000 extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__["AbstractDistanceCalculator"] {
    _setDefaults() { }
    static _calculatehp(b, ap) {
        const hp = Math.atan2(b, ap);
        if (hp >= 0)
            return hp;
        return hp + CIEDE2000._deg360InRad;
    }
    static _calculateRT(ahp, aCp) {
        const aCp_to_7 = Math.pow(aCp, 7.0);
        const R_C = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)); // 25^7
        const delta_theta = CIEDE2000._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad, 2.0));
        return -Math.sin(2.0 * delta_theta) * R_C;
    }
    static _calculateT(ahp) {
        return 1.0 - .17 * Math.cos(ahp - CIEDE2000._deg30InRad) + .24 * Math.cos(ahp * 2.0) + .32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) - .2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad);
    }
    static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
        const hpSum = h1p + h2p;
        if (C1pC2p === 0)
            return hpSum;
        if (h_bar <= CIEDE2000._deg180InRad)
            return hpSum / 2.0;
        if (hpSum < CIEDE2000._deg360InRad)
            return (hpSum + CIEDE2000._deg360InRad) / 2.0;
        return (hpSum - CIEDE2000._deg360InRad) / 2.0;
    }
    static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
        let dhp;
        if (C1pC2p === 0) {
            dhp = 0;
        }
        else if (h_bar <= CIEDE2000._deg180InRad) {
            dhp = h2p - h1p;
        }
        else if (h2p <= h1p) {
            dhp = h2p - h1p + CIEDE2000._deg360InRad;
        }
        else {
            dhp = h2p - h1p - CIEDE2000._deg360InRad;
        }
        return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);
    }
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const lab1 = Object(_conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__["rgb2lab"])(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(r1 * this._whitePoint.r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(g1 * this._whitePoint.g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(b1 * this._whitePoint.b));
        const lab2 = Object(_conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__["rgb2lab"])(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(r2 * this._whitePoint.r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(g2 * this._whitePoint.g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255"])(b2 * this._whitePoint.b));
        const dA = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA;
        const dE2 = this.calculateRawInLab(lab1, lab2);
        return Math.sqrt(dE2 + dA * dA);
    }
    calculateRawInLab(Lab1, Lab2) {
        // Get L,a,b values for color 1
        const L1 = Lab1.L;
        const a1 = Lab1.a;
        const b1 = Lab1.b;
        // Get L,a,b values for color 2
        const L2 = Lab2.L;
        const a2 = Lab2.a;
        const b2 = Lab2.b;
        // Calculate Cprime1, Cprime2, Cabbar
        const C1 = Math.sqrt(a1 * a1 + b1 * b1);
        const C2 = Math.sqrt(a2 * a2 + b2 * b2);
        const pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2.0, 7.0);
        const G = 0.5 * (1.0 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))); // 25^7
        const a1p = (1.0 + G) * a1;
        const a2p = (1.0 + G) * a2;
        const C1p = Math.sqrt(a1p * a1p + b1 * b1);
        const C2p = Math.sqrt(a2p * a2p + b2 * b2);
        const C1pC2p = C1p * C2p;
        // Angles in Degree.
        const h1p = CIEDE2000._calculatehp(b1, a1p);
        const h2p = CIEDE2000._calculatehp(b2, a2p);
        const h_bar = Math.abs(h1p - h2p);
        const dLp = L2 - L1;
        const dCp = C2p - C1p;
        const dHp = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
        const ahp = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
        const T = CIEDE2000._calculateT(ahp);
        const aCp = (C1p + C2p) / 2.0;
        const aLp_minus_50_square = Math.pow((L1 + L2) / 2.0 - 50.0, 2.0);
        const S_L = 1.0 + (.015 * aLp_minus_50_square) / Math.sqrt(20.0 + aLp_minus_50_square);
        const S_C = 1.0 + .045 * aCp;
        const S_H = 1.0 + .015 * T * aCp;
        const R_T = CIEDE2000._calculateRT(ahp, aCp);
        const dLpSL = dLp / S_L; // S_L * kL, where kL is 1.0
        const dCpSC = dCp / S_C; // S_C * kC, where kC is 1.0
        const dHpSH = dHp / S_H; // S_H * kH, where kH is 1.0
        return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;
    }
}
/**
 * Weight in distance: 0.25
 * Max DeltaE: 100
 * Max DeltaA: 255
 */
CIEDE2000._kA = 0.25 * 100 / 255;
CIEDE2000._pow25to7 = Math.pow(25, 7);
CIEDE2000._deg360InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["degrees2radians"])(360);
CIEDE2000._deg180InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["degrees2radians"])(180);
CIEDE2000._deg30InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["degrees2radians"])(30);
CIEDE2000._deg6InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["degrees2radians"])(6);
CIEDE2000._deg63InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["degrees2radians"])(63);
CIEDE2000._deg275InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["degrees2radians"])(275);
CIEDE2000._deg25InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["degrees2radians"])(25);
//# sourceMappingURL=ciede2000.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/distance/cmetric.js":
/*!***********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/distance/cmetric.js ***!
  \***********************************************************/
/*! exports provided: CMetric */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CMetric", function() { return CMetric; });
/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ "./node_modules/image-q/dist/esm/distance/distanceCalculator.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */

/**
 * TODO: Name it: http://www.compuphase.com/cmetric.htm
 */
class CMetric extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__["AbstractDistanceCalculator"] {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const rmean = (r1 + r2) / 2 * this._whitePoint.r;
        const r = (r1 - r2) * this._whitePoint.r;
        const g = (g1 - g2) * this._whitePoint.g;
        const b = (b1 - b2) * this._whitePoint.b;
        const dE = ((((512 + rmean) * r * r) >> 8) + 4 * g * g + (((767 - rmean) * b * b) >> 8));
        const dA = (a2 - a1) * this._whitePoint.a;
        return Math.sqrt(dE + dA * dA);
    }
    _setDefaults() { }
}
//# sourceMappingURL=cmetric.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/distance/distanceCalculator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/distance/distanceCalculator.js ***!
  \**********************************************************************/
/*! exports provided: AbstractDistanceCalculator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractDistanceCalculator", function() { return AbstractDistanceCalculator; });
class AbstractDistanceCalculator {
    constructor() {
        this._setDefaults();
        // set default maximal color component deltas (255 - 0 = 255)
        this.setWhitePoint(255, 255, 255, 255);
    }
    setWhitePoint(r, g, b, a) {
        this._whitePoint = {
            r: (r > 0) ? 255 / r : 0,
            g: (g > 0) ? 255 / g : 0,
            b: (b > 0) ? 255 / b : 0,
            a: (a > 0) ? 255 / a : 0,
        };
        this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
    }
    calculateNormalized(colorA, colorB) {
        return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
    }
}
//# sourceMappingURL=distanceCalculator.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/distance/euclidean.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/distance/euclidean.js ***!
  \*************************************************************/
/*! exports provided: AbstractEuclidean, Euclidean, EuclideanBT709, EuclideanBT709NoAlpha */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractEuclidean", function() { return AbstractEuclidean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euclidean", function() { return Euclidean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EuclideanBT709", function() { return EuclideanBT709; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EuclideanBT709NoAlpha", function() { return EuclideanBT709NoAlpha; });
/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ "./node_modules/image-q/dist/esm/distance/distanceCalculator.js");
/* harmony import */ var _constants_bt709__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/bt709 */ "./node_modules/image-q/dist/esm/constants/bt709.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */


/**
 * Euclidean color distance
 */
class AbstractEuclidean extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__["AbstractDistanceCalculator"] {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const dR = r2 - r1;
        const dG = g2 - g1;
        const dB = b2 - b1;
        const dA = a2 - a1;
        return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
    }
}
class Euclidean extends AbstractEuclidean {
    _setDefaults() {
        this._kR = 1;
        this._kG = 1;
        this._kB = 1;
        this._kA = 1;
    }
}
/**
 * Euclidean color distance (RGBQuant modification w Alpha)
 */
class EuclideanBT709 extends AbstractEuclidean {
    _setDefaults() {
        this._kR = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].RED;
        this._kG = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].GREEN;
        this._kB = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].BLUE;
        // TODO: what is the best coefficient below?
        this._kA = 1;
    }
}
/**
 * Euclidean color distance (RGBQuant modification w/o Alpha)
 */
class EuclideanBT709NoAlpha extends AbstractEuclidean {
    _setDefaults() {
        this._kR = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].RED;
        this._kG = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].GREEN;
        this._kB = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].BLUE;
        this._kA = 0;
    }
}
//# sourceMappingURL=euclidean.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/distance/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/distance/index.js ***!
  \*********************************************************/
/*! exports provided: AbstractDistanceCalculator, CIE94Textiles, CIE94GraphicArts, CIEDE2000, CMetric, AbstractEuclidean, Euclidean, EuclideanBT709NoAlpha, EuclideanBT709, AbstractManhattan, Manhattan, ManhattanBT709, ManhattanNommyde, PNGQuant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ "./node_modules/image-q/dist/esm/distance/distanceCalculator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbstractDistanceCalculator", function() { return _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__["AbstractDistanceCalculator"]; });

/* harmony import */ var _cie94__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cie94 */ "./node_modules/image-q/dist/esm/distance/cie94.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CIE94Textiles", function() { return _cie94__WEBPACK_IMPORTED_MODULE_1__["CIE94Textiles"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CIE94GraphicArts", function() { return _cie94__WEBPACK_IMPORTED_MODULE_1__["CIE94GraphicArts"]; });

/* harmony import */ var _ciede2000__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciede2000 */ "./node_modules/image-q/dist/esm/distance/ciede2000.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CIEDE2000", function() { return _ciede2000__WEBPACK_IMPORTED_MODULE_2__["CIEDE2000"]; });

/* harmony import */ var _cmetric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cmetric */ "./node_modules/image-q/dist/esm/distance/cmetric.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CMetric", function() { return _cmetric__WEBPACK_IMPORTED_MODULE_3__["CMetric"]; });

/* harmony import */ var _euclidean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./euclidean */ "./node_modules/image-q/dist/esm/distance/euclidean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbstractEuclidean", function() { return _euclidean__WEBPACK_IMPORTED_MODULE_4__["AbstractEuclidean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Euclidean", function() { return _euclidean__WEBPACK_IMPORTED_MODULE_4__["Euclidean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EuclideanBT709NoAlpha", function() { return _euclidean__WEBPACK_IMPORTED_MODULE_4__["EuclideanBT709NoAlpha"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EuclideanBT709", function() { return _euclidean__WEBPACK_IMPORTED_MODULE_4__["EuclideanBT709"]; });

/* harmony import */ var _manhattan__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./manhattan */ "./node_modules/image-q/dist/esm/distance/manhattan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbstractManhattan", function() { return _manhattan__WEBPACK_IMPORTED_MODULE_5__["AbstractManhattan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Manhattan", function() { return _manhattan__WEBPACK_IMPORTED_MODULE_5__["Manhattan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ManhattanBT709", function() { return _manhattan__WEBPACK_IMPORTED_MODULE_5__["ManhattanBT709"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ManhattanNommyde", function() { return _manhattan__WEBPACK_IMPORTED_MODULE_5__["ManhattanNommyde"]; });

/* harmony import */ var _pngQuant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pngQuant */ "./node_modules/image-q/dist/esm/distance/pngQuant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PNGQuant", function() { return _pngQuant__WEBPACK_IMPORTED_MODULE_6__["PNGQuant"]; });

/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/distance/manhattan.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/distance/manhattan.js ***!
  \*************************************************************/
/*! exports provided: AbstractManhattan, Manhattan, ManhattanNommyde, ManhattanBT709 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractManhattan", function() { return AbstractManhattan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Manhattan", function() { return Manhattan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ManhattanNommyde", function() { return ManhattanNommyde; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ManhattanBT709", function() { return ManhattanBT709; });
/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ "./node_modules/image-q/dist/esm/distance/distanceCalculator.js");
/* harmony import */ var _constants_bt709__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/bt709 */ "./node_modules/image-q/dist/esm/constants/bt709.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */


/**
 * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients
 */
class AbstractManhattan extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__["AbstractDistanceCalculator"] {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        let dR = r2 - r1;
        let dG = g2 - g1;
        let dB = b2 - b1;
        let dA = a2 - a1;
        if (dR < 0)
            dR = 0 - dR;
        if (dG < 0)
            dG = 0 - dG;
        if (dB < 0)
            dB = 0 - dB;
        if (dA < 0)
            dA = 0 - dA;
        return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
    }
}
class Manhattan extends AbstractManhattan {
    _setDefaults() {
        this._kR = 1;
        this._kG = 1;
        this._kB = 1;
        this._kA = 1;
    }
}
/**
 * Manhattan distance (Nommyde modification)
 * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320
 */
class ManhattanNommyde extends AbstractManhattan {
    _setDefaults() {
        this._kR = 0.4984;
        this._kG = 0.8625;
        this._kB = 0.2979;
        // TODO: what is the best coefficient below?
        this._kA = 1;
    }
}
/**
 * Manhattan distance (sRGB coefficients)
 */
class ManhattanBT709 extends AbstractManhattan {
    _setDefaults() {
        this._kR = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].RED;
        this._kG = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].GREEN;
        this._kB = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__["Y"].BLUE;
        // TODO: what is the best coefficient below?
        this._kA = 1;
    }
}
//# sourceMappingURL=manhattan.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/distance/pngQuant.js":
/*!************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/distance/pngQuant.js ***!
  \************************************************************/
/*! exports provided: PNGQuant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PNGQuant", function() { return PNGQuant; });
/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ "./node_modules/image-q/dist/esm/distance/distanceCalculator.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */

/**
 * TODO: check quality of this distance equation
 * TODO: ask author for usage rights
 * taken from:
 * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}
 * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}
 */
class PNGQuant extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__["AbstractDistanceCalculator"] {
    /**
     * Author's comments
     * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black
     * px_b.a   = px.a   + 1*(1-px.a)
     * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white
     * px_w.a   = px.a   + 1*(1-px.a)
     *
     * px_b.rgb = px.rgb              // difference same as in opaque RGB
     * px_b.a   = 1
     * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below
     * px_w.a   = 1
     *
     * (px.rgb - px.a) - (py.rgb - py.a)
     * (px.rgb - py.rgb) + (py.a - px.a)
     *
     */
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const alphas = (a2 - a1) * this._whitePoint.a;
        return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) +
            this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) +
            this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
    }
    _colordifferenceCh(x, y, alphas) {
        // maximum of channel blended on white, and blended on black
        // premultiplied alpha and backgrounds 0/1 shorten the formula
        const black = x - y;
        const white = black + alphas;
        return black * black + white * white;
    }
    _setDefaults() { }
}
//# sourceMappingURL=pngQuant.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/image-q.js":
/*!**************************************************!*\
  !*** ./node_modules/image-q/dist/esm/image-q.js ***!
  \**************************************************/
/*! exports provided: buildPalette, buildPaletteSync, applyPalette, applyPaletteSync, constants, conversion, distance, palette, image, quality, utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/image-q/dist/esm/constants/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "constants", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _conversion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conversion */ "./node_modules/image-q/dist/esm/conversion/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "conversion", function() { return _conversion__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _distance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./distance */ "./node_modules/image-q/dist/esm/distance/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return _distance__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./palette */ "./node_modules/image-q/dist/esm/palette/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "palette", function() { return _palette__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./image */ "./node_modules/image-q/dist/esm/image/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "image", function() { return _image__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _quality__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quality */ "./node_modules/image-q/dist/esm/quality/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quality", function() { return _quality__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ "./node_modules/image-q/dist/esm/utils/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _basicAPI__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./basicAPI */ "./node_modules/image-q/dist/esm/basicAPI.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildPalette", function() { return _basicAPI__WEBPACK_IMPORTED_MODULE_7__["buildPalette"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildPaletteSync", function() { return _basicAPI__WEBPACK_IMPORTED_MODULE_7__["buildPaletteSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyPalette", function() { return _basicAPI__WEBPACK_IMPORTED_MODULE_7__["applyPalette"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyPaletteSync", function() { return _basicAPI__WEBPACK_IMPORTED_MODULE_7__["applyPaletteSync"]; });

/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */









//# sourceMappingURL=image-q.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/image/array.js":
/*!******************************************************!*\
  !*** ./node_modules/image-q/dist/esm/image/array.js ***!
  \******************************************************/
/*! exports provided: ErrorDiffusionArrayKernel, ErrorDiffusionArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorDiffusionArrayKernel", function() { return ErrorDiffusionArrayKernel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorDiffusionArray", function() { return ErrorDiffusionArray; });
/* harmony import */ var _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageQuantizer */ "./node_modules/image-q/dist/esm/image/imageQuantizer.js");
/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/point */ "./node_modules/image-q/dist/esm/utils/point.js");
/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/* harmony import */ var _utils_progressTracker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/progressTracker */ "./node_modules/image-q/dist/esm/utils/progressTracker.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
 */




// TODO: is it the best name for this enum "kernel"?
var ErrorDiffusionArrayKernel;
(function (ErrorDiffusionArrayKernel) {
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["FloydSteinberg"] = 0] = "FloydSteinberg";
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Stucki"] = 2] = "Stucki";
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Atkinson"] = 3] = "Atkinson";
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Jarvis"] = 4] = "Jarvis";
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Burkes"] = 5] = "Burkes";
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["Sierra"] = 6] = "Sierra";
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["TwoSierra"] = 7] = "TwoSierra";
    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel["SierraLite"] = 8] = "SierraLite";
})(ErrorDiffusionArrayKernel || (ErrorDiffusionArrayKernel = {}));
// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/
class ErrorDiffusionArray extends _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__["AbstractImageQuantizer"] {
    constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
        super();
        this._setKernel(kernel);
        this._distance = colorDistanceCalculator;
        this._minColorDistance = minimumColorDistanceToDither;
        this._serpentine = serpentine;
        this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
    }
    /**
     * adapted from http://jsbin.com/iXofIji/2/edit by PAEz
     * fixed version. it doesn't use image pixels as error storage, also it doesn't have 0.3 + 0.3 + 0.3 + 0.3 = 0 error
     * Mutates pointContainer
     */
    *quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray();
        const originalPoint = new _utils_point__WEBPACK_IMPORTED_MODULE_1__["Point"]();
        const width = pointContainer.getWidth();
        const height = pointContainer.getHeight();
        const errorLines = [];
        let dir = 1;
        let maxErrorLines = 1;
        // initial error lines (number is taken from dithering kernel)
        for (const kernel of this._kernel) {
            const kernelErrorLines = kernel[2] + 1;
            if (maxErrorLines < kernelErrorLines)
                maxErrorLines = kernelErrorLines;
        }
        for (let i = 0; i < maxErrorLines; i++) {
            this._fillErrorLine(errorLines[i] = [], width);
        }
        const tracker = new _utils_progressTracker__WEBPACK_IMPORTED_MODULE_3__["ProgressTracker"](height, 99);
        for (let y = 0; y < height; y++) {
            if (tracker.shouldNotify(y)) {
                yield {
                    progress: tracker.progress,
                };
            }
            // always serpentine
            if (this._serpentine)
                dir = dir * -1;
            const lni = y * width;
            const xStart = dir === 1 ? 0 : width - 1;
            const xEnd = dir === 1 ? width : -1;
            // cyclic shift with erasing
            this._fillErrorLine(errorLines[0], width);
            // TODO: why it is needed to cast types here?
            errorLines.push(errorLines.shift());
            const errorLine = errorLines[0];
            for (let x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {
                // Image pixel
                const point = pointArray[idx];
                // originalPoint = new Utils.Point(),
                const error = errorLine[x];
                originalPoint.from(point);
                const correctedPoint = _utils_point__WEBPACK_IMPORTED_MODULE_1__["Point"].createByRGBA(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255Rounded"])(point.r + error[0]), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255Rounded"])(point.g + error[1]), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255Rounded"])(point.b + error[2]), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__["inRange0to255Rounded"])(point.a + error[3]));
                // Reduced pixel
                const palettePoint = palette.getNearestColor(this._distance, correctedPoint);
                point.from(palettePoint);
                // dithering strength
                if (this._minColorDistance) {
                    const dist = this._distance.calculateNormalized(point, palettePoint);
                    if (dist < this._minColorDistance)
                        continue;
                }
                // Component distance
                let er;
                let eg;
                let eb;
                let ea;
                if (this._calculateErrorLikeGIMP) {
                    er = correctedPoint.r - palettePoint.r;
                    eg = correctedPoint.g - palettePoint.g;
                    eb = correctedPoint.b - palettePoint.b;
                    ea = correctedPoint.a - palettePoint.a;
                }
                else {
                    er = originalPoint.r - palettePoint.r;
                    eg = originalPoint.g - palettePoint.g;
                    eb = originalPoint.b - palettePoint.b;
                    ea = originalPoint.a - palettePoint.a;
                }
                const dStart = dir === 1 ? 0 : this._kernel.length - 1;
                const dEnd = dir === 1 ? this._kernel.length : -1;
                for (let i = dStart; i !== dEnd; i += dir) {
                    const x1 = this._kernel[i][1] * dir;
                    const y1 = this._kernel[i][2];
                    if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
                        const d = this._kernel[i][0];
                        const e = errorLines[y1][x1 + x];
                        e[0] = e[0] + er * d;
                        e[1] = e[1] + eg * d;
                        e[2] = e[2] + eb * d;
                        e[3] = e[3] + ea * d;
                    }
                }
            }
        }
        yield {
            pointContainer,
            progress: 100,
        };
    }
    _fillErrorLine(errorLine, width) {
        // shrink
        if (errorLine.length > width) {
            errorLine.length = width;
        }
        // reuse existing arrays
        const l = errorLine.length;
        for (let i = 0; i < l; i++) {
            const error = errorLine[i];
            error[0] = error[1] = error[2] = error[3] = 0;
        }
        // create missing arrays
        for (let i = l; i < width; i++) {
            errorLine[i] = [0.0, 0.0, 0.0, 0.0];
        }
    }
    _setKernel(kernel) {
        switch (kernel) {
            case ErrorDiffusionArrayKernel.FloydSteinberg:
                this._kernel = [
                    [7 / 16, 1, 0],
                    [3 / 16, -1, 1],
                    [5 / 16, 0, 1],
                    [1 / 16, 1, 1],
                ];
                break;
            case ErrorDiffusionArrayKernel.FalseFloydSteinberg:
                this._kernel = [
                    [3 / 8, 1, 0],
                    [3 / 8, 0, 1],
                    [2 / 8, 1, 1],
                ];
                break;
            case ErrorDiffusionArrayKernel.Stucki:
                this._kernel = [
                    [8 / 42, 1, 0],
                    [4 / 42, 2, 0],
                    [2 / 42, -2, 1],
                    [4 / 42, -1, 1],
                    [8 / 42, 0, 1],
                    [4 / 42, 1, 1],
                    [2 / 42, 2, 1],
                    [1 / 42, -2, 2],
                    [2 / 42, -1, 2],
                    [4 / 42, 0, 2],
                    [2 / 42, 1, 2],
                    [1 / 42, 2, 2],
                ];
                break;
            case ErrorDiffusionArrayKernel.Atkinson:
                this._kernel = [
                    [1 / 8, 1, 0],
                    [1 / 8, 2, 0],
                    [1 / 8, -1, 1],
                    [1 / 8, 0, 1],
                    [1 / 8, 1, 1],
                    [1 / 8, 0, 2],
                ];
                break;
            case ErrorDiffusionArrayKernel.Jarvis:
                this._kernel = [
                    [7 / 48, 1, 0],
                    [5 / 48, 2, 0],
                    [3 / 48, -2, 1],
                    [5 / 48, -1, 1],
                    [7 / 48, 0, 1],
                    [5 / 48, 1, 1],
                    [3 / 48, 2, 1],
                    [1 / 48, -2, 2],
                    [3 / 48, -1, 2],
                    [5 / 48, 0, 2],
                    [3 / 48, 1, 2],
                    [1 / 48, 2, 2],
                ];
                break;
            case ErrorDiffusionArrayKernel.Burkes:
                this._kernel = [
                    [8 / 32, 1, 0],
                    [4 / 32, 2, 0],
                    [2 / 32, -2, 1],
                    [4 / 32, -1, 1],
                    [8 / 32, 0, 1],
                    [4 / 32, 1, 1],
                    [2 / 32, 2, 1],
                ];
                break;
            case ErrorDiffusionArrayKernel.Sierra:
                this._kernel = [
                    [5 / 32, 1, 0],
                    [3 / 32, 2, 0],
                    [2 / 32, -2, 1],
                    [4 / 32, -1, 1],
                    [5 / 32, 0, 1],
                    [4 / 32, 1, 1],
                    [2 / 32, 2, 1],
                    [2 / 32, -1, 2],
                    [3 / 32, 0, 2],
                    [2 / 32, 1, 2],
                ];
                break;
            case ErrorDiffusionArrayKernel.TwoSierra:
                this._kernel = [
                    [4 / 16, 1, 0],
                    [3 / 16, 2, 0],
                    [1 / 16, -2, 1],
                    [2 / 16, -1, 1],
                    [3 / 16, 0, 1],
                    [2 / 16, 1, 1],
                    [1 / 16, 2, 1],
                ];
                break;
            case ErrorDiffusionArrayKernel.SierraLite:
                this._kernel = [
                    [2 / 4, 1, 0],
                    [1 / 4, -1, 1],
                    [1 / 4, 0, 1],
                ];
                break;
            default:
                throw new Error('ErrorDiffusionArray: unknown kernel = ' + kernel);
        }
    }
}
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/image/imageQuantizer.js":
/*!***************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/image/imageQuantizer.js ***!
  \***************************************************************/
/*! exports provided: AbstractImageQuantizer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractImageQuantizer", function() { return AbstractImageQuantizer; });
class AbstractImageQuantizer {
    quantizeSync(pointContainer, palette) {
        for (const value of this.quantize(pointContainer, palette)) {
            if (value.pointContainer) {
                return value.pointContainer;
            }
        }
        throw new Error('unreachable');
    }
}
//# sourceMappingURL=imageQuantizer.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/image/index.js":
/*!******************************************************!*\
  !*** ./node_modules/image-q/dist/esm/image/index.js ***!
  \******************************************************/
/*! exports provided: AbstractImageQuantizer, NearestColor, ErrorDiffusionArray, ErrorDiffusionArrayKernel, ErrorDiffusionRiemersma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageQuantizer */ "./node_modules/image-q/dist/esm/image/imageQuantizer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbstractImageQuantizer", function() { return _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__["AbstractImageQuantizer"]; });

/* harmony import */ var _nearestColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nearestColor */ "./node_modules/image-q/dist/esm/image/nearestColor.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NearestColor", function() { return _nearestColor__WEBPACK_IMPORTED_MODULE_1__["NearestColor"]; });

/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "./node_modules/image-q/dist/esm/image/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorDiffusionArray", function() { return _array__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorDiffusionArrayKernel", function() { return _array__WEBPACK_IMPORTED_MODULE_2__["ErrorDiffusionArrayKernel"]; });

/* harmony import */ var _riemersma__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./riemersma */ "./node_modules/image-q/dist/esm/image/riemersma.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorDiffusionRiemersma", function() { return _riemersma__WEBPACK_IMPORTED_MODULE_3__["ErrorDiffusionRiemersma"]; });

/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/image/nearestColor.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/image/nearestColor.js ***!
  \*************************************************************/
/*! exports provided: NearestColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestColor", function() { return NearestColor; });
/* harmony import */ var _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageQuantizer */ "./node_modules/image-q/dist/esm/image/imageQuantizer.js");
/* harmony import */ var _utils_progressTracker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/progressTracker */ "./node_modules/image-q/dist/esm/utils/progressTracker.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * nearestColor.ts - part of Image Quantization Library
 */


class NearestColor extends _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__["AbstractImageQuantizer"] {
    constructor(colorDistanceCalculator) {
        super();
        this._distance = colorDistanceCalculator;
    }
    /**
     * Mutates pointContainer
     */
    *quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray();
        const width = pointContainer.getWidth();
        const height = pointContainer.getHeight();
        const tracker = new _utils_progressTracker__WEBPACK_IMPORTED_MODULE_1__["ProgressTracker"](height, 99);
        for (let y = 0; y < height; y++) {
            if (tracker.shouldNotify(y)) {
                yield {
                    progress: tracker.progress,
                };
            }
            for (let x = 0, idx = y * width; x < width; x++, idx++) {
                // Image pixel
                const point = pointArray[idx];
                // Reduced pixel
                point.from(palette.getNearestColor(this._distance, point));
            }
        }
        yield {
            pointContainer,
            progress: 100,
        };
    }
}
//# sourceMappingURL=nearestColor.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/image/riemersma.js":
/*!**********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/image/riemersma.js ***!
  \**********************************************************/
/*! exports provided: ErrorDiffusionRiemersma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorDiffusionRiemersma", function() { return ErrorDiffusionRiemersma; });
/* harmony import */ var _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageQuantizer */ "./node_modules/image-q/dist/esm/image/imageQuantizer.js");
/* harmony import */ var _spaceFillingCurves_hilbertCurve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spaceFillingCurves/hilbertCurve */ "./node_modules/image-q/dist/esm/image/spaceFillingCurves/hilbertCurve.js");
/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/point */ "./node_modules/image-q/dist/esm/utils/point.js");
/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/**
 * @preserve
 * MIT License
 *
 * Copyright 2015-2018 Igor Bezkrovnyi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * riemersma.ts - part of Image Quantization Library
 */




class ErrorDiffusionRiemersma extends _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__["AbstractImageQuantizer"] {
    constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
        super();
        this._distance = colorDistanceCalculator;
        this._errorQueueSize = errorQueueSize;
        this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
    }
    /**
     * Mutates pointContainer
     */
    *quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray();
        const width = pointContainer.getWidth();
        const height = pointContainer.getHeight();
        const errorQueue = [];
        let head = 0;
        for (let i = 0; i < this._errorQueueSize; i++) {
            errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
        }
        yield* Object(_spaceFillingCurves_hilbertCurve__WEBPACK_IMPORTED_MODULE_1__["hilbertCurve"])(width, height, (x, y) => {
            const p = pointArray[x + y * width];
            let r = p.r;
            let g = p.g;
            let b = p.b;
            let a = p.a;
            for (let i = 0; i < this._errorQueueSize; i++) {
                const weight = this._weights[i];
                const e = errorQueue[(i + head) % this._errorQueueSize];
                r += e.r * weight;
                g += e.g * weight;
                b += e.b * weight;
                a += e.a * weight;
            }
            const correctedPoint = _utils_point__WEBPACK_IMPORTED_MODULE_2__["Point"].createByRGBA(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__["inRange0to255Rounded"])(r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__["inRange0to255Rounded"])(g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__["inRange0to255Rounded"])(b), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__["inRange0to255Rounded"])(a));
            const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);
            // update head and calculate tail
            head = (head + 1) % this._errorQueueSize;
            const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
            // update error with new value
            errorQueue[tail].r = p.r - quantizedPoint.r;
            errorQueue[tail].g = p.g - quantizedPoint.g;
            errorQueue[tail].b = p.b - quantizedPoint.b;
            errorQueue[tail].a = p.a - quantizedPoint.a;
            // update point
            p.from(quantizedPoint);
        });
        yield {
            pointContainer,
            progress: 100,
        };
    }
    static _createWeights(errorPropagation, errorQueueSize) {
        const weights = [];
        const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
        for (let i = 0, next = 1; i < errorQueueSize; i++) {
            weights[i] = (((next + 0.5) | 0) / errorQueueSize) * errorPropagation;
            next *= multiplier;
        }
        return weights;
    }
}
//# sourceMappingURL=riemersma.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/image/spaceFillingCurves/hilbertCurve.js":
/*!********************************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/image/spaceFillingCurves/hilbertCurve.js ***!
  \********************************************************************************/
/*! exports provided: hilbertCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hilbertCurve", function() { return hilbertCurve; });
/* harmony import */ var _utils_progressTracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/progressTracker */ "./node_modules/image-q/dist/esm/utils/progressTracker.js");

var Direction;
(function (Direction) {
    Direction[Direction["NONE"] = 0] = "NONE";
    Direction[Direction["UP"] = 1] = "UP";
    Direction[Direction["LEFT"] = 2] = "LEFT";
    Direction[Direction["RIGHT"] = 3] = "RIGHT";
    Direction[Direction["DOWN"] = 4] = "DOWN";
})(Direction || (Direction = {}));
function* hilbertCurve(width, height, callback) {
    const maxBound = Math.max(width, height);
    const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
    const tracker = new _utils_progressTracker__WEBPACK_IMPORTED_MODULE_0__["ProgressTracker"](width * height, 99);
    const data = {
        width,
        height,
        level,
        callback,
        tracker,
        index: 0,
        x: 0,
        y: 0,
    };
    yield* walkHilbert(data, Direction.UP);
    visit(data, Direction.NONE);
}
function* walkHilbert(data, direction) {
    if (data.level < 1)
        return;
    if (data.tracker.shouldNotify(data.index))
        yield { progress: data.tracker.progress };
    data.level--;
    switch (direction) {
        case Direction.LEFT:
            yield* walkHilbert(data, Direction.UP);
            visit(data, Direction.RIGHT);
            yield* walkHilbert(data, Direction.LEFT);
            visit(data, Direction.DOWN);
            yield* walkHilbert(data, Direction.LEFT);
            visit(data, Direction.LEFT);
            yield* walkHilbert(data, Direction.DOWN);
            break;
        case Direction.RIGHT:
            yield* walkHilbert(data, Direction.DOWN);
            visit(data, Direction.LEFT);
            yield* walkHilbert(data, Direction.RIGHT);
            visit(data, Direction.UP);
            yield* walkHilbert(data, Direction.RIGHT);
            visit(data, Direction.RIGHT);
            yield* walkHilbert(data, Direction.UP);
            break;
        case Direction.UP:
            yield* walkHilbert(data, Direction.LEFT);
            visit(data, Direction.DOWN);
            yield* walkHilbert(data, Direction.UP);
            visit(data, Direction.RIGHT);
            yield* walkHilbert(data, Direction.UP);
            visit(data, Direction.UP);
            yield* walkHilbert(data, Direction.RIGHT);
            break;
        case Direction.DOWN:
            yield* walkHilbert(data, Direction.RIGHT);
            visit(data, Direction.UP);
            yield* walkHilbert(data, Direction.DOWN);
            visit(data, Direction.LEFT);
            yield* walkHilbert(data, Direction.DOWN);
            visit(data, Direction.DOWN);
            yield* walkHilbert(data, Direction.LEFT);
            break;
        default:
            break;
    }
    data.level++;
}
function visit(data, direction) {
    if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
        data.callback(data.x, data.y);
        data.index++;
    }
    switch (direction) {
        case Direction.LEFT:
            data.x--;
            break;
        case Direction.RIGHT:
            data.x++;
            break;
        case Direction.UP:
            data.y--;
            break;
        case Direction.DOWN:
            data.y++;
            break;
    }
}
//# sourceMappingURL=hilbertCurve.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/palette/index.js":
/*!********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/palette/index.js ***!
  \********************************************************/
/*! exports provided: AbstractPaletteQuantizer, NeuQuant, NeuQuantFloat, RGBQuant, ColorHistogram, WuQuant, WuColorCube */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paletteQuantizer */ "./node_modules/image-q/dist/esm/palette/paletteQuantizer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbstractPaletteQuantizer", function() { return _paletteQuantizer__WEBPACK_IMPORTED_MODULE_0__["AbstractPaletteQuantizer"]; });

/* harmony import */ var _neuquant_neuquant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./neuquant/neuquant */ "./node_modules/image-q/dist/esm/palette/neuquant/neuquant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NeuQuant", function() { return _neuquant_neuquant__WEBPACK_IMPORTED_MODULE_1__["NeuQuant"]; });

/* harmony import */ var _neuquant_neuquantFloat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./neuquant/neuquantFloat */ "./node_modules/image-q/dist/esm/palette/neuquant/neuquantFloat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NeuQuantFloat", function() { return _neuquant_neuquantFloat__WEBPACK_IMPORTED_MODULE_2__["NeuQuantFloat"]; });

/* harmony import */ var _rgbquant_rgbquant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgbquant/rgbquant */ "./node_modules/image-q/dist/esm/palette/rgbquant/rgbquant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBQuant", function() { return _rgbquant_rgbquant__WEBPACK_IMPORTED_MODULE_3__["RGBQuant"]; });

/* harmony import */ var _rgbquant_colorHistogram__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rgbquant/colorHistogram */ "./node_modules/image-q/dist/esm/palette/rgbquant/colorHistogram.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorHistogram", function() { return _rgbquant_colorHistogram__WEBPACK_IMPORTED_MODULE_4__["ColorHistogram"]; });

/* harmony import */ var _wu_wuQuant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wu/wuQuant */ "./node_modules/image-q/dist/esm/palette/wu/wuQuant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WuQuant", function() { return _wu_wuQuant__WEBPACK_IMPORTED_MODULE_5__["WuQuant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WuColorCube", function() { return _wu_wuQuant__WEBPACK_IMPORTED_MODULE_5__["WuColorCube"]; });

/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/palette/neuquant/neuquant.js":
/*!********************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/palette/neuquant/neuquant.js ***!
  \********************************************************************/
/*! exports provided: NeuQuant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeuQuant", function() { return NeuQuant; });
/* harmony import */ var _utils_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/palette */ "./node_modules/image-q/dist/esm/utils/palette.js");
/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/point */ "./node_modules/image-q/dist/esm/utils/point.js");
/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../paletteQuantizer */ "./node_modules/image-q/dist/esm/palette/paletteQuantizer.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ "./node_modules/image-q/dist/esm/utils/index.js");
/*
 * NeuQuant Neural-Net Quantization Algorithm
 * ------------------------------------------
 *
 * Copyright (c) 1994 Anthony Dekker
 *
 * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See
 * "Kohonen neural networks for optimal colour quantization" in "Network:
 * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of
 * the algorithm.
 *
 * Any party obtaining a copy of these files from the author, directly or
 * indirectly, is granted, free of charge, a full and unrestricted irrevocable,
 * world-wide, paid up, royalty-free, nonexclusive right and license to deal in
 * this software and documentation files (the "Software"), including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons who
 * receive copies from any such party to do so, with the only requirement being
 * that this copyright notice remain intact.
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */




// bias for colour values
const networkBiasShift = 3;
class Neuron {
    constructor(defaultValue) {
        this.r = this.g = this.b = this.a = defaultValue;
    }
    /**
     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)
     * @example
     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);
     */
    toPoint() {
        return _utils_point__WEBPACK_IMPORTED_MODULE_1__["Point"].createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
    }
    subtract(r, g, b, a) {
        this.r -= r | 0;
        this.g -= g | 0;
        this.b -= b | 0;
        this.a -= a | 0;
    }
}
class NeuQuant extends _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__["AbstractPaletteQuantizer"] {
    constructor(colorDistanceCalculator, colors = 256) {
        super();
        this._distance = colorDistanceCalculator;
        this._pointArray = [];
        this._sampleFactor = 1;
        this._networkSize = colors;
        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
    }
    sample(pointContainer) {
        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    *quantize() {
        this._init();
        yield* this._learn();
        yield {
            palette: this._buildPalette(),
            progress: 100,
        };
    }
    _init() {
        this._freq = [];
        this._bias = [];
        this._radPower = [];
        this._network = [];
        for (let i = 0; i < this._networkSize; i++) {
            this._network[i] = new Neuron((i << (networkBiasShift + 8)) / this._networkSize | 0);
            // 1/this._networkSize
            this._freq[i] = NeuQuant._initialBias / this._networkSize | 0;
            this._bias[i] = 0;
        }
    }
    /**
     * Main Learning Loop
     */
    *_learn() {
        let sampleFactor = this._sampleFactor;
        const pointsNumber = this._pointArray.length;
        if (pointsNumber < NeuQuant._minpicturebytes)
            sampleFactor = 1;
        const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
        const pointsToSample = pointsNumber / sampleFactor | 0;
        let delta = pointsToSample / NeuQuant._nCycles | 0;
        let alpha = NeuQuant._initAlpha;
        let radius = (this._networkSize >> 3) * NeuQuant._radiusBias;
        let rad = radius >> NeuQuant._radiusBiasShift;
        if (rad <= 1)
            rad = 0;
        for (let i = 0; i < rad; i++) {
            this._radPower[i] = alpha * (((rad * rad - i * i) * NeuQuant._radBias) / (rad * rad)) >>> 0;
        }
        let step;
        if (pointsNumber < NeuQuant._minpicturebytes) {
            step = 1;
        }
        else if (pointsNumber % NeuQuant._prime1 !== 0) {
            step = NeuQuant._prime1;
        }
        else if ((pointsNumber % NeuQuant._prime2) !== 0) {
            step = NeuQuant._prime2;
        }
        else if ((pointsNumber % NeuQuant._prime3) !== 0) {
            step = NeuQuant._prime3;
        }
        else {
            step = NeuQuant._prime4;
        }
        const tracker = new _utils__WEBPACK_IMPORTED_MODULE_3__["ProgressTracker"](pointsToSample, 99);
        for (let i = 0, pointIndex = 0; i < pointsToSample;) {
            if (tracker.shouldNotify(i)) {
                yield {
                    progress: tracker.progress,
                };
            }
            const point = this._pointArray[pointIndex];
            const b = point.b << networkBiasShift;
            const g = point.g << networkBiasShift;
            const r = point.r << networkBiasShift;
            const a = point.a << networkBiasShift;
            const neuronIndex = this._contest(b, g, r, a);
            this._alterSingle(alpha, neuronIndex, b, g, r, a);
            if (rad !== 0)
                this._alterNeighbour(rad, neuronIndex, b, g, r, a);
            /* alter neighbours */
            pointIndex += step;
            if (pointIndex >= pointsNumber)
                pointIndex -= pointsNumber;
            i++;
            if (delta === 0)
                delta = 1;
            if (i % delta === 0) {
                alpha -= (alpha / alphadec) | 0;
                radius -= (radius / NeuQuant._radiusDecrease) | 0;
                rad = radius >> NeuQuant._radiusBiasShift;
                if (rad <= 1)
                    rad = 0;
                for (let j = 0; j < rad; j++)
                    this._radPower[j] = alpha * (((rad * rad - j * j) * NeuQuant._radBias) / (rad * rad)) >>> 0;
            }
        }
    }
    _buildPalette() {
        const palette = new _utils_palette__WEBPACK_IMPORTED_MODULE_0__["Palette"]();
        this._network.forEach(neuron => {
            palette.add(neuron.toPoint());
        });
        palette.sort();
        return palette;
    }
    /**
     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]
     */
    _alterNeighbour(rad, i, b, g, r, al) {
        let lo = i - rad;
        if (lo < -1)
            lo = -1;
        let hi = i + rad;
        if (hi > this._networkSize)
            hi = this._networkSize;
        let j = i + 1;
        let k = i - 1;
        let m = 1;
        while (j < hi || k > lo) {
            const a = this._radPower[m++] / NeuQuant._alphaRadBias;
            if (j < hi) {
                const p = this._network[j++];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
            if (k > lo) {
                const p = this._network[k--];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
        }
    }
    /**
     * Move neuron i towards biased (b,g,r) by factor alpha
     */
    _alterSingle(alpha, i, b, g, r, a) {
        alpha /= NeuQuant._initAlpha;
        /* alter hit neuron */
        const n = this._network[i];
        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
    }
    /**
     * Search for biased BGR values
     * description:
     *    finds closest neuron (min dist) and updates freq
     *    finds best neuron (min dist-bias) and returns position
     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative
     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])
     *
     * Original distance equation:
     *        dist = abs(dR) + abs(dG) + abs(dB)
     */
    _contest(b, g, r, a) {
        const multiplier = (255 * 4) << networkBiasShift;
        let bestd = ~(1 << 31);
        let bestbiasd = bestd;
        let bestpos = -1;
        let bestbiaspos = bestpos;
        for (let i = 0; i < this._networkSize; i++) {
            const n = this._network[i];
            const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
            if (dist < bestd) {
                bestd = dist;
                bestpos = i;
            }
            const biasdist = dist - ((this._bias[i]) >> (NeuQuant._initialBiasShift - networkBiasShift));
            if (biasdist < bestbiasd) {
                bestbiasd = biasdist;
                bestbiaspos = i;
            }
            const betafreq = (this._freq[i] >> NeuQuant._betaShift);
            this._freq[i] -= betafreq;
            this._bias[i] += (betafreq << NeuQuant._gammaShift);
        }
        this._freq[bestpos] += NeuQuant._beta;
        this._bias[bestpos] -= NeuQuant._betaGamma;
        return bestbiaspos;
    }
}
/*
 four primes near 500 - assume no image has a length so large
 that it is divisible by all four primes
 */
NeuQuant._prime1 = 499;
NeuQuant._prime2 = 491;
NeuQuant._prime3 = 487;
NeuQuant._prime4 = 503;
NeuQuant._minpicturebytes = NeuQuant._prime4;
// no. of learning cycles
NeuQuant._nCycles = 100;
// defs for freq and bias
NeuQuant._initialBiasShift = 16;
// bias for fractions
NeuQuant._initialBias = (1 << NeuQuant._initialBiasShift);
NeuQuant._gammaShift = 10;
// gamma = 1024
// TODO: why gamma is never used?
// private static _gamma : number     = (1 << NeuQuant._gammaShift);
NeuQuant._betaShift = 10;
NeuQuant._beta = (NeuQuant._initialBias >> NeuQuant._betaShift);
// beta = 1/1024
NeuQuant._betaGamma = (NeuQuant._initialBias << (NeuQuant._gammaShift - NeuQuant._betaShift));
/*
 * for 256 cols, radius starts
 */
NeuQuant._radiusBiasShift = 6;
// at 32.0 biased by 6 bits
NeuQuant._radiusBias = 1 << NeuQuant._radiusBiasShift;
// and decreases by a factor of 1/30 each cycle
NeuQuant._radiusDecrease = 30;
/* defs for decreasing alpha factor */
// alpha starts at 1.0
NeuQuant._alphaBiasShift = 10;
// biased by 10 bits
NeuQuant._initAlpha = (1 << NeuQuant._alphaBiasShift);
/* radBias and alphaRadBias used for radpower calculation */
NeuQuant._radBiasShift = 8;
NeuQuant._radBias = 1 << NeuQuant._radBiasShift;
NeuQuant._alphaRadBiasShift = NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;
NeuQuant._alphaRadBias = 1 << NeuQuant._alphaRadBiasShift;
//# sourceMappingURL=neuquant.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/palette/neuquant/neuquantFloat.js":
/*!*************************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/palette/neuquant/neuquantFloat.js ***!
  \*************************************************************************/
/*! exports provided: NeuQuantFloat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeuQuantFloat", function() { return NeuQuantFloat; });
/* harmony import */ var _utils_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/palette */ "./node_modules/image-q/dist/esm/utils/palette.js");
/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/point */ "./node_modules/image-q/dist/esm/utils/point.js");
/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../paletteQuantizer */ "./node_modules/image-q/dist/esm/palette/paletteQuantizer.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ "./node_modules/image-q/dist/esm/utils/index.js");
/*
 * NeuQuantFloat Neural-Net Quantization Algorithm
 * ------------------------------------------
 *
 * Copyright (c) 1994 Anthony Dekker
 *
 * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See
 * "Kohonen neural networks for optimal colour quantization" in "Network:
 * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of
 * the algorithm.
 *
 * Any party obtaining a copy of these files from the author, directly or
 * indirectly, is granted, free of charge, a full and unrestricted irrevocable,
 * world-wide, paid up, royalty-free, nonexclusive right and license to deal in
 * this software and documentation files (the "Software"), including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons who
 * receive copies from any such party to do so, with the only requirement being
 * that this copyright notice remain intact.
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */




// bias for colour values
const networkBiasShift = 3;
class NeuronFloat {
    constructor(defaultValue) {
        this.r = this.g = this.b = this.a = defaultValue;
    }
    /**
     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)
     * @example
     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);
     */
    toPoint() {
        return _utils_point__WEBPACK_IMPORTED_MODULE_1__["Point"].createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
    }
    subtract(r, g, b, a) {
        this.r -= r;
        this.g -= g;
        this.b -= b;
        this.a -= a;
    }
}
class NeuQuantFloat extends _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__["AbstractPaletteQuantizer"] {
    constructor(colorDistanceCalculator, colors = 256) {
        super();
        this._distance = colorDistanceCalculator;
        this._pointArray = [];
        this._sampleFactor = 1;
        this._networkSize = colors;
        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
    }
    sample(pointContainer) {
        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    *quantize() {
        this._init();
        yield* this._learn();
        yield {
            palette: this._buildPalette(),
            progress: 100,
        };
    }
    _init() {
        this._freq = [];
        this._bias = [];
        this._radPower = [];
        this._network = [];
        for (let i = 0; i < this._networkSize; i++) {
            this._network[i] = new NeuronFloat((i << (networkBiasShift + 8)) / this._networkSize);
            // 1/this._networkSize
            this._freq[i] = NeuQuantFloat._initialBias / this._networkSize;
            this._bias[i] = 0;
        }
    }
    /**
     * Main Learning Loop
     */
    *_learn() {
        let sampleFactor = this._sampleFactor;
        const pointsNumber = this._pointArray.length;
        if (pointsNumber < NeuQuantFloat._minpicturebytes)
            sampleFactor = 1;
        const alphadec = 30 + (sampleFactor - 1) / 3;
        const pointsToSample = pointsNumber / sampleFactor;
        let delta = pointsToSample / NeuQuantFloat._nCycles | 0;
        let alpha = NeuQuantFloat._initAlpha;
        let radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;
        let rad = radius >> NeuQuantFloat._radiusBiasShift;
        if (rad <= 1)
            rad = 0;
        for (let i = 0; i < rad; i++) {
            this._radPower[i] = alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));
        }
        let step;
        if (pointsNumber < NeuQuantFloat._minpicturebytes) {
            step = 1;
        }
        else if (pointsNumber % NeuQuantFloat._prime1 !== 0) {
            step = NeuQuantFloat._prime1;
        }
        else if ((pointsNumber % NeuQuantFloat._prime2) !== 0) {
            step = NeuQuantFloat._prime2;
        }
        else if ((pointsNumber % NeuQuantFloat._prime3) !== 0) {
            step = NeuQuantFloat._prime3;
        }
        else {
            step = NeuQuantFloat._prime4;
        }
        const tracker = new _utils__WEBPACK_IMPORTED_MODULE_3__["ProgressTracker"](pointsToSample, 99);
        for (let i = 0, pointIndex = 0; i < pointsToSample;) {
            if (tracker.shouldNotify(i)) {
                yield {
                    progress: tracker.progress,
                };
            }
            const point = this._pointArray[pointIndex];
            const b = point.b << networkBiasShift;
            const g = point.g << networkBiasShift;
            const r = point.r << networkBiasShift;
            const a = point.a << networkBiasShift;
            const neuronIndex = this._contest(b, g, r, a);
            this._alterSingle(alpha, neuronIndex, b, g, r, a);
            if (rad !== 0)
                this._alterNeighbour(rad, neuronIndex, b, g, r, a);
            /* alter neighbours */
            pointIndex += step;
            if (pointIndex >= pointsNumber)
                pointIndex -= pointsNumber;
            i++;
            if (delta === 0)
                delta = 1;
            if (i % delta === 0) {
                alpha -= (alpha / alphadec);
                radius -= (radius / NeuQuantFloat._radiusDecrease);
                rad = radius >> NeuQuantFloat._radiusBiasShift;
                if (rad <= 1)
                    rad = 0;
                for (let j = 0; j < rad; j++)
                    this._radPower[j] = alpha * (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));
            }
        }
    }
    _buildPalette() {
        const palette = new _utils_palette__WEBPACK_IMPORTED_MODULE_0__["Palette"]();
        this._network.forEach(neuron => {
            palette.add(neuron.toPoint());
        });
        palette.sort();
        return palette;
    }
    /**
     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]
     */
    _alterNeighbour(rad, i, b, g, r, al) {
        let lo = i - rad;
        if (lo < -1)
            lo = -1;
        let hi = i + rad;
        if (hi > this._networkSize)
            hi = this._networkSize;
        let j = i + 1;
        let k = i - 1;
        let m = 1;
        while (j < hi || k > lo) {
            const a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;
            if (j < hi) {
                const p = this._network[j++];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
            if (k > lo) {
                const p = this._network[k--];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
        }
    }
    /**
     * Move neuron i towards biased (b,g,r) by factor alpha
     */
    _alterSingle(alpha, i, b, g, r, a) {
        alpha /= NeuQuantFloat._initAlpha;
        /* alter hit neuron */
        const n = this._network[i];
        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
    }
    /**
     * Search for biased BGR values
     * description:
     *    finds closest neuron (min dist) and updates freq
     *    finds best neuron (min dist-bias) and returns position
     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative
     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])
     *
     * Original distance equation:
     *        dist = abs(dR) + abs(dG) + abs(dB)
     */
    _contest(b, g, r, al) {
        const multiplier = (255 * 4) << networkBiasShift;
        let bestd = ~(1 << 31);
        let bestbiasd = bestd;
        let bestpos = -1;
        let bestbiaspos = bestpos;
        for (let i = 0; i < this._networkSize; i++) {
            const n = this._network[i];
            const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
            if (dist < bestd) {
                bestd = dist;
                bestpos = i;
            }
            const biasdist = dist - ((this._bias[i]) >> (NeuQuantFloat._initialBiasShift - networkBiasShift));
            if (biasdist < bestbiasd) {
                bestbiasd = biasdist;
                bestbiaspos = i;
            }
            const betafreq = (this._freq[i] >> NeuQuantFloat._betaShift);
            this._freq[i] -= betafreq;
            this._bias[i] += (betafreq << NeuQuantFloat._gammaShift);
        }
        this._freq[bestpos] += NeuQuantFloat._beta;
        this._bias[bestpos] -= NeuQuantFloat._betaGamma;
        return bestbiaspos;
    }
}
/*
 four primes near 500 - assume no image has a length so large
 that it is divisible by all four primes
 */
NeuQuantFloat._prime1 = 499;
NeuQuantFloat._prime2 = 491;
NeuQuantFloat._prime3 = 487;
NeuQuantFloat._prime4 = 503;
NeuQuantFloat._minpicturebytes = NeuQuantFloat._prime4;
// no. of learning cycles
NeuQuantFloat._nCycles = 100;
// defs for freq and bias
NeuQuantFloat._initialBiasShift = 16;
// bias for fractions
NeuQuantFloat._initialBias = (1 << NeuQuantFloat._initialBiasShift);
NeuQuantFloat._gammaShift = 10;
// gamma = 1024
// TODO: why gamma is never used?
// private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);
NeuQuantFloat._betaShift = 10;
NeuQuantFloat._beta = (NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift);
// beta = 1/1024
NeuQuantFloat._betaGamma = (NeuQuantFloat._initialBias << (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift));
/*
 * for 256 cols, radius starts
 */
NeuQuantFloat._radiusBiasShift = 6;
// at 32.0 biased by 6 bits
NeuQuantFloat._radiusBias = 1 << NeuQuantFloat._radiusBiasShift;
// and decreases by a factor of 1/30 each cycle
NeuQuantFloat._radiusDecrease = 30;
/* defs for decreasing alpha factor */
// alpha starts at 1.0
NeuQuantFloat._alphaBiasShift = 10;
// biased by 10 bits
NeuQuantFloat._initAlpha = (1 << NeuQuantFloat._alphaBiasShift);
/* radBias and alphaRadBias used for radpower calculation */
NeuQuantFloat._radBiasShift = 8;
NeuQuantFloat._radBias = 1 << NeuQuantFloat._radBiasShift;
NeuQuantFloat._alphaRadBiasShift = NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;
NeuQuantFloat._alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift;
//# sourceMappingURL=neuquantFloat.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/palette/paletteQuantizer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/palette/paletteQuantizer.js ***!
  \*******************************************************************/
/*! exports provided: AbstractPaletteQuantizer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractPaletteQuantizer", function() { return AbstractPaletteQuantizer; });
class AbstractPaletteQuantizer {
    quantizeSync() {
        for (const value of this.quantize()) {
            if (value.palette) {
                return value.palette;
            }
        }
        throw new Error('unreachable');
    }
}
//# sourceMappingURL=paletteQuantizer.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/palette/rgbquant/colorHistogram.js":
/*!**************************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/palette/rgbquant/colorHistogram.js ***!
  \**************************************************************************/
/*! exports provided: ColorHistogram */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorHistogram", function() { return ColorHistogram; });
/* harmony import */ var _utils_hueStatistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/hueStatistics */ "./node_modules/image-q/dist/esm/utils/hueStatistics.js");
/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/*
 * Copyright (c) 2015, Leon Sorokin
 * All rights reserved. (MIT Licensed)
 *
 * ColorHistogram.js - an image quantization lib
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */


class ColorHistogram {
    constructor(method, colors) {
        // 1 = by global population, 2 = subregion population threshold
        this._method = method;
        // if > 0, enables hues stats and min-color retention per group
        this._minHueCols = colors << 2; // opts.minHueCols || 0;
        // # of highest-frequency colors to start with for palette reduction
        this._initColors = colors << 2;
        // HueStatistics instance
        this._hueStats = new _utils_hueStatistics__WEBPACK_IMPORTED_MODULE_0__["HueStatistics"](ColorHistogram._hueGroups, this._minHueCols);
        this._histogram = Object.create(null); // tslint:disable-line:no-null-keyword
    }
    sample(pointContainer) {
        switch (this._method) {
            case 1:
                this._colorStats1D(pointContainer);
                break;
            case 2:
                this._colorStats2D(pointContainer);
                break;
        }
    }
    getImportanceSortedColorsIDXI32() {
        // TODO: fix typing issue in stableSort func
        const sorted = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_1__["stableSort"])(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);
        if (sorted.length === 0) {
            return [];
        }
        let idxi32;
        switch (this._method) {
            case 1:
                const initialColorsLimit = Math.min(sorted.length, this._initColors);
                const last = sorted[initialColorsLimit - 1];
                const freq = this._histogram[last];
                idxi32 = sorted.slice(0, initialColorsLimit);
                // add any cut off colors with same freq as last
                let pos = initialColorsLimit;
                const len = sorted.length;
                while (pos < len && this._histogram[sorted[pos]] === freq) {
                    idxi32.push(sorted[pos++]);
                }
                // inject min huegroup colors
                this._hueStats.injectIntoArray(idxi32);
                break;
            case 2:
                idxi32 = sorted;
                break;
            default:
                // TODO: rethink errors
                throw new Error('Incorrect method');
        }
        // int32-ify values
        return idxi32.map(function (v) {
            return +v;
        });
    }
    // global top-population
    _colorStats1D(pointContainer) {
        const histG = this._histogram;
        const pointArray = pointContainer.getPointArray();
        const len = pointArray.length;
        for (let i = 0; i < len; i++) {
            const col = pointArray[i].uint32;
            // collect hue stats
            this._hueStats.check(col);
            if (col in histG) {
                histG[col]++;
            }
            else {
                histG[col] = 1;
            }
        }
    }
    // population threshold within subregions
    // FIXME: this can over-reduce (few/no colors same?), need a way to keep
    // important colors that dont ever reach local thresholds (gradients?)
    _colorStats2D(pointContainer) {
        const width = pointContainer.getWidth();
        const height = pointContainer.getHeight();
        const pointArray = pointContainer.getPointArray();
        const boxW = ColorHistogram._boxSize[0];
        const boxH = ColorHistogram._boxSize[1];
        const area = boxW * boxH;
        const boxes = this._makeBoxes(width, height, boxW, boxH);
        const histG = this._histogram;
        boxes.forEach(box => {
            let effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;
            if (effc < 2)
                effc = 2;
            const histL = {};
            this._iterateBox(box, width, (i) => {
                const col = pointArray[i].uint32;
                // collect hue stats
                this._hueStats.check(col);
                if (col in histG) {
                    histG[col]++;
                }
                else if (col in histL) {
                    if (++histL[col] >= effc) {
                        histG[col] = histL[col];
                    }
                }
                else {
                    histL[col] = 1;
                }
            });
        });
        // inject min huegroup colors
        this._hueStats.injectIntoDictionary(histG);
    }
    // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent
    _iterateBox(bbox, wid, fn) {
        const b = bbox;
        const i0 = b.y * wid + b.x;
        const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
        const incr = wid - b.w + 1;
        let cnt = 0;
        let i = i0;
        do {
            fn.call(this, i);
            i += (++cnt % b.w === 0) ? incr : 1;
        } while (i <= i1);
    }
    /**
     *    partitions a rectangle of width x height into
     *    array of boxes stepX x stepY (or less)
     */
    _makeBoxes(width, height, stepX, stepY) {
        const wrem = width % stepX;
        const hrem = height % stepY;
        const xend = width - wrem;
        const yend = height - hrem;
        const boxesArray = [];
        for (let y = 0; y < height; y += stepY) {
            for (let x = 0; x < width; x += stepX) {
                boxesArray.push({ x, y, w: (x === xend ? wrem : stepX), h: (y === yend ? hrem : stepY) });
            }
        }
        return boxesArray;
    }
}
ColorHistogram._boxSize = [64, 64];
ColorHistogram._boxPixels = 2;
ColorHistogram._hueGroups = 10;
//# sourceMappingURL=colorHistogram.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/palette/rgbquant/rgbquant.js":
/*!********************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/palette/rgbquant/rgbquant.js ***!
  \********************************************************************/
/*! exports provided: RGBQuant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBQuant", function() { return RGBQuant; });
/* harmony import */ var _utils_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/palette */ "./node_modules/image-q/dist/esm/utils/palette.js");
/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/point */ "./node_modules/image-q/dist/esm/utils/point.js");
/* harmony import */ var _colorHistogram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colorHistogram */ "./node_modules/image-q/dist/esm/palette/rgbquant/colorHistogram.js");
/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../paletteQuantizer */ "./node_modules/image-q/dist/esm/palette/paletteQuantizer.js");
/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils */ "./node_modules/image-q/dist/esm/utils/index.js");
/*
 * Copyright (c) 2015, Leon Sorokin
 * All rights reserved. (MIT Licensed)
 *
 * RGBQuant.js - an image quantization lib
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */






class RemovedColor {
    constructor(index, color, distance) {
        this.index = index;
        this.color = color;
        this.distance = distance;
    }
}
// TODO: make input/output image and input/output palettes with instances of class Point only!
class RGBQuant extends _paletteQuantizer__WEBPACK_IMPORTED_MODULE_3__["AbstractPaletteQuantizer"] {
    constructor(colorDistanceCalculator, colors = 256, method = 2) {
        super();
        this._distance = colorDistanceCalculator;
        // desired final palette size
        this._colors = colors;
        // histogram to accumulate
        this._histogram = new _colorHistogram__WEBPACK_IMPORTED_MODULE_2__["ColorHistogram"](method, colors);
        this._initialDistance = 0.01;
        this._distanceIncrement = 0.005;
    }
    // gathers histogram info
    sample(image) {
        /*
         var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];
    
         for (var i = 0, l = pointArray.length; i < l; i++) {
         var color = pointArray[i];
         for (var componentIndex = 0; componentIndex < 4; componentIndex++) {
         if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];
         if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];
         }
         }
         var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];
         this._distance.setWhitePoint(rd, gd, bd, ad);
    
         this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;
         */
        this._histogram.sample(image);
    }
    // reduces histogram to palette, remaps & memoizes reduced colors
    *quantize() {
        const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
        if (idxi32.length === 0) {
            throw new Error('No colors in image');
        }
        yield* this._buildPalette(idxi32);
    }
    // reduces similar colors from an importance-sorted Uint32 rgba array
    *_buildPalette(idxi32) {
        // reduce histogram to create initial palette
        // build full rgb palette
        const palette = new _utils_palette__WEBPACK_IMPORTED_MODULE_0__["Palette"]();
        const colorArray = palette.getPointContainer().getPointArray();
        const usageArray = new Array(idxi32.length); // tslint:disable-line:prefer-array-literal
        for (let i = 0; i < idxi32.length; i++) {
            colorArray.push(_utils_point__WEBPACK_IMPORTED_MODULE_1__["Point"].createByUint32(idxi32[i]));
            usageArray[i] = 1;
        }
        const len = colorArray.length;
        const memDist = [];
        let palLen = len;
        let thold = this._initialDistance;
        // palette already at or below desired length
        const tracker = new _utils__WEBPACK_IMPORTED_MODULE_5__["ProgressTracker"](palLen - this._colors, 99);
        while (palLen > this._colors) {
            memDist.length = 0;
            // iterate palette
            for (let i = 0; i < len; i++) {
                if (tracker.shouldNotify(len - palLen)) {
                    yield {
                        progress: tracker.progress,
                    };
                }
                if (usageArray[i] === 0)
                    continue;
                const pxi = colorArray[i];
                // if (!pxi) continue;
                for (let j = i + 1; j < len; j++) {
                    if (usageArray[j] === 0)
                        continue;
                    const pxj = colorArray[j];
                    // if (!pxj) continue;
                    const dist = this._distance.calculateNormalized(pxi, pxj);
                    if (dist < thold) {
                        // store index,rgb,dist
                        memDist.push(new RemovedColor(j, pxj, dist));
                        usageArray[j] = 0;
                        palLen--;
                    }
                }
            }
            // palette reduction pass
            // console.log("palette length: " + palLen);
            // if palette is still much larger than target, increment by larger initDist
            thold += (palLen > this._colors * 3) ? this._initialDistance : this._distanceIncrement;
        }
        // if palette is over-reduced, re-add removed colors with largest distances from last round
        if (palLen < this._colors) {
            // sort descending
            Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_4__["stableSort"])(memDist, function (a, b) {
                return b.distance - a.distance;
            });
            let k = 0;
            while (palLen < this._colors && k < memDist.length) {
                const removedColor = memDist[k];
                // re-inject rgb into final palette
                usageArray[removedColor.index] = 1;
                palLen++;
                k++;
            }
        }
        let colors = colorArray.length;
        for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
            if (usageArray[colorIndex] === 0) {
                if (colorIndex !== colors - 1) {
                    colorArray[colorIndex] = colorArray[colors - 1];
                }
                --colors;
            }
        }
        colorArray.length = colors;
        palette.sort();
        yield {
            palette,
            progress: 100,
        };
    }
}
//# sourceMappingURL=rgbquant.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/palette/wu/wuQuant.js":
/*!*************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/palette/wu/wuQuant.js ***!
  \*************************************************************/
/*! exports provided: WuColorCube, WuQuant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WuColorCube", function() { return WuColorCube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WuQuant", function() { return WuQuant; });
/* harmony import */ var _utils_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/palette */ "./node_modules/image-q/dist/esm/utils/palette.js");
/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/point */ "./node_modules/image-q/dist/esm/utils/point.js");
/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../paletteQuantizer */ "./node_modules/image-q/dist/esm/palette/paletteQuantizer.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ "./node_modules/image-q/dist/esm/utils/index.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */




function createArray1D(dimension1) {
    const a = [];
    for (let k = 0; k < dimension1; k++) {
        a[k] = 0;
    }
    return a;
}
function createArray4D(dimension1, dimension2, dimension3, dimension4) {
    const a = new Array(dimension1);
    for (let i = 0; i < dimension1; i++) {
        a[i] = new Array(dimension2);
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = new Array(dimension3);
            for (let k = 0; k < dimension3; k++) {
                a[i][j][k] = new Array(dimension4);
                for (let l = 0; l < dimension4; l++) {
                    a[i][j][k][l] = 0;
                }
            }
        }
    }
    return a;
}
function createArray3D(dimension1, dimension2, dimension3) {
    const a = new Array(dimension1);
    for (let i = 0; i < dimension1; i++) {
        a[i] = new Array(dimension2);
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = new Array(dimension3);
            for (let k = 0; k < dimension3; k++) {
                a[i][j][k] = 0;
            }
        }
    }
    return a;
}
function fillArray3D(a, dimension1, dimension2, dimension3, value) {
    for (let i = 0; i < dimension1; i++) {
        a[i] = [];
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = [];
            for (let k = 0; k < dimension3; k++) {
                a[i][j][k] = value;
            }
        }
    }
}
function fillArray1D(a, dimension1, value) {
    for (let i = 0; i < dimension1; i++) {
        a[i] = value;
    }
}
class WuColorCube {
}
class WuQuant extends _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__["AbstractPaletteQuantizer"] {
    constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
        super();
        this._distance = colorDistanceCalculator;
        this._setQuality(significantBitsPerChannel);
        this._initialize(colors);
    }
    sample(image) {
        const pointArray = image.getPointArray();
        for (let i = 0, l = pointArray.length; i < l; i++) {
            this._addColor(pointArray[i]);
        }
        this._pixels = this._pixels.concat(pointArray);
    }
    *quantize() {
        yield* this._preparePalette();
        const palette = new _utils_palette__WEBPACK_IMPORTED_MODULE_0__["Palette"]();
        // generates palette
        for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
            if (this._sums[paletteIndex] > 0) {
                const sum = this._sums[paletteIndex];
                const r = this._reds[paletteIndex] / sum;
                const g = this._greens[paletteIndex] / sum;
                const b = this._blues[paletteIndex] / sum;
                const a = this._alphas[paletteIndex] / sum;
                const color = _utils_point__WEBPACK_IMPORTED_MODULE_1__["Point"].createByRGBA(r | 0, g | 0, b | 0, a | 0);
                palette.add(color);
            }
        }
        palette.sort();
        yield {
            palette,
            progress: 100,
        };
    }
    *_preparePalette() {
        // preprocess the colors
        yield* this._calculateMoments();
        let next = 0;
        const volumeVariance = createArray1D(this._colors);
        // processes the cubes
        for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
            // if cut is possible; make it
            if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
                volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0.0;
                volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0.0;
            }
            else {
                // the cut was not possible, revert the index
                volumeVariance[next] = 0.0;
                cubeIndex--;
            }
            next = 0;
            let temp = volumeVariance[0];
            for (let index = 1; index <= cubeIndex; ++index) {
                if (volumeVariance[index] > temp) {
                    temp = volumeVariance[index];
                    next = index;
                }
            }
            if (temp <= 0.0) {
                this._colors = cubeIndex + 1;
                break;
            }
        }
        const lookupRed = [];
        const lookupGreen = [];
        const lookupBlue = [];
        const lookupAlpha = [];
        // precalculates lookup tables
        for (let k = 0; k < this._colors; ++k) {
            const weight = WuQuant._volume(this._cubes[k], this._weights);
            if (weight > 0) {
                lookupRed[k] = (WuQuant._volume(this._cubes[k], this._momentsRed) / weight) | 0;
                lookupGreen[k] = (WuQuant._volume(this._cubes[k], this._momentsGreen) / weight) | 0;
                lookupBlue[k] = (WuQuant._volume(this._cubes[k], this._momentsBlue) / weight) | 0;
                lookupAlpha[k] = (WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight) | 0;
            }
            else {
                lookupRed[k] = 0;
                lookupGreen[k] = 0;
                lookupBlue[k] = 0;
                lookupAlpha[k] = 0;
            }
        }
        this._reds = createArray1D(this._colors + 1);
        this._greens = createArray1D(this._colors + 1);
        this._blues = createArray1D(this._colors + 1);
        this._alphas = createArray1D(this._colors + 1);
        this._sums = createArray1D(this._colors + 1);
        // scans and adds colors
        for (let index = 0, l = this._pixels.length; index < l; index++) {
            const color = this._pixels[index];
            const match = -1;
            let bestMatch = match;
            let bestDistance = Number.MAX_VALUE;
            for (let lookup = 0; lookup < this._colors; lookup++) {
                const foundRed = lookupRed[lookup];
                const foundGreen = lookupGreen[lookup];
                const foundBlue = lookupBlue[lookup];
                const foundAlpha = lookupAlpha[lookup];
                const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestMatch = lookup;
                }
            }
            this._reds[bestMatch] += color.r;
            this._greens[bestMatch] += color.g;
            this._blues[bestMatch] += color.b;
            this._alphas[bestMatch] += color.a;
            this._sums[bestMatch]++;
        }
    }
    _addColor(color) {
        const bitsToRemove = 8 - this._significantBitsPerChannel;
        const indexRed = (color.r >> bitsToRemove) + 1;
        const indexGreen = (color.g >> bitsToRemove) + 1;
        const indexBlue = (color.b >> bitsToRemove) + 1;
        const indexAlpha = (color.a >> bitsToRemove) + 1;
        // if(color.a > 10) {
        this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
        this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
        this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
        this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
        this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
        this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
        // }
    }
    /**
     * Converts the histogram to a series of _moments.
     */
    *_calculateMoments() {
        const area = [];
        const areaRed = [];
        const areaGreen = [];
        const areaBlue = [];
        const areaAlpha = [];
        const area2 = [];
        const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        let trackerProgress = 0;
        const tracker = new _utils__WEBPACK_IMPORTED_MODULE_3__["ProgressTracker"](this._alphaMaxSideIndex * this._maxSideIndex, 99);
        for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
            fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
            fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
            fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
            fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
            fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
            fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
            for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
                if (tracker.shouldNotify(trackerProgress)) {
                    yield {
                        progress: tracker.progress,
                    };
                }
                fillArray1D(area, this._sideSize, 0);
                fillArray1D(areaRed, this._sideSize, 0);
                fillArray1D(areaGreen, this._sideSize, 0);
                fillArray1D(areaBlue, this._sideSize, 0);
                fillArray1D(areaAlpha, this._sideSize, 0);
                fillArray1D(area2, this._sideSize, 0);
                for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
                    let line = 0;
                    let lineRed = 0;
                    let lineGreen = 0;
                    let lineBlue = 0;
                    let lineAlpha = 0;
                    let line2 = 0.0;
                    for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
                        line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
                        lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
                        lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
                        lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
                        lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
                        line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
                        area[blueIndex] += line;
                        areaRed[blueIndex] += lineRed;
                        areaGreen[blueIndex] += lineGreen;
                        areaBlue[blueIndex] += lineBlue;
                        areaAlpha[blueIndex] += lineAlpha;
                        area2[blueIndex] += line2;
                        xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
                        xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
                        xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
                        xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
                        xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
                        xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
                        this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
                        this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
                        this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
                        this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
                        this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
                        this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
                    }
                }
            }
        }
    }
    /**
     * Computes the volume of the cube in a specific moment.
     */
    static _volumeFloat(cube, moment) {
        return (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] -
            moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -
            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +
            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] -
            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] +
            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +
            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -
            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -
            (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -
                moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -
                moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +
                moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -
                moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +
                moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +
                moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] -
                moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
    }
    /**
     * Computes the volume of the cube in a specific moment.
     */
    static _volume(cube, moment) {
        return WuQuant._volumeFloat(cube, moment) | 0;
    }
    /**
     * Splits the cube in given position][and color direction.
     */
    static _top(cube, direction, position, moment) {
        let result;
        switch (direction) {
            case WuQuant._alpha:
                result = (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] -
                    moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -
                    moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +
                    moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -
                    (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -
                        moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -
                        moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +
                        moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                break;
            case WuQuant._red:
                result = (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] -
                    moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] -
                    moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] +
                    moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum]) -
                    (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] -
                        moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] -
                        moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] +
                        moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
                break;
            case WuQuant._green:
                result = (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] -
                    moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] -
                    moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] +
                    moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum]) -
                    (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] -
                        moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] -
                        moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] +
                        moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
                break;
            case WuQuant._blue:
                result = (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] -
                    moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] -
                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] +
                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position]) -
                    (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] -
                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] -
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] +
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
                break;
            default:
                throw new Error('impossible');
        }
        return result | 0;
    }
    /**
     * Splits the cube in a given color direction at its minimum.
     */
    static _bottom(cube, direction, moment) {
        switch (direction) {
            case WuQuant._alpha:
                return (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] +
                    moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +
                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -
                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -
                    (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +
                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            case WuQuant._red:
                return (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +
                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] +
                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -
                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -
                    (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +
                        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] +
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            case WuQuant._green:
                return (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +
                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] +
                    moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -
                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -
                    (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +
                        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] +
                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            case WuQuant._blue:
                return (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +
                    moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +
                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -
                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]) -
                    (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +
                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -
                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            default:
                // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?
                return 0;
        }
    }
    /**
     * Calculates statistical variance for a given cube.
     */
    _calculateVariance(cube) {
        const volumeRed = WuQuant._volume(cube, this._momentsRed);
        const volumeGreen = WuQuant._volume(cube, this._momentsGreen);
        const volumeBlue = WuQuant._volume(cube, this._momentsBlue);
        const volumeAlpha = WuQuant._volume(cube, this._momentsAlpha);
        const volumeMoment = WuQuant._volumeFloat(cube, this._moments);
        const volumeWeight = WuQuant._volume(cube, this._weights);
        const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
        return volumeMoment - (distance / volumeWeight);
    }
    /**
     * Finds the optimal (maximal) position for the cut.
     */
    _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
        const bottomRed = WuQuant._bottom(cube, direction, this._momentsRed) | 0;
        const bottomGreen = WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
        const bottomBlue = WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
        const bottomAlpha = WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
        const bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;
        let result = 0.0;
        let cutPosition = -1;
        for (let position = first; position < last; ++position) {
            // determines the cube cut at a certain position
            let halfRed = bottomRed + WuQuant._top(cube, direction, position, this._momentsRed);
            let halfGreen = bottomGreen + WuQuant._top(cube, direction, position, this._momentsGreen);
            let halfBlue = bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue);
            let halfAlpha = bottomAlpha + WuQuant._top(cube, direction, position, this._momentsAlpha);
            let halfWeight = bottomWeight + WuQuant._top(cube, direction, position, this._weights);
            // the cube cannot be cut at bottom (this would lead to empty cube)
            if (halfWeight !== 0) {
                let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
                let temp = halfDistance / halfWeight;
                halfRed = wholeRed - halfRed;
                halfGreen = wholeGreen - halfGreen;
                halfBlue = wholeBlue - halfBlue;
                halfAlpha = wholeAlpha - halfAlpha;
                halfWeight = wholeWeight - halfWeight;
                if (halfWeight !== 0) {
                    halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
                    temp += halfDistance / halfWeight;
                    if (temp > result) {
                        result = temp;
                        cutPosition = position;
                    }
                }
            }
        }
        return { max: result, position: cutPosition };
    }
    // Cuts a cube with another one.
    _cut(first, second) {
        let direction;
        const wholeRed = WuQuant._volume(first, this._momentsRed);
        const wholeGreen = WuQuant._volume(first, this._momentsGreen);
        const wholeBlue = WuQuant._volume(first, this._momentsBlue);
        const wholeAlpha = WuQuant._volume(first, this._momentsAlpha);
        const wholeWeight = WuQuant._volume(first, this._weights);
        const red = this._maximize(first, WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        const green = this._maximize(first, WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        const blue = this._maximize(first, WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        const alpha = this._maximize(first, WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
            direction = WuQuant._alpha;
            // cannot split empty cube
            if (alpha.position < 0)
                return false;
        }
        else {
            if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
                direction = WuQuant._red;
            }
            else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
                direction = WuQuant._green;
            }
            else {
                direction = WuQuant._blue;
            }
        }
        second.redMaximum = first.redMaximum;
        second.greenMaximum = first.greenMaximum;
        second.blueMaximum = first.blueMaximum;
        second.alphaMaximum = first.alphaMaximum;
        // cuts in a certain direction
        switch (direction) {
            case WuQuant._red:
                second.redMinimum = first.redMaximum = red.position;
                second.greenMinimum = first.greenMinimum;
                second.blueMinimum = first.blueMinimum;
                second.alphaMinimum = first.alphaMinimum;
                break;
            case WuQuant._green:
                second.greenMinimum = first.greenMaximum = green.position;
                second.redMinimum = first.redMinimum;
                second.blueMinimum = first.blueMinimum;
                second.alphaMinimum = first.alphaMinimum;
                break;
            case WuQuant._blue:
                second.blueMinimum = first.blueMaximum = blue.position;
                second.redMinimum = first.redMinimum;
                second.greenMinimum = first.greenMinimum;
                second.alphaMinimum = first.alphaMinimum;
                break;
            case WuQuant._alpha:
                second.alphaMinimum = first.alphaMaximum = alpha.position;
                second.blueMinimum = first.blueMinimum;
                second.redMinimum = first.redMinimum;
                second.greenMinimum = first.greenMinimum;
                break;
        }
        // determines the volumes after cut
        first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
        second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
        // the cut was successful
        return true;
    }
    _initialize(colors) {
        this._colors = colors;
        // creates all the _cubes
        this._cubes = [];
        // initializes all the _cubes
        for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
            this._cubes[cubeIndex] = new WuColorCube();
        }
        // resets the reference minimums
        this._cubes[0].redMinimum = 0;
        this._cubes[0].greenMinimum = 0;
        this._cubes[0].blueMinimum = 0;
        this._cubes[0].alphaMinimum = 0;
        // resets the reference maximums
        this._cubes[0].redMaximum = this._maxSideIndex;
        this._cubes[0].greenMaximum = this._maxSideIndex;
        this._cubes[0].blueMaximum = this._maxSideIndex;
        this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
        this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._table = [];
        for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {
            this._table[tableIndex] = tableIndex * tableIndex;
        }
        this._pixels = [];
    }
    _setQuality(significantBitsPerChannel = 5) {
        this._significantBitsPerChannel = significantBitsPerChannel;
        this._maxSideIndex = 1 << this._significantBitsPerChannel;
        this._alphaMaxSideIndex = this._maxSideIndex;
        this._sideSize = this._maxSideIndex + 1;
        this._alphaSideSize = this._alphaMaxSideIndex + 1;
    }
}
WuQuant._alpha = 3;
WuQuant._red = 2;
WuQuant._green = 1;
WuQuant._blue = 0;
//# sourceMappingURL=wuQuant.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/quality/index.js":
/*!********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/quality/index.js ***!
  \********************************************************/
/*! exports provided: ssim */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ssim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssim */ "./node_modules/image-q/dist/esm/quality/ssim.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssim", function() { return _ssim__WEBPACK_IMPORTED_MODULE_0__["ssim"]; });

/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/quality/ssim.js":
/*!*******************************************************!*\
  !*** ./node_modules/image-q/dist/esm/quality/ssim.js ***!
  \*******************************************************/
/*! exports provided: ssim */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssim", function() { return ssim; });
/* harmony import */ var _constants_bt709__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/bt709 */ "./node_modules/image-q/dist/esm/constants/bt709.js");

// based on https://github.com/rhys-e/structural-similarity
// http://en.wikipedia.org/wiki/Structural_similarity
const K1 = 0.01; // tslint:disable-line:naming-convention
const K2 = 0.03; // tslint:disable-line:naming-convention
function ssim(image1, image2) {
    if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
        throw new Error('Images have different sizes!');
    }
    const bitsPerComponent = 8;
    const L = (1 << bitsPerComponent) - 1; // tslint:disable-line:naming-convention
    const c1 = Math.pow((K1 * L), 2);
    const c2 = Math.pow((K2 * L), 2);
    let numWindows = 0;
    let mssim = 0.0;
    // calculate ssim for each window
    iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
        // calculate variance and covariance
        let sigxy = 0.0;
        let sigsqx = 0.0;
        let sigsqy = 0.0;
        for (let i = 0; i < lumaValues1.length; i++) {
            sigsqx += Math.pow((lumaValues1[i] - averageLumaValue1), 2);
            sigsqy += Math.pow((lumaValues2[i] - averageLumaValue2), 2);
            sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
        }
        const numPixelsInWin = lumaValues1.length - 1;
        sigsqx /= numPixelsInWin;
        sigsqy /= numPixelsInWin;
        sigxy /= numPixelsInWin;
        // perform ssim calculation on window
        const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
        const denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2);
        const ssim = numerator / denominator;
        mssim += ssim;
        numWindows++;
    });
    return mssim / numWindows;
}
function iterate(image1, image2, callback) {
    const windowSize = 8;
    const width = image1.getWidth();
    const height = image1.getHeight();
    for (let y = 0; y < height; y += windowSize) {
        for (let x = 0; x < width; x += windowSize) {
            // avoid out-of-width/height
            const windowWidth = Math.min(windowSize, width - x);
            const windowHeight = Math.min(windowSize, height - y);
            const lumaValues1 = calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight);
            const lumaValues2 = calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight);
            const averageLuma1 = calculateAverageLuma(lumaValues1);
            const averageLuma2 = calculateAverageLuma(lumaValues2);
            callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
        }
    }
}
function calculateLumaValuesForWindow(image, x, y, width, height) {
    const pointArray = image.getPointArray();
    const lumaValues = [];
    let counter = 0;
    for (let j = y; j < y + height; j++) {
        const offset = j * image.getWidth();
        for (let i = x; i < x + width; i++) {
            const point = pointArray[offset + i];
            lumaValues[counter] = point.r * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__["Y"].RED + point.g * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__["Y"].GREEN + point.b * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__["Y"].BLUE;
            counter++;
        }
    }
    return lumaValues;
}
function calculateAverageLuma(lumaValues) {
    let sumLuma = 0.0;
    for (const luma of lumaValues) {
        sumLuma += luma;
    }
    return sumLuma / lumaValues.length;
}
//# sourceMappingURL=ssim.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/utils/arithmetic.js":
/*!***********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/utils/arithmetic.js ***!
  \***********************************************************/
/*! exports provided: degrees2radians, max3, min3, intInRange, inRange0to255Rounded, inRange0to255, stableSort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees2radians", function() { return degrees2radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max3", function() { return max3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min3", function() { return min3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intInRange", function() { return intInRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inRange0to255Rounded", function() { return inRange0to255Rounded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inRange0to255", function() { return inRange0to255; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stableSort", function() { return stableSort; });
function degrees2radians(n) {
    return n * (Math.PI / 180);
}
function max3(a, b, c) {
    let m = a;
    if (m < b)
        m = b;
    if (m < c)
        m = c;
    return m;
}
function min3(a, b, c) {
    let m = a;
    if (m > b)
        m = b;
    if (m > c)
        m = c;
    return m;
}
function intInRange(value, low, high) {
    if (value > high)
        value = high;
    if (value < low)
        value = low;
    return value | 0;
}
function inRange0to255Rounded(n) {
    n = Math.round(n);
    if (n > 255)
        n = 255;
    else if (n < 0)
        n = 0;
    return n;
}
function inRange0to255(n) {
    if (n > 255)
        n = 255;
    else if (n < 0)
        n = 0;
    return n;
}
function stableSort(arrayToSort, callback) {
    const type = typeof arrayToSort[0];
    let sorted;
    if (type === 'number' || type === 'string') {
        const ord = Object.create(null); // tslint:disable-line:no-null-keyword
        for (let i = 0, l = arrayToSort.length; i < l; i++) {
            const val = arrayToSort[i]; // tslint:disable-line:no-any
            if (ord[val] || ord[val] === 0)
                continue;
            ord[val] = i;
        }
        sorted = arrayToSort.sort(function (a, b) {
            return callback(a, b) || ord[a] - ord[b];
        });
    }
    else {
        const ord2 = arrayToSort.slice(0);
        sorted = arrayToSort.sort(function (a, b) {
            return callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b);
        });
    }
    return sorted;
}
//# sourceMappingURL=arithmetic.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/utils/hueStatistics.js":
/*!**************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/utils/hueStatistics.js ***!
  \**************************************************************/
/*! exports provided: HueStatistics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HueStatistics", function() { return HueStatistics; });
/* harmony import */ var _conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../conversion/rgb2hsl */ "./node_modules/image-q/dist/esm/conversion/rgb2hsl.js");
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./palette */ "./node_modules/image-q/dist/esm/utils/palette.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */


class HueGroup {
    constructor() {
        this.num = 0;
        this.cols = [];
    }
}
class HueStatistics {
    constructor(numGroups, minCols) {
        this._numGroups = numGroups;
        this._minCols = minCols;
        this._stats = [];
        for (let i = 0; i <= numGroups; i++) {
            this._stats[i] = new HueGroup();
        }
        this._groupsFull = 0;
    }
    check(i32) {
        if (this._groupsFull === this._numGroups + 1) {
            this.check = function () {
            };
        }
        const r = (i32 & 0xff);
        const g = (i32 >>> 8) & 0xff;
        const b = (i32 >>> 16) & 0xff;
        const hg = (r === g && g === b) ? 0 : 1 + Object(_palette__WEBPACK_IMPORTED_MODULE_1__["hueGroup"])(Object(_conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_0__["rgb2hsl"])(r, g, b).h, this._numGroups);
        const gr = this._stats[hg];
        const min = this._minCols;
        gr.num++;
        if (gr.num > min) {
            return;
        }
        if (gr.num === min) {
            this._groupsFull++;
        }
        if (gr.num <= min) {
            this._stats[hg].cols.push(i32);
        }
    }
    injectIntoDictionary(histG) {
        for (let i = 0; i <= this._numGroups; i++) {
            if (this._stats[i].num <= this._minCols) {
                this._stats[i].cols.forEach((col) => {
                    if (!histG[col]) {
                        histG[col] = 1;
                    }
                    else {
                        histG[col]++;
                    }
                });
            }
        }
    }
    injectIntoArray(histG) {
        for (let i = 0; i <= this._numGroups; i++) {
            if (this._stats[i].num <= this._minCols) {
                this._stats[i].cols.forEach((col) => {
                    if (histG.indexOf(col) === -1) {
                        histG.push(col);
                    }
                });
            }
        }
    }
}
//# sourceMappingURL=hueStatistics.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/utils/index.js":
/*!******************************************************!*\
  !*** ./node_modules/image-q/dist/esm/utils/index.js ***!
  \******************************************************/
/*! exports provided: Point, PointContainer, Palette, HueStatistics, ProgressTracker, arithmetic */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _arithmetic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arithmetic */ "./node_modules/image-q/dist/esm/utils/arithmetic.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "arithmetic", function() { return _arithmetic__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _hueStatistics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hueStatistics */ "./node_modules/image-q/dist/esm/utils/hueStatistics.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HueStatistics", function() { return _hueStatistics__WEBPACK_IMPORTED_MODULE_1__["HueStatistics"]; });

/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./palette */ "./node_modules/image-q/dist/esm/utils/palette.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Palette", function() { return _palette__WEBPACK_IMPORTED_MODULE_2__["Palette"]; });

/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./node_modules/image-q/dist/esm/utils/point.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return _point__WEBPACK_IMPORTED_MODULE_3__["Point"]; });

/* harmony import */ var _pointContainer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pointContainer */ "./node_modules/image-q/dist/esm/utils/pointContainer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointContainer", function() { return _pointContainer__WEBPACK_IMPORTED_MODULE_4__["PointContainer"]; });

/* harmony import */ var _progressTracker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./progressTracker */ "./node_modules/image-q/dist/esm/utils/progressTracker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProgressTracker", function() { return _progressTracker__WEBPACK_IMPORTED_MODULE_5__["ProgressTracker"]; });

/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/utils/palette.js":
/*!********************************************************!*\
  !*** ./node_modules/image-q/dist/esm/utils/palette.js ***!
  \********************************************************/
/*! exports provided: hueGroup, Palette */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hueGroup", function() { return hueGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Palette", function() { return Palette; });
/* harmony import */ var _pointContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointContainer */ "./node_modules/image-q/dist/esm/utils/pointContainer.js");
/* harmony import */ var _conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conversion/rgb2hsl */ "./node_modules/image-q/dist/esm/conversion/rgb2hsl.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */


// TODO: make paletteArray via pointContainer, so, export will be available via pointContainer.exportXXX
const hueGroups = 10;
function hueGroup(hue, segmentsNumber) {
    const maxHue = 360;
    const seg = maxHue / segmentsNumber;
    const half = seg / 2;
    for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
        if (hue >= mid && hue < mid + seg)
            return i;
    }
    return 0;
}
class Palette {
    constructor() {
        this._pointArray = [];
        this._i32idx = {};
        this._pointContainer = new _pointContainer__WEBPACK_IMPORTED_MODULE_0__["PointContainer"]();
        this._pointContainer.setHeight(1);
        this._pointArray = this._pointContainer.getPointArray();
    }
    add(color) {
        this._pointArray.push(color);
        this._pointContainer.setWidth(this._pointArray.length);
    }
    has(color) {
        for (let i = this._pointArray.length - 1; i >= 0; i--) {
            if (color.uint32 === this._pointArray[i].uint32)
                return true;
        }
        return false;
    }
    // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl
    getNearestColor(colorDistanceCalculator, color) {
        return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
    }
    getPointContainer() {
        return this._pointContainer;
    }
    // TOTRY: use HUSL - http://boronine.com/husl/
    /*
     public nearestIndexByUint32(i32) {
     var idx : number = this._nearestPointFromCache("" + i32);
     if (idx >= 0) return idx;
  
     var min = 1000,
     rgb = [
     (i32 & 0xff),
     (i32 >>> 8) & 0xff,
     (i32 >>> 16) & 0xff,
     (i32 >>> 24) & 0xff
     ],
     len = this._pointArray.length;
  
     idx = 0;
     for (var i = 0; i < len; i++) {
     var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);
  
     if (dist < min) {
     min = dist;
     idx = i;
     }
     }
  
     this._i32idx[i32] = idx;
     return idx;
     }
     */
    _nearestPointFromCache(key) {
        return typeof this._i32idx[key] === 'number' ? this._i32idx[key] : -1;
    }
    _getNearestIndex(colorDistanceCalculator, point) {
        let idx = this._nearestPointFromCache('' + point.uint32);
        if (idx >= 0)
            return idx;
        let minimalDistance = Number.MAX_VALUE;
        idx = 0;
        for (let i = 0, l = this._pointArray.length; i < l; i++) {
            const p = this._pointArray[i];
            const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
            if (distance < minimalDistance) {
                minimalDistance = distance;
                idx = i;
            }
        }
        this._i32idx[point.uint32] = idx;
        return idx;
    }
    /*
     public reduce(histogram : ColorHistogram, colors : number) {
     if (this._pointArray.length > colors) {
     var idxi32 = histogram.getImportanceSortedColorsIDXI32();
  
     // quantize histogram to existing palette
     var keep = [], uniqueColors = 0, idx, pruned = false;
  
     for (var i = 0, len = idxi32.length; i < len; i++) {
     // palette length reached, unset all remaining colors (sparse palette)
     if (uniqueColors >= colors) {
     this.prunePal(keep);
     pruned = true;
     break;
     } else {
     idx = this.nearestIndexByUint32(idxi32[i]);
     if (keep.indexOf(idx) < 0) {
     keep.push(idx);
     uniqueColors++;
     }
     }
     }
  
     if (!pruned) {
     this.prunePal(keep);
     }
     }
     }
  
     // TODO: check usage, not tested!
     public prunePal(keep : number[]) {
     var colors = this._pointArray.length;
     for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
     if (keep.indexOf(colorIndex) < 0) {
  
     if(colorIndex + 1 < colors) {
     this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];
     }
     --colors;
     //this._pointArray[colorIndex] = null;
     }
     }
     console.log("colors pruned: " + (this._pointArray.length - colors));
     this._pointArray.length = colors;
     this._i32idx = {};
     }
     */
    // TODO: group very low lum and very high lum colors
    // TODO: pass custom sort order
    // TODO: sort criteria function should be placed to HueStats class
    sort() {
        this._i32idx = {};
        this._pointArray.sort((a, b) => {
            const hslA = Object(_conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_1__["rgb2hsl"])(a.r, a.g, a.b);
            const hslB = Object(_conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_1__["rgb2hsl"])(b.r, b.g, b.b);
            // sort all grays + whites together
            const hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + hueGroup(hslA.h, hueGroups);
            const hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + hueGroup(hslB.h, hueGroups);
            /*
             var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);
             var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);
             */
            const hueDiff = hueB - hueA;
            if (hueDiff)
                return -hueDiff;
            /*
             var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));
             if (lumDiff) return -lumDiff;
             */
            const lA = a.getLuminosity(true);
            const lB = b.getLuminosity(true);
            if (lB - lA !== 0)
                return lB - lA;
            const satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);
            if (satDiff)
                return -satDiff;
            return 0;
        });
    }
}
//# sourceMappingURL=palette.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/utils/point.js":
/*!******************************************************!*\
  !*** ./node_modules/image-q/dist/esm/utils/point.js ***!
  \******************************************************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony import */ var _constants_bt709__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/bt709 */ "./node_modules/image-q/dist/esm/constants/bt709.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */

/**
 * v8 optimized class
 * 1) "constructor" should have initialization with worst types
 * 2) "set" should have |0 / >>> 0
 */
class Point {
    // Lab : { L : number; a : number; b : number };
    static createByQuadruplet(quadruplet) {
        const point = new Point();
        point.r = quadruplet[0] | 0;
        point.g = quadruplet[1] | 0;
        point.b = quadruplet[2] | 0;
        point.a = quadruplet[3] | 0;
        point._loadUINT32();
        point._loadQuadruplet();
        // point._loadLab();
        return point;
    }
    static createByRGBA(red, green, blue, alpha) {
        const point = new Point();
        point.r = red | 0;
        point.g = green | 0;
        point.b = blue | 0;
        point.a = alpha | 0;
        point._loadUINT32();
        point._loadQuadruplet();
        // point._loadLab();
        return point;
    }
    static createByUint32(uint32) {
        const point = new Point();
        point.uint32 = uint32 >>> 0;
        point._loadRGBA();
        point._loadQuadruplet();
        // point._loadLab();
        return point;
    }
    constructor() {
        this.uint32 = -1 >>> 0;
        this.r = this.g = this.b = this.a = 0;
        this.rgba = new Array(4);
        this.rgba[0] = 0;
        this.rgba[1] = 0;
        this.rgba[2] = 0;
        this.rgba[3] = 0;
        /*
         this.Lab = {
         L : 0.0,
         a : 0.0,
         b : 0.0
         };
         */
    }
    from(point) {
        this.r = point.r;
        this.g = point.g;
        this.b = point.b;
        this.a = point.a;
        this.uint32 = point.uint32;
        this.rgba[0] = point.r;
        this.rgba[1] = point.g;
        this.rgba[2] = point.b;
        this.rgba[3] = point.a;
        /*
         this.Lab.L = point.Lab.L;
         this.Lab.a = point.Lab.a;
         this.Lab.b = point.Lab.b;
         */
    }
    /*
     * TODO:
     Luminance from RGB:
  
     Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]
     Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]
     Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]
     */
    getLuminosity(useAlphaChannel) {
        let r = this.r;
        let g = this.g;
        let b = this.b;
        if (useAlphaChannel) {
            r = Math.min(255, 255 - this.a + this.a * r / 255);
            g = Math.min(255, 255 - this.a + this.a * g / 255);
            b = Math.min(255, 255 - this.a + this.a * b / 255);
        }
        // var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;
        /*
         if(useAlphaChannel) {
         luma = (luma * (255 - this.a)) / 255;
         }
         */
        return r * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__["Y"].RED + g * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__["Y"].GREEN + b * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__["Y"].BLUE;
    }
    _loadUINT32() {
        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
    }
    _loadRGBA() {
        this.r = this.uint32 & 0xff;
        this.g = (this.uint32 >>> 8) & 0xff;
        this.b = (this.uint32 >>> 16) & 0xff;
        this.a = (this.uint32 >>> 24) & 0xff;
    }
    _loadQuadruplet() {
        this.rgba[0] = this.r;
        this.rgba[1] = this.g;
        this.rgba[2] = this.b;
        this.rgba[3] = this.a;
        /*
         var xyz = rgb2xyz(this.r, this.g, this.b);
         var lab = xyz2lab(xyz.x, xyz.y, xyz.z);
         this.lab.l = lab.l;
         this.lab.a = lab.a;
         this.lab.b = lab.b;
         */
    }
}
//# sourceMappingURL=point.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/utils/pointContainer.js":
/*!***************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/utils/pointContainer.js ***!
  \***************************************************************/
/*! exports provided: PointContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointContainer", function() { return PointContainer; });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ "./node_modules/image-q/dist/esm/utils/point.js");
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */

/**
 * v8 optimizations done.
 * fromXXX methods are static to move out polymorphic code from class instance itself.
 */
class PointContainer {
    constructor() {
        this._width = 0;
        this._height = 0;
        this._pointArray = [];
    }
    getWidth() {
        return this._width;
    }
    getHeight() {
        return this._height;
    }
    setWidth(width) {
        this._width = width;
    }
    setHeight(height) {
        this._height = height;
    }
    getPointArray() {
        return this._pointArray;
    }
    clone() {
        const clone = new PointContainer();
        clone._width = this._width;
        clone._height = this._height;
        for (let i = 0, l = this._pointArray.length; i < l; i++) {
            clone._pointArray[i] = _point__WEBPACK_IMPORTED_MODULE_0__["Point"].createByUint32(this._pointArray[i].uint32 | 0); // "| 0" is added for v8 optimization
        }
        return clone;
    }
    toUint32Array() {
        const l = this._pointArray.length;
        const uint32Array = new Uint32Array(l);
        for (let i = 0; i < l; i++) {
            uint32Array[i] = this._pointArray[i].uint32;
        }
        return uint32Array;
    }
    toUint8Array() {
        return new Uint8Array(this.toUint32Array().buffer);
    }
    static fromHTMLImageElement(img) {
        const width = img.naturalWidth;
        const height = img.naturalHeight;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d'); // tslint:disable-line:no-non-null-assertion
        ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
        return PointContainer.fromHTMLCanvasElement(canvas);
    }
    static fromHTMLCanvasElement(canvas) {
        const width = canvas.width;
        const height = canvas.height;
        const ctx = canvas.getContext('2d'); // tslint:disable-line:no-non-null-assertion
        const imgData = ctx.getImageData(0, 0, width, height);
        return PointContainer.fromImageData(imgData);
    }
    static fromImageData(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        return PointContainer.fromUint8Array(imageData.data, width, height);
    }
    static fromUint8Array(uint8Array, width, height) {
        switch (Object.prototype.toString.call(uint8Array)) {
            case '[object Uint8ClampedArray]':
            case '[object Uint8Array]':
                break;
            default:
                uint8Array = new Uint8Array(uint8Array);
        }
        const uint32Array = new Uint32Array(uint8Array.buffer);
        return PointContainer.fromUint32Array(uint32Array, width, height);
    }
    static fromUint32Array(uint32Array, width, height) {
        const container = new PointContainer();
        container._width = width;
        container._height = height;
        for (let i = 0, l = uint32Array.length; i < l; i++) {
            container._pointArray[i] = _point__WEBPACK_IMPORTED_MODULE_0__["Point"].createByUint32(uint32Array[i] | 0); // "| 0" is added for v8 optimization
        }
        return container;
    }
    static fromBuffer(buffer, width, height) {
        const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
        return PointContainer.fromUint32Array(uint32Array, width, height);
    }
}
//# sourceMappingURL=pointContainer.js.map

/***/ }),

/***/ "./node_modules/image-q/dist/esm/utils/progressTracker.js":
/*!****************************************************************!*\
  !*** ./node_modules/image-q/dist/esm/utils/progressTracker.js ***!
  \****************************************************************/
/*! exports provided: ProgressTracker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProgressTracker", function() { return ProgressTracker; });
class ProgressTracker {
    constructor(valueRange, progressRange) {
        this._range = valueRange;
        this._progressRange = progressRange;
        this._step = Math.max(1, this._range / (ProgressTracker.steps + 1) | 0);
        this._last = -this._step;
        this.progress = 0;
    }
    shouldNotify(current) {
        if (current - this._last >= this._step) {
            this._last = current;
            this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
            return true;
        }
        return false;
    }
}
ProgressTracker.steps = 100;
//# sourceMappingURL=progressTracker.js.map

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/omggif/omggif.js":
/*!***************************************!*\
  !*** ./node_modules/omggif/omggif.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.



function GifWriter(buf, width, height, gopts) {
  var p = 0;

  var gopts = gopts === undefined ? { } : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;

  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
    throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;
    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {
      throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256.");
    }
    return num_colors;
  }

  // - Header.
  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

  // Handling of Global Color Table (palette) and background index.
  var gp_num_colors_pow2 = 0;
  var background = 0;
  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);
    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;
    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors)
        throw new Error("Background index out of range.");
      // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).
      if (background === 0)
        throw new Error("Background index explicitly passed as 0.");
    }
  }

  // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
  // NOTE: Indicates 0-bpp original color resolution (unused?).
  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
  buf[p++] = background;  // Background Color Index.
  buf[p++] = 0;  // Pixel aspect ratio (unused?).

  // - Global Color Table
  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {  // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535)
      throw new Error("Loop count invalid.")
    // Extension code, label, and length.
    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
    // NETSCAPE2.0
    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
    // Sub-block
    buf[p++] = 0x03; buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00;  // Terminator.
  }


  var ended = false;

  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
    if (ended === true) { --p; ended = false; }  // Un-end.

    opts = opts === undefined ? { } : opts;

    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?
    if (x < 0 || y < 0 || x > 65535 || y > 65535)
      throw new Error("x/y invalid.")

    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
      throw new Error("Width/Height invalid.")

    if (indexed_pixels.length < w * h)
      throw new Error("Not enough pixels for the frame size.");

    var using_local_palette = true;
    var palette = opts.palette;
    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null)
      throw new Error("Must supply either a local or global palette.");

    var num_colors = check_palette_and_num_colors(palette);

    // Compute the min_code_size (power of 2), destroying num_colors.
    var min_code_size = 0;
    while (num_colors >>= 1) ++min_code_size;
    num_colors = 1 << min_code_size;  // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay;

    // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.
    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
      throw new Error("Disposal out of range.");

    var use_transparency = false;
    var transparent_index = 0;
    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors)
        throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
      buf[p++] = 4;  // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index;  // Transparent color index.
      buf[p++] = 0;  // Block Terminator.
    }

    // - Image Descriptor
    buf[p++] = 0x2c;  // Image Seperator.
    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
    // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.
    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

    // - Local Color Table
    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(
            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);

    return p;
  };

  this.end = function() {
    if (ended === false) {
      buf[p++] = 0x3b;  // Trailer.
      ended = true;
    }
    return p;
  };

  this.getOutputBuffer = function() { return buf; };
  this.setOutputBuffer = function(v) { buf = v; };
  this.getOutputBufferPosition = function() { return p; };
  this.setOutputBufferPosition = function(v) { p = v; };
}

// Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.
function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++;  // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  var cur_shift = 0;
  // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).
  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8; cur_shift -= 8;
      if (p === cur_subblock + 256) {  // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  }

  // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.

  // Output code for the current contents of the index buffer.
  var ib_code = index_stream[0] & code_mask;  // Load first input index.
  var code_table = { };  // Key'd on our 20-bit "tuple".

  emit_code(clear_code);  // Spec says first code should be a clear code.

  // First index already loaded, process the rest of the stream.
  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
    var cur_code = code_table[cur_key];  // buffer + k.

    // Check if we have to create a new code table entry.
    if (cur_code === undefined) {  // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;
      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8; cur_shift -= 8;
        if (p === cur_subblock + 256) {  // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {  // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = { };
      } else {  // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= (1 << cur_code_size)) ++cur_code_size;
        code_table[cur_key] = next_code++;  // Insert into code table.
      }

      ib_code = k;  // Index buffer to single input k.
    } else {
      ib_code = cur_code;  // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code);  // There will still be something in the index buffer.
  emit_code(eoi_code);  // End Of Information.

  // Flush / finalize the sub-blocks stream to the buffer.
  emit_bytes_to_buffer(1);

  // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.
  if (cur_subblock + 1 === p) {  // Started but unused.
    buf[cur_subblock] = 0;
  } else {  // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }
  return p;
}

function GifReader(buf) {
  var p = 0;

  // - Header (GIF87a or GIF89a).
  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  }

  // - Logical Screen Descriptor.
  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++];  // <Packed Fields>.
  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << (num_global_colors_pow2 + 1);
  var background = buf[p++];
  buf[p++];  // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size   = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3;  // Seek past palette.
  }

  var no_eof = true;

  var frames = [ ];

  var delay = 0;
  var transparent_index = null;
  var disposal = 0;  // 0 - No disposal specified.
  var loop_count = null;

  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:  // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:  // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
                // NETSCAPE2.0
                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
                // Sub-block
                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++;  // Skip terminator.
            } else {  // We don't know what it is, just try to get past it.
              p += 12;
              while (true) {  // Seek through subblocks.
                var block_size = buf[p++];
                // Bad block size (ex: undefined from an out of bounds read).
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;  // 0 size is terminator
                p += block_size;
              }
            }
            break;

          case 0xf9:  // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p+4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++;  // Skip terminator.
            break;

          case 0xfe:  // Comment Extension.
            while (true) {  // Seek through subblocks.
              var block_size = buf[p++];
              // Bad block size (ex: undefined from an out of bounds read).
              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break;  // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));
              p += block_size;
            }
            break;

          default:
            throw new Error(
                "Unknown graphic control label: 0x" + buf[p-1].toString(16));
        }
        break;

      case 0x2c:  // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << (num_local_colors_pow2 + 1);
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;
        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p;  // Override with local palette.
          palette_size = num_local_colors;
          p += num_local_colors * 3;  // Seek past palette.
        }

        var data_offset = p;

        p++;  // codesize
        while (true) {
          var block_size = buf[p++];
          // Bad block size (ex: undefined from an out of bounds read).
          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break;  // 0 size is terminator
          p += block_size;
        }

        frames.push({x: x, y: y, width: w, height: h,
                     has_local_palette: has_local_palette,
                     palette_offset: palette_offset,
                     palette_size: palette_size,
                     data_offset: data_offset,
                     data_length: p - data_offset,
                     transparent_index: transparent_index,
                     interlaced: !!interlace_flag,
                     delay: delay,
                     disposal: disposal});
        break;

      case 0x3b:  // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));
        break;
    }
  }

  this.numFrames = function() {
    return frames.length;
  };

  this.loopCount = function() {
    return loop_count;
  };

  this.frameInfo = function(frame_num) {
    if (frame_num < 0 || frame_num >= frames.length)
      throw new Error("Frame index out of range.");
    return frames[frame_num];
  }

  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };

  // I will go to copy and paste hell one day...
  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];

  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.
  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;

  var op = 0;  // Output pointer.

  var subblock_size = code_stream[p++];

  // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);
  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

  var prev_code = null;  // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break;  // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++];  // Next subblock.
      } else {
        --subblock_size;
      }
    }

    // TODO(deanm): We should never really get here, we should have received
    // and EOI.
    if (cur_shift < cur_code_size)
      break;

    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size;

    // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.
    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.

      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1;

      // Don't update prev_code ?
      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    }

    // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.

    var chase_code = code < next_code ? code : prev_code;

    // Chase what we will output, either {CODE} or {CODE-1}.
    var chase_length = 0;
    var chase = chase_code;
    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;

    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    }

    // Already have the first byte from the chase, might as well write it fast.
    output[op++] = k;

    op += chase_length;
    var b = op;  // Track pointer, writing backwards.

    if (chase_code !== code)  // The case of emitting {CODE-1} + k.
      output[op++] = k;

    chase = chase_code;
    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff;  // Write backwards.
      chase >>= 8;  // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k;
      // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).
      if (next_code >= code_mask+1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
}

// CommonJS.
try { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) {}


/***/ }),

/***/ "./node_modules/punycode/punycode.js":
/*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/sockjs-client/dist/sockjs.js":
/*!***************************************************!*\
  !*** ./node_modules/sockjs-client/dist/sockjs.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.4.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.4.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "./node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/BaseClient.js":
/*!*********************************************************!*\
  !*** (webpack)-dev-server/client/clients/BaseClient.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js":
/*!***********************************************************!*\
  !*** (webpack)-dev-server/client/clients/SockJSClient.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(/*! sockjs-client/dist/sockjs */ "./node_modules/sockjs-client/dist/sockjs.js");

var BaseClient = __webpack_require__(/*! ./BaseClient */ "./node_modules/webpack-dev-server/client/clients/BaseClient.js");

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(/*! ./SockJSClient */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js");
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/index.js?http://localhost:9000":
/*!*********************************************************!*\
  !*** (webpack)-dev-server/client?http://localhost:9000 ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(/*! strip-ansi */ "./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js");

var socket = __webpack_require__(/*! ./socket */ "./node_modules/webpack-dev-server/client/socket.js");

var overlay = __webpack_require__(/*! ./overlay */ "./node_modules/webpack-dev-server/client/overlay.js");

var _require = __webpack_require__(/*! ./utils/log */ "./node_modules/webpack-dev-server/client/utils/log.js"),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(/*! ./utils/sendMessage */ "./node_modules/webpack-dev-server/client/utils/sendMessage.js");

var reloadApp = __webpack_require__(/*! ./utils/reloadApp */ "./node_modules/webpack-dev-server/client/utils/reloadApp.js");

var createSocketUrl = __webpack_require__(/*! ./utils/createSocketUrl */ "./node_modules/webpack-dev-server/client/utils/createSocketUrl.js");

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__("./node_modules/webpack/hot sync ^\\.\\/log$");

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost:9000"))

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!**********************************************!*\
  !*** (webpack)-dev-server/client/overlay.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(/*! ansi-html */ "./node_modules/ansi-html/index.js");

var _require = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/index.js"),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!*********************************************!*\
  !*** (webpack)-dev-server/client/socket.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(/*! ./clients/SockJSClient */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js");
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! (webpack)-dev-server/client/clients/SockJSClient.js */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js")))

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketUrl.js":
/*!************************************************************!*\
  !*** (webpack)-dev-server/client/utils/createSocketUrl.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var getCurrentScriptSource = __webpack_require__(/*! ./getCurrentScriptSource */ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js");

function createSocketUrl(resourceQuery) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    urlParts = url.parse(resourceQuery.substr(1));
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();

    if (scriptHost) {
      // eslint-disable-next-line no-useless-escape
      scriptHost = scriptHost.replace(/\/[^\/]+$/, '');
    }

    urlParts = url.parse(scriptHost || '/', false, true);
  }

  if (!urlParts.port || urlParts.port === '0') {
    urlParts.port = self.location.port;
  }

  var _urlParts = urlParts,
      auth = _urlParts.auth,
      path = _urlParts.path;
  var _urlParts2 = urlParts,
      hostname = _urlParts2.hostname,
      protocol = _urlParts2.protocol; // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384

  var isAnyHostname = (hostname === '0.0.0.0' || hostname === '::') && self.location.hostname && // eslint-disable-next-line no-bitwise
  !!~self.location.protocol.indexOf('http');

  if (isAnyHostname) {
    hostname = self.location.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = self.location.protocol;
  } // default values of the sock url if they are not provided


  var sockHost = hostname;
  var sockPath = '/sockjs-node';
  var sockPort = urlParts.port; // eslint-disable-next-line no-undefined

  var shouldParsePath = path !== null && path !== undefined && path !== '/';

  if (shouldParsePath) {
    var parsedQuery = querystring.parse(path); // all of these sock url params are optionally passed in through
    // resourceQuery, so we need to fall back to the default if
    // they are not provided

    sockHost = parsedQuery.sockHost || sockHost;
    sockPath = parsedQuery.sockPath || sockPath;
    sockPort = parsedQuery.sockPort || sockPort;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!*******************************************************************!*\
  !*** (webpack)-dev-server/client/utils/getCurrentScriptSource.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!************************************************!*\
  !*** (webpack)-dev-server/client/utils/log.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js").getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!******************************************************!*\
  !*** (webpack)-dev-server/client/utils/reloadApp.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(/*! ./log */ "./node_modules/webpack-dev-server/client/utils/log.js"),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(/*! webpack/hot/emitter */ "./node_modules/webpack/hot/emitter.js");

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!********************************************************!*\
  !*** (webpack)-dev-server/client/utils/sendMessage.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),

/***/ "./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js":
/*!*************************************************************!*\
  !*** (webpack)-dev-server/node_modules/ansi-regex/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),

/***/ "./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js":
/*!*************************************************************!*\
  !*** (webpack)-dev-server/node_modules/strip-ansi/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js")();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/hot sync ^\\.\\/log$":
/*!*************************************************!*\
  !*** (webpack)/hot sync nonrecursive ^\.\/log$ ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": "./node_modules/webpack/hot/log.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/webpack/hot sync ^\\.\\/log$";

/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!********************************!*\
  !*** (webpack)/hot/emitter.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js");
module.exports = new EventEmitter();


/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!****************************!*\
  !*** (webpack)/hot/log.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./src/Animated_GIF.js":
/*!*****************************!*\
  !*** ./src/Animated_GIF.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var omggif__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! omggif */ "./node_modules/omggif/omggif.js");
/* harmony import */ var omggif__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(omggif__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var image_q__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! image-q */ "./node_modules/image-q/dist/esm/image-q.js");
/* harmony import */ var _Animated_GIF_worker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Animated_GIF.worker */ "./src/Animated_GIF.worker.js");
/* harmony import */ var _Animated_GIF_worker__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Animated_GIF_worker__WEBPACK_IMPORTED_MODULE_2__);



// A library/utility for generating GIF files
// Uses Dean McNamee's omggif library
// and image-q's RGBQuant quantizer
//
// @author sole / http://soledadpenades.com
// Updated by Adrian De Lisle to support transparency & slight modernization
const Animated_GIF = function Animated_GIF(globalOptions) {
  'use strict'

  globalOptions = globalOptions || {}

  let globalWidth = globalOptions.width || 160
  let globalHeight = globalOptions.height || 120
  const globalDithering = globalOptions.dithering || undefined
  const globalPalette = globalOptions.palette || null
  const globalDisposal = globalOptions.disposal || 0
  const globalTransparencyCutOff = globalOptions.transparencyCutOff || 0.7 // used for normalizing pixels to be full transparent or opaque
  let canvas = null,
    ctx = null,
    repeat = 0,
    delay = 250
  const frames = []
  let numRenderedFrames = 0
  let onRenderCompleteCallback = function() {}
  let onRenderProgressCallback = function() {}
  let workers = [],
    availableWorkers = [],
    numWorkers
  let generatingGIF = false

  // We'll try to be a little lenient with the palette so as to make the library easy to use
  // The only thing we can't cope with is having a non-array so we'll bail on that one.
  if (globalPalette) {
    if (!(globalPalette instanceof Array)) {
      throw ('Palette MUST be an array but it is: ', globalPalette)
    } else {
      // Now there are other two constraints that we will warn about
      // and silently fix them... somehow:

      // a) Must contain between 2 and 256 colours
      if (globalPalette.length < 2 || globalPalette.length > 256) {
        console.error('Palette must hold only between 2 and 256 colours')

        while (globalPalette.length < 2) {
          globalPalette.push(0x000000)
        }

        if (globalPalette.length > 256) {
          globalPalette = globalPalette.slice(0, 256)
        }
      }

      // b) Must be power of 2
      if (!powerOfTwo(globalPalette.length)) {
        console.error('Palette must have a power of two number of colours')

        while (!powerOfTwo(globalPalette.length)) {
          globalPalette.splice(globalPalette.length - 1, 1)
        }
      }
    }
  }

  globalOptions = globalOptions || {}
  numWorkers = globalOptions.numWorkers || 2

  for (let i = 0; i < numWorkers; i++) {
    const w = new _Animated_GIF_worker__WEBPACK_IMPORTED_MODULE_2___default.a()
    workers.push(w)
    availableWorkers.push(w)
  }

  // ---

  // Return a worker for processing a frame
  function getWorker() {
    if (availableWorkers.length === 0) {
      throw 'No workers left!'
    }

    return availableWorkers.pop()
  }

  // Restore a worker to the pool
  function freeWorker(worker) {
    availableWorkers.push(worker)
  }

  // Faster/closurized bufferToString function
  // (caching the String.fromCharCode values)
  const bufferToString = (function() {
    let byteMap = []
    for (let i = 0; i < 256; i++) {
      byteMap[i] = String.fromCharCode(i)
    }

    return function(buffer) {
      const numberValues = buffer.length
      let str = ''

      for (let i = 0; i < numberValues; i++) {
        str += byteMap[buffer[i]]
      }

      return str
    }
  })()

  function startRendering(completeCallback) {
    onRenderCompleteCallback = completeCallback

    for (let i = 0; i < numWorkers && i < frames.length; i++) {
      processFrame(i)
    }
  }

  function processFrame(position) {
    let frame
    let worker

    frame = frames[position]

    if (frame.beingProcessed || frame.done) {
      console.error('Frame already being processed or done!', frame.position)
      onFrameFinished()
      return
    }

    frame.beingProcessed = true

    worker = getWorker()

    worker.onmessage = function(ev) {
      const data = ev.data

      // Delete original data, and free memory
      delete frame.data

      // TODO grrr... HACK for object -> Array
      frame.pixels = Array.prototype.slice.call(data.pixels)
      frame.palette = Array.prototype.slice.call(data.palette)
      frame.transparencyIndex = data.transparencyIndex
      frame.done = true
      frame.beingProcessed = false

      freeWorker(worker)

      onFrameFinished()
    }

    worker.postMessage(frame)
  }

  function processNextFrame() {
    let position = -1

    for (let i = 0; i < frames.length; i++) {
      var frame = frames[i]
      if (!frame.done && !frame.beingProcessed) {
        position = i
        break
      }
    }

    if (position >= 0) {
      processFrame(position)
    }
  }

  function onFrameFinished() {
    // ~~~ taskFinished

    // The GIF is not written until we're done with all the frames
    // because they might not be processed in the same order
    const allDone = frames.every(function(frame) {
      return !frame.beingProcessed && frame.done
    })

    numRenderedFrames++
    onRenderProgressCallback((numRenderedFrames * 0.75) / frames.length)

    if (allDone) {
      if (!generatingGIF) {
        generateGIF(frames, onRenderCompleteCallback)
      }
    } else {
      setTimeout(processNextFrame, 1)
    }
  }

  // Takes the already processed data in frames and feeds it to a new
  // GifWriter instance in order to get the binary GIF file
  function generateGIF(frames, callback) {
    // TODO: Weird: using a simple JS array instead of a typed array,
    // the files are WAY smaller o_o. Patches/explanations welcome!
    const buffer = [] // new Uint8Array(width * height * frames.length * 5);
    const gifOptions = { loop: repeat }

    // Using global palette but only if we're also using dithering
    if (globalDithering !== null && globalPalette !== null) {
      gifOptions.palette = globalPalette
    }

    const gifWriter = new omggif__WEBPACK_IMPORTED_MODULE_0__["GifWriter"](
      buffer,
      globalWidth,
      globalHeight,
      gifOptions
    )

    generatingGIF = true

    frames.forEach(function(frame) {
      let framePalette = globalPalette ? globalPalette : frame.palette

      onRenderProgressCallback(
        0.75 + (0.25 * frame.position * 1.0) / frames.length
      )

      while (!powerOfTwo(framePalette.length) && framePalette.length < 256) {
        framePalette.push(0x000000)
      }

      gifWriter.addFrame(0, 0, globalWidth, globalHeight, frame.pixels, {
        palette: framePalette,
        delay: delay,
        transparent: frame.transparencyIndex,
        disposal: frame.disposal,
      })
    })

    gifWriter.end()
    onRenderProgressCallback(1.0)

    frames = []
    generatingGIF = false

    callback(buffer)
  }

  function powerOfTwo(value) {
    return value !== 0 && (value & (value - 1)) === 0
  }

  // ---

  this.setSize = function(w, h) {
    globalWidth = w
    globalHeight = h
    canvas = document.createElement('canvas')
    canvas.width = w
    canvas.height = h
    ctx = canvas.getContext('2d')
  }

  // Internally, GIF uses tenths of seconds to store the delay
  this.setDelay = function(seconds) {
    delay = seconds * 0.1
  }

  // From GIF: 0 = loop forever, null = not looping, n > 0 = loop n times and stop
  this.setRepeat = function(r) {
    repeat = r
  }

  this.addFrame = function(element, options = {}) {
    if (ctx === null) {
      this.setSize(globalWidth, globalHeight)
    }
    // clear the canvas because drawing over other frames breaks transparency
    ctx.clearRect(0, 0, globalWidth, globalHeight)
    ctx.drawImage(element, 0, 0, globalWidth, globalHeight)
    const imageData = ctx.getImageData(0, 0, globalWidth, globalHeight)

    this.addFrameImageData(imageData, options)
  }

  this.addFrameImageData = function(imageData, options = {}) {
    const imageDataArray = new Uint8Array(imageData.data)

    frames.push({
      data: imageDataArray,
      width: imageData.width,
      height: imageData.height,
      palette: options.palette || globalPalette,
      dithering: options.dithering || globalDithering,
      disposal: options.disposal || globalDisposal,
      transparencyCutOff:
        options.transparencyCutOff || globalTransparencyCutOff,
      done: false,
      beingProcessed: false,
      position: frames.length,
    })
  }

  this.onRenderProgress = function(callback) {
    onRenderProgressCallback = callback
  }

  this.isRendering = function() {
    return generatingGIF
  }

  this.getBase64GIF = function(completeCallback) {
    const onRenderComplete = function(buffer) {
      const str = bufferToString(buffer)
      const gif = 'data:image/gif;base64,' + btoa(str)
      completeCallback(gif)
    }

    startRendering(onRenderComplete)
  }

  this.getBlobGIF = function(completeCallback) {
    const onRenderComplete = function(buffer) {
      const array = new Uint8Array(buffer)
      const blob = new Blob([array], { type: 'image/gif' })
      completeCallback(blob)
    }

    startRendering(onRenderComplete)
  }

  // Once this function is called, the object becomes unusable
  // and you'll need to create a new one.
  this.destroy = function() {
    // Explicitly ask web workers to die so they are explicitly GC'ed
    workers.forEach(function(w) {
      w.terminate()
    })
  }
}

window.Animated_GIF = Animated_GIF
/* harmony default export */ __webpack_exports__["default"] = (Animated_GIF);


/***/ }),

/***/ "./src/Animated_GIF.worker.js":
/*!************************************!*\
  !*** ./src/Animated_GIF.worker.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/Animated_GIF.worker.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/core-js/fn/set-immediate.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/core-js/fn/set-immediate.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(/*! ../modules/web.immediate */ \"./node_modules/core-js/modules/web.immediate.js\");\nmodule.exports = __webpack_require__(/*! ../modules/_core */ \"./node_modules/core-js/modules/_core.js\").setImmediate;\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_a-function.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_a-function.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_an-object.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_an-object.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_cof.js\":\n/*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_cof.js ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_core.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_core.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar core = module.exports = { version: '2.5.2' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_ctx.js\":\n/*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_ctx.js ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(/*! ./_a-function */ \"./node_modules/core-js/modules/_a-function.js\");\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_descriptors.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_descriptors.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\")(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_dom-create.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_dom-create.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\nvar document = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_export.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/core-js/modules/_export.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\nvar core = __webpack_require__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\");\nvar hide = __webpack_require__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\nvar redefine = __webpack_require__(/*! ./_redefine */ \"./node_modules/core-js/modules/_redefine.js\");\nvar ctx = __webpack_require__(/*! ./_ctx */ \"./node_modules/core-js/modules/_ctx.js\");\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_fails.js\":\n/*!************************************************!*\\\n  !*** ./node_modules/core-js/modules/_fails.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_global.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/core-js/modules/_global.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_has.js\":\n/*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_has.js ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_hide.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_hide.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\");\nvar createDesc = __webpack_require__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\nmodule.exports = __webpack_require__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_html.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_html.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar document = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").document;\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_ie8-dom-define.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") && !__webpack_require__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\")(function () {\n  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ \"./node_modules/core-js/modules/_dom-create.js\")('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_invoke.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/core-js/modules/_invoke.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_is-object.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_is-object.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_object-dp.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-dp.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ \"./node_modules/core-js/modules/_ie8-dom-define.js\");\nvar toPrimitive = __webpack_require__(/*! ./_to-primitive */ \"./node_modules/core-js/modules/_to-primitive.js\");\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_property-desc.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_property-desc.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_redefine.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/core-js/modules/_redefine.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\nvar hide = __webpack_require__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\nvar has = __webpack_require__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\nvar SRC = __webpack_require__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\")('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\").inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_task.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_task.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx = __webpack_require__(/*! ./_ctx */ \"./node_modules/core-js/modules/_ctx.js\");\nvar invoke = __webpack_require__(/*! ./_invoke */ \"./node_modules/core-js/modules/_invoke.js\");\nvar html = __webpack_require__(/*! ./_html */ \"./node_modules/core-js/modules/_html.js\");\nvar cel = __webpack_require__(/*! ./_dom-create */ \"./node_modules/core-js/modules/_dom-create.js\");\nvar global = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (__webpack_require__(/*! ./_cof */ \"./node_modules/core-js/modules/_cof.js\")(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_to-primitive.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_to-primitive.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/_uid.js\":\n/*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_uid.js ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/web.immediate.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/modules/web.immediate.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar $task = __webpack_require__(/*! ./_task */ \"./node_modules/core-js/modules/_task.js\");\n$export($export.G + $export.B, {\n  setImmediate: $task.set,\n  clearImmediate: $task.clear\n});\n\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/basicAPI.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/basicAPI.js ***!\n  \\***************************************************/\n/*! exports provided: buildPaletteSync, buildPalette, applyPaletteSync, applyPalette */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildPaletteSync\", function() { return buildPaletteSync; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildPalette\", function() { return buildPalette; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyPaletteSync\", function() { return applyPaletteSync; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyPalette\", function() { return applyPalette; });\n/* harmony import */ var core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/fn/set-immediate */ \"./node_modules/core-js/fn/set-immediate.js\");\n/* harmony import */ var core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _distance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distance */ \"./node_modules/image-q/dist/esm/distance/index.js\");\n/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./image */ \"./node_modules/image-q/dist/esm/image/index.js\");\n/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./palette */ \"./node_modules/image-q/dist/esm/palette/index.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * helper.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\nfunction buildPaletteSync(images, { colorDistanceFormula, paletteQuantization, colors } = {}) {\r\n    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\r\n    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\r\n    images.forEach(image => paletteQuantizer.sample(image));\r\n    return paletteQuantizer.quantizeSync();\r\n}\r\nasync function buildPalette(images, { colorDistanceFormula, paletteQuantization, colors, onProgress } = {}) {\r\n    return new Promise((resolve, reject) => {\r\n        const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\r\n        const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\r\n        images.forEach(image => paletteQuantizer.sample(image));\r\n        let palette;\r\n        let timerId;\r\n        const iterator = paletteQuantizer.quantize();\r\n        const next = () => {\r\n            try {\r\n                const result = iterator.next();\r\n                if (result.done) {\r\n                    resolve(palette);\r\n                }\r\n                else {\r\n                    if (result.value.palette)\r\n                        palette = result.value.palette;\r\n                    if (onProgress)\r\n                        onProgress(result.value.progress);\r\n                    timerId = core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__(next);\r\n                }\r\n            }\r\n            catch (error) {\r\n                clearTimeout(timerId);\r\n                reject(error);\r\n            }\r\n        };\r\n        timerId = core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__(next);\r\n    });\r\n}\r\nfunction applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {\r\n    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\r\n    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\r\n    return imageQuantizer.quantizeSync(image, palette);\r\n}\r\nasync function applyPalette(image, palette, { colorDistanceFormula, imageQuantization, onProgress } = {}) {\r\n    return new Promise((resolve, reject) => {\r\n        const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\r\n        const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\r\n        let outPointContainer;\r\n        let timerId;\r\n        const iterator = imageQuantizer.quantize(image, palette);\r\n        const next = () => {\r\n            try {\r\n                const result = iterator.next();\r\n                if (result.done) {\r\n                    resolve(outPointContainer);\r\n                }\r\n                else {\r\n                    if (result.value.pointContainer)\r\n                        outPointContainer = result.value.pointContainer;\r\n                    if (onProgress)\r\n                        onProgress(result.value.progress);\r\n                    timerId = core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__(next);\r\n                }\r\n            }\r\n            catch (error) {\r\n                clearTimeout(timerId);\r\n                reject(error);\r\n            }\r\n        };\r\n        timerId = core_js_fn_set_immediate__WEBPACK_IMPORTED_MODULE_0__(next);\r\n    });\r\n}\r\nfunction colorDistanceFormulaToColorDistance(colorDistanceFormula = 'euclidean-bt709') {\r\n    switch (colorDistanceFormula) {\r\n        case 'cie94-graphic-arts': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"CIE94GraphicArts\"]();\r\n        case 'cie94-textiles': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"CIE94Textiles\"]();\r\n        case 'ciede2000': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"CIEDE2000\"]();\r\n        case 'color-metric': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"CMetric\"]();\r\n        case 'euclidean': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"Euclidean\"]();\r\n        case 'euclidean-bt709': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"EuclideanBT709\"]();\r\n        case 'euclidean-bt709-noalpha': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"EuclideanBT709NoAlpha\"]();\r\n        case 'manhattan': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"Manhattan\"]();\r\n        case 'manhattan-bt709': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"ManhattanBT709\"]();\r\n        case 'manhattan-nommyde': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"ManhattanNommyde\"]();\r\n        case 'pngquant': return new _distance__WEBPACK_IMPORTED_MODULE_1__[\"PNGQuant\"]();\r\n        default: throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);\r\n    }\r\n}\r\nfunction imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = 'floyd-steinberg') {\r\n    switch (imageQuantization) {\r\n        case 'nearest': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"NearestColor\"](distanceCalculator);\r\n        case 'riemersma': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionRiemersma\"](distanceCalculator);\r\n        case 'floyd-steinberg': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].FloydSteinberg);\r\n        case 'false-floyd-steinberg': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].FalseFloydSteinberg);\r\n        case 'stucki': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].Stucki);\r\n        case 'atkinson': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].Atkinson);\r\n        case 'jarvis': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].Jarvis);\r\n        case 'burkes': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].Burkes);\r\n        case 'sierra': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].Sierra);\r\n        case 'two-sierra': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].TwoSierra);\r\n        case 'sierra-lite': return new _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"](distanceCalculator, _image__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"].SierraLite);\r\n        default: throw new Error(`Unknown imageQuantization ${imageQuantization}`);\r\n    }\r\n}\r\nfunction paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = 'wuquant', colors = 256) {\r\n    switch (paletteQuantization) {\r\n        case 'neuquant': return new _palette__WEBPACK_IMPORTED_MODULE_3__[\"NeuQuant\"](distanceCalculator, colors);\r\n        case 'rgbquant': return new _palette__WEBPACK_IMPORTED_MODULE_3__[\"RGBQuant\"](distanceCalculator, colors);\r\n        case 'wuquant': return new _palette__WEBPACK_IMPORTED_MODULE_3__[\"WuQuant\"](distanceCalculator, colors);\r\n        case 'neuquant-float': return new _palette__WEBPACK_IMPORTED_MODULE_3__[\"NeuQuantFloat\"](distanceCalculator, colors);\r\n        default: throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);\r\n    }\r\n}\r\n//# sourceMappingURL=basicAPI.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/constants/bt709.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/constants/bt709.js ***!\n  \\**********************************************************/\n/*! exports provided: Y, x, y */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Y\", function() { return Y; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return x; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return y; });\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * constants.ts - part of Image Quantization Library\r\n */\r\n/**\r\n * sRGB (based on ITU-R Recommendation BT.709)\r\n * http://en.wikipedia.org/wiki/SRGB\r\n */\r\nvar Y;\r\n(function (Y) {\r\n    Y[Y[\"RED\"] = 0.2126] = \"RED\";\r\n    Y[Y[\"GREEN\"] = 0.7152] = \"GREEN\";\r\n    Y[Y[\"BLUE\"] = 0.0722] = \"BLUE\";\r\n    Y[Y[\"WHITE\"] = 1] = \"WHITE\";\r\n})(Y || (Y = {}));\r\n// tslint:disable-next-line:naming-convention\r\nvar x;\r\n(function (x) {\r\n    x[x[\"RED\"] = 0.64] = \"RED\";\r\n    x[x[\"GREEN\"] = 0.3] = \"GREEN\";\r\n    x[x[\"BLUE\"] = 0.15] = \"BLUE\";\r\n    x[x[\"WHITE\"] = 0.3127] = \"WHITE\";\r\n})(x || (x = {}));\r\n// tslint:disable-next-line:naming-convention\r\nvar y;\r\n(function (y) {\r\n    y[y[\"RED\"] = 0.33] = \"RED\";\r\n    y[y[\"GREEN\"] = 0.6] = \"GREEN\";\r\n    y[y[\"BLUE\"] = 0.06] = \"BLUE\";\r\n    y[y[\"WHITE\"] = 0.329] = \"WHITE\";\r\n})(y || (y = {}));\r\n//# sourceMappingURL=bt709.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/constants/index.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/constants/index.js ***!\n  \\**********************************************************/\n/*! exports provided: bt709 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bt709__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bt709 */ \"./node_modules/image-q/dist/esm/constants/bt709.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"bt709\", function() { return _bt709__WEBPACK_IMPORTED_MODULE_0__; });\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * constants.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/conversion/index.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/conversion/index.js ***!\n  \\***********************************************************/\n/*! exports provided: rgb2xyz, rgb2hsl, rgb2lab, lab2xyz, lab2rgb, xyz2lab, xyz2rgb */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rgb2xyz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rgb2xyz */ \"./node_modules/image-q/dist/esm/conversion/rgb2xyz.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rgb2xyz\", function() { return _rgb2xyz__WEBPACK_IMPORTED_MODULE_0__[\"rgb2xyz\"]; });\n\n/* harmony import */ var _rgb2hsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb2hsl */ \"./node_modules/image-q/dist/esm/conversion/rgb2hsl.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rgb2hsl\", function() { return _rgb2hsl__WEBPACK_IMPORTED_MODULE_1__[\"rgb2hsl\"]; });\n\n/* harmony import */ var _rgb2lab__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rgb2lab */ \"./node_modules/image-q/dist/esm/conversion/rgb2lab.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rgb2lab\", function() { return _rgb2lab__WEBPACK_IMPORTED_MODULE_2__[\"rgb2lab\"]; });\n\n/* harmony import */ var _lab2xyz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lab2xyz */ \"./node_modules/image-q/dist/esm/conversion/lab2xyz.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"lab2xyz\", function() { return _lab2xyz__WEBPACK_IMPORTED_MODULE_3__[\"lab2xyz\"]; });\n\n/* harmony import */ var _lab2rgb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lab2rgb */ \"./node_modules/image-q/dist/esm/conversion/lab2rgb.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"lab2rgb\", function() { return _lab2rgb__WEBPACK_IMPORTED_MODULE_4__[\"lab2rgb\"]; });\n\n/* harmony import */ var _xyz2lab__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xyz2lab */ \"./node_modules/image-q/dist/esm/conversion/xyz2lab.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"xyz2lab\", function() { return _xyz2lab__WEBPACK_IMPORTED_MODULE_5__[\"xyz2lab\"]; });\n\n/* harmony import */ var _xyz2rgb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./xyz2rgb */ \"./node_modules/image-q/dist/esm/conversion/xyz2rgb.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"xyz2rgb\", function() { return _xyz2rgb__WEBPACK_IMPORTED_MODULE_6__[\"xyz2rgb\"]; });\n\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/conversion/lab2rgb.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/conversion/lab2rgb.js ***!\n  \\*************************************************************/\n/*! exports provided: lab2rgb */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lab2rgb\", function() { return lab2rgb; });\n/* harmony import */ var _lab2xyz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lab2xyz */ \"./node_modules/image-q/dist/esm/conversion/lab2xyz.js\");\n/* harmony import */ var _xyz2rgb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xyz2rgb */ \"./node_modules/image-q/dist/esm/conversion/xyz2rgb.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * lab2rgb.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n// tslint:disable-next-line:naming-convention\r\nfunction lab2rgb(L, a, b) {\r\n    const xyz = Object(_lab2xyz__WEBPACK_IMPORTED_MODULE_0__[\"lab2xyz\"])(L, a, b);\r\n    return Object(_xyz2rgb__WEBPACK_IMPORTED_MODULE_1__[\"xyz2rgb\"])(xyz.x, xyz.y, xyz.z);\r\n}\r\n//# sourceMappingURL=lab2rgb.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/conversion/lab2xyz.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/conversion/lab2xyz.js ***!\n  \\*************************************************************/\n/*! exports provided: lab2xyz */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lab2xyz\", function() { return lab2xyz; });\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * lab2xyz.ts - part of Image Quantization Library\r\n */\r\nconst refX = 0.95047; // ref_X =  95.047   Observer= 2, Illuminant = D65\r\nconst refY = 1.00000; // ref_Y = 100.000\r\nconst refZ = 1.08883; // ref_Z = 108.883\r\nfunction pivot(n) {\r\n    return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;\r\n}\r\n// tslint:disable-next-line:naming-convention\r\nfunction lab2xyz(L, a, b) {\r\n    const y = (L + 16) / 116;\r\n    const x = a / 500 + y;\r\n    const z = y - b / 200;\r\n    return {\r\n        x: refX * pivot(x),\r\n        y: refY * pivot(y),\r\n        z: refZ * pivot(z),\r\n    };\r\n}\r\n//# sourceMappingURL=lab2xyz.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/conversion/rgb2hsl.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/conversion/rgb2hsl.js ***!\n  \\*************************************************************/\n/*! exports provided: rgb2hsl */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgb2hsl\", function() { return rgb2hsl; });\n/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2hsl.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * Calculate HSL from RGB\r\n * Hue is in degrees [0..360]\r\n * Lightness: [0..1]\r\n * Saturation: [0..1]\r\n * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/\r\n */\r\nfunction rgb2hsl(r, g, b) {\r\n    const min = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__[\"min3\"])(r, g, b);\r\n    const max = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__[\"max3\"])(r, g, b);\r\n    const delta = max - min;\r\n    const l = (min + max) / 510;\r\n    let s = 0;\r\n    if (l > 0 && l < 1)\r\n        s = delta / (l < 0.5 ? (max + min) : (510 - max - min));\r\n    let h = 0;\r\n    if (delta > 0) {\r\n        if (max === r) {\r\n            h = (g - b) / delta;\r\n        }\r\n        else if (max === g) {\r\n            h = (2 + (b - r) / delta);\r\n        }\r\n        else {\r\n            h = (4 + (r - g) / delta);\r\n        }\r\n        h *= 60;\r\n        if (h < 0)\r\n            h += 360;\r\n    }\r\n    return { h, s, l };\r\n}\r\n//# sourceMappingURL=rgb2hsl.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/conversion/rgb2lab.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/conversion/rgb2lab.js ***!\n  \\*************************************************************/\n/*! exports provided: rgb2lab */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgb2lab\", function() { return rgb2lab; });\n/* harmony import */ var _rgb2xyz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rgb2xyz */ \"./node_modules/image-q/dist/esm/conversion/rgb2xyz.js\");\n/* harmony import */ var _xyz2lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xyz2lab */ \"./node_modules/image-q/dist/esm/conversion/xyz2lab.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2lab.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\nfunction rgb2lab(r, g, b) {\r\n    const xyz = Object(_rgb2xyz__WEBPACK_IMPORTED_MODULE_0__[\"rgb2xyz\"])(r, g, b);\r\n    return Object(_xyz2lab__WEBPACK_IMPORTED_MODULE_1__[\"xyz2lab\"])(xyz.x, xyz.y, xyz.z);\r\n}\r\n//# sourceMappingURL=rgb2lab.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/conversion/rgb2xyz.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/conversion/rgb2xyz.js ***!\n  \\*************************************************************/\n/*! exports provided: rgb2xyz */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgb2xyz\", function() { return rgb2xyz; });\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2xyz.ts - part of Image Quantization Library\r\n */\r\nfunction correctGamma(n) {\r\n    return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;\r\n}\r\nfunction rgb2xyz(r, g, b) {\r\n    // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\r\n    r = correctGamma(r / 255);\r\n    g = correctGamma(g / 255);\r\n    b = correctGamma(b / 255);\r\n    // Observer. = 2, Illuminant = D65\r\n    return {\r\n        x: r * 0.4124 + g * 0.3576 + b * 0.1805,\r\n        y: r * 0.2126 + g * 0.7152 + b * 0.0722,\r\n        z: r * 0.0193 + g * 0.1192 + b * 0.9505,\r\n    };\r\n}\r\n//# sourceMappingURL=rgb2xyz.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/conversion/xyz2lab.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/conversion/xyz2lab.js ***!\n  \\*************************************************************/\n/*! exports provided: xyz2lab */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xyz2lab\", function() { return xyz2lab; });\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * xyz2lab.ts - part of Image Quantization Library\r\n */\r\nconst refX = 0.95047; // ref_X =  95.047   Observer= 2, Illuminant= D65\r\nconst refY = 1.00000; // ref_Y = 100.000\r\nconst refZ = 1.08883; // ref_Z = 108.883\r\nfunction pivot(n) {\r\n    return n > 0.008856 ? Math.pow(n, 1 / 3) : (7.787 * n + 16 / 116);\r\n}\r\nfunction xyz2lab(x, y, z) {\r\n    x = pivot(x / refX);\r\n    y = pivot(y / refY);\r\n    z = pivot(z / refZ);\r\n    if ((116 * y) - 16 < 0)\r\n        throw new Error('xxx');\r\n    return {\r\n        L: Math.max(0, (116 * y) - 16),\r\n        a: 500 * (x - y),\r\n        b: 200 * (y - z),\r\n    };\r\n}\r\n//# sourceMappingURL=xyz2lab.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/conversion/xyz2rgb.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/conversion/xyz2rgb.js ***!\n  \\*************************************************************/\n/*! exports provided: xyz2rgb */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xyz2rgb\", function() { return xyz2rgb; });\n/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * xyz2rgb.ts - part of Image Quantization Library\r\n */\r\n\r\n// gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\r\nfunction correctGamma(n) {\r\n    return n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;\r\n}\r\nfunction xyz2rgb(x, y, z) {\r\n    // Observer. = 2, Illuminant = D65\r\n    const r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986);\r\n    const g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415);\r\n    const b = correctGamma(x * 0.0557 + y * -0.2040 + z * 1.0570);\r\n    return {\r\n        r: Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__[\"inRange0to255Rounded\"])(r * 255),\r\n        g: Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__[\"inRange0to255Rounded\"])(g * 255),\r\n        b: Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_0__[\"inRange0to255Rounded\"])(b * 255),\r\n    };\r\n}\r\n//# sourceMappingURL=xyz2rgb.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/distance/cie94.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/distance/cie94.js ***!\n  \\*********************************************************/\n/*! exports provided: AbstractCIE94, CIE94Textiles, CIE94GraphicArts */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractCIE94\", function() { return AbstractCIE94; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CIE94Textiles\", function() { return CIE94Textiles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CIE94GraphicArts\", function() { return CIE94GraphicArts; });\n/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ \"./node_modules/image-q/dist/esm/distance/distanceCalculator.js\");\n/* harmony import */ var _conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conversion/rgb2lab */ \"./node_modules/image-q/dist/esm/conversion/rgb2lab.js\");\n/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * cie94.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n/**\r\n * CIE94 method of delta-e\r\n * http://en.wikipedia.org/wiki/Color_difference#CIE94\r\n */\r\nclass AbstractCIE94 extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__[\"AbstractDistanceCalculator\"] {\r\n    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        const lab1 = Object(_conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__[\"rgb2lab\"])(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(r1 * this._whitePoint.r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(g1 * this._whitePoint.g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(b1 * this._whitePoint.b));\r\n        const lab2 = Object(_conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__[\"rgb2lab\"])(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(r2 * this._whitePoint.r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(g2 * this._whitePoint.g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(b2 * this._whitePoint.b));\r\n        const dL = lab1.L - lab2.L;\r\n        const dA = lab1.a - lab2.a;\r\n        const dB = lab1.b - lab2.b;\r\n        const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);\r\n        const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);\r\n        const dC = c1 - c2;\r\n        let deltaH = dA * dA + dB * dB - dC * dC;\r\n        deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\r\n        const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\r\n        // TODO: add alpha channel support\r\n        return Math.sqrt(Math.pow(dL / this._Kl, 2) +\r\n            Math.pow(dC / (1.0 + this._K1 * c1), 2) +\r\n            Math.pow(deltaH / (1.0 + this._K2 * c1), 2) +\r\n            Math.pow(dAlpha, 2));\r\n    }\r\n}\r\nclass CIE94Textiles extends AbstractCIE94 {\r\n    _setDefaults() {\r\n        this._Kl = 2.0;\r\n        this._K1 = 0.048;\r\n        this._K2 = 0.014;\r\n        this._kA = 0.25 * 50 / 255;\r\n    }\r\n}\r\nclass CIE94GraphicArts extends AbstractCIE94 {\r\n    _setDefaults() {\r\n        this._Kl = 1.0;\r\n        this._K1 = 0.045;\r\n        this._K2 = 0.015;\r\n        this._kA = 0.25 * 100 / 255;\r\n    }\r\n}\r\n//# sourceMappingURL=cie94.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/distance/ciede2000.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/distance/ciede2000.js ***!\n  \\*************************************************************/\n/*! exports provided: CIEDE2000 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CIEDE2000\", function() { return CIEDE2000; });\n/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ \"./node_modules/image-q/dist/esm/distance/distanceCalculator.js\");\n/* harmony import */ var _conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conversion/rgb2lab */ \"./node_modules/image-q/dist/esm/conversion/rgb2lab.js\");\n/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ciede2000.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n// tslint:disable:variable-name\r\n// tslint:disable:naming-convention\r\n/**\r\n * CIEDE2000 algorithm - Adapted from Sharma et al's MATLAB implementation at\r\n * http://www.ece.rochester.edu/~gsharma/ciede2000/\r\n */\r\nclass CIEDE2000 extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__[\"AbstractDistanceCalculator\"] {\r\n    _setDefaults() { }\r\n    static _calculatehp(b, ap) {\r\n        const hp = Math.atan2(b, ap);\r\n        if (hp >= 0)\r\n            return hp;\r\n        return hp + CIEDE2000._deg360InRad;\r\n    }\r\n    static _calculateRT(ahp, aCp) {\r\n        const aCp_to_7 = Math.pow(aCp, 7.0);\r\n        const R_C = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)); // 25^7\r\n        const delta_theta = CIEDE2000._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad, 2.0));\r\n        return -Math.sin(2.0 * delta_theta) * R_C;\r\n    }\r\n    static _calculateT(ahp) {\r\n        return 1.0 - .17 * Math.cos(ahp - CIEDE2000._deg30InRad) + .24 * Math.cos(ahp * 2.0) + .32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) - .2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad);\r\n    }\r\n    static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {\r\n        const hpSum = h1p + h2p;\r\n        if (C1pC2p === 0)\r\n            return hpSum;\r\n        if (h_bar <= CIEDE2000._deg180InRad)\r\n            return hpSum / 2.0;\r\n        if (hpSum < CIEDE2000._deg360InRad)\r\n            return (hpSum + CIEDE2000._deg360InRad) / 2.0;\r\n        return (hpSum - CIEDE2000._deg360InRad) / 2.0;\r\n    }\r\n    static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {\r\n        let dhp;\r\n        if (C1pC2p === 0) {\r\n            dhp = 0;\r\n        }\r\n        else if (h_bar <= CIEDE2000._deg180InRad) {\r\n            dhp = h2p - h1p;\r\n        }\r\n        else if (h2p <= h1p) {\r\n            dhp = h2p - h1p + CIEDE2000._deg360InRad;\r\n        }\r\n        else {\r\n            dhp = h2p - h1p - CIEDE2000._deg360InRad;\r\n        }\r\n        return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);\r\n    }\r\n    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        const lab1 = Object(_conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__[\"rgb2lab\"])(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(r1 * this._whitePoint.r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(g1 * this._whitePoint.g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(b1 * this._whitePoint.b));\r\n        const lab2 = Object(_conversion_rgb2lab__WEBPACK_IMPORTED_MODULE_1__[\"rgb2lab\"])(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(r2 * this._whitePoint.r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(g2 * this._whitePoint.g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255\"])(b2 * this._whitePoint.b));\r\n        const dA = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA;\r\n        const dE2 = this.calculateRawInLab(lab1, lab2);\r\n        return Math.sqrt(dE2 + dA * dA);\r\n    }\r\n    calculateRawInLab(Lab1, Lab2) {\r\n        // Get L,a,b values for color 1\r\n        const L1 = Lab1.L;\r\n        const a1 = Lab1.a;\r\n        const b1 = Lab1.b;\r\n        // Get L,a,b values for color 2\r\n        const L2 = Lab2.L;\r\n        const a2 = Lab2.a;\r\n        const b2 = Lab2.b;\r\n        // Calculate Cprime1, Cprime2, Cabbar\r\n        const C1 = Math.sqrt(a1 * a1 + b1 * b1);\r\n        const C2 = Math.sqrt(a2 * a2 + b2 * b2);\r\n        const pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2.0, 7.0);\r\n        const G = 0.5 * (1.0 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))); // 25^7\r\n        const a1p = (1.0 + G) * a1;\r\n        const a2p = (1.0 + G) * a2;\r\n        const C1p = Math.sqrt(a1p * a1p + b1 * b1);\r\n        const C2p = Math.sqrt(a2p * a2p + b2 * b2);\r\n        const C1pC2p = C1p * C2p;\r\n        // Angles in Degree.\r\n        const h1p = CIEDE2000._calculatehp(b1, a1p);\r\n        const h2p = CIEDE2000._calculatehp(b2, a2p);\r\n        const h_bar = Math.abs(h1p - h2p);\r\n        const dLp = L2 - L1;\r\n        const dCp = C2p - C1p;\r\n        const dHp = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);\r\n        const ahp = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);\r\n        const T = CIEDE2000._calculateT(ahp);\r\n        const aCp = (C1p + C2p) / 2.0;\r\n        const aLp_minus_50_square = Math.pow((L1 + L2) / 2.0 - 50.0, 2.0);\r\n        const S_L = 1.0 + (.015 * aLp_minus_50_square) / Math.sqrt(20.0 + aLp_minus_50_square);\r\n        const S_C = 1.0 + .045 * aCp;\r\n        const S_H = 1.0 + .015 * T * aCp;\r\n        const R_T = CIEDE2000._calculateRT(ahp, aCp);\r\n        const dLpSL = dLp / S_L; // S_L * kL, where kL is 1.0\r\n        const dCpSC = dCp / S_C; // S_C * kC, where kC is 1.0\r\n        const dHpSH = dHp / S_H; // S_H * kH, where kH is 1.0\r\n        return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;\r\n    }\r\n}\r\n/**\r\n * Weight in distance: 0.25\r\n * Max DeltaE: 100\r\n * Max DeltaA: 255\r\n */\r\nCIEDE2000._kA = 0.25 * 100 / 255;\r\nCIEDE2000._pow25to7 = Math.pow(25, 7);\r\nCIEDE2000._deg360InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"degrees2radians\"])(360);\r\nCIEDE2000._deg180InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"degrees2radians\"])(180);\r\nCIEDE2000._deg30InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"degrees2radians\"])(30);\r\nCIEDE2000._deg6InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"degrees2radians\"])(6);\r\nCIEDE2000._deg63InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"degrees2radians\"])(63);\r\nCIEDE2000._deg275InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"degrees2radians\"])(275);\r\nCIEDE2000._deg25InRad = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"degrees2radians\"])(25);\r\n//# sourceMappingURL=ciede2000.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/distance/cmetric.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/distance/cmetric.js ***!\n  \\***********************************************************/\n/*! exports provided: CMetric */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CMetric\", function() { return CMetric; });\n/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ \"./node_modules/image-q/dist/esm/distance/distanceCalculator.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * cmetric.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * TODO: Name it: http://www.compuphase.com/cmetric.htm\r\n */\r\nclass CMetric extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__[\"AbstractDistanceCalculator\"] {\r\n    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        const rmean = (r1 + r2) / 2 * this._whitePoint.r;\r\n        const r = (r1 - r2) * this._whitePoint.r;\r\n        const g = (g1 - g2) * this._whitePoint.g;\r\n        const b = (b1 - b2) * this._whitePoint.b;\r\n        const dE = ((((512 + rmean) * r * r) >> 8) + 4 * g * g + (((767 - rmean) * b * b) >> 8));\r\n        const dA = (a2 - a1) * this._whitePoint.a;\r\n        return Math.sqrt(dE + dA * dA);\r\n    }\r\n    _setDefaults() { }\r\n}\r\n//# sourceMappingURL=cmetric.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/distance/distanceCalculator.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/distance/distanceCalculator.js ***!\n  \\**********************************************************************/\n/*! exports provided: AbstractDistanceCalculator */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractDistanceCalculator\", function() { return AbstractDistanceCalculator; });\nclass AbstractDistanceCalculator {\r\n    constructor() {\r\n        this._setDefaults();\r\n        // set default maximal color component deltas (255 - 0 = 255)\r\n        this.setWhitePoint(255, 255, 255, 255);\r\n    }\r\n    setWhitePoint(r, g, b, a) {\r\n        this._whitePoint = {\r\n            r: (r > 0) ? 255 / r : 0,\r\n            g: (g > 0) ? 255 / g : 0,\r\n            b: (b > 0) ? 255 / b : 0,\r\n            a: (a > 0) ? 255 / a : 0,\r\n        };\r\n        this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\r\n    }\r\n    calculateNormalized(colorA, colorB) {\r\n        return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;\r\n    }\r\n}\r\n//# sourceMappingURL=distanceCalculator.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/distance/euclidean.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/distance/euclidean.js ***!\n  \\*************************************************************/\n/*! exports provided: AbstractEuclidean, Euclidean, EuclideanBT709, EuclideanBT709NoAlpha */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractEuclidean\", function() { return AbstractEuclidean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Euclidean\", function() { return Euclidean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EuclideanBT709\", function() { return EuclideanBT709; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EuclideanBT709NoAlpha\", function() { return EuclideanBT709NoAlpha; });\n/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ \"./node_modules/image-q/dist/esm/distance/distanceCalculator.js\");\n/* harmony import */ var _constants_bt709__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/bt709 */ \"./node_modules/image-q/dist/esm/constants/bt709.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * euclidean.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n/**\r\n * Euclidean color distance\r\n */\r\nclass AbstractEuclidean extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__[\"AbstractDistanceCalculator\"] {\r\n    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        const dR = r2 - r1;\r\n        const dG = g2 - g1;\r\n        const dB = b2 - b1;\r\n        const dA = a2 - a1;\r\n        return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);\r\n    }\r\n}\r\nclass Euclidean extends AbstractEuclidean {\r\n    _setDefaults() {\r\n        this._kR = 1;\r\n        this._kG = 1;\r\n        this._kB = 1;\r\n        this._kA = 1;\r\n    }\r\n}\r\n/**\r\n * Euclidean color distance (RGBQuant modification w Alpha)\r\n */\r\nclass EuclideanBT709 extends AbstractEuclidean {\r\n    _setDefaults() {\r\n        this._kR = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].RED;\r\n        this._kG = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].GREEN;\r\n        this._kB = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].BLUE;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n/**\r\n * Euclidean color distance (RGBQuant modification w/o Alpha)\r\n */\r\nclass EuclideanBT709NoAlpha extends AbstractEuclidean {\r\n    _setDefaults() {\r\n        this._kR = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].RED;\r\n        this._kG = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].GREEN;\r\n        this._kB = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].BLUE;\r\n        this._kA = 0;\r\n    }\r\n}\r\n//# sourceMappingURL=euclidean.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/distance/index.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/distance/index.js ***!\n  \\*********************************************************/\n/*! exports provided: AbstractDistanceCalculator, CIE94Textiles, CIE94GraphicArts, CIEDE2000, CMetric, AbstractEuclidean, Euclidean, EuclideanBT709NoAlpha, EuclideanBT709, AbstractManhattan, Manhattan, ManhattanBT709, ManhattanNommyde, PNGQuant */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ \"./node_modules/image-q/dist/esm/distance/distanceCalculator.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AbstractDistanceCalculator\", function() { return _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__[\"AbstractDistanceCalculator\"]; });\n\n/* harmony import */ var _cie94__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cie94 */ \"./node_modules/image-q/dist/esm/distance/cie94.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CIE94Textiles\", function() { return _cie94__WEBPACK_IMPORTED_MODULE_1__[\"CIE94Textiles\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CIE94GraphicArts\", function() { return _cie94__WEBPACK_IMPORTED_MODULE_1__[\"CIE94GraphicArts\"]; });\n\n/* harmony import */ var _ciede2000__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciede2000 */ \"./node_modules/image-q/dist/esm/distance/ciede2000.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CIEDE2000\", function() { return _ciede2000__WEBPACK_IMPORTED_MODULE_2__[\"CIEDE2000\"]; });\n\n/* harmony import */ var _cmetric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cmetric */ \"./node_modules/image-q/dist/esm/distance/cmetric.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CMetric\", function() { return _cmetric__WEBPACK_IMPORTED_MODULE_3__[\"CMetric\"]; });\n\n/* harmony import */ var _euclidean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./euclidean */ \"./node_modules/image-q/dist/esm/distance/euclidean.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AbstractEuclidean\", function() { return _euclidean__WEBPACK_IMPORTED_MODULE_4__[\"AbstractEuclidean\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Euclidean\", function() { return _euclidean__WEBPACK_IMPORTED_MODULE_4__[\"Euclidean\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EuclideanBT709NoAlpha\", function() { return _euclidean__WEBPACK_IMPORTED_MODULE_4__[\"EuclideanBT709NoAlpha\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EuclideanBT709\", function() { return _euclidean__WEBPACK_IMPORTED_MODULE_4__[\"EuclideanBT709\"]; });\n\n/* harmony import */ var _manhattan__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./manhattan */ \"./node_modules/image-q/dist/esm/distance/manhattan.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AbstractManhattan\", function() { return _manhattan__WEBPACK_IMPORTED_MODULE_5__[\"AbstractManhattan\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Manhattan\", function() { return _manhattan__WEBPACK_IMPORTED_MODULE_5__[\"Manhattan\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ManhattanBT709\", function() { return _manhattan__WEBPACK_IMPORTED_MODULE_5__[\"ManhattanBT709\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ManhattanNommyde\", function() { return _manhattan__WEBPACK_IMPORTED_MODULE_5__[\"ManhattanNommyde\"]; });\n\n/* harmony import */ var _pngQuant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pngQuant */ \"./node_modules/image-q/dist/esm/distance/pngQuant.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PNGQuant\", function() { return _pngQuant__WEBPACK_IMPORTED_MODULE_6__[\"PNGQuant\"]; });\n\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/distance/manhattan.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/distance/manhattan.js ***!\n  \\*************************************************************/\n/*! exports provided: AbstractManhattan, Manhattan, ManhattanNommyde, ManhattanBT709 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractManhattan\", function() { return AbstractManhattan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Manhattan\", function() { return Manhattan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ManhattanNommyde\", function() { return ManhattanNommyde; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ManhattanBT709\", function() { return ManhattanBT709; });\n/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ \"./node_modules/image-q/dist/esm/distance/distanceCalculator.js\");\n/* harmony import */ var _constants_bt709__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/bt709 */ \"./node_modules/image-q/dist/esm/constants/bt709.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * manhattanNeuQuant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n/**\r\n * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients\r\n */\r\nclass AbstractManhattan extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__[\"AbstractDistanceCalculator\"] {\r\n    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        let dR = r2 - r1;\r\n        let dG = g2 - g1;\r\n        let dB = b2 - b1;\r\n        let dA = a2 - a1;\r\n        if (dR < 0)\r\n            dR = 0 - dR;\r\n        if (dG < 0)\r\n            dG = 0 - dG;\r\n        if (dB < 0)\r\n            dB = 0 - dB;\r\n        if (dA < 0)\r\n            dA = 0 - dA;\r\n        return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\r\n    }\r\n}\r\nclass Manhattan extends AbstractManhattan {\r\n    _setDefaults() {\r\n        this._kR = 1;\r\n        this._kG = 1;\r\n        this._kB = 1;\r\n        this._kA = 1;\r\n    }\r\n}\r\n/**\r\n * Manhattan distance (Nommyde modification)\r\n * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320\r\n */\r\nclass ManhattanNommyde extends AbstractManhattan {\r\n    _setDefaults() {\r\n        this._kR = 0.4984;\r\n        this._kG = 0.8625;\r\n        this._kB = 0.2979;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n/**\r\n * Manhattan distance (sRGB coefficients)\r\n */\r\nclass ManhattanBT709 extends AbstractManhattan {\r\n    _setDefaults() {\r\n        this._kR = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].RED;\r\n        this._kG = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].GREEN;\r\n        this._kB = _constants_bt709__WEBPACK_IMPORTED_MODULE_1__[\"Y\"].BLUE;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n//# sourceMappingURL=manhattan.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/distance/pngQuant.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/distance/pngQuant.js ***!\n  \\************************************************************/\n/*! exports provided: PNGQuant */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PNGQuant\", function() { return PNGQuant; });\n/* harmony import */ var _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceCalculator */ \"./node_modules/image-q/dist/esm/distance/distanceCalculator.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * pngQuant.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * TODO: check quality of this distance equation\r\n * TODO: ask author for usage rights\r\n * taken from:\r\n * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}\r\n * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}\r\n */\r\nclass PNGQuant extends _distanceCalculator__WEBPACK_IMPORTED_MODULE_0__[\"AbstractDistanceCalculator\"] {\r\n    /**\r\n     * Author's comments\r\n     * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black\r\n     * px_b.a   = px.a   + 1*(1-px.a)\r\n     * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white\r\n     * px_w.a   = px.a   + 1*(1-px.a)\r\n     *\r\n     * px_b.rgb = px.rgb              // difference same as in opaque RGB\r\n     * px_b.a   = 1\r\n     * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below\r\n     * px_w.a   = 1\r\n     *\r\n     * (px.rgb - px.a) - (py.rgb - py.a)\r\n     * (px.rgb - py.rgb) + (py.a - px.a)\r\n     *\r\n     */\r\n    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\r\n        const alphas = (a2 - a1) * this._whitePoint.a;\r\n        return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) +\r\n            this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) +\r\n            this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);\r\n    }\r\n    _colordifferenceCh(x, y, alphas) {\r\n        // maximum of channel blended on white, and blended on black\r\n        // premultiplied alpha and backgrounds 0/1 shorten the formula\r\n        const black = x - y;\r\n        const white = black + alphas;\r\n        return black * black + white * white;\r\n    }\r\n    _setDefaults() { }\r\n}\r\n//# sourceMappingURL=pngQuant.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/image-q.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/image-q.js ***!\n  \\**************************************************/\n/*! exports provided: buildPalette, buildPaletteSync, applyPalette, applyPaletteSync, constants, conversion, distance, palette, image, quality, utils */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./node_modules/image-q/dist/esm/constants/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"constants\", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__; });\n/* harmony import */ var _conversion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conversion */ \"./node_modules/image-q/dist/esm/conversion/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"conversion\", function() { return _conversion__WEBPACK_IMPORTED_MODULE_1__; });\n/* harmony import */ var _distance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./distance */ \"./node_modules/image-q/dist/esm/distance/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return _distance__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./palette */ \"./node_modules/image-q/dist/esm/palette/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"palette\", function() { return _palette__WEBPACK_IMPORTED_MODULE_3__; });\n/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./image */ \"./node_modules/image-q/dist/esm/image/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"image\", function() { return _image__WEBPACK_IMPORTED_MODULE_4__; });\n/* harmony import */ var _quality__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quality */ \"./node_modules/image-q/dist/esm/quality/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quality\", function() { return _quality__WEBPACK_IMPORTED_MODULE_5__; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ \"./node_modules/image-q/dist/esm/utils/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"utils\", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__; });\n/* harmony import */ var _basicAPI__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./basicAPI */ \"./node_modules/image-q/dist/esm/basicAPI.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildPalette\", function() { return _basicAPI__WEBPACK_IMPORTED_MODULE_7__[\"buildPalette\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"buildPaletteSync\", function() { return _basicAPI__WEBPACK_IMPORTED_MODULE_7__[\"buildPaletteSync\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"applyPalette\", function() { return _basicAPI__WEBPACK_IMPORTED_MODULE_7__[\"applyPalette\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"applyPaletteSync\", function() { return _basicAPI__WEBPACK_IMPORTED_MODULE_7__[\"applyPaletteSync\"]; });\n\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=image-q.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/image/array.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/image/array.js ***!\n  \\******************************************************/\n/*! exports provided: ErrorDiffusionArrayKernel, ErrorDiffusionArray */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ErrorDiffusionArrayKernel\", function() { return ErrorDiffusionArrayKernel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ErrorDiffusionArray\", function() { return ErrorDiffusionArray; });\n/* harmony import */ var _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageQuantizer */ \"./node_modules/image-q/dist/esm/image/imageQuantizer.js\");\n/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/point */ \"./node_modules/image-q/dist/esm/utils/point.js\");\n/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/* harmony import */ var _utils_progressTracker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/progressTracker */ \"./node_modules/image-q/dist/esm/utils/progressTracker.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n// TODO: is it the best name for this enum \"kernel\"?\r\nvar ErrorDiffusionArrayKernel;\r\n(function (ErrorDiffusionArrayKernel) {\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"FloydSteinberg\"] = 0] = \"FloydSteinberg\";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"FalseFloydSteinberg\"] = 1] = \"FalseFloydSteinberg\";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Stucki\"] = 2] = \"Stucki\";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Atkinson\"] = 3] = \"Atkinson\";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Jarvis\"] = 4] = \"Jarvis\";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Burkes\"] = 5] = \"Burkes\";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Sierra\"] = 6] = \"Sierra\";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"TwoSierra\"] = 7] = \"TwoSierra\";\r\n    ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"SierraLite\"] = 8] = \"SierraLite\";\r\n})(ErrorDiffusionArrayKernel || (ErrorDiffusionArrayKernel = {}));\r\n// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\r\nclass ErrorDiffusionArray extends _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__[\"AbstractImageQuantizer\"] {\r\n    constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {\r\n        super();\r\n        this._setKernel(kernel);\r\n        this._distance = colorDistanceCalculator;\r\n        this._minColorDistance = minimumColorDistanceToDither;\r\n        this._serpentine = serpentine;\r\n        this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\r\n    }\r\n    /**\r\n     * adapted from http://jsbin.com/iXofIji/2/edit by PAEz\r\n     * fixed version. it doesn't use image pixels as error storage, also it doesn't have 0.3 + 0.3 + 0.3 + 0.3 = 0 error\r\n     * Mutates pointContainer\r\n     */\r\n    *quantize(pointContainer, palette) {\r\n        const pointArray = pointContainer.getPointArray();\r\n        const originalPoint = new _utils_point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"]();\r\n        const width = pointContainer.getWidth();\r\n        const height = pointContainer.getHeight();\r\n        const errorLines = [];\r\n        let dir = 1;\r\n        let maxErrorLines = 1;\r\n        // initial error lines (number is taken from dithering kernel)\r\n        for (const kernel of this._kernel) {\r\n            const kernelErrorLines = kernel[2] + 1;\r\n            if (maxErrorLines < kernelErrorLines)\r\n                maxErrorLines = kernelErrorLines;\r\n        }\r\n        for (let i = 0; i < maxErrorLines; i++) {\r\n            this._fillErrorLine(errorLines[i] = [], width);\r\n        }\r\n        const tracker = new _utils_progressTracker__WEBPACK_IMPORTED_MODULE_3__[\"ProgressTracker\"](height, 99);\r\n        for (let y = 0; y < height; y++) {\r\n            if (tracker.shouldNotify(y)) {\r\n                yield {\r\n                    progress: tracker.progress,\r\n                };\r\n            }\r\n            // always serpentine\r\n            if (this._serpentine)\r\n                dir = dir * -1;\r\n            const lni = y * width;\r\n            const xStart = dir === 1 ? 0 : width - 1;\r\n            const xEnd = dir === 1 ? width : -1;\r\n            // cyclic shift with erasing\r\n            this._fillErrorLine(errorLines[0], width);\r\n            // TODO: why it is needed to cast types here?\r\n            errorLines.push(errorLines.shift());\r\n            const errorLine = errorLines[0];\r\n            for (let x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {\r\n                // Image pixel\r\n                const point = pointArray[idx];\r\n                // originalPoint = new Utils.Point(),\r\n                const error = errorLine[x];\r\n                originalPoint.from(point);\r\n                const correctedPoint = _utils_point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"].createByRGBA(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255Rounded\"])(point.r + error[0]), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255Rounded\"])(point.g + error[1]), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255Rounded\"])(point.b + error[2]), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_2__[\"inRange0to255Rounded\"])(point.a + error[3]));\r\n                // Reduced pixel\r\n                const palettePoint = palette.getNearestColor(this._distance, correctedPoint);\r\n                point.from(palettePoint);\r\n                // dithering strength\r\n                if (this._minColorDistance) {\r\n                    const dist = this._distance.calculateNormalized(point, palettePoint);\r\n                    if (dist < this._minColorDistance)\r\n                        continue;\r\n                }\r\n                // Component distance\r\n                let er;\r\n                let eg;\r\n                let eb;\r\n                let ea;\r\n                if (this._calculateErrorLikeGIMP) {\r\n                    er = correctedPoint.r - palettePoint.r;\r\n                    eg = correctedPoint.g - palettePoint.g;\r\n                    eb = correctedPoint.b - palettePoint.b;\r\n                    ea = correctedPoint.a - palettePoint.a;\r\n                }\r\n                else {\r\n                    er = originalPoint.r - palettePoint.r;\r\n                    eg = originalPoint.g - palettePoint.g;\r\n                    eb = originalPoint.b - palettePoint.b;\r\n                    ea = originalPoint.a - palettePoint.a;\r\n                }\r\n                const dStart = dir === 1 ? 0 : this._kernel.length - 1;\r\n                const dEnd = dir === 1 ? this._kernel.length : -1;\r\n                for (let i = dStart; i !== dEnd; i += dir) {\r\n                    const x1 = this._kernel[i][1] * dir;\r\n                    const y1 = this._kernel[i][2];\r\n                    if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\r\n                        const d = this._kernel[i][0];\r\n                        const e = errorLines[y1][x1 + x];\r\n                        e[0] = e[0] + er * d;\r\n                        e[1] = e[1] + eg * d;\r\n                        e[2] = e[2] + eb * d;\r\n                        e[3] = e[3] + ea * d;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        yield {\r\n            pointContainer,\r\n            progress: 100,\r\n        };\r\n    }\r\n    _fillErrorLine(errorLine, width) {\r\n        // shrink\r\n        if (errorLine.length > width) {\r\n            errorLine.length = width;\r\n        }\r\n        // reuse existing arrays\r\n        const l = errorLine.length;\r\n        for (let i = 0; i < l; i++) {\r\n            const error = errorLine[i];\r\n            error[0] = error[1] = error[2] = error[3] = 0;\r\n        }\r\n        // create missing arrays\r\n        for (let i = l; i < width; i++) {\r\n            errorLine[i] = [0.0, 0.0, 0.0, 0.0];\r\n        }\r\n    }\r\n    _setKernel(kernel) {\r\n        switch (kernel) {\r\n            case ErrorDiffusionArrayKernel.FloydSteinberg:\r\n                this._kernel = [\r\n                    [7 / 16, 1, 0],\r\n                    [3 / 16, -1, 1],\r\n                    [5 / 16, 0, 1],\r\n                    [1 / 16, 1, 1],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.FalseFloydSteinberg:\r\n                this._kernel = [\r\n                    [3 / 8, 1, 0],\r\n                    [3 / 8, 0, 1],\r\n                    [2 / 8, 1, 1],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Stucki:\r\n                this._kernel = [\r\n                    [8 / 42, 1, 0],\r\n                    [4 / 42, 2, 0],\r\n                    [2 / 42, -2, 1],\r\n                    [4 / 42, -1, 1],\r\n                    [8 / 42, 0, 1],\r\n                    [4 / 42, 1, 1],\r\n                    [2 / 42, 2, 1],\r\n                    [1 / 42, -2, 2],\r\n                    [2 / 42, -1, 2],\r\n                    [4 / 42, 0, 2],\r\n                    [2 / 42, 1, 2],\r\n                    [1 / 42, 2, 2],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Atkinson:\r\n                this._kernel = [\r\n                    [1 / 8, 1, 0],\r\n                    [1 / 8, 2, 0],\r\n                    [1 / 8, -1, 1],\r\n                    [1 / 8, 0, 1],\r\n                    [1 / 8, 1, 1],\r\n                    [1 / 8, 0, 2],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Jarvis:\r\n                this._kernel = [\r\n                    [7 / 48, 1, 0],\r\n                    [5 / 48, 2, 0],\r\n                    [3 / 48, -2, 1],\r\n                    [5 / 48, -1, 1],\r\n                    [7 / 48, 0, 1],\r\n                    [5 / 48, 1, 1],\r\n                    [3 / 48, 2, 1],\r\n                    [1 / 48, -2, 2],\r\n                    [3 / 48, -1, 2],\r\n                    [5 / 48, 0, 2],\r\n                    [3 / 48, 1, 2],\r\n                    [1 / 48, 2, 2],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Burkes:\r\n                this._kernel = [\r\n                    [8 / 32, 1, 0],\r\n                    [4 / 32, 2, 0],\r\n                    [2 / 32, -2, 1],\r\n                    [4 / 32, -1, 1],\r\n                    [8 / 32, 0, 1],\r\n                    [4 / 32, 1, 1],\r\n                    [2 / 32, 2, 1],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.Sierra:\r\n                this._kernel = [\r\n                    [5 / 32, 1, 0],\r\n                    [3 / 32, 2, 0],\r\n                    [2 / 32, -2, 1],\r\n                    [4 / 32, -1, 1],\r\n                    [5 / 32, 0, 1],\r\n                    [4 / 32, 1, 1],\r\n                    [2 / 32, 2, 1],\r\n                    [2 / 32, -1, 2],\r\n                    [3 / 32, 0, 2],\r\n                    [2 / 32, 1, 2],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.TwoSierra:\r\n                this._kernel = [\r\n                    [4 / 16, 1, 0],\r\n                    [3 / 16, 2, 0],\r\n                    [1 / 16, -2, 1],\r\n                    [2 / 16, -1, 1],\r\n                    [3 / 16, 0, 1],\r\n                    [2 / 16, 1, 1],\r\n                    [1 / 16, 2, 1],\r\n                ];\r\n                break;\r\n            case ErrorDiffusionArrayKernel.SierraLite:\r\n                this._kernel = [\r\n                    [2 / 4, 1, 0],\r\n                    [1 / 4, -1, 1],\r\n                    [1 / 4, 0, 1],\r\n                ];\r\n                break;\r\n            default:\r\n                throw new Error('ErrorDiffusionArray: unknown kernel = ' + kernel);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=array.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/image/imageQuantizer.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/image/imageQuantizer.js ***!\n  \\***************************************************************/\n/*! exports provided: AbstractImageQuantizer */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractImageQuantizer\", function() { return AbstractImageQuantizer; });\nclass AbstractImageQuantizer {\r\n    quantizeSync(pointContainer, palette) {\r\n        for (const value of this.quantize(pointContainer, palette)) {\r\n            if (value.pointContainer) {\r\n                return value.pointContainer;\r\n            }\r\n        }\r\n        throw new Error('unreachable');\r\n    }\r\n}\r\n//# sourceMappingURL=imageQuantizer.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/image/index.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/image/index.js ***!\n  \\******************************************************/\n/*! exports provided: AbstractImageQuantizer, NearestColor, ErrorDiffusionArray, ErrorDiffusionArrayKernel, ErrorDiffusionRiemersma */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageQuantizer */ \"./node_modules/image-q/dist/esm/image/imageQuantizer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AbstractImageQuantizer\", function() { return _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__[\"AbstractImageQuantizer\"]; });\n\n/* harmony import */ var _nearestColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nearestColor */ \"./node_modules/image-q/dist/esm/image/nearestColor.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NearestColor\", function() { return _nearestColor__WEBPACK_IMPORTED_MODULE_1__[\"NearestColor\"]; });\n\n/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ \"./node_modules/image-q/dist/esm/image/array.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ErrorDiffusionArray\", function() { return _array__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArray\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ErrorDiffusionArrayKernel\", function() { return _array__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDiffusionArrayKernel\"]; });\n\n/* harmony import */ var _riemersma__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./riemersma */ \"./node_modules/image-q/dist/esm/image/riemersma.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ErrorDiffusionRiemersma\", function() { return _riemersma__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDiffusionRiemersma\"]; });\n\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/image/nearestColor.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/image/nearestColor.js ***!\n  \\*************************************************************/\n/*! exports provided: NearestColor */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestColor\", function() { return NearestColor; });\n/* harmony import */ var _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageQuantizer */ \"./node_modules/image-q/dist/esm/image/imageQuantizer.js\");\n/* harmony import */ var _utils_progressTracker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/progressTracker */ \"./node_modules/image-q/dist/esm/utils/progressTracker.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * nearestColor.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\nclass NearestColor extends _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__[\"AbstractImageQuantizer\"] {\r\n    constructor(colorDistanceCalculator) {\r\n        super();\r\n        this._distance = colorDistanceCalculator;\r\n    }\r\n    /**\r\n     * Mutates pointContainer\r\n     */\r\n    *quantize(pointContainer, palette) {\r\n        const pointArray = pointContainer.getPointArray();\r\n        const width = pointContainer.getWidth();\r\n        const height = pointContainer.getHeight();\r\n        const tracker = new _utils_progressTracker__WEBPACK_IMPORTED_MODULE_1__[\"ProgressTracker\"](height, 99);\r\n        for (let y = 0; y < height; y++) {\r\n            if (tracker.shouldNotify(y)) {\r\n                yield {\r\n                    progress: tracker.progress,\r\n                };\r\n            }\r\n            for (let x = 0, idx = y * width; x < width; x++, idx++) {\r\n                // Image pixel\r\n                const point = pointArray[idx];\r\n                // Reduced pixel\r\n                point.from(palette.getNearestColor(this._distance, point));\r\n            }\r\n        }\r\n        yield {\r\n            pointContainer,\r\n            progress: 100,\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=nearestColor.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/image/riemersma.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/image/riemersma.js ***!\n  \\**********************************************************/\n/*! exports provided: ErrorDiffusionRiemersma */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ErrorDiffusionRiemersma\", function() { return ErrorDiffusionRiemersma; });\n/* harmony import */ var _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageQuantizer */ \"./node_modules/image-q/dist/esm/image/imageQuantizer.js\");\n/* harmony import */ var _spaceFillingCurves_hilbertCurve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spaceFillingCurves/hilbertCurve */ \"./node_modules/image-q/dist/esm/image/spaceFillingCurves/hilbertCurve.js\");\n/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/point */ \"./node_modules/image-q/dist/esm/utils/point.js\");\n/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/**\r\n * @preserve\r\n * MIT License\r\n *\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to\r\n * deal in the Software without restriction, including without limitation the\r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n * sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n * IN THE SOFTWARE.\r\n *\r\n * riemersma.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\nclass ErrorDiffusionRiemersma extends _imageQuantizer__WEBPACK_IMPORTED_MODULE_0__[\"AbstractImageQuantizer\"] {\r\n    constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {\r\n        super();\r\n        this._distance = colorDistanceCalculator;\r\n        this._errorQueueSize = errorQueueSize;\r\n        this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);\r\n    }\r\n    /**\r\n     * Mutates pointContainer\r\n     */\r\n    *quantize(pointContainer, palette) {\r\n        const pointArray = pointContainer.getPointArray();\r\n        const width = pointContainer.getWidth();\r\n        const height = pointContainer.getHeight();\r\n        const errorQueue = [];\r\n        let head = 0;\r\n        for (let i = 0; i < this._errorQueueSize; i++) {\r\n            errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };\r\n        }\r\n        yield* Object(_spaceFillingCurves_hilbertCurve__WEBPACK_IMPORTED_MODULE_1__[\"hilbertCurve\"])(width, height, (x, y) => {\r\n            const p = pointArray[x + y * width];\r\n            let r = p.r;\r\n            let g = p.g;\r\n            let b = p.b;\r\n            let a = p.a;\r\n            for (let i = 0; i < this._errorQueueSize; i++) {\r\n                const weight = this._weights[i];\r\n                const e = errorQueue[(i + head) % this._errorQueueSize];\r\n                r += e.r * weight;\r\n                g += e.g * weight;\r\n                b += e.b * weight;\r\n                a += e.a * weight;\r\n            }\r\n            const correctedPoint = _utils_point__WEBPACK_IMPORTED_MODULE_2__[\"Point\"].createByRGBA(Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__[\"inRange0to255Rounded\"])(r), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__[\"inRange0to255Rounded\"])(g), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__[\"inRange0to255Rounded\"])(b), Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_3__[\"inRange0to255Rounded\"])(a));\r\n            const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);\r\n            // update head and calculate tail\r\n            head = (head + 1) % this._errorQueueSize;\r\n            const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\r\n            // update error with new value\r\n            errorQueue[tail].r = p.r - quantizedPoint.r;\r\n            errorQueue[tail].g = p.g - quantizedPoint.g;\r\n            errorQueue[tail].b = p.b - quantizedPoint.b;\r\n            errorQueue[tail].a = p.a - quantizedPoint.a;\r\n            // update point\r\n            p.from(quantizedPoint);\r\n        });\r\n        yield {\r\n            pointContainer,\r\n            progress: 100,\r\n        };\r\n    }\r\n    static _createWeights(errorPropagation, errorQueueSize) {\r\n        const weights = [];\r\n        const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));\r\n        for (let i = 0, next = 1; i < errorQueueSize; i++) {\r\n            weights[i] = (((next + 0.5) | 0) / errorQueueSize) * errorPropagation;\r\n            next *= multiplier;\r\n        }\r\n        return weights;\r\n    }\r\n}\r\n//# sourceMappingURL=riemersma.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/image/spaceFillingCurves/hilbertCurve.js\":\n/*!********************************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/image/spaceFillingCurves/hilbertCurve.js ***!\n  \\********************************************************************************/\n/*! exports provided: hilbertCurve */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hilbertCurve\", function() { return hilbertCurve; });\n/* harmony import */ var _utils_progressTracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/progressTracker */ \"./node_modules/image-q/dist/esm/utils/progressTracker.js\");\n\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"NONE\"] = 0] = \"NONE\";\r\n    Direction[Direction[\"UP\"] = 1] = \"UP\";\r\n    Direction[Direction[\"LEFT\"] = 2] = \"LEFT\";\r\n    Direction[Direction[\"RIGHT\"] = 3] = \"RIGHT\";\r\n    Direction[Direction[\"DOWN\"] = 4] = \"DOWN\";\r\n})(Direction || (Direction = {}));\r\nfunction* hilbertCurve(width, height, callback) {\r\n    const maxBound = Math.max(width, height);\r\n    const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);\r\n    const tracker = new _utils_progressTracker__WEBPACK_IMPORTED_MODULE_0__[\"ProgressTracker\"](width * height, 99);\r\n    const data = {\r\n        width,\r\n        height,\r\n        level,\r\n        callback,\r\n        tracker,\r\n        index: 0,\r\n        x: 0,\r\n        y: 0,\r\n    };\r\n    yield* walkHilbert(data, Direction.UP);\r\n    visit(data, Direction.NONE);\r\n}\r\nfunction* walkHilbert(data, direction) {\r\n    if (data.level < 1)\r\n        return;\r\n    if (data.tracker.shouldNotify(data.index))\r\n        yield { progress: data.tracker.progress };\r\n    data.level--;\r\n    switch (direction) {\r\n        case Direction.LEFT:\r\n            yield* walkHilbert(data, Direction.UP);\r\n            visit(data, Direction.RIGHT);\r\n            yield* walkHilbert(data, Direction.LEFT);\r\n            visit(data, Direction.DOWN);\r\n            yield* walkHilbert(data, Direction.LEFT);\r\n            visit(data, Direction.LEFT);\r\n            yield* walkHilbert(data, Direction.DOWN);\r\n            break;\r\n        case Direction.RIGHT:\r\n            yield* walkHilbert(data, Direction.DOWN);\r\n            visit(data, Direction.LEFT);\r\n            yield* walkHilbert(data, Direction.RIGHT);\r\n            visit(data, Direction.UP);\r\n            yield* walkHilbert(data, Direction.RIGHT);\r\n            visit(data, Direction.RIGHT);\r\n            yield* walkHilbert(data, Direction.UP);\r\n            break;\r\n        case Direction.UP:\r\n            yield* walkHilbert(data, Direction.LEFT);\r\n            visit(data, Direction.DOWN);\r\n            yield* walkHilbert(data, Direction.UP);\r\n            visit(data, Direction.RIGHT);\r\n            yield* walkHilbert(data, Direction.UP);\r\n            visit(data, Direction.UP);\r\n            yield* walkHilbert(data, Direction.RIGHT);\r\n            break;\r\n        case Direction.DOWN:\r\n            yield* walkHilbert(data, Direction.RIGHT);\r\n            visit(data, Direction.UP);\r\n            yield* walkHilbert(data, Direction.DOWN);\r\n            visit(data, Direction.LEFT);\r\n            yield* walkHilbert(data, Direction.DOWN);\r\n            visit(data, Direction.DOWN);\r\n            yield* walkHilbert(data, Direction.LEFT);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    data.level++;\r\n}\r\nfunction visit(data, direction) {\r\n    if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {\r\n        data.callback(data.x, data.y);\r\n        data.index++;\r\n    }\r\n    switch (direction) {\r\n        case Direction.LEFT:\r\n            data.x--;\r\n            break;\r\n        case Direction.RIGHT:\r\n            data.x++;\r\n            break;\r\n        case Direction.UP:\r\n            data.y--;\r\n            break;\r\n        case Direction.DOWN:\r\n            data.y++;\r\n            break;\r\n    }\r\n}\r\n//# sourceMappingURL=hilbertCurve.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/palette/index.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/palette/index.js ***!\n  \\********************************************************/\n/*! exports provided: AbstractPaletteQuantizer, NeuQuant, NeuQuantFloat, RGBQuant, ColorHistogram, WuQuant, WuColorCube */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paletteQuantizer */ \"./node_modules/image-q/dist/esm/palette/paletteQuantizer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AbstractPaletteQuantizer\", function() { return _paletteQuantizer__WEBPACK_IMPORTED_MODULE_0__[\"AbstractPaletteQuantizer\"]; });\n\n/* harmony import */ var _neuquant_neuquant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./neuquant/neuquant */ \"./node_modules/image-q/dist/esm/palette/neuquant/neuquant.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NeuQuant\", function() { return _neuquant_neuquant__WEBPACK_IMPORTED_MODULE_1__[\"NeuQuant\"]; });\n\n/* harmony import */ var _neuquant_neuquantFloat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./neuquant/neuquantFloat */ \"./node_modules/image-q/dist/esm/palette/neuquant/neuquantFloat.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NeuQuantFloat\", function() { return _neuquant_neuquantFloat__WEBPACK_IMPORTED_MODULE_2__[\"NeuQuantFloat\"]; });\n\n/* harmony import */ var _rgbquant_rgbquant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgbquant/rgbquant */ \"./node_modules/image-q/dist/esm/palette/rgbquant/rgbquant.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RGBQuant\", function() { return _rgbquant_rgbquant__WEBPACK_IMPORTED_MODULE_3__[\"RGBQuant\"]; });\n\n/* harmony import */ var _rgbquant_colorHistogram__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rgbquant/colorHistogram */ \"./node_modules/image-q/dist/esm/palette/rgbquant/colorHistogram.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ColorHistogram\", function() { return _rgbquant_colorHistogram__WEBPACK_IMPORTED_MODULE_4__[\"ColorHistogram\"]; });\n\n/* harmony import */ var _wu_wuQuant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wu/wuQuant */ \"./node_modules/image-q/dist/esm/palette/wu/wuQuant.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WuQuant\", function() { return _wu_wuQuant__WEBPACK_IMPORTED_MODULE_5__[\"WuQuant\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WuColorCube\", function() { return _wu_wuQuant__WEBPACK_IMPORTED_MODULE_5__[\"WuColorCube\"]; });\n\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/palette/neuquant/neuquant.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/palette/neuquant/neuquant.js ***!\n  \\********************************************************************/\n/*! exports provided: NeuQuant */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NeuQuant\", function() { return NeuQuant; });\n/* harmony import */ var _utils_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/palette */ \"./node_modules/image-q/dist/esm/utils/palette.js\");\n/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/point */ \"./node_modules/image-q/dist/esm/utils/point.js\");\n/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../paletteQuantizer */ \"./node_modules/image-q/dist/esm/palette/paletteQuantizer.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ \"./node_modules/image-q/dist/esm/utils/index.js\");\n/*\r\n * NeuQuant Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the \"Software\"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * neuquant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n// bias for colour values\r\nconst networkBiasShift = 3;\r\nclass Neuron {\r\n    constructor(defaultValue) {\r\n        this.r = this.g = this.b = this.a = defaultValue;\r\n    }\r\n    /**\r\n     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n     * @example\r\n     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n     */\r\n    toPoint() {\r\n        return _utils_point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"].createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\r\n    }\r\n    subtract(r, g, b, a) {\r\n        this.r -= r | 0;\r\n        this.g -= g | 0;\r\n        this.b -= b | 0;\r\n        this.a -= a | 0;\r\n    }\r\n}\r\nclass NeuQuant extends _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__[\"AbstractPaletteQuantizer\"] {\r\n    constructor(colorDistanceCalculator, colors = 256) {\r\n        super();\r\n        this._distance = colorDistanceCalculator;\r\n        this._pointArray = [];\r\n        this._sampleFactor = 1;\r\n        this._networkSize = colors;\r\n        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\r\n    }\r\n    sample(pointContainer) {\r\n        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\r\n    }\r\n    *quantize() {\r\n        this._init();\r\n        yield* this._learn();\r\n        yield {\r\n            palette: this._buildPalette(),\r\n            progress: 100,\r\n        };\r\n    }\r\n    _init() {\r\n        this._freq = [];\r\n        this._bias = [];\r\n        this._radPower = [];\r\n        this._network = [];\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            this._network[i] = new Neuron((i << (networkBiasShift + 8)) / this._networkSize | 0);\r\n            // 1/this._networkSize\r\n            this._freq[i] = NeuQuant._initialBias / this._networkSize | 0;\r\n            this._bias[i] = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Main Learning Loop\r\n     */\r\n    *_learn() {\r\n        let sampleFactor = this._sampleFactor;\r\n        const pointsNumber = this._pointArray.length;\r\n        if (pointsNumber < NeuQuant._minpicturebytes)\r\n            sampleFactor = 1;\r\n        const alphadec = 30 + (sampleFactor - 1) / 3 | 0;\r\n        const pointsToSample = pointsNumber / sampleFactor | 0;\r\n        let delta = pointsToSample / NeuQuant._nCycles | 0;\r\n        let alpha = NeuQuant._initAlpha;\r\n        let radius = (this._networkSize >> 3) * NeuQuant._radiusBias;\r\n        let rad = radius >> NeuQuant._radiusBiasShift;\r\n        if (rad <= 1)\r\n            rad = 0;\r\n        for (let i = 0; i < rad; i++) {\r\n            this._radPower[i] = alpha * (((rad * rad - i * i) * NeuQuant._radBias) / (rad * rad)) >>> 0;\r\n        }\r\n        let step;\r\n        if (pointsNumber < NeuQuant._minpicturebytes) {\r\n            step = 1;\r\n        }\r\n        else if (pointsNumber % NeuQuant._prime1 !== 0) {\r\n            step = NeuQuant._prime1;\r\n        }\r\n        else if ((pointsNumber % NeuQuant._prime2) !== 0) {\r\n            step = NeuQuant._prime2;\r\n        }\r\n        else if ((pointsNumber % NeuQuant._prime3) !== 0) {\r\n            step = NeuQuant._prime3;\r\n        }\r\n        else {\r\n            step = NeuQuant._prime4;\r\n        }\r\n        const tracker = new _utils__WEBPACK_IMPORTED_MODULE_3__[\"ProgressTracker\"](pointsToSample, 99);\r\n        for (let i = 0, pointIndex = 0; i < pointsToSample;) {\r\n            if (tracker.shouldNotify(i)) {\r\n                yield {\r\n                    progress: tracker.progress,\r\n                };\r\n            }\r\n            const point = this._pointArray[pointIndex];\r\n            const b = point.b << networkBiasShift;\r\n            const g = point.g << networkBiasShift;\r\n            const r = point.r << networkBiasShift;\r\n            const a = point.a << networkBiasShift;\r\n            const neuronIndex = this._contest(b, g, r, a);\r\n            this._alterSingle(alpha, neuronIndex, b, g, r, a);\r\n            if (rad !== 0)\r\n                this._alterNeighbour(rad, neuronIndex, b, g, r, a);\r\n            /* alter neighbours */\r\n            pointIndex += step;\r\n            if (pointIndex >= pointsNumber)\r\n                pointIndex -= pointsNumber;\r\n            i++;\r\n            if (delta === 0)\r\n                delta = 1;\r\n            if (i % delta === 0) {\r\n                alpha -= (alpha / alphadec) | 0;\r\n                radius -= (radius / NeuQuant._radiusDecrease) | 0;\r\n                rad = radius >> NeuQuant._radiusBiasShift;\r\n                if (rad <= 1)\r\n                    rad = 0;\r\n                for (let j = 0; j < rad; j++)\r\n                    this._radPower[j] = alpha * (((rad * rad - j * j) * NeuQuant._radBias) / (rad * rad)) >>> 0;\r\n            }\r\n        }\r\n    }\r\n    _buildPalette() {\r\n        const palette = new _utils_palette__WEBPACK_IMPORTED_MODULE_0__[\"Palette\"]();\r\n        this._network.forEach(neuron => {\r\n            palette.add(neuron.toPoint());\r\n        });\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n    /**\r\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n     */\r\n    _alterNeighbour(rad, i, b, g, r, al) {\r\n        let lo = i - rad;\r\n        if (lo < -1)\r\n            lo = -1;\r\n        let hi = i + rad;\r\n        if (hi > this._networkSize)\r\n            hi = this._networkSize;\r\n        let j = i + 1;\r\n        let k = i - 1;\r\n        let m = 1;\r\n        while (j < hi || k > lo) {\r\n            const a = this._radPower[m++] / NeuQuant._alphaRadBias;\r\n            if (j < hi) {\r\n                const p = this._network[j++];\r\n                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\r\n            }\r\n            if (k > lo) {\r\n                const p = this._network[k--];\r\n                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Move neuron i towards biased (b,g,r) by factor alpha\r\n     */\r\n    _alterSingle(alpha, i, b, g, r, a) {\r\n        alpha /= NeuQuant._initAlpha;\r\n        /* alter hit neuron */\r\n        const n = this._network[i];\r\n        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\r\n    }\r\n    /**\r\n     * Search for biased BGR values\r\n     * description:\r\n     *    finds closest neuron (min dist) and updates freq\r\n     *    finds best neuron (min dist-bias) and returns position\r\n     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n     *\r\n     * Original distance equation:\r\n     *        dist = abs(dR) + abs(dG) + abs(dB)\r\n     */\r\n    _contest(b, g, r, a) {\r\n        const multiplier = (255 * 4) << networkBiasShift;\r\n        let bestd = ~(1 << 31);\r\n        let bestbiasd = bestd;\r\n        let bestpos = -1;\r\n        let bestbiaspos = bestpos;\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            const n = this._network[i];\r\n            const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;\r\n            if (dist < bestd) {\r\n                bestd = dist;\r\n                bestpos = i;\r\n            }\r\n            const biasdist = dist - ((this._bias[i]) >> (NeuQuant._initialBiasShift - networkBiasShift));\r\n            if (biasdist < bestbiasd) {\r\n                bestbiasd = biasdist;\r\n                bestbiaspos = i;\r\n            }\r\n            const betafreq = (this._freq[i] >> NeuQuant._betaShift);\r\n            this._freq[i] -= betafreq;\r\n            this._bias[i] += (betafreq << NeuQuant._gammaShift);\r\n        }\r\n        this._freq[bestpos] += NeuQuant._beta;\r\n        this._bias[bestpos] -= NeuQuant._betaGamma;\r\n        return bestbiaspos;\r\n    }\r\n}\r\n/*\r\n four primes near 500 - assume no image has a length so large\r\n that it is divisible by all four primes\r\n */\r\nNeuQuant._prime1 = 499;\r\nNeuQuant._prime2 = 491;\r\nNeuQuant._prime3 = 487;\r\nNeuQuant._prime4 = 503;\r\nNeuQuant._minpicturebytes = NeuQuant._prime4;\r\n// no. of learning cycles\r\nNeuQuant._nCycles = 100;\r\n// defs for freq and bias\r\nNeuQuant._initialBiasShift = 16;\r\n// bias for fractions\r\nNeuQuant._initialBias = (1 << NeuQuant._initialBiasShift);\r\nNeuQuant._gammaShift = 10;\r\n// gamma = 1024\r\n// TODO: why gamma is never used?\r\n// private static _gamma : number     = (1 << NeuQuant._gammaShift);\r\nNeuQuant._betaShift = 10;\r\nNeuQuant._beta = (NeuQuant._initialBias >> NeuQuant._betaShift);\r\n// beta = 1/1024\r\nNeuQuant._betaGamma = (NeuQuant._initialBias << (NeuQuant._gammaShift - NeuQuant._betaShift));\r\n/*\r\n * for 256 cols, radius starts\r\n */\r\nNeuQuant._radiusBiasShift = 6;\r\n// at 32.0 biased by 6 bits\r\nNeuQuant._radiusBias = 1 << NeuQuant._radiusBiasShift;\r\n// and decreases by a factor of 1/30 each cycle\r\nNeuQuant._radiusDecrease = 30;\r\n/* defs for decreasing alpha factor */\r\n// alpha starts at 1.0\r\nNeuQuant._alphaBiasShift = 10;\r\n// biased by 10 bits\r\nNeuQuant._initAlpha = (1 << NeuQuant._alphaBiasShift);\r\n/* radBias and alphaRadBias used for radpower calculation */\r\nNeuQuant._radBiasShift = 8;\r\nNeuQuant._radBias = 1 << NeuQuant._radBiasShift;\r\nNeuQuant._alphaRadBiasShift = NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;\r\nNeuQuant._alphaRadBias = 1 << NeuQuant._alphaRadBiasShift;\r\n//# sourceMappingURL=neuquant.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/palette/neuquant/neuquantFloat.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/palette/neuquant/neuquantFloat.js ***!\n  \\*************************************************************************/\n/*! exports provided: NeuQuantFloat */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NeuQuantFloat\", function() { return NeuQuantFloat; });\n/* harmony import */ var _utils_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/palette */ \"./node_modules/image-q/dist/esm/utils/palette.js\");\n/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/point */ \"./node_modules/image-q/dist/esm/utils/point.js\");\n/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../paletteQuantizer */ \"./node_modules/image-q/dist/esm/palette/paletteQuantizer.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ \"./node_modules/image-q/dist/esm/utils/index.js\");\n/*\r\n * NeuQuantFloat Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the \"Software\"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * neuquant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n// bias for colour values\r\nconst networkBiasShift = 3;\r\nclass NeuronFloat {\r\n    constructor(defaultValue) {\r\n        this.r = this.g = this.b = this.a = defaultValue;\r\n    }\r\n    /**\r\n     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n     * @example\r\n     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n     */\r\n    toPoint() {\r\n        return _utils_point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"].createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\r\n    }\r\n    subtract(r, g, b, a) {\r\n        this.r -= r;\r\n        this.g -= g;\r\n        this.b -= b;\r\n        this.a -= a;\r\n    }\r\n}\r\nclass NeuQuantFloat extends _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__[\"AbstractPaletteQuantizer\"] {\r\n    constructor(colorDistanceCalculator, colors = 256) {\r\n        super();\r\n        this._distance = colorDistanceCalculator;\r\n        this._pointArray = [];\r\n        this._sampleFactor = 1;\r\n        this._networkSize = colors;\r\n        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\r\n    }\r\n    sample(pointContainer) {\r\n        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\r\n    }\r\n    *quantize() {\r\n        this._init();\r\n        yield* this._learn();\r\n        yield {\r\n            palette: this._buildPalette(),\r\n            progress: 100,\r\n        };\r\n    }\r\n    _init() {\r\n        this._freq = [];\r\n        this._bias = [];\r\n        this._radPower = [];\r\n        this._network = [];\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            this._network[i] = new NeuronFloat((i << (networkBiasShift + 8)) / this._networkSize);\r\n            // 1/this._networkSize\r\n            this._freq[i] = NeuQuantFloat._initialBias / this._networkSize;\r\n            this._bias[i] = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Main Learning Loop\r\n     */\r\n    *_learn() {\r\n        let sampleFactor = this._sampleFactor;\r\n        const pointsNumber = this._pointArray.length;\r\n        if (pointsNumber < NeuQuantFloat._minpicturebytes)\r\n            sampleFactor = 1;\r\n        const alphadec = 30 + (sampleFactor - 1) / 3;\r\n        const pointsToSample = pointsNumber / sampleFactor;\r\n        let delta = pointsToSample / NeuQuantFloat._nCycles | 0;\r\n        let alpha = NeuQuantFloat._initAlpha;\r\n        let radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\r\n        let rad = radius >> NeuQuantFloat._radiusBiasShift;\r\n        if (rad <= 1)\r\n            rad = 0;\r\n        for (let i = 0; i < rad; i++) {\r\n            this._radPower[i] = alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));\r\n        }\r\n        let step;\r\n        if (pointsNumber < NeuQuantFloat._minpicturebytes) {\r\n            step = 1;\r\n        }\r\n        else if (pointsNumber % NeuQuantFloat._prime1 !== 0) {\r\n            step = NeuQuantFloat._prime1;\r\n        }\r\n        else if ((pointsNumber % NeuQuantFloat._prime2) !== 0) {\r\n            step = NeuQuantFloat._prime2;\r\n        }\r\n        else if ((pointsNumber % NeuQuantFloat._prime3) !== 0) {\r\n            step = NeuQuantFloat._prime3;\r\n        }\r\n        else {\r\n            step = NeuQuantFloat._prime4;\r\n        }\r\n        const tracker = new _utils__WEBPACK_IMPORTED_MODULE_3__[\"ProgressTracker\"](pointsToSample, 99);\r\n        for (let i = 0, pointIndex = 0; i < pointsToSample;) {\r\n            if (tracker.shouldNotify(i)) {\r\n                yield {\r\n                    progress: tracker.progress,\r\n                };\r\n            }\r\n            const point = this._pointArray[pointIndex];\r\n            const b = point.b << networkBiasShift;\r\n            const g = point.g << networkBiasShift;\r\n            const r = point.r << networkBiasShift;\r\n            const a = point.a << networkBiasShift;\r\n            const neuronIndex = this._contest(b, g, r, a);\r\n            this._alterSingle(alpha, neuronIndex, b, g, r, a);\r\n            if (rad !== 0)\r\n                this._alterNeighbour(rad, neuronIndex, b, g, r, a);\r\n            /* alter neighbours */\r\n            pointIndex += step;\r\n            if (pointIndex >= pointsNumber)\r\n                pointIndex -= pointsNumber;\r\n            i++;\r\n            if (delta === 0)\r\n                delta = 1;\r\n            if (i % delta === 0) {\r\n                alpha -= (alpha / alphadec);\r\n                radius -= (radius / NeuQuantFloat._radiusDecrease);\r\n                rad = radius >> NeuQuantFloat._radiusBiasShift;\r\n                if (rad <= 1)\r\n                    rad = 0;\r\n                for (let j = 0; j < rad; j++)\r\n                    this._radPower[j] = alpha * (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));\r\n            }\r\n        }\r\n    }\r\n    _buildPalette() {\r\n        const palette = new _utils_palette__WEBPACK_IMPORTED_MODULE_0__[\"Palette\"]();\r\n        this._network.forEach(neuron => {\r\n            palette.add(neuron.toPoint());\r\n        });\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n    /**\r\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n     */\r\n    _alterNeighbour(rad, i, b, g, r, al) {\r\n        let lo = i - rad;\r\n        if (lo < -1)\r\n            lo = -1;\r\n        let hi = i + rad;\r\n        if (hi > this._networkSize)\r\n            hi = this._networkSize;\r\n        let j = i + 1;\r\n        let k = i - 1;\r\n        let m = 1;\r\n        while (j < hi || k > lo) {\r\n            const a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;\r\n            if (j < hi) {\r\n                const p = this._network[j++];\r\n                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\r\n            }\r\n            if (k > lo) {\r\n                const p = this._network[k--];\r\n                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Move neuron i towards biased (b,g,r) by factor alpha\r\n     */\r\n    _alterSingle(alpha, i, b, g, r, a) {\r\n        alpha /= NeuQuantFloat._initAlpha;\r\n        /* alter hit neuron */\r\n        const n = this._network[i];\r\n        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\r\n    }\r\n    /**\r\n     * Search for biased BGR values\r\n     * description:\r\n     *    finds closest neuron (min dist) and updates freq\r\n     *    finds best neuron (min dist-bias) and returns position\r\n     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n     *\r\n     * Original distance equation:\r\n     *        dist = abs(dR) + abs(dG) + abs(dB)\r\n     */\r\n    _contest(b, g, r, al) {\r\n        const multiplier = (255 * 4) << networkBiasShift;\r\n        let bestd = ~(1 << 31);\r\n        let bestbiasd = bestd;\r\n        let bestpos = -1;\r\n        let bestbiaspos = bestpos;\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            const n = this._network[i];\r\n            const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;\r\n            if (dist < bestd) {\r\n                bestd = dist;\r\n                bestpos = i;\r\n            }\r\n            const biasdist = dist - ((this._bias[i]) >> (NeuQuantFloat._initialBiasShift - networkBiasShift));\r\n            if (biasdist < bestbiasd) {\r\n                bestbiasd = biasdist;\r\n                bestbiaspos = i;\r\n            }\r\n            const betafreq = (this._freq[i] >> NeuQuantFloat._betaShift);\r\n            this._freq[i] -= betafreq;\r\n            this._bias[i] += (betafreq << NeuQuantFloat._gammaShift);\r\n        }\r\n        this._freq[bestpos] += NeuQuantFloat._beta;\r\n        this._bias[bestpos] -= NeuQuantFloat._betaGamma;\r\n        return bestbiaspos;\r\n    }\r\n}\r\n/*\r\n four primes near 500 - assume no image has a length so large\r\n that it is divisible by all four primes\r\n */\r\nNeuQuantFloat._prime1 = 499;\r\nNeuQuantFloat._prime2 = 491;\r\nNeuQuantFloat._prime3 = 487;\r\nNeuQuantFloat._prime4 = 503;\r\nNeuQuantFloat._minpicturebytes = NeuQuantFloat._prime4;\r\n// no. of learning cycles\r\nNeuQuantFloat._nCycles = 100;\r\n// defs for freq and bias\r\nNeuQuantFloat._initialBiasShift = 16;\r\n// bias for fractions\r\nNeuQuantFloat._initialBias = (1 << NeuQuantFloat._initialBiasShift);\r\nNeuQuantFloat._gammaShift = 10;\r\n// gamma = 1024\r\n// TODO: why gamma is never used?\r\n// private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\r\nNeuQuantFloat._betaShift = 10;\r\nNeuQuantFloat._beta = (NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift);\r\n// beta = 1/1024\r\nNeuQuantFloat._betaGamma = (NeuQuantFloat._initialBias << (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift));\r\n/*\r\n * for 256 cols, radius starts\r\n */\r\nNeuQuantFloat._radiusBiasShift = 6;\r\n// at 32.0 biased by 6 bits\r\nNeuQuantFloat._radiusBias = 1 << NeuQuantFloat._radiusBiasShift;\r\n// and decreases by a factor of 1/30 each cycle\r\nNeuQuantFloat._radiusDecrease = 30;\r\n/* defs for decreasing alpha factor */\r\n// alpha starts at 1.0\r\nNeuQuantFloat._alphaBiasShift = 10;\r\n// biased by 10 bits\r\nNeuQuantFloat._initAlpha = (1 << NeuQuantFloat._alphaBiasShift);\r\n/* radBias and alphaRadBias used for radpower calculation */\r\nNeuQuantFloat._radBiasShift = 8;\r\nNeuQuantFloat._radBias = 1 << NeuQuantFloat._radBiasShift;\r\nNeuQuantFloat._alphaRadBiasShift = NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\r\nNeuQuantFloat._alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift;\r\n//# sourceMappingURL=neuquantFloat.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/palette/paletteQuantizer.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/palette/paletteQuantizer.js ***!\n  \\*******************************************************************/\n/*! exports provided: AbstractPaletteQuantizer */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractPaletteQuantizer\", function() { return AbstractPaletteQuantizer; });\nclass AbstractPaletteQuantizer {\r\n    quantizeSync() {\r\n        for (const value of this.quantize()) {\r\n            if (value.palette) {\r\n                return value.palette;\r\n            }\r\n        }\r\n        throw new Error('unreachable');\r\n    }\r\n}\r\n//# sourceMappingURL=paletteQuantizer.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/palette/rgbquant/colorHistogram.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/palette/rgbquant/colorHistogram.js ***!\n  \\**************************************************************************/\n/*! exports provided: ColorHistogram */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorHistogram\", function() { return ColorHistogram; });\n/* harmony import */ var _utils_hueStatistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/hueStatistics */ \"./node_modules/image-q/dist/esm/utils/hueStatistics.js\");\n/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/*\r\n * Copyright (c) 2015, Leon Sorokin\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ColorHistogram.js - an image quantization lib\r\n */\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * colorHistogram.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\nclass ColorHistogram {\r\n    constructor(method, colors) {\r\n        // 1 = by global population, 2 = subregion population threshold\r\n        this._method = method;\r\n        // if > 0, enables hues stats and min-color retention per group\r\n        this._minHueCols = colors << 2; // opts.minHueCols || 0;\r\n        // # of highest-frequency colors to start with for palette reduction\r\n        this._initColors = colors << 2;\r\n        // HueStatistics instance\r\n        this._hueStats = new _utils_hueStatistics__WEBPACK_IMPORTED_MODULE_0__[\"HueStatistics\"](ColorHistogram._hueGroups, this._minHueCols);\r\n        this._histogram = Object.create(null); // tslint:disable-line:no-null-keyword\r\n    }\r\n    sample(pointContainer) {\r\n        switch (this._method) {\r\n            case 1:\r\n                this._colorStats1D(pointContainer);\r\n                break;\r\n            case 2:\r\n                this._colorStats2D(pointContainer);\r\n                break;\r\n        }\r\n    }\r\n    getImportanceSortedColorsIDXI32() {\r\n        // TODO: fix typing issue in stableSort func\r\n        const sorted = Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_1__[\"stableSort\"])(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);\r\n        if (sorted.length === 0) {\r\n            return [];\r\n        }\r\n        let idxi32;\r\n        switch (this._method) {\r\n            case 1:\r\n                const initialColorsLimit = Math.min(sorted.length, this._initColors);\r\n                const last = sorted[initialColorsLimit - 1];\r\n                const freq = this._histogram[last];\r\n                idxi32 = sorted.slice(0, initialColorsLimit);\r\n                // add any cut off colors with same freq as last\r\n                let pos = initialColorsLimit;\r\n                const len = sorted.length;\r\n                while (pos < len && this._histogram[sorted[pos]] === freq) {\r\n                    idxi32.push(sorted[pos++]);\r\n                }\r\n                // inject min huegroup colors\r\n                this._hueStats.injectIntoArray(idxi32);\r\n                break;\r\n            case 2:\r\n                idxi32 = sorted;\r\n                break;\r\n            default:\r\n                // TODO: rethink errors\r\n                throw new Error('Incorrect method');\r\n        }\r\n        // int32-ify values\r\n        return idxi32.map(function (v) {\r\n            return +v;\r\n        });\r\n    }\r\n    // global top-population\r\n    _colorStats1D(pointContainer) {\r\n        const histG = this._histogram;\r\n        const pointArray = pointContainer.getPointArray();\r\n        const len = pointArray.length;\r\n        for (let i = 0; i < len; i++) {\r\n            const col = pointArray[i].uint32;\r\n            // collect hue stats\r\n            this._hueStats.check(col);\r\n            if (col in histG) {\r\n                histG[col]++;\r\n            }\r\n            else {\r\n                histG[col] = 1;\r\n            }\r\n        }\r\n    }\r\n    // population threshold within subregions\r\n    // FIXME: this can over-reduce (few/no colors same?), need a way to keep\r\n    // important colors that dont ever reach local thresholds (gradients?)\r\n    _colorStats2D(pointContainer) {\r\n        const width = pointContainer.getWidth();\r\n        const height = pointContainer.getHeight();\r\n        const pointArray = pointContainer.getPointArray();\r\n        const boxW = ColorHistogram._boxSize[0];\r\n        const boxH = ColorHistogram._boxSize[1];\r\n        const area = boxW * boxH;\r\n        const boxes = this._makeBoxes(width, height, boxW, boxH);\r\n        const histG = this._histogram;\r\n        boxes.forEach(box => {\r\n            let effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;\r\n            if (effc < 2)\r\n                effc = 2;\r\n            const histL = {};\r\n            this._iterateBox(box, width, (i) => {\r\n                const col = pointArray[i].uint32;\r\n                // collect hue stats\r\n                this._hueStats.check(col);\r\n                if (col in histG) {\r\n                    histG[col]++;\r\n                }\r\n                else if (col in histL) {\r\n                    if (++histL[col] >= effc) {\r\n                        histG[col] = histL[col];\r\n                    }\r\n                }\r\n                else {\r\n                    histL[col] = 1;\r\n                }\r\n            });\r\n        });\r\n        // inject min huegroup colors\r\n        this._hueStats.injectIntoDictionary(histG);\r\n    }\r\n    // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\r\n    _iterateBox(bbox, wid, fn) {\r\n        const b = bbox;\r\n        const i0 = b.y * wid + b.x;\r\n        const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\r\n        const incr = wid - b.w + 1;\r\n        let cnt = 0;\r\n        let i = i0;\r\n        do {\r\n            fn.call(this, i);\r\n            i += (++cnt % b.w === 0) ? incr : 1;\r\n        } while (i <= i1);\r\n    }\r\n    /**\r\n     *    partitions a rectangle of width x height into\r\n     *    array of boxes stepX x stepY (or less)\r\n     */\r\n    _makeBoxes(width, height, stepX, stepY) {\r\n        const wrem = width % stepX;\r\n        const hrem = height % stepY;\r\n        const xend = width - wrem;\r\n        const yend = height - hrem;\r\n        const boxesArray = [];\r\n        for (let y = 0; y < height; y += stepY) {\r\n            for (let x = 0; x < width; x += stepX) {\r\n                boxesArray.push({ x, y, w: (x === xend ? wrem : stepX), h: (y === yend ? hrem : stepY) });\r\n            }\r\n        }\r\n        return boxesArray;\r\n    }\r\n}\r\nColorHistogram._boxSize = [64, 64];\r\nColorHistogram._boxPixels = 2;\r\nColorHistogram._hueGroups = 10;\r\n//# sourceMappingURL=colorHistogram.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/palette/rgbquant/rgbquant.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/palette/rgbquant/rgbquant.js ***!\n  \\********************************************************************/\n/*! exports provided: RGBQuant */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBQuant\", function() { return RGBQuant; });\n/* harmony import */ var _utils_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/palette */ \"./node_modules/image-q/dist/esm/utils/palette.js\");\n/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/point */ \"./node_modules/image-q/dist/esm/utils/point.js\");\n/* harmony import */ var _colorHistogram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colorHistogram */ \"./node_modules/image-q/dist/esm/palette/rgbquant/colorHistogram.js\");\n/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../paletteQuantizer */ \"./node_modules/image-q/dist/esm/palette/paletteQuantizer.js\");\n/* harmony import */ var _utils_arithmetic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils */ \"./node_modules/image-q/dist/esm/utils/index.js\");\n/*\r\n * Copyright (c) 2015, Leon Sorokin\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * RGBQuant.js - an image quantization lib\r\n */\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgbquant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass RemovedColor {\r\n    constructor(index, color, distance) {\r\n        this.index = index;\r\n        this.color = color;\r\n        this.distance = distance;\r\n    }\r\n}\r\n// TODO: make input/output image and input/output palettes with instances of class Point only!\r\nclass RGBQuant extends _paletteQuantizer__WEBPACK_IMPORTED_MODULE_3__[\"AbstractPaletteQuantizer\"] {\r\n    constructor(colorDistanceCalculator, colors = 256, method = 2) {\r\n        super();\r\n        this._distance = colorDistanceCalculator;\r\n        // desired final palette size\r\n        this._colors = colors;\r\n        // histogram to accumulate\r\n        this._histogram = new _colorHistogram__WEBPACK_IMPORTED_MODULE_2__[\"ColorHistogram\"](method, colors);\r\n        this._initialDistance = 0.01;\r\n        this._distanceIncrement = 0.005;\r\n    }\r\n    // gathers histogram info\r\n    sample(image) {\r\n        /*\r\n         var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];\r\n    \r\n         for (var i = 0, l = pointArray.length; i < l; i++) {\r\n         var color = pointArray[i];\r\n         for (var componentIndex = 0; componentIndex < 4; componentIndex++) {\r\n         if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];\r\n         if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];\r\n         }\r\n         }\r\n         var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];\r\n         this._distance.setWhitePoint(rd, gd, bd, ad);\r\n    \r\n         this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;\r\n         */\r\n        this._histogram.sample(image);\r\n    }\r\n    // reduces histogram to palette, remaps & memoizes reduced colors\r\n    *quantize() {\r\n        const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\r\n        if (idxi32.length === 0) {\r\n            throw new Error('No colors in image');\r\n        }\r\n        yield* this._buildPalette(idxi32);\r\n    }\r\n    // reduces similar colors from an importance-sorted Uint32 rgba array\r\n    *_buildPalette(idxi32) {\r\n        // reduce histogram to create initial palette\r\n        // build full rgb palette\r\n        const palette = new _utils_palette__WEBPACK_IMPORTED_MODULE_0__[\"Palette\"]();\r\n        const colorArray = palette.getPointContainer().getPointArray();\r\n        const usageArray = new Array(idxi32.length); // tslint:disable-line:prefer-array-literal\r\n        for (let i = 0; i < idxi32.length; i++) {\r\n            colorArray.push(_utils_point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"].createByUint32(idxi32[i]));\r\n            usageArray[i] = 1;\r\n        }\r\n        const len = colorArray.length;\r\n        const memDist = [];\r\n        let palLen = len;\r\n        let thold = this._initialDistance;\r\n        // palette already at or below desired length\r\n        const tracker = new _utils__WEBPACK_IMPORTED_MODULE_5__[\"ProgressTracker\"](palLen - this._colors, 99);\r\n        while (palLen > this._colors) {\r\n            memDist.length = 0;\r\n            // iterate palette\r\n            for (let i = 0; i < len; i++) {\r\n                if (tracker.shouldNotify(len - palLen)) {\r\n                    yield {\r\n                        progress: tracker.progress,\r\n                    };\r\n                }\r\n                if (usageArray[i] === 0)\r\n                    continue;\r\n                const pxi = colorArray[i];\r\n                // if (!pxi) continue;\r\n                for (let j = i + 1; j < len; j++) {\r\n                    if (usageArray[j] === 0)\r\n                        continue;\r\n                    const pxj = colorArray[j];\r\n                    // if (!pxj) continue;\r\n                    const dist = this._distance.calculateNormalized(pxi, pxj);\r\n                    if (dist < thold) {\r\n                        // store index,rgb,dist\r\n                        memDist.push(new RemovedColor(j, pxj, dist));\r\n                        usageArray[j] = 0;\r\n                        palLen--;\r\n                    }\r\n                }\r\n            }\r\n            // palette reduction pass\r\n            // console.log(\"palette length: \" + palLen);\r\n            // if palette is still much larger than target, increment by larger initDist\r\n            thold += (palLen > this._colors * 3) ? this._initialDistance : this._distanceIncrement;\r\n        }\r\n        // if palette is over-reduced, re-add removed colors with largest distances from last round\r\n        if (palLen < this._colors) {\r\n            // sort descending\r\n            Object(_utils_arithmetic__WEBPACK_IMPORTED_MODULE_4__[\"stableSort\"])(memDist, function (a, b) {\r\n                return b.distance - a.distance;\r\n            });\r\n            let k = 0;\r\n            while (palLen < this._colors && k < memDist.length) {\r\n                const removedColor = memDist[k];\r\n                // re-inject rgb into final palette\r\n                usageArray[removedColor.index] = 1;\r\n                palLen++;\r\n                k++;\r\n            }\r\n        }\r\n        let colors = colorArray.length;\r\n        for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n            if (usageArray[colorIndex] === 0) {\r\n                if (colorIndex !== colors - 1) {\r\n                    colorArray[colorIndex] = colorArray[colors - 1];\r\n                }\r\n                --colors;\r\n            }\r\n        }\r\n        colorArray.length = colors;\r\n        palette.sort();\r\n        yield {\r\n            palette,\r\n            progress: 100,\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=rgbquant.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/palette/wu/wuQuant.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/palette/wu/wuQuant.js ***!\n  \\*************************************************************/\n/*! exports provided: WuColorCube, WuQuant */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WuColorCube\", function() { return WuColorCube; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WuQuant\", function() { return WuQuant; });\n/* harmony import */ var _utils_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/palette */ \"./node_modules/image-q/dist/esm/utils/palette.js\");\n/* harmony import */ var _utils_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/point */ \"./node_modules/image-q/dist/esm/utils/point.js\");\n/* harmony import */ var _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../paletteQuantizer */ \"./node_modules/image-q/dist/esm/palette/paletteQuantizer.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ \"./node_modules/image-q/dist/esm/utils/index.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * wuQuant.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\nfunction createArray1D(dimension1) {\r\n    const a = [];\r\n    for (let k = 0; k < dimension1; k++) {\r\n        a[k] = 0;\r\n    }\r\n    return a;\r\n}\r\nfunction createArray4D(dimension1, dimension2, dimension3, dimension4) {\r\n    const a = new Array(dimension1);\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[i] = new Array(dimension2);\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[i][j] = new Array(dimension3);\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[i][j][k] = new Array(dimension4);\r\n                for (let l = 0; l < dimension4; l++) {\r\n                    a[i][j][k][l] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}\r\nfunction createArray3D(dimension1, dimension2, dimension3) {\r\n    const a = new Array(dimension1);\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[i] = new Array(dimension2);\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[i][j] = new Array(dimension3);\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[i][j][k] = 0;\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}\r\nfunction fillArray3D(a, dimension1, dimension2, dimension3, value) {\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[i] = [];\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[i][j] = [];\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[i][j][k] = value;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction fillArray1D(a, dimension1, value) {\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[i] = value;\r\n    }\r\n}\r\nclass WuColorCube {\r\n}\r\nclass WuQuant extends _paletteQuantizer__WEBPACK_IMPORTED_MODULE_2__[\"AbstractPaletteQuantizer\"] {\r\n    constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {\r\n        super();\r\n        this._distance = colorDistanceCalculator;\r\n        this._setQuality(significantBitsPerChannel);\r\n        this._initialize(colors);\r\n    }\r\n    sample(image) {\r\n        const pointArray = image.getPointArray();\r\n        for (let i = 0, l = pointArray.length; i < l; i++) {\r\n            this._addColor(pointArray[i]);\r\n        }\r\n        this._pixels = this._pixels.concat(pointArray);\r\n    }\r\n    *quantize() {\r\n        yield* this._preparePalette();\r\n        const palette = new _utils_palette__WEBPACK_IMPORTED_MODULE_0__[\"Palette\"]();\r\n        // generates palette\r\n        for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\r\n            if (this._sums[paletteIndex] > 0) {\r\n                const sum = this._sums[paletteIndex];\r\n                const r = this._reds[paletteIndex] / sum;\r\n                const g = this._greens[paletteIndex] / sum;\r\n                const b = this._blues[paletteIndex] / sum;\r\n                const a = this._alphas[paletteIndex] / sum;\r\n                const color = _utils_point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"].createByRGBA(r | 0, g | 0, b | 0, a | 0);\r\n                palette.add(color);\r\n            }\r\n        }\r\n        palette.sort();\r\n        yield {\r\n            palette,\r\n            progress: 100,\r\n        };\r\n    }\r\n    *_preparePalette() {\r\n        // preprocess the colors\r\n        yield* this._calculateMoments();\r\n        let next = 0;\r\n        const volumeVariance = createArray1D(this._colors);\r\n        // processes the cubes\r\n        for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\r\n            // if cut is possible; make it\r\n            if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\r\n                volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0.0;\r\n                volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0.0;\r\n            }\r\n            else {\r\n                // the cut was not possible, revert the index\r\n                volumeVariance[next] = 0.0;\r\n                cubeIndex--;\r\n            }\r\n            next = 0;\r\n            let temp = volumeVariance[0];\r\n            for (let index = 1; index <= cubeIndex; ++index) {\r\n                if (volumeVariance[index] > temp) {\r\n                    temp = volumeVariance[index];\r\n                    next = index;\r\n                }\r\n            }\r\n            if (temp <= 0.0) {\r\n                this._colors = cubeIndex + 1;\r\n                break;\r\n            }\r\n        }\r\n        const lookupRed = [];\r\n        const lookupGreen = [];\r\n        const lookupBlue = [];\r\n        const lookupAlpha = [];\r\n        // precalculates lookup tables\r\n        for (let k = 0; k < this._colors; ++k) {\r\n            const weight = WuQuant._volume(this._cubes[k], this._weights);\r\n            if (weight > 0) {\r\n                lookupRed[k] = (WuQuant._volume(this._cubes[k], this._momentsRed) / weight) | 0;\r\n                lookupGreen[k] = (WuQuant._volume(this._cubes[k], this._momentsGreen) / weight) | 0;\r\n                lookupBlue[k] = (WuQuant._volume(this._cubes[k], this._momentsBlue) / weight) | 0;\r\n                lookupAlpha[k] = (WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight) | 0;\r\n            }\r\n            else {\r\n                lookupRed[k] = 0;\r\n                lookupGreen[k] = 0;\r\n                lookupBlue[k] = 0;\r\n                lookupAlpha[k] = 0;\r\n            }\r\n        }\r\n        this._reds = createArray1D(this._colors + 1);\r\n        this._greens = createArray1D(this._colors + 1);\r\n        this._blues = createArray1D(this._colors + 1);\r\n        this._alphas = createArray1D(this._colors + 1);\r\n        this._sums = createArray1D(this._colors + 1);\r\n        // scans and adds colors\r\n        for (let index = 0, l = this._pixels.length; index < l; index++) {\r\n            const color = this._pixels[index];\r\n            const match = -1;\r\n            let bestMatch = match;\r\n            let bestDistance = Number.MAX_VALUE;\r\n            for (let lookup = 0; lookup < this._colors; lookup++) {\r\n                const foundRed = lookupRed[lookup];\r\n                const foundGreen = lookupGreen[lookup];\r\n                const foundBlue = lookupBlue[lookup];\r\n                const foundAlpha = lookupAlpha[lookup];\r\n                const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);\r\n                if (distance < bestDistance) {\r\n                    bestDistance = distance;\r\n                    bestMatch = lookup;\r\n                }\r\n            }\r\n            this._reds[bestMatch] += color.r;\r\n            this._greens[bestMatch] += color.g;\r\n            this._blues[bestMatch] += color.b;\r\n            this._alphas[bestMatch] += color.a;\r\n            this._sums[bestMatch]++;\r\n        }\r\n    }\r\n    _addColor(color) {\r\n        const bitsToRemove = 8 - this._significantBitsPerChannel;\r\n        const indexRed = (color.r >> bitsToRemove) + 1;\r\n        const indexGreen = (color.g >> bitsToRemove) + 1;\r\n        const indexBlue = (color.b >> bitsToRemove) + 1;\r\n        const indexAlpha = (color.a >> bitsToRemove) + 1;\r\n        // if(color.a > 10) {\r\n        this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\r\n        this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\r\n        this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\r\n        this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\r\n        this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\r\n        this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];\r\n        // }\r\n    }\r\n    /**\r\n     * Converts the histogram to a series of _moments.\r\n     */\r\n    *_calculateMoments() {\r\n        const area = [];\r\n        const areaRed = [];\r\n        const areaGreen = [];\r\n        const areaBlue = [];\r\n        const areaAlpha = [];\r\n        const area2 = [];\r\n        const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n        const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n        const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n        const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n        const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n        const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n        let trackerProgress = 0;\r\n        const tracker = new _utils__WEBPACK_IMPORTED_MODULE_3__[\"ProgressTracker\"](this._alphaMaxSideIndex * this._maxSideIndex, 99);\r\n        for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {\r\n            fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {\r\n                if (tracker.shouldNotify(trackerProgress)) {\r\n                    yield {\r\n                        progress: tracker.progress,\r\n                    };\r\n                }\r\n                fillArray1D(area, this._sideSize, 0);\r\n                fillArray1D(areaRed, this._sideSize, 0);\r\n                fillArray1D(areaGreen, this._sideSize, 0);\r\n                fillArray1D(areaBlue, this._sideSize, 0);\r\n                fillArray1D(areaAlpha, this._sideSize, 0);\r\n                fillArray1D(area2, this._sideSize, 0);\r\n                for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {\r\n                    let line = 0;\r\n                    let lineRed = 0;\r\n                    let lineGreen = 0;\r\n                    let lineBlue = 0;\r\n                    let lineAlpha = 0;\r\n                    let line2 = 0.0;\r\n                    for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {\r\n                        line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                        lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                        lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                        lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                        lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                        line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\r\n                        area[blueIndex] += line;\r\n                        areaRed[blueIndex] += lineRed;\r\n                        areaGreen[blueIndex] += lineGreen;\r\n                        areaBlue[blueIndex] += lineBlue;\r\n                        areaAlpha[blueIndex] += lineAlpha;\r\n                        area2[blueIndex] += line2;\r\n                        xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\r\n                        xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];\r\n                        xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];\r\n                        xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];\r\n                        xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];\r\n                        xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\r\n                        this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];\r\n                        this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];\r\n                        this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];\r\n                        this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];\r\n                        this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];\r\n                        this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Computes the volume of the cube in a specific moment.\r\n     */\r\n    static _volumeFloat(cube, moment) {\r\n        return (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] -\r\n            moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -\r\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +\r\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] -\r\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] +\r\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +\r\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -\r\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n            (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -\r\n                moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -\r\n                moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -\r\n                moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +\r\n                moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +\r\n                moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] -\r\n                moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n    }\r\n    /**\r\n     * Computes the volume of the cube in a specific moment.\r\n     */\r\n    static _volume(cube, moment) {\r\n        return WuQuant._volumeFloat(cube, moment) | 0;\r\n    }\r\n    /**\r\n     * Splits the cube in given position][and color direction.\r\n     */\r\n    static _top(cube, direction, position, moment) {\r\n        let result;\r\n        switch (direction) {\r\n            case WuQuant._alpha:\r\n                result = (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] -\r\n                    moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -\r\n                    moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +\r\n                    moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -\r\n                        moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n                break;\r\n            case WuQuant._red:\r\n                result = (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] -\r\n                    moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);\r\n                break;\r\n            case WuQuant._green:\r\n                result = (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] -\r\n                    moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum]) -\r\n                    (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] -\r\n                        moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);\r\n                break;\r\n            case WuQuant._blue:\r\n                result = (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] -\r\n                    moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] -\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] +\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position]) -\r\n                    (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] -\r\n                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);\r\n                break;\r\n            default:\r\n                throw new Error('impossible');\r\n        }\r\n        return result | 0;\r\n    }\r\n    /**\r\n     * Splits the cube in a given color direction at its minimum.\r\n     */\r\n    static _bottom(cube, direction, moment) {\r\n        switch (direction) {\r\n            case WuQuant._alpha:\r\n                return (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n            case WuQuant._red:\r\n                return (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] +\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n            case WuQuant._green:\r\n                return (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] +\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] +\r\n                    moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] -\r\n                    moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum]) -\r\n                    (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n            case WuQuant._blue:\r\n                return (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +\r\n                    moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -\r\n                    moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]) -\r\n                    (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] +\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] -\r\n                        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\r\n            default:\r\n                // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?\r\n                return 0;\r\n        }\r\n    }\r\n    /**\r\n     * Calculates statistical variance for a given cube.\r\n     */\r\n    _calculateVariance(cube) {\r\n        const volumeRed = WuQuant._volume(cube, this._momentsRed);\r\n        const volumeGreen = WuQuant._volume(cube, this._momentsGreen);\r\n        const volumeBlue = WuQuant._volume(cube, this._momentsBlue);\r\n        const volumeAlpha = WuQuant._volume(cube, this._momentsAlpha);\r\n        const volumeMoment = WuQuant._volumeFloat(cube, this._moments);\r\n        const volumeWeight = WuQuant._volume(cube, this._weights);\r\n        const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;\r\n        return volumeMoment - (distance / volumeWeight);\r\n    }\r\n    /**\r\n     * Finds the optimal (maximal) position for the cut.\r\n     */\r\n    _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {\r\n        const bottomRed = WuQuant._bottom(cube, direction, this._momentsRed) | 0;\r\n        const bottomGreen = WuQuant._bottom(cube, direction, this._momentsGreen) | 0;\r\n        const bottomBlue = WuQuant._bottom(cube, direction, this._momentsBlue) | 0;\r\n        const bottomAlpha = WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;\r\n        const bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;\r\n        let result = 0.0;\r\n        let cutPosition = -1;\r\n        for (let position = first; position < last; ++position) {\r\n            // determines the cube cut at a certain position\r\n            let halfRed = bottomRed + WuQuant._top(cube, direction, position, this._momentsRed);\r\n            let halfGreen = bottomGreen + WuQuant._top(cube, direction, position, this._momentsGreen);\r\n            let halfBlue = bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue);\r\n            let halfAlpha = bottomAlpha + WuQuant._top(cube, direction, position, this._momentsAlpha);\r\n            let halfWeight = bottomWeight + WuQuant._top(cube, direction, position, this._weights);\r\n            // the cube cannot be cut at bottom (this would lead to empty cube)\r\n            if (halfWeight !== 0) {\r\n                let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\r\n                let temp = halfDistance / halfWeight;\r\n                halfRed = wholeRed - halfRed;\r\n                halfGreen = wholeGreen - halfGreen;\r\n                halfBlue = wholeBlue - halfBlue;\r\n                halfAlpha = wholeAlpha - halfAlpha;\r\n                halfWeight = wholeWeight - halfWeight;\r\n                if (halfWeight !== 0) {\r\n                    halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\r\n                    temp += halfDistance / halfWeight;\r\n                    if (temp > result) {\r\n                        result = temp;\r\n                        cutPosition = position;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return { max: result, position: cutPosition };\r\n    }\r\n    // Cuts a cube with another one.\r\n    _cut(first, second) {\r\n        let direction;\r\n        const wholeRed = WuQuant._volume(first, this._momentsRed);\r\n        const wholeGreen = WuQuant._volume(first, this._momentsGreen);\r\n        const wholeBlue = WuQuant._volume(first, this._momentsBlue);\r\n        const wholeAlpha = WuQuant._volume(first, this._momentsAlpha);\r\n        const wholeWeight = WuQuant._volume(first, this._weights);\r\n        const red = this._maximize(first, WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n        const green = this._maximize(first, WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n        const blue = this._maximize(first, WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n        const alpha = this._maximize(first, WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n        if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {\r\n            direction = WuQuant._alpha;\r\n            // cannot split empty cube\r\n            if (alpha.position < 0)\r\n                return false;\r\n        }\r\n        else {\r\n            if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {\r\n                direction = WuQuant._red;\r\n            }\r\n            else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {\r\n                direction = WuQuant._green;\r\n            }\r\n            else {\r\n                direction = WuQuant._blue;\r\n            }\r\n        }\r\n        second.redMaximum = first.redMaximum;\r\n        second.greenMaximum = first.greenMaximum;\r\n        second.blueMaximum = first.blueMaximum;\r\n        second.alphaMaximum = first.alphaMaximum;\r\n        // cuts in a certain direction\r\n        switch (direction) {\r\n            case WuQuant._red:\r\n                second.redMinimum = first.redMaximum = red.position;\r\n                second.greenMinimum = first.greenMinimum;\r\n                second.blueMinimum = first.blueMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n            case WuQuant._green:\r\n                second.greenMinimum = first.greenMaximum = green.position;\r\n                second.redMinimum = first.redMinimum;\r\n                second.blueMinimum = first.blueMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n            case WuQuant._blue:\r\n                second.blueMinimum = first.blueMaximum = blue.position;\r\n                second.redMinimum = first.redMinimum;\r\n                second.greenMinimum = first.greenMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n            case WuQuant._alpha:\r\n                second.alphaMinimum = first.alphaMaximum = alpha.position;\r\n                second.blueMinimum = first.blueMinimum;\r\n                second.redMinimum = first.redMinimum;\r\n                second.greenMinimum = first.greenMinimum;\r\n                break;\r\n        }\r\n        // determines the volumes after cut\r\n        first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);\r\n        second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);\r\n        // the cut was successful\r\n        return true;\r\n    }\r\n    _initialize(colors) {\r\n        this._colors = colors;\r\n        // creates all the _cubes\r\n        this._cubes = [];\r\n        // initializes all the _cubes\r\n        for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\r\n            this._cubes[cubeIndex] = new WuColorCube();\r\n        }\r\n        // resets the reference minimums\r\n        this._cubes[0].redMinimum = 0;\r\n        this._cubes[0].greenMinimum = 0;\r\n        this._cubes[0].blueMinimum = 0;\r\n        this._cubes[0].alphaMinimum = 0;\r\n        // resets the reference maximums\r\n        this._cubes[0].redMaximum = this._maxSideIndex;\r\n        this._cubes[0].greenMaximum = this._maxSideIndex;\r\n        this._cubes[0].blueMaximum = this._maxSideIndex;\r\n        this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\r\n        this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._table = [];\r\n        for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\r\n            this._table[tableIndex] = tableIndex * tableIndex;\r\n        }\r\n        this._pixels = [];\r\n    }\r\n    _setQuality(significantBitsPerChannel = 5) {\r\n        this._significantBitsPerChannel = significantBitsPerChannel;\r\n        this._maxSideIndex = 1 << this._significantBitsPerChannel;\r\n        this._alphaMaxSideIndex = this._maxSideIndex;\r\n        this._sideSize = this._maxSideIndex + 1;\r\n        this._alphaSideSize = this._alphaMaxSideIndex + 1;\r\n    }\r\n}\r\nWuQuant._alpha = 3;\r\nWuQuant._red = 2;\r\nWuQuant._green = 1;\r\nWuQuant._blue = 0;\r\n//# sourceMappingURL=wuQuant.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/quality/index.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/quality/index.js ***!\n  \\********************************************************/\n/*! exports provided: ssim */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ssim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssim */ \"./node_modules/image-q/dist/esm/quality/ssim.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ssim\", function() { return _ssim__WEBPACK_IMPORTED_MODULE_0__[\"ssim\"]; });\n\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/quality/ssim.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/quality/ssim.js ***!\n  \\*******************************************************/\n/*! exports provided: ssim */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ssim\", function() { return ssim; });\n/* harmony import */ var _constants_bt709__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/bt709 */ \"./node_modules/image-q/dist/esm/constants/bt709.js\");\n\r\n// based on https://github.com/rhys-e/structural-similarity\r\n// http://en.wikipedia.org/wiki/Structural_similarity\r\nconst K1 = 0.01; // tslint:disable-line:naming-convention\r\nconst K2 = 0.03; // tslint:disable-line:naming-convention\r\nfunction ssim(image1, image2) {\r\n    if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {\r\n        throw new Error('Images have different sizes!');\r\n    }\r\n    const bitsPerComponent = 8;\r\n    const L = (1 << bitsPerComponent) - 1; // tslint:disable-line:naming-convention\r\n    const c1 = Math.pow((K1 * L), 2);\r\n    const c2 = Math.pow((K2 * L), 2);\r\n    let numWindows = 0;\r\n    let mssim = 0.0;\r\n    // calculate ssim for each window\r\n    iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {\r\n        // calculate variance and covariance\r\n        let sigxy = 0.0;\r\n        let sigsqx = 0.0;\r\n        let sigsqy = 0.0;\r\n        for (let i = 0; i < lumaValues1.length; i++) {\r\n            sigsqx += Math.pow((lumaValues1[i] - averageLumaValue1), 2);\r\n            sigsqy += Math.pow((lumaValues2[i] - averageLumaValue2), 2);\r\n            sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);\r\n        }\r\n        const numPixelsInWin = lumaValues1.length - 1;\r\n        sigsqx /= numPixelsInWin;\r\n        sigsqy /= numPixelsInWin;\r\n        sigxy /= numPixelsInWin;\r\n        // perform ssim calculation on window\r\n        const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\r\n        const denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2);\r\n        const ssim = numerator / denominator;\r\n        mssim += ssim;\r\n        numWindows++;\r\n    });\r\n    return mssim / numWindows;\r\n}\r\nfunction iterate(image1, image2, callback) {\r\n    const windowSize = 8;\r\n    const width = image1.getWidth();\r\n    const height = image1.getHeight();\r\n    for (let y = 0; y < height; y += windowSize) {\r\n        for (let x = 0; x < width; x += windowSize) {\r\n            // avoid out-of-width/height\r\n            const windowWidth = Math.min(windowSize, width - x);\r\n            const windowHeight = Math.min(windowSize, height - y);\r\n            const lumaValues1 = calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight);\r\n            const lumaValues2 = calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight);\r\n            const averageLuma1 = calculateAverageLuma(lumaValues1);\r\n            const averageLuma2 = calculateAverageLuma(lumaValues2);\r\n            callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\r\n        }\r\n    }\r\n}\r\nfunction calculateLumaValuesForWindow(image, x, y, width, height) {\r\n    const pointArray = image.getPointArray();\r\n    const lumaValues = [];\r\n    let counter = 0;\r\n    for (let j = y; j < y + height; j++) {\r\n        const offset = j * image.getWidth();\r\n        for (let i = x; i < x + width; i++) {\r\n            const point = pointArray[offset + i];\r\n            lumaValues[counter] = point.r * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__[\"Y\"].RED + point.g * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__[\"Y\"].GREEN + point.b * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__[\"Y\"].BLUE;\r\n            counter++;\r\n        }\r\n    }\r\n    return lumaValues;\r\n}\r\nfunction calculateAverageLuma(lumaValues) {\r\n    let sumLuma = 0.0;\r\n    for (const luma of lumaValues) {\r\n        sumLuma += luma;\r\n    }\r\n    return sumLuma / lumaValues.length;\r\n}\r\n//# sourceMappingURL=ssim.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/utils/arithmetic.js ***!\n  \\***********************************************************/\n/*! exports provided: degrees2radians, max3, min3, intInRange, inRange0to255Rounded, inRange0to255, stableSort */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degrees2radians\", function() { return degrees2radians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max3\", function() { return max3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min3\", function() { return min3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intInRange\", function() { return intInRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inRange0to255Rounded\", function() { return inRange0to255Rounded; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inRange0to255\", function() { return inRange0to255; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stableSort\", function() { return stableSort; });\nfunction degrees2radians(n) {\r\n    return n * (Math.PI / 180);\r\n}\r\nfunction max3(a, b, c) {\r\n    let m = a;\r\n    if (m < b)\r\n        m = b;\r\n    if (m < c)\r\n        m = c;\r\n    return m;\r\n}\r\nfunction min3(a, b, c) {\r\n    let m = a;\r\n    if (m > b)\r\n        m = b;\r\n    if (m > c)\r\n        m = c;\r\n    return m;\r\n}\r\nfunction intInRange(value, low, high) {\r\n    if (value > high)\r\n        value = high;\r\n    if (value < low)\r\n        value = low;\r\n    return value | 0;\r\n}\r\nfunction inRange0to255Rounded(n) {\r\n    n = Math.round(n);\r\n    if (n > 255)\r\n        n = 255;\r\n    else if (n < 0)\r\n        n = 0;\r\n    return n;\r\n}\r\nfunction inRange0to255(n) {\r\n    if (n > 255)\r\n        n = 255;\r\n    else if (n < 0)\r\n        n = 0;\r\n    return n;\r\n}\r\nfunction stableSort(arrayToSort, callback) {\r\n    const type = typeof arrayToSort[0];\r\n    let sorted;\r\n    if (type === 'number' || type === 'string') {\r\n        const ord = Object.create(null); // tslint:disable-line:no-null-keyword\r\n        for (let i = 0, l = arrayToSort.length; i < l; i++) {\r\n            const val = arrayToSort[i]; // tslint:disable-line:no-any\r\n            if (ord[val] || ord[val] === 0)\r\n                continue;\r\n            ord[val] = i;\r\n        }\r\n        sorted = arrayToSort.sort(function (a, b) {\r\n            return callback(a, b) || ord[a] - ord[b];\r\n        });\r\n    }\r\n    else {\r\n        const ord2 = arrayToSort.slice(0);\r\n        sorted = arrayToSort.sort(function (a, b) {\r\n            return callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b);\r\n        });\r\n    }\r\n    return sorted;\r\n}\r\n//# sourceMappingURL=arithmetic.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/utils/hueStatistics.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/utils/hueStatistics.js ***!\n  \\**************************************************************/\n/*! exports provided: HueStatistics */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HueStatistics\", function() { return HueStatistics; });\n/* harmony import */ var _conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../conversion/rgb2hsl */ \"./node_modules/image-q/dist/esm/conversion/rgb2hsl.js\");\n/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./palette */ \"./node_modules/image-q/dist/esm/utils/palette.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * hueStatistics.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\nclass HueGroup {\r\n    constructor() {\r\n        this.num = 0;\r\n        this.cols = [];\r\n    }\r\n}\r\nclass HueStatistics {\r\n    constructor(numGroups, minCols) {\r\n        this._numGroups = numGroups;\r\n        this._minCols = minCols;\r\n        this._stats = [];\r\n        for (let i = 0; i <= numGroups; i++) {\r\n            this._stats[i] = new HueGroup();\r\n        }\r\n        this._groupsFull = 0;\r\n    }\r\n    check(i32) {\r\n        if (this._groupsFull === this._numGroups + 1) {\r\n            this.check = function () {\r\n            };\r\n        }\r\n        const r = (i32 & 0xff);\r\n        const g = (i32 >>> 8) & 0xff;\r\n        const b = (i32 >>> 16) & 0xff;\r\n        const hg = (r === g && g === b) ? 0 : 1 + Object(_palette__WEBPACK_IMPORTED_MODULE_1__[\"hueGroup\"])(Object(_conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_0__[\"rgb2hsl\"])(r, g, b).h, this._numGroups);\r\n        const gr = this._stats[hg];\r\n        const min = this._minCols;\r\n        gr.num++;\r\n        if (gr.num > min) {\r\n            return;\r\n        }\r\n        if (gr.num === min) {\r\n            this._groupsFull++;\r\n        }\r\n        if (gr.num <= min) {\r\n            this._stats[hg].cols.push(i32);\r\n        }\r\n    }\r\n    injectIntoDictionary(histG) {\r\n        for (let i = 0; i <= this._numGroups; i++) {\r\n            if (this._stats[i].num <= this._minCols) {\r\n                this._stats[i].cols.forEach((col) => {\r\n                    if (!histG[col]) {\r\n                        histG[col] = 1;\r\n                    }\r\n                    else {\r\n                        histG[col]++;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    injectIntoArray(histG) {\r\n        for (let i = 0; i <= this._numGroups; i++) {\r\n            if (this._stats[i].num <= this._minCols) {\r\n                this._stats[i].cols.forEach((col) => {\r\n                    if (histG.indexOf(col) === -1) {\r\n                        histG.push(col);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=hueStatistics.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/utils/index.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/utils/index.js ***!\n  \\******************************************************/\n/*! exports provided: Point, PointContainer, Palette, HueStatistics, ProgressTracker, arithmetic */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _arithmetic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arithmetic */ \"./node_modules/image-q/dist/esm/utils/arithmetic.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"arithmetic\", function() { return _arithmetic__WEBPACK_IMPORTED_MODULE_0__; });\n/* harmony import */ var _hueStatistics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hueStatistics */ \"./node_modules/image-q/dist/esm/utils/hueStatistics.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HueStatistics\", function() { return _hueStatistics__WEBPACK_IMPORTED_MODULE_1__[\"HueStatistics\"]; });\n\n/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./palette */ \"./node_modules/image-q/dist/esm/utils/palette.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Palette\", function() { return _palette__WEBPACK_IMPORTED_MODULE_2__[\"Palette\"]; });\n\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ \"./node_modules/image-q/dist/esm/utils/point.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return _point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]; });\n\n/* harmony import */ var _pointContainer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pointContainer */ \"./node_modules/image-q/dist/esm/utils/pointContainer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PointContainer\", function() { return _pointContainer__WEBPACK_IMPORTED_MODULE_4__[\"PointContainer\"]; });\n\n/* harmony import */ var _progressTracker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./progressTracker */ \"./node_modules/image-q/dist/esm/utils/progressTracker.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ProgressTracker\", function() { return _progressTracker__WEBPACK_IMPORTED_MODULE_5__[\"ProgressTracker\"]; });\n\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/utils/palette.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/utils/palette.js ***!\n  \\********************************************************/\n/*! exports provided: hueGroup, Palette */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hueGroup\", function() { return hueGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Palette\", function() { return Palette; });\n/* harmony import */ var _pointContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointContainer */ \"./node_modules/image-q/dist/esm/utils/pointContainer.js\");\n/* harmony import */ var _conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conversion/rgb2hsl */ \"./node_modules/image-q/dist/esm/conversion/rgb2hsl.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * palette.ts - part of Image Quantization Library\r\n */\r\n\r\n\r\n// TODO: make paletteArray via pointContainer, so, export will be available via pointContainer.exportXXX\r\nconst hueGroups = 10;\r\nfunction hueGroup(hue, segmentsNumber) {\r\n    const maxHue = 360;\r\n    const seg = maxHue / segmentsNumber;\r\n    const half = seg / 2;\r\n    for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\r\n        if (hue >= mid && hue < mid + seg)\r\n            return i;\r\n    }\r\n    return 0;\r\n}\r\nclass Palette {\r\n    constructor() {\r\n        this._pointArray = [];\r\n        this._i32idx = {};\r\n        this._pointContainer = new _pointContainer__WEBPACK_IMPORTED_MODULE_0__[\"PointContainer\"]();\r\n        this._pointContainer.setHeight(1);\r\n        this._pointArray = this._pointContainer.getPointArray();\r\n    }\r\n    add(color) {\r\n        this._pointArray.push(color);\r\n        this._pointContainer.setWidth(this._pointArray.length);\r\n    }\r\n    has(color) {\r\n        for (let i = this._pointArray.length - 1; i >= 0; i--) {\r\n            if (color.uint32 === this._pointArray[i].uint32)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\r\n    getNearestColor(colorDistanceCalculator, color) {\r\n        return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];\r\n    }\r\n    getPointContainer() {\r\n        return this._pointContainer;\r\n    }\r\n    // TOTRY: use HUSL - http://boronine.com/husl/\r\n    /*\r\n     public nearestIndexByUint32(i32) {\r\n     var idx : number = this._nearestPointFromCache(\"\" + i32);\r\n     if (idx >= 0) return idx;\r\n  \r\n     var min = 1000,\r\n     rgb = [\r\n     (i32 & 0xff),\r\n     (i32 >>> 8) & 0xff,\r\n     (i32 >>> 16) & 0xff,\r\n     (i32 >>> 24) & 0xff\r\n     ],\r\n     len = this._pointArray.length;\r\n  \r\n     idx = 0;\r\n     for (var i = 0; i < len; i++) {\r\n     var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\r\n  \r\n     if (dist < min) {\r\n     min = dist;\r\n     idx = i;\r\n     }\r\n     }\r\n  \r\n     this._i32idx[i32] = idx;\r\n     return idx;\r\n     }\r\n     */\r\n    _nearestPointFromCache(key) {\r\n        return typeof this._i32idx[key] === 'number' ? this._i32idx[key] : -1;\r\n    }\r\n    _getNearestIndex(colorDistanceCalculator, point) {\r\n        let idx = this._nearestPointFromCache('' + point.uint32);\r\n        if (idx >= 0)\r\n            return idx;\r\n        let minimalDistance = Number.MAX_VALUE;\r\n        idx = 0;\r\n        for (let i = 0, l = this._pointArray.length; i < l; i++) {\r\n            const p = this._pointArray[i];\r\n            const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);\r\n            if (distance < minimalDistance) {\r\n                minimalDistance = distance;\r\n                idx = i;\r\n            }\r\n        }\r\n        this._i32idx[point.uint32] = idx;\r\n        return idx;\r\n    }\r\n    /*\r\n     public reduce(histogram : ColorHistogram, colors : number) {\r\n     if (this._pointArray.length > colors) {\r\n     var idxi32 = histogram.getImportanceSortedColorsIDXI32();\r\n  \r\n     // quantize histogram to existing palette\r\n     var keep = [], uniqueColors = 0, idx, pruned = false;\r\n  \r\n     for (var i = 0, len = idxi32.length; i < len; i++) {\r\n     // palette length reached, unset all remaining colors (sparse palette)\r\n     if (uniqueColors >= colors) {\r\n     this.prunePal(keep);\r\n     pruned = true;\r\n     break;\r\n     } else {\r\n     idx = this.nearestIndexByUint32(idxi32[i]);\r\n     if (keep.indexOf(idx) < 0) {\r\n     keep.push(idx);\r\n     uniqueColors++;\r\n     }\r\n     }\r\n     }\r\n  \r\n     if (!pruned) {\r\n     this.prunePal(keep);\r\n     }\r\n     }\r\n     }\r\n  \r\n     // TODO: check usage, not tested!\r\n     public prunePal(keep : number[]) {\r\n     var colors = this._pointArray.length;\r\n     for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n     if (keep.indexOf(colorIndex) < 0) {\r\n  \r\n     if(colorIndex + 1 < colors) {\r\n     this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\r\n     }\r\n     --colors;\r\n     //this._pointArray[colorIndex] = null;\r\n     }\r\n     }\r\n     console.log(\"colors pruned: \" + (this._pointArray.length - colors));\r\n     this._pointArray.length = colors;\r\n     this._i32idx = {};\r\n     }\r\n     */\r\n    // TODO: group very low lum and very high lum colors\r\n    // TODO: pass custom sort order\r\n    // TODO: sort criteria function should be placed to HueStats class\r\n    sort() {\r\n        this._i32idx = {};\r\n        this._pointArray.sort((a, b) => {\r\n            const hslA = Object(_conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_1__[\"rgb2hsl\"])(a.r, a.g, a.b);\r\n            const hslB = Object(_conversion_rgb2hsl__WEBPACK_IMPORTED_MODULE_1__[\"rgb2hsl\"])(b.r, b.g, b.b);\r\n            // sort all grays + whites together\r\n            const hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + hueGroup(hslA.h, hueGroups);\r\n            const hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + hueGroup(hslB.h, hueGroups);\r\n            /*\r\n             var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\r\n             var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\r\n             */\r\n            const hueDiff = hueB - hueA;\r\n            if (hueDiff)\r\n                return -hueDiff;\r\n            /*\r\n             var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\r\n             if (lumDiff) return -lumDiff;\r\n             */\r\n            const lA = a.getLuminosity(true);\r\n            const lB = b.getLuminosity(true);\r\n            if (lB - lA !== 0)\r\n                return lB - lA;\r\n            const satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);\r\n            if (satDiff)\r\n                return -satDiff;\r\n            return 0;\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=palette.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/utils/point.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/utils/point.js ***!\n  \\******************************************************/\n/*! exports provided: Point */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n/* harmony import */ var _constants_bt709__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/bt709 */ \"./node_modules/image-q/dist/esm/constants/bt709.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * point.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * v8 optimized class\r\n * 1) \"constructor\" should have initialization with worst types\r\n * 2) \"set\" should have |0 / >>> 0\r\n */\r\nclass Point {\r\n    // Lab : { L : number; a : number; b : number };\r\n    static createByQuadruplet(quadruplet) {\r\n        const point = new Point();\r\n        point.r = quadruplet[0] | 0;\r\n        point.g = quadruplet[1] | 0;\r\n        point.b = quadruplet[2] | 0;\r\n        point.a = quadruplet[3] | 0;\r\n        point._loadUINT32();\r\n        point._loadQuadruplet();\r\n        // point._loadLab();\r\n        return point;\r\n    }\r\n    static createByRGBA(red, green, blue, alpha) {\r\n        const point = new Point();\r\n        point.r = red | 0;\r\n        point.g = green | 0;\r\n        point.b = blue | 0;\r\n        point.a = alpha | 0;\r\n        point._loadUINT32();\r\n        point._loadQuadruplet();\r\n        // point._loadLab();\r\n        return point;\r\n    }\r\n    static createByUint32(uint32) {\r\n        const point = new Point();\r\n        point.uint32 = uint32 >>> 0;\r\n        point._loadRGBA();\r\n        point._loadQuadruplet();\r\n        // point._loadLab();\r\n        return point;\r\n    }\r\n    constructor() {\r\n        this.uint32 = -1 >>> 0;\r\n        this.r = this.g = this.b = this.a = 0;\r\n        this.rgba = new Array(4);\r\n        this.rgba[0] = 0;\r\n        this.rgba[1] = 0;\r\n        this.rgba[2] = 0;\r\n        this.rgba[3] = 0;\r\n        /*\r\n         this.Lab = {\r\n         L : 0.0,\r\n         a : 0.0,\r\n         b : 0.0\r\n         };\r\n         */\r\n    }\r\n    from(point) {\r\n        this.r = point.r;\r\n        this.g = point.g;\r\n        this.b = point.b;\r\n        this.a = point.a;\r\n        this.uint32 = point.uint32;\r\n        this.rgba[0] = point.r;\r\n        this.rgba[1] = point.g;\r\n        this.rgba[2] = point.b;\r\n        this.rgba[3] = point.a;\r\n        /*\r\n         this.Lab.L = point.Lab.L;\r\n         this.Lab.a = point.Lab.a;\r\n         this.Lab.b = point.Lab.b;\r\n         */\r\n    }\r\n    /*\r\n     * TODO:\r\n     Luminance from RGB:\r\n  \r\n     Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]\r\n     Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]\r\n     Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]\r\n     */\r\n    getLuminosity(useAlphaChannel) {\r\n        let r = this.r;\r\n        let g = this.g;\r\n        let b = this.b;\r\n        if (useAlphaChannel) {\r\n            r = Math.min(255, 255 - this.a + this.a * r / 255);\r\n            g = Math.min(255, 255 - this.a + this.a * g / 255);\r\n            b = Math.min(255, 255 - this.a + this.a * b / 255);\r\n        }\r\n        // var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;\r\n        /*\r\n         if(useAlphaChannel) {\r\n         luma = (luma * (255 - this.a)) / 255;\r\n         }\r\n         */\r\n        return r * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__[\"Y\"].RED + g * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__[\"Y\"].GREEN + b * _constants_bt709__WEBPACK_IMPORTED_MODULE_0__[\"Y\"].BLUE;\r\n    }\r\n    _loadUINT32() {\r\n        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;\r\n    }\r\n    _loadRGBA() {\r\n        this.r = this.uint32 & 0xff;\r\n        this.g = (this.uint32 >>> 8) & 0xff;\r\n        this.b = (this.uint32 >>> 16) & 0xff;\r\n        this.a = (this.uint32 >>> 24) & 0xff;\r\n    }\r\n    _loadQuadruplet() {\r\n        this.rgba[0] = this.r;\r\n        this.rgba[1] = this.g;\r\n        this.rgba[2] = this.b;\r\n        this.rgba[3] = this.a;\r\n        /*\r\n         var xyz = rgb2xyz(this.r, this.g, this.b);\r\n         var lab = xyz2lab(xyz.x, xyz.y, xyz.z);\r\n         this.lab.l = lab.l;\r\n         this.lab.a = lab.a;\r\n         this.lab.b = lab.b;\r\n         */\r\n    }\r\n}\r\n//# sourceMappingURL=point.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/utils/pointContainer.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/utils/pointContainer.js ***!\n  \\***************************************************************/\n/*! exports provided: PointContainer */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointContainer\", function() { return PointContainer; });\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ \"./node_modules/image-q/dist/esm/utils/point.js\");\n/**\r\n * @preserve\r\n * Copyright 2015-2018 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * pointContainer.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * v8 optimizations done.\r\n * fromXXX methods are static to move out polymorphic code from class instance itself.\r\n */\r\nclass PointContainer {\r\n    constructor() {\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this._pointArray = [];\r\n    }\r\n    getWidth() {\r\n        return this._width;\r\n    }\r\n    getHeight() {\r\n        return this._height;\r\n    }\r\n    setWidth(width) {\r\n        this._width = width;\r\n    }\r\n    setHeight(height) {\r\n        this._height = height;\r\n    }\r\n    getPointArray() {\r\n        return this._pointArray;\r\n    }\r\n    clone() {\r\n        const clone = new PointContainer();\r\n        clone._width = this._width;\r\n        clone._height = this._height;\r\n        for (let i = 0, l = this._pointArray.length; i < l; i++) {\r\n            clone._pointArray[i] = _point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"].createByUint32(this._pointArray[i].uint32 | 0); // \"| 0\" is added for v8 optimization\r\n        }\r\n        return clone;\r\n    }\r\n    toUint32Array() {\r\n        const l = this._pointArray.length;\r\n        const uint32Array = new Uint32Array(l);\r\n        for (let i = 0; i < l; i++) {\r\n            uint32Array[i] = this._pointArray[i].uint32;\r\n        }\r\n        return uint32Array;\r\n    }\r\n    toUint8Array() {\r\n        return new Uint8Array(this.toUint32Array().buffer);\r\n    }\r\n    static fromHTMLImageElement(img) {\r\n        const width = img.naturalWidth;\r\n        const height = img.naturalHeight;\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        const ctx = canvas.getContext('2d'); // tslint:disable-line:no-non-null-assertion\r\n        ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\r\n        return PointContainer.fromHTMLCanvasElement(canvas);\r\n    }\r\n    static fromHTMLCanvasElement(canvas) {\r\n        const width = canvas.width;\r\n        const height = canvas.height;\r\n        const ctx = canvas.getContext('2d'); // tslint:disable-line:no-non-null-assertion\r\n        const imgData = ctx.getImageData(0, 0, width, height);\r\n        return PointContainer.fromImageData(imgData);\r\n    }\r\n    static fromImageData(imageData) {\r\n        const width = imageData.width;\r\n        const height = imageData.height;\r\n        return PointContainer.fromUint8Array(imageData.data, width, height);\r\n    }\r\n    static fromUint8Array(uint8Array, width, height) {\r\n        switch (Object.prototype.toString.call(uint8Array)) {\r\n            case '[object Uint8ClampedArray]':\r\n            case '[object Uint8Array]':\r\n                break;\r\n            default:\r\n                uint8Array = new Uint8Array(uint8Array);\r\n        }\r\n        const uint32Array = new Uint32Array(uint8Array.buffer);\r\n        return PointContainer.fromUint32Array(uint32Array, width, height);\r\n    }\r\n    static fromUint32Array(uint32Array, width, height) {\r\n        const container = new PointContainer();\r\n        container._width = width;\r\n        container._height = height;\r\n        for (let i = 0, l = uint32Array.length; i < l; i++) {\r\n            container._pointArray[i] = _point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"].createByUint32(uint32Array[i] | 0); // \"| 0\" is added for v8 optimization\r\n        }\r\n        return container;\r\n    }\r\n    static fromBuffer(buffer, width, height) {\r\n        const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);\r\n        return PointContainer.fromUint32Array(uint32Array, width, height);\r\n    }\r\n}\r\n//# sourceMappingURL=pointContainer.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/image-q/dist/esm/utils/progressTracker.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/image-q/dist/esm/utils/progressTracker.js ***!\n  \\****************************************************************/\n/*! exports provided: ProgressTracker */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProgressTracker\", function() { return ProgressTracker; });\nclass ProgressTracker {\r\n    constructor(valueRange, progressRange) {\r\n        this._range = valueRange;\r\n        this._progressRange = progressRange;\r\n        this._step = Math.max(1, this._range / (ProgressTracker.steps + 1) | 0);\r\n        this._last = -this._step;\r\n        this.progress = 0;\r\n    }\r\n    shouldNotify(current) {\r\n        if (current - this._last >= this._step) {\r\n            this._last = current;\r\n            this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nProgressTracker.steps = 100;\r\n//# sourceMappingURL=progressTracker.js.map\n\n/***/ }),\n\n/***/ \"./src/Animated_GIF.worker.js\":\n/*!************************************!*\\\n  !*** ./src/Animated_GIF.worker.js ***!\n  \\************************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var image_q__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! image-q */ \"./node_modules/image-q/dist/esm/image-q.js\");\n\n\n/**\n * Searches for an unused colour in the image data so it can be used as a unique colour\n * for transparent pixels. Builds up a set of all known colours then searches from\n * 0x000000 to 0xFFFFFF for a colour not in the set. They're is probably a much more effecient\n * way of doing this. There is also a possibilty all colours are used, but that's probably\n * just a test image.\n * @param {*} data\n * @param {*} width\n * @param {*} height\n */\nfunction searchForUnusedColour(data, width, height) {\n  let i = 0\n  const length = width * height * 4\n  const knownColours = new Set()\n\n  while (i < length) {\n    const r = data[i++]\n    const g = data[i++]\n    const b = data[i++]\n    i++ // don't track the transparency here just the rgb values\n    const pixelColour = (r << 16) | (g << 8) | b\n    knownColours.add(pixelColour)\n  }\n\n  let unusedColour = 0x00\n  while (unusedColour < 0xffffff) {\n    if (!knownColours.has(unusedColour)) break\n    unusedColour++\n  }\n\n  return unusedColour\n}\n\nfunction dataToRGBANormalized(\n  data,\n  width,\n  height,\n  unusedColour,\n  transparencyCutOff = 0.7\n) {\n  let i = 0\n  const length = width * height * 4\n  const rgba = []\n  const transparencyCutOffValue = Math.trunc(255 * transparencyCutOff)\n  let hasTransparency = false\n\n  const unusedColourR = (unusedColour & 0xff0000) >> 16\n  const unusedColourG = (unusedColour & 0x00ff00) >> 8\n  const unusedColourB = unusedColour & 0x0000ff\n\n  while (i < length) {\n    const r = data[i++]\n    const g = data[i++]\n    const b = data[i++]\n    let a = data[i++]\n    a = a >= transparencyCutOffValue ? 0xff : 0x00\n\n    if (unusedColour !== undefined && a === 0) {\n      rgba.push(unusedColourR)\n      rgba.push(unusedColourG)\n      rgba.push(unusedColourB)\n      rgba.push(0x00)\n      hasTransparency = true\n    } else {\n      rgba.push(r)\n      rgba.push(g)\n      rgba.push(b)\n      rgba.push(0xff)\n    }\n  }\n\n  return { rgba, hasTransparency }\n}\n\n/**\n * Takes an array of points from image-q and converts them to an array of sorted rgb values\n * @param {Array[Points]} points\n * returns {Array}\n */\nfunction pointsToRgb(points) {\n  return points.map(point => (point.r << 16) | (point.g << 8) | point.b)\n}\n\n/**\n * @param {Uint32Array} pixels\n * @param {Uint32Array} palette\n * @returns {Uint8Array}\n */\nfunction indexPixelsWithPalette(pixels, palette) {\n  return Uint8Array.from(pixels.map(pixel => palette.indexOf(pixel)))\n}\n\nfunction processFrameWithQuantizer(\n  imageData,\n  width,\n  height,\n  transparencyCutOff,\n  dithering\n) {\n  const unusedColour = searchForUnusedColour(imageData, width, height)\n  const { rgba, hasTransparency } = dataToRGBANormalized(\n    imageData,\n    width,\n    height,\n    unusedColour,\n    transparencyCutOff\n  )\n\n  const pointContainer = image_q__WEBPACK_IMPORTED_MODULE_0__[\"utils\"].PointContainer.fromUint8Array(\n    new Uint8Array(rgba),\n    width,\n    height\n  )\n  const palette = Object(image_q__WEBPACK_IMPORTED_MODULE_0__[\"buildPaletteSync\"])([pointContainer], {\n    paletteQuantization: 'rgbquant',\n    colors: hasTransparency && unusedColour ? 255 : 256, // leave one for transparency\n  })\n  if (hasTransparency && unusedColour) {\n    palette.add(image_q__WEBPACK_IMPORTED_MODULE_0__[\"utils\"].Point.createByUint32(unusedColour))\n  }\n  const outPointContainer = Object(image_q__WEBPACK_IMPORTED_MODULE_0__[\"applyPaletteSync\"])(pointContainer, palette, {\n    imageQuantization: dithering,\n  })\n  const paletteRgbArray = pointsToRgb(\n    palette.getPointContainer().getPointArray()\n  )\n  paletteRgbArray.sort((a, b) => a - b)\n  const transparencyIndex = paletteRgbArray.indexOf(unusedColour)\n\n  const indexedPixels = indexPixelsWithPalette(\n    pointsToRgb(outPointContainer.getPointArray()),\n    paletteRgbArray\n  )\n\n  return {\n    pixels: indexedPixels,\n    palette: Array.from(paletteRgbArray),\n    transparencyIndex: transparencyIndex > -1 ? transparencyIndex : undefined,\n  }\n}\n\n// ~~~\n\nfunction run(frame) {\n  const { width, height, data, dithering, transparencyCutOff } = frame\n\n  return processFrameWithQuantizer(\n    data,\n    width,\n    height,\n    transparencyCutOff,\n    dithering\n  )\n}\n\nself.onmessage = function(ev) {\n  var data = ev.data\n  var response = run(data)\n  postMessage(response)\n}\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vc2V0LWltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Jhc2ljQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9idDcwOS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb25zdGFudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL2xhYjJyZ2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9sYWIyeHl6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMmhzbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3JnYjJsYWIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9yZ2IyeHl6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24veHl6MmxhYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3h5ejJyZ2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvY2llOTQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvY2llZGUyMDAwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2NtZXRyaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvZGlzdGFuY2VDYWxjdWxhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2V1Y2xpZGVhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9tYW5oYXR0YW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvcG5nUXVhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UtcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbWFnZVF1YW50aXplci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9uZWFyZXN0Q29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvcmllbWVyc21hLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2ltYWdlL3NwYWNlRmlsbGluZ0N1cnZlcy9oaWxiZXJ0Q3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL25ldXF1YW50L25ldXF1YW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvbmV1cXVhbnQvbmV1cXVhbnRGbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3BhbGV0dGVRdWFudGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9yZ2JxdWFudC9jb2xvckhpc3RvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3JnYnF1YW50L3JnYnF1YW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvd3Uvd3VRdWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9xdWFsaXR5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3F1YWxpdHkvc3NpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9hcml0aG1ldGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2h1ZVN0YXRpc3RpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcGFsZXR0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wb2ludENvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wcm9ncmVzc1RyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FuaW1hdGVkX0dJRi53b3JrZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxp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QzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFB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QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsNkNBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQkFBZ0IsNkNBQUs7QUFDckI7QUFDQSw0QkFBNEIsZ0VBQWdCO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUyxxREFBcUQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMjQ3ZGRiNjc4NTA4ZjgxNDI4MC53b3JrZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9BbmltYXRlZF9HSUYud29ya2VyLmpzXCIpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5zZXRJbW1lZGlhdGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjInIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcbiIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogaGVscGVyLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0ICogYXMgc2V0SW1tZWRpYXRlIGZyb20gJ2NvcmUtanMvZm4vc2V0LWltbWVkaWF0ZSc7XHJcbmltcG9ydCAqIGFzIGRpc3RhbmNlIGZyb20gJy4vZGlzdGFuY2UnO1xyXG5pbXBvcnQgKiBhcyBpbWFnZSBmcm9tICcuL2ltYWdlJztcclxuaW1wb3J0ICogYXMgcGFsZXR0ZSBmcm9tICcuL3BhbGV0dGUnO1xyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQYWxldHRlU3luYyhpbWFnZXMsIHsgY29sb3JEaXN0YW5jZUZvcm11bGEsIHBhbGV0dGVRdWFudGl6YXRpb24sIGNvbG9ycyB9ID0ge30pIHtcclxuICAgIGNvbnN0IGRpc3RhbmNlQ2FsY3VsYXRvciA9IGNvbG9yRGlzdGFuY2VGb3JtdWxhVG9Db2xvckRpc3RhbmNlKGNvbG9yRGlzdGFuY2VGb3JtdWxhKTtcclxuICAgIGNvbnN0IHBhbGV0dGVRdWFudGl6ZXIgPSBwYWxldHRlUXVhbnRpemF0aW9uVG9QYWxldHRlUXVhbnRpemVyKGRpc3RhbmNlQ2FsY3VsYXRvciwgcGFsZXR0ZVF1YW50aXphdGlvbiwgY29sb3JzKTtcclxuICAgIGltYWdlcy5mb3JFYWNoKGltYWdlID0+IHBhbGV0dGVRdWFudGl6ZXIuc2FtcGxlKGltYWdlKSk7XHJcbiAgICByZXR1cm4gcGFsZXR0ZVF1YW50aXplci5xdWFudGl6ZVN5bmMoKTtcclxufVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRQYWxldHRlKGltYWdlcywgeyBjb2xvckRpc3RhbmNlRm9ybXVsYSwgcGFsZXR0ZVF1YW50aXphdGlvbiwgY29sb3JzLCBvblByb2dyZXNzIH0gPSB7fSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZUNhbGN1bGF0b3IgPSBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSk7XHJcbiAgICAgICAgY29uc3QgcGFsZXR0ZVF1YW50aXplciA9IHBhbGV0dGVRdWFudGl6YXRpb25Ub1BhbGV0dGVRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBwYWxldHRlUXVhbnRpemF0aW9uLCBjb2xvcnMpO1xyXG4gICAgICAgIGltYWdlcy5mb3JFYWNoKGltYWdlID0+IHBhbGV0dGVRdWFudGl6ZXIuc2FtcGxlKGltYWdlKSk7XHJcbiAgICAgICAgbGV0IHBhbGV0dGU7XHJcbiAgICAgICAgbGV0IHRpbWVySWQ7XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBwYWxldHRlUXVhbnRpemVyLnF1YW50aXplKCk7XHJcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocGFsZXR0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlLnBhbGV0dGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbGV0dGUgPSByZXN1bHQudmFsdWUucGFsZXR0ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25Qcm9ncmVzcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhyZXN1bHQudmFsdWUucHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVySWQgPSBzZXRJbW1lZGlhdGUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aW1lcklkID0gc2V0SW1tZWRpYXRlKG5leHQpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGFsZXR0ZVN5bmMoaW1hZ2UsIHBhbGV0dGUsIHsgY29sb3JEaXN0YW5jZUZvcm11bGEsIGltYWdlUXVhbnRpemF0aW9uIH0gPSB7fSkge1xyXG4gICAgY29uc3QgZGlzdGFuY2VDYWxjdWxhdG9yID0gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEpO1xyXG4gICAgY29uc3QgaW1hZ2VRdWFudGl6ZXIgPSBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbik7XHJcbiAgICByZXR1cm4gaW1hZ2VRdWFudGl6ZXIucXVhbnRpemVTeW5jKGltYWdlLCBwYWxldHRlKTtcclxufVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlQYWxldHRlKGltYWdlLCBwYWxldHRlLCB7IGNvbG9yRGlzdGFuY2VGb3JtdWxhLCBpbWFnZVF1YW50aXphdGlvbiwgb25Qcm9ncmVzcyB9ID0ge30pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2VDYWxjdWxhdG9yID0gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEpO1xyXG4gICAgICAgIGNvbnN0IGltYWdlUXVhbnRpemVyID0gaW1hZ2VRdWFudGl6YXRpb25Ub0ltYWdlUXVhbnRpemVyKGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2VRdWFudGl6YXRpb24pO1xyXG4gICAgICAgIGxldCBvdXRQb2ludENvbnRhaW5lcjtcclxuICAgICAgICBsZXQgdGltZXJJZDtcclxuICAgICAgICBjb25zdCBpdGVyYXRvciA9IGltYWdlUXVhbnRpemVyLnF1YW50aXplKGltYWdlLCBwYWxldHRlKTtcclxuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRQb2ludENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlLnBvaW50Q29udGFpbmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQb2ludENvbnRhaW5lciA9IHJlc3VsdC52YWx1ZS5wb2ludENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25Qcm9ncmVzcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhyZXN1bHQudmFsdWUucHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVySWQgPSBzZXRJbW1lZGlhdGUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aW1lcklkID0gc2V0SW1tZWRpYXRlKG5leHQpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEgPSAnZXVjbGlkZWFuLWJ0NzA5Jykge1xyXG4gICAgc3dpdGNoIChjb2xvckRpc3RhbmNlRm9ybXVsYSkge1xyXG4gICAgICAgIGNhc2UgJ2NpZTk0LWdyYXBoaWMtYXJ0cyc6IHJldHVybiBuZXcgZGlzdGFuY2UuQ0lFOTRHcmFwaGljQXJ0cygpO1xyXG4gICAgICAgIGNhc2UgJ2NpZTk0LXRleHRpbGVzJzogcmV0dXJuIG5ldyBkaXN0YW5jZS5DSUU5NFRleHRpbGVzKCk7XHJcbiAgICAgICAgY2FzZSAnY2llZGUyMDAwJzogcmV0dXJuIG5ldyBkaXN0YW5jZS5DSUVERTIwMDAoKTtcclxuICAgICAgICBjYXNlICdjb2xvci1tZXRyaWMnOiByZXR1cm4gbmV3IGRpc3RhbmNlLkNNZXRyaWMoKTtcclxuICAgICAgICBjYXNlICdldWNsaWRlYW4nOiByZXR1cm4gbmV3IGRpc3RhbmNlLkV1Y2xpZGVhbigpO1xyXG4gICAgICAgIGNhc2UgJ2V1Y2xpZGVhbi1idDcwOSc6IHJldHVybiBuZXcgZGlzdGFuY2UuRXVjbGlkZWFuQlQ3MDkoKTtcclxuICAgICAgICBjYXNlICdldWNsaWRlYW4tYnQ3MDktbm9hbHBoYSc6IHJldHVybiBuZXcgZGlzdGFuY2UuRXVjbGlkZWFuQlQ3MDlOb0FscGhhKCk7XHJcbiAgICAgICAgY2FzZSAnbWFuaGF0dGFuJzogcmV0dXJuIG5ldyBkaXN0YW5jZS5NYW5oYXR0YW4oKTtcclxuICAgICAgICBjYXNlICdtYW5oYXR0YW4tYnQ3MDknOiByZXR1cm4gbmV3IGRpc3RhbmNlLk1hbmhhdHRhbkJUNzA5KCk7XHJcbiAgICAgICAgY2FzZSAnbWFuaGF0dGFuLW5vbW15ZGUnOiByZXR1cm4gbmV3IGRpc3RhbmNlLk1hbmhhdHRhbk5vbW15ZGUoKTtcclxuICAgICAgICBjYXNlICdwbmdxdWFudCc6IHJldHVybiBuZXcgZGlzdGFuY2UuUE5HUXVhbnQoKTtcclxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29sb3JEaXN0YW5jZUZvcm11bGEgJHtjb2xvckRpc3RhbmNlRm9ybXVsYX1gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbiA9ICdmbG95ZC1zdGVpbmJlcmcnKSB7XHJcbiAgICBzd2l0Y2ggKGltYWdlUXVhbnRpemF0aW9uKSB7XHJcbiAgICAgICAgY2FzZSAnbmVhcmVzdCc6IHJldHVybiBuZXcgaW1hZ2UuTmVhcmVzdENvbG9yKGRpc3RhbmNlQ2FsY3VsYXRvcik7XHJcbiAgICAgICAgY2FzZSAncmllbWVyc21hJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvblJpZW1lcnNtYShkaXN0YW5jZUNhbGN1bGF0b3IpO1xyXG4gICAgICAgIGNhc2UgJ2Zsb3lkLXN0ZWluYmVyZyc6IHJldHVybiBuZXcgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuRmxveWRTdGVpbmJlcmcpO1xyXG4gICAgICAgIGNhc2UgJ2ZhbHNlLWZsb3lkLXN0ZWluYmVyZyc6IHJldHVybiBuZXcgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuRmFsc2VGbG95ZFN0ZWluYmVyZyk7XHJcbiAgICAgICAgY2FzZSAnc3R1Y2tpJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5TdHVja2kpO1xyXG4gICAgICAgIGNhc2UgJ2F0a2luc29uJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5BdGtpbnNvbik7XHJcbiAgICAgICAgY2FzZSAnamFydmlzJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5KYXJ2aXMpO1xyXG4gICAgICAgIGNhc2UgJ2J1cmtlcyc6IHJldHVybiBuZXcgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuQnVya2VzKTtcclxuICAgICAgICBjYXNlICdzaWVycmEnOiByZXR1cm4gbmV3IGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlNpZXJyYSk7XHJcbiAgICAgICAgY2FzZSAndHdvLXNpZXJyYSc6IHJldHVybiBuZXcgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuVHdvU2llcnJhKTtcclxuICAgICAgICBjYXNlICdzaWVycmEtbGl0ZSc6IHJldHVybiBuZXcgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuU2llcnJhTGl0ZSk7XHJcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGltYWdlUXVhbnRpemF0aW9uICR7aW1hZ2VRdWFudGl6YXRpb259YCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFsZXR0ZVF1YW50aXphdGlvblRvUGFsZXR0ZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIHBhbGV0dGVRdWFudGl6YXRpb24gPSAnd3VxdWFudCcsIGNvbG9ycyA9IDI1Nikge1xyXG4gICAgc3dpdGNoIChwYWxldHRlUXVhbnRpemF0aW9uKSB7XHJcbiAgICAgICAgY2FzZSAnbmV1cXVhbnQnOiByZXR1cm4gbmV3IHBhbGV0dGUuTmV1UXVhbnQoZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xyXG4gICAgICAgIGNhc2UgJ3JnYnF1YW50JzogcmV0dXJuIG5ldyBwYWxldHRlLlJHQlF1YW50KGRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzKTtcclxuICAgICAgICBjYXNlICd3dXF1YW50JzogcmV0dXJuIG5ldyBwYWxldHRlLld1UXVhbnQoZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xyXG4gICAgICAgIGNhc2UgJ25ldXF1YW50LWZsb2F0JzogcmV0dXJuIG5ldyBwYWxldHRlLk5ldVF1YW50RmxvYXQoZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xyXG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYWxldHRlUXVhbnRpemF0aW9uICR7cGFsZXR0ZVF1YW50aXphdGlvbn1gKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNpY0FQSS5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGNvbnN0YW50cy50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbi8qKlxyXG4gKiBzUkdCIChiYXNlZCBvbiBJVFUtUiBSZWNvbW1lbmRhdGlvbiBCVC43MDkpXHJcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU1JHQlxyXG4gKi9cclxuZXhwb3J0IHZhciBZO1xyXG4oZnVuY3Rpb24gKFkpIHtcclxuICAgIFlbWVtcIlJFRFwiXSA9IDAuMjEyNl0gPSBcIlJFRFwiO1xyXG4gICAgWVtZW1wiR1JFRU5cIl0gPSAwLjcxNTJdID0gXCJHUkVFTlwiO1xyXG4gICAgWVtZW1wiQkxVRVwiXSA9IDAuMDcyMl0gPSBcIkJMVUVcIjtcclxuICAgIFlbWVtcIldISVRFXCJdID0gMV0gPSBcIldISVRFXCI7XHJcbn0pKFkgfHwgKFkgPSB7fSkpO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IHZhciB4O1xyXG4oZnVuY3Rpb24gKHgpIHtcclxuICAgIHhbeFtcIlJFRFwiXSA9IDAuNjRdID0gXCJSRURcIjtcclxuICAgIHhbeFtcIkdSRUVOXCJdID0gMC4zXSA9IFwiR1JFRU5cIjtcclxuICAgIHhbeFtcIkJMVUVcIl0gPSAwLjE1XSA9IFwiQkxVRVwiO1xyXG4gICAgeFt4W1wiV0hJVEVcIl0gPSAwLjMxMjddID0gXCJXSElURVwiO1xyXG59KSh4IHx8ICh4ID0ge30pKTtcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCB2YXIgeTtcclxuKGZ1bmN0aW9uICh5KSB7XHJcbiAgICB5W3lbXCJSRURcIl0gPSAwLjMzXSA9IFwiUkVEXCI7XHJcbiAgICB5W3lbXCJHUkVFTlwiXSA9IDAuNl0gPSBcIkdSRUVOXCI7XHJcbiAgICB5W3lbXCJCTFVFXCJdID0gMC4wNl0gPSBcIkJMVUVcIjtcclxuICAgIHlbeVtcIldISVRFXCJdID0gMC4zMjldID0gXCJXSElURVwiO1xyXG59KSh5IHx8ICh5ID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnQ3MDkuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBjb25zdGFudHMudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgKiBhcyBidDcwOSBmcm9tICcuL2J0NzA5JztcclxuZXhwb3J0IHsgYnQ3MDksIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuZXhwb3J0IHsgcmdiMnh5eiB9IGZyb20gJy4vcmdiMnh5eic7XHJcbmV4cG9ydCB7IHJnYjJoc2wgfSBmcm9tICcuL3JnYjJoc2wnO1xyXG5leHBvcnQgeyByZ2IybGFiIH0gZnJvbSAnLi9yZ2IybGFiJztcclxuZXhwb3J0IHsgbGFiMnh5eiB9IGZyb20gJy4vbGFiMnh5eic7XHJcbmV4cG9ydCB7IGxhYjJyZ2IgfSBmcm9tICcuL2xhYjJyZ2InO1xyXG5leHBvcnQgeyB4eXoybGFiIH0gZnJvbSAnLi94eXoybGFiJztcclxuZXhwb3J0IHsgeHl6MnJnYiB9IGZyb20gJy4veHl6MnJnYic7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogbGFiMnJnYi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IGxhYjJ4eXogfSBmcm9tICcuL2xhYjJ4eXonO1xyXG5pbXBvcnQgeyB4eXoycmdiIH0gZnJvbSAnLi94eXoycmdiJztcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBsYWIycmdiKEwsIGEsIGIpIHtcclxuICAgIGNvbnN0IHh5eiA9IGxhYjJ4eXooTCwgYSwgYik7XHJcbiAgICByZXR1cm4geHl6MnJnYih4eXoueCwgeHl6LnksIHh5ei56KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYWIycmdiLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogbGFiMnh5ei50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmNvbnN0IHJlZlggPSAwLjk1MDQ3OyAvLyByZWZfWCA9ICA5NS4wNDcgICBPYnNlcnZlcj0gMsKwLCBJbGx1bWluYW50ID0gRDY1XHJcbmNvbnN0IHJlZlkgPSAxLjAwMDAwOyAvLyByZWZfWSA9IDEwMC4wMDBcclxuY29uc3QgcmVmWiA9IDEuMDg4ODM7IC8vIHJlZl9aID0gMTA4Ljg4M1xyXG5mdW5jdGlvbiBwaXZvdChuKSB7XHJcbiAgICByZXR1cm4gbiA+IDAuMjA2ODkzMDM0ID8gTWF0aC5wb3cobiwgMykgOiAobiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xyXG59XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgZnVuY3Rpb24gbGFiMnh5eihMLCBhLCBiKSB7XHJcbiAgICBjb25zdCB5ID0gKEwgKyAxNikgLyAxMTY7XHJcbiAgICBjb25zdCB4ID0gYSAvIDUwMCArIHk7XHJcbiAgICBjb25zdCB6ID0geSAtIGIgLyAyMDA7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHJlZlggKiBwaXZvdCh4KSxcclxuICAgICAgICB5OiByZWZZICogcGl2b3QoeSksXHJcbiAgICAgICAgejogcmVmWiAqIHBpdm90KHopLFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYWIyeHl6LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogcmdiMmhzbC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IG1pbjMsIG1heDMgfSBmcm9tICcuLi91dGlscy9hcml0aG1ldGljJztcclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBIU0wgZnJvbSBSR0JcclxuICogSHVlIGlzIGluIGRlZ3JlZXMgWzAuLjM2MF1cclxuICogTGlnaHRuZXNzOiBbMC4uMV1cclxuICogU2F0dXJhdGlvbjogWzAuLjFdXHJcbiAqIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMDYwOTE0MDQwNDM2L2h0dHA6Ly9sb2NhbC53YXNwLnV3YS5lZHUuYXUvfnBib3Vya2UvY29sb3VyL2hzbC9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZ2IyaHNsKHIsIGcsIGIpIHtcclxuICAgIGNvbnN0IG1pbiA9IG1pbjMociwgZywgYik7XHJcbiAgICBjb25zdCBtYXggPSBtYXgzKHIsIGcsIGIpO1xyXG4gICAgY29uc3QgZGVsdGEgPSBtYXggLSBtaW47XHJcbiAgICBjb25zdCBsID0gKG1pbiArIG1heCkgLyA1MTA7XHJcbiAgICBsZXQgcyA9IDA7XHJcbiAgICBpZiAobCA+IDAgJiYgbCA8IDEpXHJcbiAgICAgICAgcyA9IGRlbHRhIC8gKGwgPCAwLjUgPyAobWF4ICsgbWluKSA6ICg1MTAgLSBtYXggLSBtaW4pKTtcclxuICAgIGxldCBoID0gMDtcclxuICAgIGlmIChkZWx0YSA+IDApIHtcclxuICAgICAgICBpZiAobWF4ID09PSByKSB7XHJcbiAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1heCA9PT0gZykge1xyXG4gICAgICAgICAgICBoID0gKDIgKyAoYiAtIHIpIC8gZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaCA9ICg0ICsgKHIgLSBnKSAvIGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaCAqPSA2MDtcclxuICAgICAgICBpZiAoaCA8IDApXHJcbiAgICAgICAgICAgIGggKz0gMzYwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgaCwgcywgbCB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJnYjJoc2wuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiByZ2IybGFiLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgcmdiMnh5eiB9IGZyb20gJy4vcmdiMnh5eic7XHJcbmltcG9ydCB7IHh5ejJsYWIgfSBmcm9tICcuL3h5ejJsYWInO1xyXG5leHBvcnQgZnVuY3Rpb24gcmdiMmxhYihyLCBnLCBiKSB7XHJcbiAgICBjb25zdCB4eXogPSByZ2IyeHl6KHIsIGcsIGIpO1xyXG4gICAgcmV0dXJuIHh5ejJsYWIoeHl6LngsIHh5ei55LCB4eXoueik7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmdiMmxhYi5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIHJnYjJ4eXoudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5mdW5jdGlvbiBjb3JyZWN0R2FtbWEobikge1xyXG4gICAgcmV0dXJuIG4gPiAwLjA0MDQ1ID8gTWF0aC5wb3coKG4gKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IG4gLyAxMi45MjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmdiMnh5eihyLCBnLCBiKSB7XHJcbiAgICAvLyBnYW1tYSBjb3JyZWN0aW9uLCBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU1JHQiNUaGVfcmV2ZXJzZV90cmFuc2Zvcm1hdGlvblxyXG4gICAgciA9IGNvcnJlY3RHYW1tYShyIC8gMjU1KTtcclxuICAgIGcgPSBjb3JyZWN0R2FtbWEoZyAvIDI1NSk7XHJcbiAgICBiID0gY29ycmVjdEdhbW1hKGIgLyAyNTUpO1xyXG4gICAgLy8gT2JzZXJ2ZXIuID0gMsKwLCBJbGx1bWluYW50ID0gRDY1XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHIgKiAwLjQxMjQgKyBnICogMC4zNTc2ICsgYiAqIDAuMTgwNSxcclxuICAgICAgICB5OiByICogMC4yMTI2ICsgZyAqIDAuNzE1MiArIGIgKiAwLjA3MjIsXHJcbiAgICAgICAgejogciAqIDAuMDE5MyArIGcgKiAwLjExOTIgKyBiICogMC45NTA1LFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZ2IyeHl6LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogeHl6MmxhYi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmNvbnN0IHJlZlggPSAwLjk1MDQ3OyAvLyByZWZfWCA9ICA5NS4wNDcgICBPYnNlcnZlcj0gMsKwLCBJbGx1bWluYW50PSBENjVcclxuY29uc3QgcmVmWSA9IDEuMDAwMDA7IC8vIHJlZl9ZID0gMTAwLjAwMFxyXG5jb25zdCByZWZaID0gMS4wODg4MzsgLy8gcmVmX1ogPSAxMDguODgzXHJcbmZ1bmN0aW9uIHBpdm90KG4pIHtcclxuICAgIHJldHVybiBuID4gMC4wMDg4NTYgPyBNYXRoLnBvdyhuLCAxIC8gMykgOiAoNy43ODcgKiBuICsgMTYgLyAxMTYpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB4eXoybGFiKHgsIHksIHopIHtcclxuICAgIHggPSBwaXZvdCh4IC8gcmVmWCk7XHJcbiAgICB5ID0gcGl2b3QoeSAvIHJlZlkpO1xyXG4gICAgeiA9IHBpdm90KHogLyByZWZaKTtcclxuICAgIGlmICgoMTE2ICogeSkgLSAxNiA8IDApXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4eHgnKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgTDogTWF0aC5tYXgoMCwgKDExNiAqIHkpIC0gMTYpLFxyXG4gICAgICAgIGE6IDUwMCAqICh4IC0geSksXHJcbiAgICAgICAgYjogMjAwICogKHkgLSB6KSxcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eHl6MmxhYi5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIHh5ejJyZ2IudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBpblJhbmdlMHRvMjU1Um91bmRlZCB9IGZyb20gJy4uL3V0aWxzL2FyaXRobWV0aWMnO1xyXG4vLyBnYW1tYSBjb3JyZWN0aW9uLCBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU1JHQiNUaGVfcmV2ZXJzZV90cmFuc2Zvcm1hdGlvblxyXG5mdW5jdGlvbiBjb3JyZWN0R2FtbWEobikge1xyXG4gICAgcmV0dXJuIG4gPiAwLjAwMzEzMDggPyAxLjA1NSAqIE1hdGgucG93KG4sIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIG47XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHh5ejJyZ2IoeCwgeSwgeikge1xyXG4gICAgLy8gT2JzZXJ2ZXIuID0gMsKwLCBJbGx1bWluYW50ID0gRDY1XHJcbiAgICBjb25zdCByID0gY29ycmVjdEdhbW1hKHggKiAzLjI0MDYgKyB5ICogLTEuNTM3MiArIHogKiAtMC40OTg2KTtcclxuICAgIGNvbnN0IGcgPSBjb3JyZWN0R2FtbWEoeCAqIC0wLjk2ODkgKyB5ICogMS44NzU4ICsgeiAqIDAuMDQxNSk7XHJcbiAgICBjb25zdCBiID0gY29ycmVjdEdhbW1hKHggKiAwLjA1NTcgKyB5ICogLTAuMjA0MCArIHogKiAxLjA1NzApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByOiBpblJhbmdlMHRvMjU1Um91bmRlZChyICogMjU1KSxcclxuICAgICAgICBnOiBpblJhbmdlMHRvMjU1Um91bmRlZChnICogMjU1KSxcclxuICAgICAgICBiOiBpblJhbmdlMHRvMjU1Um91bmRlZChiICogMjU1KSxcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eHl6MnJnYi5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGNpZTk0LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IgfSBmcm9tICcuL2Rpc3RhbmNlQ2FsY3VsYXRvcic7XHJcbmltcG9ydCB7IHJnYjJsYWIgfSBmcm9tICcuLi9jb252ZXJzaW9uL3JnYjJsYWInO1xyXG5pbXBvcnQgeyBpblJhbmdlMHRvMjU1IH0gZnJvbSAnLi4vdXRpbHMvYXJpdGhtZXRpYyc7XHJcbi8qKlxyXG4gKiBDSUU5NCBtZXRob2Qgb2YgZGVsdGEtZVxyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbG9yX2RpZmZlcmVuY2UjQ0lFOTRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdENJRTk0IGV4dGVuZHMgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3Ige1xyXG4gICAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xyXG4gICAgICAgIGNvbnN0IGxhYjEgPSByZ2IybGFiKGluUmFuZ2UwdG8yNTUocjEgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBpblJhbmdlMHRvMjU1KGcxICogdGhpcy5fd2hpdGVQb2ludC5nKSwgaW5SYW5nZTB0bzI1NShiMSAqIHRoaXMuX3doaXRlUG9pbnQuYikpO1xyXG4gICAgICAgIGNvbnN0IGxhYjIgPSByZ2IybGFiKGluUmFuZ2UwdG8yNTUocjIgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBpblJhbmdlMHRvMjU1KGcyICogdGhpcy5fd2hpdGVQb2ludC5nKSwgaW5SYW5nZTB0bzI1NShiMiAqIHRoaXMuX3doaXRlUG9pbnQuYikpO1xyXG4gICAgICAgIGNvbnN0IGRMID0gbGFiMS5MIC0gbGFiMi5MO1xyXG4gICAgICAgIGNvbnN0IGRBID0gbGFiMS5hIC0gbGFiMi5hO1xyXG4gICAgICAgIGNvbnN0IGRCID0gbGFiMS5iIC0gbGFiMi5iO1xyXG4gICAgICAgIGNvbnN0IGMxID0gTWF0aC5zcXJ0KGxhYjEuYSAqIGxhYjEuYSArIGxhYjEuYiAqIGxhYjEuYik7XHJcbiAgICAgICAgY29uc3QgYzIgPSBNYXRoLnNxcnQobGFiMi5hICogbGFiMi5hICsgbGFiMi5iICogbGFiMi5iKTtcclxuICAgICAgICBjb25zdCBkQyA9IGMxIC0gYzI7XHJcbiAgICAgICAgbGV0IGRlbHRhSCA9IGRBICogZEEgKyBkQiAqIGRCIC0gZEMgKiBkQztcclxuICAgICAgICBkZWx0YUggPSBkZWx0YUggPCAwID8gMCA6IE1hdGguc3FydChkZWx0YUgpO1xyXG4gICAgICAgIGNvbnN0IGRBbHBoYSA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYSAqIHRoaXMuX2tBO1xyXG4gICAgICAgIC8vIFRPRE86IGFkZCBhbHBoYSBjaGFubmVsIHN1cHBvcnRcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRMIC8gdGhpcy5fS2wsIDIpICtcclxuICAgICAgICAgICAgTWF0aC5wb3coZEMgLyAoMS4wICsgdGhpcy5fSzEgKiBjMSksIDIpICtcclxuICAgICAgICAgICAgTWF0aC5wb3coZGVsdGFIIC8gKDEuMCArIHRoaXMuX0syICogYzEpLCAyKSArXHJcbiAgICAgICAgICAgIE1hdGgucG93KGRBbHBoYSwgMikpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDSUU5NFRleHRpbGVzIGV4dGVuZHMgQWJzdHJhY3RDSUU5NCB7XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgdGhpcy5fS2wgPSAyLjA7XHJcbiAgICAgICAgdGhpcy5fSzEgPSAwLjA0ODtcclxuICAgICAgICB0aGlzLl9LMiA9IDAuMDE0O1xyXG4gICAgICAgIHRoaXMuX2tBID0gMC4yNSAqIDUwIC8gMjU1O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDSUU5NEdyYXBoaWNBcnRzIGV4dGVuZHMgQWJzdHJhY3RDSUU5NCB7XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgdGhpcy5fS2wgPSAxLjA7XHJcbiAgICAgICAgdGhpcy5fSzEgPSAwLjA0NTtcclxuICAgICAgICB0aGlzLl9LMiA9IDAuMDE1O1xyXG4gICAgICAgIHRoaXMuX2tBID0gMC4yNSAqIDEwMCAvIDI1NTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaWU5NC5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGNpZWRlMjAwMC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIH0gZnJvbSAnLi9kaXN0YW5jZUNhbGN1bGF0b3InO1xyXG5pbXBvcnQgeyByZ2IybGFiIH0gZnJvbSAnLi4vY29udmVyc2lvbi9yZ2IybGFiJztcclxuaW1wb3J0IHsgZGVncmVlczJyYWRpYW5zLCBpblJhbmdlMHRvMjU1IH0gZnJvbSAnLi4vdXRpbHMvYXJpdGhtZXRpYyc7XHJcbi8vIHRzbGludDpkaXNhYmxlOnZhcmlhYmxlLW5hbWVcclxuLy8gdHNsaW50OmRpc2FibGU6bmFtaW5nLWNvbnZlbnRpb25cclxuLyoqXHJcbiAqIENJRURFMjAwMCBhbGdvcml0aG0gLSBBZGFwdGVkIGZyb20gU2hhcm1hIGV0IGFsJ3MgTUFUTEFCIGltcGxlbWVudGF0aW9uIGF0XHJcbiAqIGh0dHA6Ly93d3cuZWNlLnJvY2hlc3Rlci5lZHUvfmdzaGFybWEvY2llZGUyMDAwL1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENJRURFMjAwMCBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcclxuICAgIF9zZXREZWZhdWx0cygpIHsgfVxyXG4gICAgc3RhdGljIF9jYWxjdWxhdGVocChiLCBhcCkge1xyXG4gICAgICAgIGNvbnN0IGhwID0gTWF0aC5hdGFuMihiLCBhcCk7XHJcbiAgICAgICAgaWYgKGhwID49IDApXHJcbiAgICAgICAgICAgIHJldHVybiBocDtcclxuICAgICAgICByZXR1cm4gaHAgKyBDSUVERTIwMDAuX2RlZzM2MEluUmFkO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jYWxjdWxhdGVSVChhaHAsIGFDcCkge1xyXG4gICAgICAgIGNvbnN0IGFDcF90b183ID0gTWF0aC5wb3coYUNwLCA3LjApO1xyXG4gICAgICAgIGNvbnN0IFJfQyA9IDIuMCAqIE1hdGguc3FydChhQ3BfdG9fNyAvIChhQ3BfdG9fNyArIENJRURFMjAwMC5fcG93MjV0bzcpKTsgLy8gMjVeN1xyXG4gICAgICAgIGNvbnN0IGRlbHRhX3RoZXRhID0gQ0lFREUyMDAwLl9kZWczMEluUmFkICogTWF0aC5leHAoLU1hdGgucG93KChhaHAgLSBDSUVERTIwMDAuX2RlZzI3NUluUmFkKSAvIENJRURFMjAwMC5fZGVnMjVJblJhZCwgMi4wKSk7XHJcbiAgICAgICAgcmV0dXJuIC1NYXRoLnNpbigyLjAgKiBkZWx0YV90aGV0YSkgKiBSX0M7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NhbGN1bGF0ZVQoYWhwKSB7XHJcbiAgICAgICAgcmV0dXJuIDEuMCAtIC4xNyAqIE1hdGguY29zKGFocCAtIENJRURFMjAwMC5fZGVnMzBJblJhZCkgKyAuMjQgKiBNYXRoLmNvcyhhaHAgKiAyLjApICsgLjMyICogTWF0aC5jb3MoYWhwICogMy4wICsgQ0lFREUyMDAwLl9kZWc2SW5SYWQpIC0gLjIgKiBNYXRoLmNvcyhhaHAgKiA0LjAgLSBDSUVERTIwMDAuX2RlZzYzSW5SYWQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jYWxjdWxhdGVfYWhwKEMxcEMycCwgaF9iYXIsIGgxcCwgaDJwKSB7XHJcbiAgICAgICAgY29uc3QgaHBTdW0gPSBoMXAgKyBoMnA7XHJcbiAgICAgICAgaWYgKEMxcEMycCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGhwU3VtO1xyXG4gICAgICAgIGlmIChoX2JhciA8PSBDSUVERTIwMDAuX2RlZzE4MEluUmFkKVxyXG4gICAgICAgICAgICByZXR1cm4gaHBTdW0gLyAyLjA7XHJcbiAgICAgICAgaWYgKGhwU3VtIDwgQ0lFREUyMDAwLl9kZWczNjBJblJhZClcclxuICAgICAgICAgICAgcmV0dXJuIChocFN1bSArIENJRURFMjAwMC5fZGVnMzYwSW5SYWQpIC8gMi4wO1xyXG4gICAgICAgIHJldHVybiAoaHBTdW0gLSBDSUVERTIwMDAuX2RlZzM2MEluUmFkKSAvIDIuMDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY2FsY3VsYXRlX2RIcChDMXBDMnAsIGhfYmFyLCBoMnAsIGgxcCkge1xyXG4gICAgICAgIGxldCBkaHA7XHJcbiAgICAgICAgaWYgKEMxcEMycCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaHAgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoX2JhciA8PSBDSUVERTIwMDAuX2RlZzE4MEluUmFkKSB7XHJcbiAgICAgICAgICAgIGRocCA9IGgycCAtIGgxcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaDJwIDw9IGgxcCkge1xyXG4gICAgICAgICAgICBkaHAgPSBoMnAgLSBoMXAgKyBDSUVERTIwMDAuX2RlZzM2MEluUmFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGhwID0gaDJwIC0gaDFwIC0gQ0lFREUyMDAwLl9kZWczNjBJblJhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDIuMCAqIE1hdGguc3FydChDMXBDMnApICogTWF0aC5zaW4oZGhwIC8gMi4wKTtcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcclxuICAgICAgICBjb25zdCBsYWIxID0gcmdiMmxhYihpblJhbmdlMHRvMjU1KHIxICogdGhpcy5fd2hpdGVQb2ludC5yKSwgaW5SYW5nZTB0bzI1NShnMSAqIHRoaXMuX3doaXRlUG9pbnQuZyksIGluUmFuZ2UwdG8yNTUoYjEgKiB0aGlzLl93aGl0ZVBvaW50LmIpKTtcclxuICAgICAgICBjb25zdCBsYWIyID0gcmdiMmxhYihpblJhbmdlMHRvMjU1KHIyICogdGhpcy5fd2hpdGVQb2ludC5yKSwgaW5SYW5nZTB0bzI1NShnMiAqIHRoaXMuX3doaXRlUG9pbnQuZyksIGluUmFuZ2UwdG8yNTUoYjIgKiB0aGlzLl93aGl0ZVBvaW50LmIpKTtcclxuICAgICAgICBjb25zdCBkQSA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYSAqIENJRURFMjAwMC5fa0E7XHJcbiAgICAgICAgY29uc3QgZEUyID0gdGhpcy5jYWxjdWxhdGVSYXdJbkxhYihsYWIxLCBsYWIyKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGRFMiArIGRBICogZEEpO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlUmF3SW5MYWIoTGFiMSwgTGFiMikge1xyXG4gICAgICAgIC8vIEdldCBMLGEsYiB2YWx1ZXMgZm9yIGNvbG9yIDFcclxuICAgICAgICBjb25zdCBMMSA9IExhYjEuTDtcclxuICAgICAgICBjb25zdCBhMSA9IExhYjEuYTtcclxuICAgICAgICBjb25zdCBiMSA9IExhYjEuYjtcclxuICAgICAgICAvLyBHZXQgTCxhLGIgdmFsdWVzIGZvciBjb2xvciAyXHJcbiAgICAgICAgY29uc3QgTDIgPSBMYWIyLkw7XHJcbiAgICAgICAgY29uc3QgYTIgPSBMYWIyLmE7XHJcbiAgICAgICAgY29uc3QgYjIgPSBMYWIyLmI7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIENwcmltZTEsIENwcmltZTIsIENhYmJhclxyXG4gICAgICAgIGNvbnN0IEMxID0gTWF0aC5zcXJ0KGExICogYTEgKyBiMSAqIGIxKTtcclxuICAgICAgICBjb25zdCBDMiA9IE1hdGguc3FydChhMiAqIGEyICsgYjIgKiBiMik7XHJcbiAgICAgICAgY29uc3QgcG93X2FfQzFfQzJfdG9fNyA9IE1hdGgucG93KChDMSArIEMyKSAvIDIuMCwgNy4wKTtcclxuICAgICAgICBjb25zdCBHID0gMC41ICogKDEuMCAtIE1hdGguc3FydChwb3dfYV9DMV9DMl90b183IC8gKHBvd19hX0MxX0MyX3RvXzcgKyBDSUVERTIwMDAuX3BvdzI1dG83KSkpOyAvLyAyNV43XHJcbiAgICAgICAgY29uc3QgYTFwID0gKDEuMCArIEcpICogYTE7XHJcbiAgICAgICAgY29uc3QgYTJwID0gKDEuMCArIEcpICogYTI7XHJcbiAgICAgICAgY29uc3QgQzFwID0gTWF0aC5zcXJ0KGExcCAqIGExcCArIGIxICogYjEpO1xyXG4gICAgICAgIGNvbnN0IEMycCA9IE1hdGguc3FydChhMnAgKiBhMnAgKyBiMiAqIGIyKTtcclxuICAgICAgICBjb25zdCBDMXBDMnAgPSBDMXAgKiBDMnA7XHJcbiAgICAgICAgLy8gQW5nbGVzIGluIERlZ3JlZS5cclxuICAgICAgICBjb25zdCBoMXAgPSBDSUVERTIwMDAuX2NhbGN1bGF0ZWhwKGIxLCBhMXApO1xyXG4gICAgICAgIGNvbnN0IGgycCA9IENJRURFMjAwMC5fY2FsY3VsYXRlaHAoYjIsIGEycCk7XHJcbiAgICAgICAgY29uc3QgaF9iYXIgPSBNYXRoLmFicyhoMXAgLSBoMnApO1xyXG4gICAgICAgIGNvbnN0IGRMcCA9IEwyIC0gTDE7XHJcbiAgICAgICAgY29uc3QgZENwID0gQzJwIC0gQzFwO1xyXG4gICAgICAgIGNvbnN0IGRIcCA9IENJRURFMjAwMC5fY2FsY3VsYXRlX2RIcChDMXBDMnAsIGhfYmFyLCBoMnAsIGgxcCk7XHJcbiAgICAgICAgY29uc3QgYWhwID0gQ0lFREUyMDAwLl9jYWxjdWxhdGVfYWhwKEMxcEMycCwgaF9iYXIsIGgxcCwgaDJwKTtcclxuICAgICAgICBjb25zdCBUID0gQ0lFREUyMDAwLl9jYWxjdWxhdGVUKGFocCk7XHJcbiAgICAgICAgY29uc3QgYUNwID0gKEMxcCArIEMycCkgLyAyLjA7XHJcbiAgICAgICAgY29uc3QgYUxwX21pbnVzXzUwX3NxdWFyZSA9IE1hdGgucG93KChMMSArIEwyKSAvIDIuMCAtIDUwLjAsIDIuMCk7XHJcbiAgICAgICAgY29uc3QgU19MID0gMS4wICsgKC4wMTUgKiBhTHBfbWludXNfNTBfc3F1YXJlKSAvIE1hdGguc3FydCgyMC4wICsgYUxwX21pbnVzXzUwX3NxdWFyZSk7XHJcbiAgICAgICAgY29uc3QgU19DID0gMS4wICsgLjA0NSAqIGFDcDtcclxuICAgICAgICBjb25zdCBTX0ggPSAxLjAgKyAuMDE1ICogVCAqIGFDcDtcclxuICAgICAgICBjb25zdCBSX1QgPSBDSUVERTIwMDAuX2NhbGN1bGF0ZVJUKGFocCwgYUNwKTtcclxuICAgICAgICBjb25zdCBkTHBTTCA9IGRMcCAvIFNfTDsgLy8gU19MICoga0wsIHdoZXJlIGtMIGlzIDEuMFxyXG4gICAgICAgIGNvbnN0IGRDcFNDID0gZENwIC8gU19DOyAvLyBTX0MgKiBrQywgd2hlcmUga0MgaXMgMS4wXHJcbiAgICAgICAgY29uc3QgZEhwU0ggPSBkSHAgLyBTX0g7IC8vIFNfSCAqIGtILCB3aGVyZSBrSCBpcyAxLjBcclxuICAgICAgICByZXR1cm4gTWF0aC5wb3coZExwU0wsIDIpICsgTWF0aC5wb3coZENwU0MsIDIpICsgTWF0aC5wb3coZEhwU0gsIDIpICsgUl9UICogZENwU0MgKiBkSHBTSDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogV2VpZ2h0IGluIGRpc3RhbmNlOiAwLjI1XHJcbiAqIE1heCBEZWx0YUU6IDEwMFxyXG4gKiBNYXggRGVsdGFBOiAyNTVcclxuICovXHJcbkNJRURFMjAwMC5fa0EgPSAwLjI1ICogMTAwIC8gMjU1O1xyXG5DSUVERTIwMDAuX3BvdzI1dG83ID0gTWF0aC5wb3coMjUsIDcpO1xyXG5DSUVERTIwMDAuX2RlZzM2MEluUmFkID0gZGVncmVlczJyYWRpYW5zKDM2MCk7XHJcbkNJRURFMjAwMC5fZGVnMTgwSW5SYWQgPSBkZWdyZWVzMnJhZGlhbnMoMTgwKTtcclxuQ0lFREUyMDAwLl9kZWczMEluUmFkID0gZGVncmVlczJyYWRpYW5zKDMwKTtcclxuQ0lFREUyMDAwLl9kZWc2SW5SYWQgPSBkZWdyZWVzMnJhZGlhbnMoNik7XHJcbkNJRURFMjAwMC5fZGVnNjNJblJhZCA9IGRlZ3JlZXMycmFkaWFucyg2Myk7XHJcbkNJRURFMjAwMC5fZGVnMjc1SW5SYWQgPSBkZWdyZWVzMnJhZGlhbnMoMjc1KTtcclxuQ0lFREUyMDAwLl9kZWcyNUluUmFkID0gZGVncmVlczJyYWRpYW5zKDI1KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2llZGUyMDAwLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogY21ldHJpYy50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIH0gZnJvbSAnLi9kaXN0YW5jZUNhbGN1bGF0b3InO1xyXG4vKipcclxuICogVE9ETzogTmFtZSBpdDogaHR0cDovL3d3dy5jb21wdXBoYXNlLmNvbS9jbWV0cmljLmh0bVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENNZXRyaWMgZXh0ZW5kcyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB7XHJcbiAgICBjYWxjdWxhdGVSYXcocjEsIGcxLCBiMSwgYTEsIHIyLCBnMiwgYjIsIGEyKSB7XHJcbiAgICAgICAgY29uc3Qgcm1lYW4gPSAocjEgKyByMikgLyAyICogdGhpcy5fd2hpdGVQb2ludC5yO1xyXG4gICAgICAgIGNvbnN0IHIgPSAocjEgLSByMikgKiB0aGlzLl93aGl0ZVBvaW50LnI7XHJcbiAgICAgICAgY29uc3QgZyA9IChnMSAtIGcyKSAqIHRoaXMuX3doaXRlUG9pbnQuZztcclxuICAgICAgICBjb25zdCBiID0gKGIxIC0gYjIpICogdGhpcy5fd2hpdGVQb2ludC5iO1xyXG4gICAgICAgIGNvbnN0IGRFID0gKCgoKDUxMiArIHJtZWFuKSAqIHIgKiByKSA+PiA4KSArIDQgKiBnICogZyArICgoKDc2NyAtIHJtZWFuKSAqIGIgKiBiKSA+PiA4KSk7XHJcbiAgICAgICAgY29uc3QgZEEgPSAoYTIgLSBhMSkgKiB0aGlzLl93aGl0ZVBvaW50LmE7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkRSArIGRBICogZEEpO1xyXG4gICAgfVxyXG4gICAgX3NldERlZmF1bHRzKCkgeyB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y21ldHJpYy5qcy5tYXAiLCJleHBvcnQgY2xhc3MgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdHMoKTtcclxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBtYXhpbWFsIGNvbG9yIGNvbXBvbmVudCBkZWx0YXMgKDI1NSAtIDAgPSAyNTUpXHJcbiAgICAgICAgdGhpcy5zZXRXaGl0ZVBvaW50KDI1NSwgMjU1LCAyNTUsIDI1NSk7XHJcbiAgICB9XHJcbiAgICBzZXRXaGl0ZVBvaW50KHIsIGcsIGIsIGEpIHtcclxuICAgICAgICB0aGlzLl93aGl0ZVBvaW50ID0ge1xyXG4gICAgICAgICAgICByOiAociA+IDApID8gMjU1IC8gciA6IDAsXHJcbiAgICAgICAgICAgIGc6IChnID4gMCkgPyAyNTUgLyBnIDogMCxcclxuICAgICAgICAgICAgYjogKGIgPiAwKSA/IDI1NSAvIGIgOiAwLFxyXG4gICAgICAgICAgICBhOiAoYSA+IDApID8gMjU1IC8gYSA6IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9tYXhEaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlUmF3KHIsIGcsIGIsIGEsIDAsIDAsIDAsIDApO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlTm9ybWFsaXplZChjb2xvckEsIGNvbG9yQikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVJhdyhjb2xvckEuciwgY29sb3JBLmcsIGNvbG9yQS5iLCBjb2xvckEuYSwgY29sb3JCLnIsIGNvbG9yQi5nLCBjb2xvckIuYiwgY29sb3JCLmEpIC8gdGhpcy5fbWF4RGlzdGFuY2U7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGFuY2VDYWxjdWxhdG9yLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogZXVjbGlkZWFuLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IgfSBmcm9tICcuL2Rpc3RhbmNlQ2FsY3VsYXRvcic7XHJcbmltcG9ydCB7IFkgfSBmcm9tICcuLi9jb25zdGFudHMvYnQ3MDknO1xyXG4vKipcclxuICogRXVjbGlkZWFuIGNvbG9yIGRpc3RhbmNlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RFdWNsaWRlYW4gZXh0ZW5kcyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB7XHJcbiAgICBjYWxjdWxhdGVSYXcocjEsIGcxLCBiMSwgYTEsIHIyLCBnMiwgYjIsIGEyKSB7XHJcbiAgICAgICAgY29uc3QgZFIgPSByMiAtIHIxO1xyXG4gICAgICAgIGNvbnN0IGRHID0gZzIgLSBnMTtcclxuICAgICAgICBjb25zdCBkQiA9IGIyIC0gYjE7XHJcbiAgICAgICAgY29uc3QgZEEgPSBhMiAtIGExO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5fa1IgKiBkUiAqIGRSICsgdGhpcy5fa0cgKiBkRyAqIGRHICsgdGhpcy5fa0IgKiBkQiAqIGRCICsgdGhpcy5fa0EgKiBkQSAqIGRBKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRXVjbGlkZWFuIGV4dGVuZHMgQWJzdHJhY3RFdWNsaWRlYW4ge1xyXG4gICAgX3NldERlZmF1bHRzKCkge1xyXG4gICAgICAgIHRoaXMuX2tSID0gMTtcclxuICAgICAgICB0aGlzLl9rRyA9IDE7XHJcbiAgICAgICAgdGhpcy5fa0IgPSAxO1xyXG4gICAgICAgIHRoaXMuX2tBID0gMTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXVjbGlkZWFuIGNvbG9yIGRpc3RhbmNlIChSR0JRdWFudCBtb2RpZmljYXRpb24gdyBBbHBoYSlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdWNsaWRlYW5CVDcwOSBleHRlbmRzIEFic3RyYWN0RXVjbGlkZWFuIHtcclxuICAgIF9zZXREZWZhdWx0cygpIHtcclxuICAgICAgICB0aGlzLl9rUiA9IFkuUkVEO1xyXG4gICAgICAgIHRoaXMuX2tHID0gWS5HUkVFTjtcclxuICAgICAgICB0aGlzLl9rQiA9IFkuQkxVRTtcclxuICAgICAgICAvLyBUT0RPOiB3aGF0IGlzIHRoZSBiZXN0IGNvZWZmaWNpZW50IGJlbG93P1xyXG4gICAgICAgIHRoaXMuX2tBID0gMTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXVjbGlkZWFuIGNvbG9yIGRpc3RhbmNlIChSR0JRdWFudCBtb2RpZmljYXRpb24gdy9vIEFscGhhKVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV1Y2xpZGVhbkJUNzA5Tm9BbHBoYSBleHRlbmRzIEFic3RyYWN0RXVjbGlkZWFuIHtcclxuICAgIF9zZXREZWZhdWx0cygpIHtcclxuICAgICAgICB0aGlzLl9rUiA9IFkuUkVEO1xyXG4gICAgICAgIHRoaXMuX2tHID0gWS5HUkVFTjtcclxuICAgICAgICB0aGlzLl9rQiA9IFkuQkxVRTtcclxuICAgICAgICB0aGlzLl9rQSA9IDA7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXVjbGlkZWFuLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuZXhwb3J0IHsgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IgfSBmcm9tICcuL2Rpc3RhbmNlQ2FsY3VsYXRvcic7XHJcbmV4cG9ydCB7IENJRTk0VGV4dGlsZXMsIENJRTk0R3JhcGhpY0FydHMgfSBmcm9tICcuL2NpZTk0JztcclxuZXhwb3J0IHsgQ0lFREUyMDAwIH0gZnJvbSAnLi9jaWVkZTIwMDAnO1xyXG5leHBvcnQgeyBDTWV0cmljIH0gZnJvbSAnLi9jbWV0cmljJztcclxuZXhwb3J0IHsgQWJzdHJhY3RFdWNsaWRlYW4sIEV1Y2xpZGVhbiwgRXVjbGlkZWFuQlQ3MDlOb0FscGhhLCBFdWNsaWRlYW5CVDcwOSB9IGZyb20gJy4vZXVjbGlkZWFuJztcclxuZXhwb3J0IHsgQWJzdHJhY3RNYW5oYXR0YW4sIE1hbmhhdHRhbiwgTWFuaGF0dGFuQlQ3MDksIE1hbmhhdHRhbk5vbW15ZGUgfSBmcm9tICcuL21hbmhhdHRhbic7XHJcbmV4cG9ydCB7IFBOR1F1YW50IH0gZnJvbSAnLi9wbmdRdWFudCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogbWFuaGF0dGFuTmV1UXVhbnQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB9IGZyb20gJy4vZGlzdGFuY2VDYWxjdWxhdG9yJztcclxuaW1wb3J0IHsgWSB9IGZyb20gJy4uL2NvbnN0YW50cy9idDcwOSc7XHJcbi8qKlxyXG4gKiBNYW5oYXR0YW4gZGlzdGFuY2UgKE5ldVF1YW50IG1vZGlmaWNhdGlvbikgLSB3L28gc1JHQiBjb2VmZmljaWVudHNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdE1hbmhhdHRhbiBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcclxuICAgIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcclxuICAgICAgICBsZXQgZFIgPSByMiAtIHIxO1xyXG4gICAgICAgIGxldCBkRyA9IGcyIC0gZzE7XHJcbiAgICAgICAgbGV0IGRCID0gYjIgLSBiMTtcclxuICAgICAgICBsZXQgZEEgPSBhMiAtIGExO1xyXG4gICAgICAgIGlmIChkUiA8IDApXHJcbiAgICAgICAgICAgIGRSID0gMCAtIGRSO1xyXG4gICAgICAgIGlmIChkRyA8IDApXHJcbiAgICAgICAgICAgIGRHID0gMCAtIGRHO1xyXG4gICAgICAgIGlmIChkQiA8IDApXHJcbiAgICAgICAgICAgIGRCID0gMCAtIGRCO1xyXG4gICAgICAgIGlmIChkQSA8IDApXHJcbiAgICAgICAgICAgIGRBID0gMCAtIGRBO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rUiAqIGRSICsgdGhpcy5fa0cgKiBkRyArIHRoaXMuX2tCICogZEIgKyB0aGlzLl9rQSAqIGRBO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBNYW5oYXR0YW4gZXh0ZW5kcyBBYnN0cmFjdE1hbmhhdHRhbiB7XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgdGhpcy5fa1IgPSAxO1xyXG4gICAgICAgIHRoaXMuX2tHID0gMTtcclxuICAgICAgICB0aGlzLl9rQiA9IDE7XHJcbiAgICAgICAgdGhpcy5fa0EgPSAxO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNYW5oYXR0YW4gZGlzdGFuY2UgKE5vbW15ZGUgbW9kaWZpY2F0aW9uKVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaWdvci1iZXprcm92bnkvaW1hZ2UtcXVhbnRpemF0aW9uL2lzc3Vlcy80I2lzc3VlY29tbWVudC0yMzUxNTUzMjBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBNYW5oYXR0YW5Ob21teWRlIGV4dGVuZHMgQWJzdHJhY3RNYW5oYXR0YW4ge1xyXG4gICAgX3NldERlZmF1bHRzKCkge1xyXG4gICAgICAgIHRoaXMuX2tSID0gMC40OTg0O1xyXG4gICAgICAgIHRoaXMuX2tHID0gMC44NjI1O1xyXG4gICAgICAgIHRoaXMuX2tCID0gMC4yOTc5O1xyXG4gICAgICAgIC8vIFRPRE86IHdoYXQgaXMgdGhlIGJlc3QgY29lZmZpY2llbnQgYmVsb3c/XHJcbiAgICAgICAgdGhpcy5fa0EgPSAxO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNYW5oYXR0YW4gZGlzdGFuY2UgKHNSR0IgY29lZmZpY2llbnRzKVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1hbmhhdHRhbkJUNzA5IGV4dGVuZHMgQWJzdHJhY3RNYW5oYXR0YW4ge1xyXG4gICAgX3NldERlZmF1bHRzKCkge1xyXG4gICAgICAgIHRoaXMuX2tSID0gWS5SRUQ7XHJcbiAgICAgICAgdGhpcy5fa0cgPSBZLkdSRUVOO1xyXG4gICAgICAgIHRoaXMuX2tCID0gWS5CTFVFO1xyXG4gICAgICAgIC8vIFRPRE86IHdoYXQgaXMgdGhlIGJlc3QgY29lZmZpY2llbnQgYmVsb3c/XHJcbiAgICAgICAgdGhpcy5fa0EgPSAxO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hbmhhdHRhbi5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIHBuZ1F1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IgfSBmcm9tICcuL2Rpc3RhbmNlQ2FsY3VsYXRvcic7XHJcbi8qKlxyXG4gKiBUT0RPOiBjaGVjayBxdWFsaXR5IG9mIHRoaXMgZGlzdGFuY2UgZXF1YXRpb25cclxuICogVE9ETzogYXNrIGF1dGhvciBmb3IgdXNhZ2UgcmlnaHRzXHJcbiAqIHRha2VuIGZyb206XHJcbiAqIHtAbGluayBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ3NTQ1MDYvY29sb3Itc2ltaWxhcml0eS1kaXN0YW5jZS1pbi1yZ2JhLWNvbG9yLXNwYWNlLzg3OTY4NjcjODc5Njg2N31cclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3JuZWwvcG5ncXVhbnQvYmxvYi9jYzM5YjQ3Nzk5YTdmZjJlZjE3YjUyOWY5NDE1ZmY2ZTZiMjEzYjhmL2xpYi9wYW0uaCNMMTQ4fVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBOR1F1YW50IGV4dGVuZHMgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBBdXRob3IncyBjb21tZW50c1xyXG4gICAgICogcHhfYi5yZ2IgPSBweC5yZ2IgKyAwKigxLXB4LmEpIC8vIGJsZW5kIHB4IG9uIGJsYWNrXHJcbiAgICAgKiBweF9iLmEgICA9IHB4LmEgICArIDEqKDEtcHguYSlcclxuICAgICAqIHB4X3cucmdiID0gcHgucmdiICsgMSooMS1weC5hKSAvLyBibGVuZCBweCBvbiB3aGl0ZVxyXG4gICAgICogcHhfdy5hICAgPSBweC5hICAgKyAxKigxLXB4LmEpXHJcbiAgICAgKlxyXG4gICAgICogcHhfYi5yZ2IgPSBweC5yZ2IgICAgICAgICAgICAgIC8vIGRpZmZlcmVuY2Ugc2FtZSBhcyBpbiBvcGFxdWUgUkdCXHJcbiAgICAgKiBweF9iLmEgICA9IDFcclxuICAgICAqIHB4X3cucmdiID0gcHgucmdiIC0gcHguYSAgICAgICAvLyBkaWZmZXJlbmNlIHNpbXBsaWZpZXMgdG8gZm9ybXVsYSBiZWxvd1xyXG4gICAgICogcHhfdy5hICAgPSAxXHJcbiAgICAgKlxyXG4gICAgICogKHB4LnJnYiAtIHB4LmEpIC0gKHB5LnJnYiAtIHB5LmEpXHJcbiAgICAgKiAocHgucmdiIC0gcHkucmdiKSArIChweS5hIC0gcHguYSlcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcclxuICAgICAgICBjb25zdCBhbHBoYXMgPSAoYTIgLSBhMSkgKiB0aGlzLl93aGl0ZVBvaW50LmE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yZGlmZmVyZW5jZUNoKHIxICogdGhpcy5fd2hpdGVQb2ludC5yLCByMiAqIHRoaXMuX3doaXRlUG9pbnQuciwgYWxwaGFzKSArXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yZGlmZmVyZW5jZUNoKGcxICogdGhpcy5fd2hpdGVQb2ludC5nLCBnMiAqIHRoaXMuX3doaXRlUG9pbnQuZywgYWxwaGFzKSArXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yZGlmZmVyZW5jZUNoKGIxICogdGhpcy5fd2hpdGVQb2ludC5iLCBiMiAqIHRoaXMuX3doaXRlUG9pbnQuYiwgYWxwaGFzKTtcclxuICAgIH1cclxuICAgIF9jb2xvcmRpZmZlcmVuY2VDaCh4LCB5LCBhbHBoYXMpIHtcclxuICAgICAgICAvLyBtYXhpbXVtIG9mIGNoYW5uZWwgYmxlbmRlZCBvbiB3aGl0ZSwgYW5kIGJsZW5kZWQgb24gYmxhY2tcclxuICAgICAgICAvLyBwcmVtdWx0aXBsaWVkIGFscGhhIGFuZCBiYWNrZ3JvdW5kcyAwLzEgc2hvcnRlbiB0aGUgZm9ybXVsYVxyXG4gICAgICAgIGNvbnN0IGJsYWNrID0geCAtIHk7XHJcbiAgICAgICAgY29uc3Qgd2hpdGUgPSBibGFjayArIGFscGhhcztcclxuICAgICAgICByZXR1cm4gYmxhY2sgKiBibGFjayArIHdoaXRlICogd2hpdGU7XHJcbiAgICB9XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7IH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbmdRdWFudC5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGlxLnRzIC0gSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCAqIGFzIGNvbnZlcnNpb24gZnJvbSAnLi9jb252ZXJzaW9uJztcclxuaW1wb3J0ICogYXMgZGlzdGFuY2UgZnJvbSAnLi9kaXN0YW5jZSc7XHJcbmltcG9ydCAqIGFzIHBhbGV0dGUgZnJvbSAnLi9wYWxldHRlJztcclxuaW1wb3J0ICogYXMgaW1hZ2UgZnJvbSAnLi9pbWFnZSc7XHJcbmltcG9ydCAqIGFzIHF1YWxpdHkgZnJvbSAnLi9xdWFsaXR5JztcclxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XHJcbmV4cG9ydCB7IGJ1aWxkUGFsZXR0ZSwgYnVpbGRQYWxldHRlU3luYywgYXBwbHlQYWxldHRlLCBhcHBseVBhbGV0dGVTeW5jLCB9IGZyb20gJy4vYmFzaWNBUEknO1xyXG5leHBvcnQgeyBjb25zdGFudHMsIGNvbnZlcnNpb24sIGRpc3RhbmNlLCBwYWxldHRlLCBpbWFnZSwgcXVhbGl0eSwgdXRpbHMsIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLXEuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBkaXRoZXJFcnJvckRpZmZ1c2lvbkFycmF5LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgQWJzdHJhY3RJbWFnZVF1YW50aXplciB9IGZyb20gJy4vaW1hZ2VRdWFudGl6ZXInO1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL3V0aWxzL3BvaW50JztcclxuaW1wb3J0IHsgaW5SYW5nZTB0bzI1NVJvdW5kZWQgfSBmcm9tICcuLi91dGlscy9hcml0aG1ldGljJztcclxuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vdXRpbHMvcHJvZ3Jlc3NUcmFja2VyJztcclxuLy8gVE9ETzogaXMgaXQgdGhlIGJlc3QgbmFtZSBmb3IgdGhpcyBlbnVtIFwia2VybmVsXCI/XHJcbmV4cG9ydCB2YXIgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDtcclxuKGZ1bmN0aW9uIChFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsKSB7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJGbG95ZFN0ZWluYmVyZ1wiXSA9IDBdID0gXCJGbG95ZFN0ZWluYmVyZ1wiO1xyXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1wiRmFsc2VGbG95ZFN0ZWluYmVyZ1wiXSA9IDFdID0gXCJGYWxzZUZsb3lkU3RlaW5iZXJnXCI7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJTdHVja2lcIl0gPSAyXSA9IFwiU3R1Y2tpXCI7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJBdGtpbnNvblwiXSA9IDNdID0gXCJBdGtpbnNvblwiO1xyXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1wiSmFydmlzXCJdID0gNF0gPSBcIkphcnZpc1wiO1xyXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1wiQnVya2VzXCJdID0gNV0gPSBcIkJ1cmtlc1wiO1xyXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1wiU2llcnJhXCJdID0gNl0gPSBcIlNpZXJyYVwiO1xyXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1wiVHdvU2llcnJhXCJdID0gN10gPSBcIlR3b1NpZXJyYVwiO1xyXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1wiU2llcnJhTGl0ZVwiXSA9IDhdID0gXCJTaWVycmFMaXRlXCI7XHJcbn0pKEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwgfHwgKEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwgPSB7fSkpO1xyXG4vLyBodHRwOi8vd3d3LnRhbm5lcmhlbGxhbmQuY29tLzQ2NjAvZGl0aGVyaW5nLWVsZXZlbi1hbGdvcml0aG1zLXNvdXJjZS1jb2RlL1xyXG5leHBvcnQgY2xhc3MgRXJyb3JEaWZmdXNpb25BcnJheSBleHRlbmRzIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGtlcm5lbCwgc2VycGVudGluZSA9IHRydWUsIG1pbmltdW1Db2xvckRpc3RhbmNlVG9EaXRoZXIgPSAwLCBjYWxjdWxhdGVFcnJvckxpa2VHSU1QID0gZmFsc2UpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3NldEtlcm5lbChrZXJuZWwpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XHJcbiAgICAgICAgdGhpcy5fbWluQ29sb3JEaXN0YW5jZSA9IG1pbmltdW1Db2xvckRpc3RhbmNlVG9EaXRoZXI7XHJcbiAgICAgICAgdGhpcy5fc2VycGVudGluZSA9IHNlcnBlbnRpbmU7XHJcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlRXJyb3JMaWtlR0lNUCA9IGNhbGN1bGF0ZUVycm9yTGlrZUdJTVA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vanNiaW4uY29tL2lYb2ZJamkvMi9lZGl0IGJ5IFBBRXpcclxuICAgICAqIGZpeGVkIHZlcnNpb24uIGl0IGRvZXNuJ3QgdXNlIGltYWdlIHBpeGVscyBhcyBlcnJvciBzdG9yYWdlLCBhbHNvIGl0IGRvZXNuJ3QgaGF2ZSAwLjMgKyAwLjMgKyAwLjMgKyAwLjMgPSAwIGVycm9yXHJcbiAgICAgKiBNdXRhdGVzIHBvaW50Q29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgICpxdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50QXJyYXkgPSBwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQb2ludCA9IG5ldyBQb2ludCgpO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCBlcnJvckxpbmVzID0gW107XHJcbiAgICAgICAgbGV0IGRpciA9IDE7XHJcbiAgICAgICAgbGV0IG1heEVycm9yTGluZXMgPSAxO1xyXG4gICAgICAgIC8vIGluaXRpYWwgZXJyb3IgbGluZXMgKG51bWJlciBpcyB0YWtlbiBmcm9tIGRpdGhlcmluZyBrZXJuZWwpXHJcbiAgICAgICAgZm9yIChjb25zdCBrZXJuZWwgb2YgdGhpcy5fa2VybmVsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbEVycm9yTGluZXMgPSBrZXJuZWxbMl0gKyAxO1xyXG4gICAgICAgICAgICBpZiAobWF4RXJyb3JMaW5lcyA8IGtlcm5lbEVycm9yTGluZXMpXHJcbiAgICAgICAgICAgICAgICBtYXhFcnJvckxpbmVzID0ga2VybmVsRXJyb3JMaW5lcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhFcnJvckxpbmVzOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsbEVycm9yTGluZShlcnJvckxpbmVzW2ldID0gW10sIHdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIoaGVpZ2h0LCA5OSk7XHJcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkoeSkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzcyxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWx3YXlzIHNlcnBlbnRpbmVcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlcnBlbnRpbmUpXHJcbiAgICAgICAgICAgICAgICBkaXIgPSBkaXIgKiAtMTtcclxuICAgICAgICAgICAgY29uc3QgbG5pID0geSAqIHdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCB4U3RhcnQgPSBkaXIgPT09IDEgPyAwIDogd2lkdGggLSAxO1xyXG4gICAgICAgICAgICBjb25zdCB4RW5kID0gZGlyID09PSAxID8gd2lkdGggOiAtMTtcclxuICAgICAgICAgICAgLy8gY3ljbGljIHNoaWZ0IHdpdGggZXJhc2luZ1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsRXJyb3JMaW5lKGVycm9yTGluZXNbMF0sIHdpZHRoKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogd2h5IGl0IGlzIG5lZWRlZCB0byBjYXN0IHR5cGVzIGhlcmU/XHJcbiAgICAgICAgICAgIGVycm9yTGluZXMucHVzaChlcnJvckxpbmVzLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvckxpbmUgPSBlcnJvckxpbmVzWzBdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0geFN0YXJ0LCBpZHggPSBsbmkgKyB4U3RhcnQ7IHggIT09IHhFbmQ7IHggKz0gZGlyLCBpZHggKz0gZGlyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbWFnZSBwaXhlbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludEFycmF5W2lkeF07XHJcbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbFBvaW50ID0gbmV3IFV0aWxzLlBvaW50KCksXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yTGluZVt4XTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUG9pbnQuZnJvbShwb2ludCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb2ludCA9IFBvaW50LmNyZWF0ZUJ5UkdCQShpblJhbmdlMHRvMjU1Um91bmRlZChwb2ludC5yICsgZXJyb3JbMF0pLCBpblJhbmdlMHRvMjU1Um91bmRlZChwb2ludC5nICsgZXJyb3JbMV0pLCBpblJhbmdlMHRvMjU1Um91bmRlZChwb2ludC5iICsgZXJyb3JbMl0pLCBpblJhbmdlMHRvMjU1Um91bmRlZChwb2ludC5hICsgZXJyb3JbM10pKTtcclxuICAgICAgICAgICAgICAgIC8vIFJlZHVjZWQgcGl4ZWxcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhbGV0dGVQb2ludCA9IHBhbGV0dGUuZ2V0TmVhcmVzdENvbG9yKHRoaXMuX2Rpc3RhbmNlLCBjb3JyZWN0ZWRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBwb2ludC5mcm9tKHBhbGV0dGVQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAvLyBkaXRoZXJpbmcgc3RyZW5ndGhcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9taW5Db2xvckRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IHRoaXMuX2Rpc3RhbmNlLmNhbGN1bGF0ZU5vcm1hbGl6ZWQocG9pbnQsIHBhbGV0dGVQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCB0aGlzLl9taW5Db2xvckRpc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIENvbXBvbmVudCBkaXN0YW5jZVxyXG4gICAgICAgICAgICAgICAgbGV0IGVyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVnO1xyXG4gICAgICAgICAgICAgICAgbGV0IGViO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbGN1bGF0ZUVycm9yTGlrZUdJTVApIHtcclxuICAgICAgICAgICAgICAgICAgICBlciA9IGNvcnJlY3RlZFBvaW50LnIgLSBwYWxldHRlUG9pbnQucjtcclxuICAgICAgICAgICAgICAgICAgICBlZyA9IGNvcnJlY3RlZFBvaW50LmcgLSBwYWxldHRlUG9pbnQuZztcclxuICAgICAgICAgICAgICAgICAgICBlYiA9IGNvcnJlY3RlZFBvaW50LmIgLSBwYWxldHRlUG9pbnQuYjtcclxuICAgICAgICAgICAgICAgICAgICBlYSA9IGNvcnJlY3RlZFBvaW50LmEgLSBwYWxldHRlUG9pbnQuYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyID0gb3JpZ2luYWxQb2ludC5yIC0gcGFsZXR0ZVBvaW50LnI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWcgPSBvcmlnaW5hbFBvaW50LmcgLSBwYWxldHRlUG9pbnQuZztcclxuICAgICAgICAgICAgICAgICAgICBlYiA9IG9yaWdpbmFsUG9pbnQuYiAtIHBhbGV0dGVQb2ludC5iO1xyXG4gICAgICAgICAgICAgICAgICAgIGVhID0gb3JpZ2luYWxQb2ludC5hIC0gcGFsZXR0ZVBvaW50LmE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkU3RhcnQgPSBkaXIgPT09IDEgPyAwIDogdGhpcy5fa2VybmVsLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkRW5kID0gZGlyID09PSAxID8gdGhpcy5fa2VybmVsLmxlbmd0aCA6IC0xO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGRTdGFydDsgaSAhPT0gZEVuZDsgaSArPSBkaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MSA9IHRoaXMuX2tlcm5lbFtpXVsxXSAqIGRpcjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB5MSA9IHRoaXMuX2tlcm5lbFtpXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeDEgKyB4ID49IDAgJiYgeDEgKyB4IDwgd2lkdGggJiYgeTEgKyB5ID49IDAgJiYgeTEgKyB5IDwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLl9rZXJuZWxbaV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBlcnJvckxpbmVzW3kxXVt4MSArIHhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlWzBdID0gZVswXSArIGVyICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVsxXSA9IGVbMV0gKyBlZyAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbMl0gPSBlWzJdICsgZWIgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlWzNdID0gZVszXSArIGVhICogZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICBwb2ludENvbnRhaW5lcixcclxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2ZpbGxFcnJvckxpbmUoZXJyb3JMaW5lLCB3aWR0aCkge1xyXG4gICAgICAgIC8vIHNocmlua1xyXG4gICAgICAgIGlmIChlcnJvckxpbmUubGVuZ3RoID4gd2lkdGgpIHtcclxuICAgICAgICAgICAgZXJyb3JMaW5lLmxlbmd0aCA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXVzZSBleGlzdGluZyBhcnJheXNcclxuICAgICAgICBjb25zdCBsID0gZXJyb3JMaW5lLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yTGluZVtpXTtcclxuICAgICAgICAgICAgZXJyb3JbMF0gPSBlcnJvclsxXSA9IGVycm9yWzJdID0gZXJyb3JbM10gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgbWlzc2luZyBhcnJheXNcclxuICAgICAgICBmb3IgKGxldCBpID0gbDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgZXJyb3JMaW5lW2ldID0gWzAuMCwgMC4wLCAwLjAsIDAuMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldEtlcm5lbChrZXJuZWwpIHtcclxuICAgICAgICBzd2l0Y2ggKGtlcm5lbCkge1xyXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuRmxveWRTdGVpbmJlcmc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgWzcgLyAxNiwgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzMgLyAxNiwgLTEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs1IC8gMTYsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gMTYsIDEsIDFdLFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuRmFsc2VGbG95ZFN0ZWluYmVyZzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDgsIDEsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFszIC8gOCwgMCwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyA4LCAxLCAxXSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlN0dWNraTpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbOCAvIDQyLCAxLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbNCAvIDQyLCAyLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDQyLCAtMiwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzQgLyA0MiwgLTEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs4IC8gNDIsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gNDIsIDEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gNDIsIDIsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gNDIsIC0yLCAyXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDQyLCAtMSwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzQgLyA0MiwgMCwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyA0MiwgMSwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA0MiwgMiwgMl0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5BdGtpbnNvbjpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDgsIDEsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gOCwgMiwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA4LCAtMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA4LCAwLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDgsIDEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gOCwgMCwgMl0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5KYXJ2aXM6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgWzcgLyA0OCwgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzUgLyA0OCwgMiwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzMgLyA0OCwgLTIsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs1IC8gNDgsIC0xLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbNyAvIDQ4LCAwLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbNSAvIDQ4LCAxLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDQ4LCAyLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDQ4LCAtMiwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzMgLyA0OCwgLTEsIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs1IC8gNDgsIDAsIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIFszIC8gNDgsIDEsIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gNDgsIDIsIDJdLFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuQnVya2VzOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2VybmVsID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFs4IC8gMzIsIDEsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gMzIsIDIsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gMzIsIC0yLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbNCAvIDMyLCAtMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzggLyAzMiwgMCwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzQgLyAzMiwgMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAzMiwgMiwgMV0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5TaWVycmE6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgWzUgLyAzMiwgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzMgLyAzMiwgMiwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAzMiwgLTIsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gMzIsIC0xLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbNSAvIDMyLCAwLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbNCAvIDMyLCAxLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDMyLCAyLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDMyLCAtMSwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzMgLyAzMiwgMCwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAzMiwgMSwgMl0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5Ud29TaWVycmE6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgWzQgLyAxNiwgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzMgLyAxNiwgMiwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyAxNiwgLTIsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gMTYsIC0xLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDE2LCAwLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDE2LCAxLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDE2LCAyLCAxXSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlNpZXJyYUxpdGU6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyA0LCAxLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDQsIC0xLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDQsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvckRpZmZ1c2lvbkFycmF5OiB1bmtub3duIGtlcm5lbCA9ICcgKyBrZXJuZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJleHBvcnQgY2xhc3MgQWJzdHJhY3RJbWFnZVF1YW50aXplciB7XHJcbiAgICBxdWFudGl6ZVN5bmMocG9pbnRDb250YWluZXIsIHBhbGV0dGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMucXVhbnRpemUocG9pbnRDb250YWluZXIsIHBhbGV0dGUpKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5wb2ludENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnBvaW50Q29udGFpbmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZVF1YW50aXplci5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGlxLnRzIC0gSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmV4cG9ydCB7IEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIgfSBmcm9tICcuL2ltYWdlUXVhbnRpemVyJztcclxuZXhwb3J0IHsgTmVhcmVzdENvbG9yIH0gZnJvbSAnLi9uZWFyZXN0Q29sb3InO1xyXG5leHBvcnQgeyBFcnJvckRpZmZ1c2lvbkFycmF5LCBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsIH0gZnJvbSAnLi9hcnJheSc7XHJcbmV4cG9ydCB7IEVycm9yRGlmZnVzaW9uUmllbWVyc21hIH0gZnJvbSAnLi9yaWVtZXJzbWEnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIG5lYXJlc3RDb2xvci50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIgfSBmcm9tICcuL2ltYWdlUXVhbnRpemVyJztcclxuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vdXRpbHMvcHJvZ3Jlc3NUcmFja2VyJztcclxuZXhwb3J0IGNsYXNzIE5lYXJlc3RDb2xvciBleHRlbmRzIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE11dGF0ZXMgcG9pbnRDb250YWluZXJcclxuICAgICAqL1xyXG4gICAgKnF1YW50aXplKHBvaW50Q29udGFpbmVyLCBwYWxldHRlKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHBvaW50Q29udGFpbmVyLmdldFdpZHRoKCk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcG9pbnRDb250YWluZXIuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIoaGVpZ2h0LCA5OSk7XHJcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkoeSkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzcyxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIGlkeCA9IHkgKiB3aWR0aDsgeCA8IHdpZHRoOyB4KyssIGlkeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbWFnZSBwaXhlbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludEFycmF5W2lkeF07XHJcbiAgICAgICAgICAgICAgICAvLyBSZWR1Y2VkIHBpeGVsXHJcbiAgICAgICAgICAgICAgICBwb2ludC5mcm9tKHBhbGV0dGUuZ2V0TmVhcmVzdENvbG9yKHRoaXMuX2Rpc3RhbmNlLCBwb2ludCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgcG9pbnRDb250YWluZXIsXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZWFyZXN0Q29sb3IuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBNSVQgTGljZW5zZVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXHJcbiAqIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXHJcbiAqIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxyXG4gKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTExcclxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xyXG4gKiBJTiBUSEUgU09GVFdBUkUuXHJcbiAqXHJcbiAqIHJpZW1lcnNtYS50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIgfSBmcm9tICcuL2ltYWdlUXVhbnRpemVyJztcclxuaW1wb3J0IHsgaGlsYmVydEN1cnZlIH0gZnJvbSAnLi9zcGFjZUZpbGxpbmdDdXJ2ZXMvaGlsYmVydEN1cnZlJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi91dGlscy9wb2ludCc7XHJcbmltcG9ydCB7IGluUmFuZ2UwdG8yNTVSb3VuZGVkIH0gZnJvbSAnLi4vdXRpbHMvYXJpdGhtZXRpYyc7XHJcbmV4cG9ydCBjbGFzcyBFcnJvckRpZmZ1c2lvblJpZW1lcnNtYSBleHRlbmRzIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGVycm9yUXVldWVTaXplID0gMTYsIGVycm9yUHJvcGFnYXRpb24gPSAxKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xyXG4gICAgICAgIHRoaXMuX2Vycm9yUXVldWVTaXplID0gZXJyb3JRdWV1ZVNpemU7XHJcbiAgICAgICAgdGhpcy5fd2VpZ2h0cyA9IEVycm9yRGlmZnVzaW9uUmllbWVyc21hLl9jcmVhdGVXZWlnaHRzKGVycm9yUHJvcGFnYXRpb24sIGVycm9yUXVldWVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTXV0YXRlcyBwb2ludENvbnRhaW5lclxyXG4gICAgICovXHJcbiAgICAqcXVhbnRpemUocG9pbnRDb250YWluZXIsIHBhbGV0dGUpIHtcclxuICAgICAgICBjb25zdCBwb2ludEFycmF5ID0gcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCBlcnJvclF1ZXVlID0gW107XHJcbiAgICAgICAgbGV0IGhlYWQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JRdWV1ZVNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBlcnJvclF1ZXVlW2ldID0geyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkKiBoaWxiZXJ0Q3VydmUod2lkdGgsIGhlaWdodCwgKHgsIHkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcCA9IHBvaW50QXJyYXlbeCArIHkgKiB3aWR0aF07XHJcbiAgICAgICAgICAgIGxldCByID0gcC5yO1xyXG4gICAgICAgICAgICBsZXQgZyA9IHAuZztcclxuICAgICAgICAgICAgbGV0IGIgPSBwLmI7XHJcbiAgICAgICAgICAgIGxldCBhID0gcC5hO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2Vycm9yUXVldWVTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IHRoaXMuX3dlaWdodHNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXJyb3JRdWV1ZVsoaSArIGhlYWQpICUgdGhpcy5fZXJyb3JRdWV1ZVNpemVdO1xyXG4gICAgICAgICAgICAgICAgciArPSBlLnIgKiB3ZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBnICs9IGUuZyAqIHdlaWdodDtcclxuICAgICAgICAgICAgICAgIGIgKz0gZS5iICogd2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgYSArPSBlLmEgKiB3ZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY29ycmVjdGVkUG9pbnQgPSBQb2ludC5jcmVhdGVCeVJHQkEoaW5SYW5nZTB0bzI1NVJvdW5kZWQociksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKGcpLCBpblJhbmdlMHRvMjU1Um91bmRlZChiKSwgaW5SYW5nZTB0bzI1NVJvdW5kZWQoYSkpO1xyXG4gICAgICAgICAgICBjb25zdCBxdWFudGl6ZWRQb2ludCA9IHBhbGV0dGUuZ2V0TmVhcmVzdENvbG9yKHRoaXMuX2Rpc3RhbmNlLCBjb3JyZWN0ZWRQb2ludCk7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBoZWFkIGFuZCBjYWxjdWxhdGUgdGFpbFxyXG4gICAgICAgICAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHRoaXMuX2Vycm9yUXVldWVTaXplO1xyXG4gICAgICAgICAgICBjb25zdCB0YWlsID0gKGhlYWQgKyB0aGlzLl9lcnJvclF1ZXVlU2l6ZSAtIDEpICUgdGhpcy5fZXJyb3JRdWV1ZVNpemU7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBlcnJvciB3aXRoIG5ldyB2YWx1ZVxyXG4gICAgICAgICAgICBlcnJvclF1ZXVlW3RhaWxdLnIgPSBwLnIgLSBxdWFudGl6ZWRQb2ludC5yO1xyXG4gICAgICAgICAgICBlcnJvclF1ZXVlW3RhaWxdLmcgPSBwLmcgLSBxdWFudGl6ZWRQb2ludC5nO1xyXG4gICAgICAgICAgICBlcnJvclF1ZXVlW3RhaWxdLmIgPSBwLmIgLSBxdWFudGl6ZWRQb2ludC5iO1xyXG4gICAgICAgICAgICBlcnJvclF1ZXVlW3RhaWxdLmEgPSBwLmEgLSBxdWFudGl6ZWRQb2ludC5hO1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgcG9pbnRcclxuICAgICAgICAgICAgcC5mcm9tKHF1YW50aXplZFBvaW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgIHBvaW50Q29udGFpbmVyLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogMTAwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NyZWF0ZVdlaWdodHMoZXJyb3JQcm9wYWdhdGlvbiwgZXJyb3JRdWV1ZVNpemUpIHtcclxuICAgICAgICBjb25zdCB3ZWlnaHRzID0gW107XHJcbiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IE1hdGguZXhwKE1hdGgubG9nKGVycm9yUXVldWVTaXplKSAvIChlcnJvclF1ZXVlU2l6ZSAtIDEpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbmV4dCA9IDE7IGkgPCBlcnJvclF1ZXVlU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHdlaWdodHNbaV0gPSAoKChuZXh0ICsgMC41KSB8IDApIC8gZXJyb3JRdWV1ZVNpemUpICogZXJyb3JQcm9wYWdhdGlvbjtcclxuICAgICAgICAgICAgbmV4dCAqPSBtdWx0aXBsaWVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2VpZ2h0cztcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaWVtZXJzbWEuanMubWFwIiwiaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvcHJvZ3Jlc3NUcmFja2VyJztcclxudmFyIERpcmVjdGlvbjtcclxuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcclxuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcclxuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJVUFwiXSA9IDFdID0gXCJVUFwiO1xyXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxFRlRcIl0gPSAyXSA9IFwiTEVGVFwiO1xyXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJJR0hUXCJdID0gM10gPSBcIlJJR0hUXCI7XHJcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiRE9XTlwiXSA9IDRdID0gXCJET1dOXCI7XHJcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcclxuZXhwb3J0IGZ1bmN0aW9uKiBoaWxiZXJ0Q3VydmUod2lkdGgsIGhlaWdodCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IG1heEJvdW5kID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XHJcbiAgICBjb25zdCBsZXZlbCA9IE1hdGguZmxvb3IoTWF0aC5sb2cobWF4Qm91bmQpIC8gTWF0aC5sb2coMikgKyAxKTtcclxuICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKHdpZHRoICogaGVpZ2h0LCA5OSk7XHJcbiAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgIHdpZHRoLFxyXG4gICAgICAgIGhlaWdodCxcclxuICAgICAgICBsZXZlbCxcclxuICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICB0cmFja2VyLFxyXG4gICAgICAgIGluZGV4OiAwLFxyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgIH07XHJcbiAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLlVQKTtcclxuICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5OT05FKTtcclxufVxyXG5mdW5jdGlvbiogd2Fsa0hpbGJlcnQoZGF0YSwgZGlyZWN0aW9uKSB7XHJcbiAgICBpZiAoZGF0YS5sZXZlbCA8IDEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKGRhdGEudHJhY2tlci5zaG91bGROb3RpZnkoZGF0YS5pbmRleCkpXHJcbiAgICAgICAgeWllbGQgeyBwcm9ncmVzczogZGF0YS50cmFja2VyLnByb2dyZXNzIH07XHJcbiAgICBkYXRhLmxldmVsLS07XHJcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLkxFRlQ6XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uVVApO1xyXG4gICAgICAgICAgICB2aXNpdChkYXRhLCBEaXJlY3Rpb24uUklHSFQpO1xyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLkxFRlQpO1xyXG4gICAgICAgICAgICB2aXNpdChkYXRhLCBEaXJlY3Rpb24uRE9XTik7XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uTEVGVCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5MRUZUKTtcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5ET1dOKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBEaXJlY3Rpb24uUklHSFQ6XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uRE9XTik7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5MRUZUKTtcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5VUCk7XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uUklHSFQpO1xyXG4gICAgICAgICAgICB2aXNpdChkYXRhLCBEaXJlY3Rpb24uUklHSFQpO1xyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLlVQKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBEaXJlY3Rpb24uVVA6XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uTEVGVCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5ET1dOKTtcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5VUCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uVVApO1xyXG4gICAgICAgICAgICB2aXNpdChkYXRhLCBEaXJlY3Rpb24uVVApO1xyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLlJJR0hUKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBEaXJlY3Rpb24uRE9XTjpcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5VUCk7XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uRE9XTik7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5MRUZUKTtcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5ET1dOKTtcclxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLkRPV04pO1xyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLkxFRlQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGRhdGEubGV2ZWwrKztcclxufVxyXG5mdW5jdGlvbiB2aXNpdChkYXRhLCBkaXJlY3Rpb24pIHtcclxuICAgIGlmIChkYXRhLnggPj0gMCAmJiBkYXRhLnggPCBkYXRhLndpZHRoICYmIGRhdGEueSA+PSAwICYmIGRhdGEueSA8IGRhdGEuaGVpZ2h0KSB7XHJcbiAgICAgICAgZGF0YS5jYWxsYmFjayhkYXRhLngsIGRhdGEueSk7XHJcbiAgICAgICAgZGF0YS5pbmRleCsrO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcclxuICAgICAgICBjYXNlIERpcmVjdGlvbi5MRUZUOlxyXG4gICAgICAgICAgICBkYXRhLngtLTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBEaXJlY3Rpb24uUklHSFQ6XHJcbiAgICAgICAgICAgIGRhdGEueCsrO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIERpcmVjdGlvbi5VUDpcclxuICAgICAgICAgICAgZGF0YS55LS07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLkRPV046XHJcbiAgICAgICAgICAgIGRhdGEueSsrO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaWxiZXJ0Q3VydmUuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5leHBvcnQgeyBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXIgfSBmcm9tICcuL3BhbGV0dGVRdWFudGl6ZXInO1xyXG5leHBvcnQgeyBOZXVRdWFudCB9IGZyb20gJy4vbmV1cXVhbnQvbmV1cXVhbnQnO1xyXG5leHBvcnQgeyBOZXVRdWFudEZsb2F0IH0gZnJvbSAnLi9uZXVxdWFudC9uZXVxdWFudEZsb2F0JztcclxuZXhwb3J0IHsgUkdCUXVhbnQgfSBmcm9tICcuL3JnYnF1YW50L3JnYnF1YW50JztcclxuZXhwb3J0IHsgQ29sb3JIaXN0b2dyYW0gfSBmcm9tICcuL3JnYnF1YW50L2NvbG9ySGlzdG9ncmFtJztcclxuZXhwb3J0IHsgV3VRdWFudCwgV3VDb2xvckN1YmUgfSBmcm9tICcuL3d1L3d1UXVhbnQnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKlxyXG4gKiBOZXVRdWFudCBOZXVyYWwtTmV0IFF1YW50aXphdGlvbiBBbGdvcml0aG1cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMTk5NCBBbnRob255IERla2tlclxyXG4gKlxyXG4gKiBORVVRVUFOVCBOZXVyYWwtTmV0IHF1YW50aXphdGlvbiBhbGdvcml0aG0gYnkgQW50aG9ueSBEZWtrZXIsIDE5OTQuIFNlZVxyXG4gKiBcIktvaG9uZW4gbmV1cmFsIG5ldHdvcmtzIGZvciBvcHRpbWFsIGNvbG91ciBxdWFudGl6YXRpb25cIiBpbiBcIk5ldHdvcms6XHJcbiAqIENvbXB1dGF0aW9uIGluIE5ldXJhbCBTeXN0ZW1zXCIgVm9sLiA1ICgxOTk0KSBwcCAzNTEtMzY3LiBmb3IgYSBkaXNjdXNzaW9uIG9mXHJcbiAqIHRoZSBhbGdvcml0aG0uXHJcbiAqXHJcbiAqIEFueSBwYXJ0eSBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoZXNlIGZpbGVzIGZyb20gdGhlIGF1dGhvciwgZGlyZWN0bHkgb3JcclxuICogaW5kaXJlY3RseSwgaXMgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIGEgZnVsbCBhbmQgdW5yZXN0cmljdGVkIGlycmV2b2NhYmxlLFxyXG4gKiB3b3JsZC13aWRlLCBwYWlkIHVwLCByb3lhbHR5LWZyZWUsIG5vbmV4Y2x1c2l2ZSByaWdodCBhbmQgbGljZW5zZSB0byBkZWFsIGluXHJcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCBpbmNsdWRpbmcgd2l0aG91dFxyXG4gKiBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLFxyXG4gKiBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgd2hvXHJcbiAqIHJlY2VpdmUgY29waWVzIGZyb20gYW55IHN1Y2ggcGFydHkgdG8gZG8gc28sIHdpdGggdGhlIG9ubHkgcmVxdWlyZW1lbnQgYmVpbmdcclxuICogdGhhdCB0aGlzIGNvcHlyaWdodCBub3RpY2UgcmVtYWluIGludGFjdC5cclxuICovXHJcbi8qKlxyXG4gKiBAcHJlc2VydmUgVHlwZVNjcmlwdCBwb3J0OlxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBuZXVxdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IFBhbGV0dGUgfSBmcm9tICcuLi8uLi91dGlscy9wYWxldHRlJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi91dGlscy9wb2ludCc7XHJcbmltcG9ydCB7IEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB9IGZyb20gJy4uL3BhbGV0dGVRdWFudGl6ZXInO1xyXG5pbXBvcnQgeyBQcm9ncmVzc1RyYWNrZXIgfSBmcm9tICcuLi8uLi91dGlscyc7XHJcbi8vIGJpYXMgZm9yIGNvbG91ciB2YWx1ZXNcclxuY29uc3QgbmV0d29ya0JpYXNTaGlmdCA9IDM7XHJcbmNsYXNzIE5ldXJvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSB0aGlzLmEgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIGlzIGEgZml4IGluIG9yaWdpbmFsIE5FVVFVQU5UIGJ5IEFudGhvbnkgRGVra2VyIChodHRwOi8vbWVtYmVycy5vemVtYWlsLmNvbS5hdS9+ZGVra2VyL05FVVFVQU5ULkhUTUwpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogciA9IE1hdGgubWluKDI1NSwgKG5ldXJvbi5yICsgKDEgPDwgKG5ldHdvcmtCaWFzU2hpZnQgLSAxKSkpID4+IG5ldHdvcmtCaWFzU2hpZnQpO1xyXG4gICAgICovXHJcbiAgICB0b1BvaW50KCkge1xyXG4gICAgICAgIHJldHVybiBQb2ludC5jcmVhdGVCeVJHQkEodGhpcy5yID4+IG5ldHdvcmtCaWFzU2hpZnQsIHRoaXMuZyA+PiBuZXR3b3JrQmlhc1NoaWZ0LCB0aGlzLmIgPj4gbmV0d29ya0JpYXNTaGlmdCwgdGhpcy5hID4+IG5ldHdvcmtCaWFzU2hpZnQpO1xyXG4gICAgfVxyXG4gICAgc3VidHJhY3QociwgZywgYiwgYSkge1xyXG4gICAgICAgIHRoaXMuciAtPSByIHwgMDtcclxuICAgICAgICB0aGlzLmcgLT0gZyB8IDA7XHJcbiAgICAgICAgdGhpcy5iIC09IGIgfCAwO1xyXG4gICAgICAgIHRoaXMuYSAtPSBhIHwgMDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgTmV1UXVhbnQgZXh0ZW5kcyBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyA9IDI1Nikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcclxuICAgICAgICB0aGlzLl9wb2ludEFycmF5ID0gW107XHJcbiAgICAgICAgdGhpcy5fc2FtcGxlRmFjdG9yID0gMTtcclxuICAgICAgICB0aGlzLl9uZXR3b3JrU2l6ZSA9IGNvbG9ycztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zZXRXaGl0ZVBvaW50KDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0LCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0KTtcclxuICAgIH1cclxuICAgIHNhbXBsZShwb2ludENvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkgPSB0aGlzLl9wb2ludEFycmF5LmNvbmNhdChwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCkpO1xyXG4gICAgfVxyXG4gICAgKnF1YW50aXplKCkge1xyXG4gICAgICAgIHRoaXMuX2luaXQoKTtcclxuICAgICAgICB5aWVsZCogdGhpcy5fbGVhcm4oKTtcclxuICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgIHBhbGV0dGU6IHRoaXMuX2J1aWxkUGFsZXR0ZSgpLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogMTAwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfaW5pdCgpIHtcclxuICAgICAgICB0aGlzLl9mcmVxID0gW107XHJcbiAgICAgICAgdGhpcy5fYmlhcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3JhZFBvd2VyID0gW107XHJcbiAgICAgICAgdGhpcy5fbmV0d29yayA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrW2ldID0gbmV3IE5ldXJvbigoaSA8PCAobmV0d29ya0JpYXNTaGlmdCArIDgpKSAvIHRoaXMuX25ldHdvcmtTaXplIHwgMCk7XHJcbiAgICAgICAgICAgIC8vIDEvdGhpcy5fbmV0d29ya1NpemVcclxuICAgICAgICAgICAgdGhpcy5fZnJlcVtpXSA9IE5ldVF1YW50Ll9pbml0aWFsQmlhcyAvIHRoaXMuX25ldHdvcmtTaXplIHwgMDtcclxuICAgICAgICAgICAgdGhpcy5fYmlhc1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWluIExlYXJuaW5nIExvb3BcclxuICAgICAqL1xyXG4gICAgKl9sZWFybigpIHtcclxuICAgICAgICBsZXQgc2FtcGxlRmFjdG9yID0gdGhpcy5fc2FtcGxlRmFjdG9yO1xyXG4gICAgICAgIGNvbnN0IHBvaW50c051bWJlciA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGlmIChwb2ludHNOdW1iZXIgPCBOZXVRdWFudC5fbWlucGljdHVyZWJ5dGVzKVxyXG4gICAgICAgICAgICBzYW1wbGVGYWN0b3IgPSAxO1xyXG4gICAgICAgIGNvbnN0IGFscGhhZGVjID0gMzAgKyAoc2FtcGxlRmFjdG9yIC0gMSkgLyAzIHwgMDtcclxuICAgICAgICBjb25zdCBwb2ludHNUb1NhbXBsZSA9IHBvaW50c051bWJlciAvIHNhbXBsZUZhY3RvciB8IDA7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gcG9pbnRzVG9TYW1wbGUgLyBOZXVRdWFudC5fbkN5Y2xlcyB8IDA7XHJcbiAgICAgICAgbGV0IGFscGhhID0gTmV1UXVhbnQuX2luaXRBbHBoYTtcclxuICAgICAgICBsZXQgcmFkaXVzID0gKHRoaXMuX25ldHdvcmtTaXplID4+IDMpICogTmV1UXVhbnQuX3JhZGl1c0JpYXM7XHJcbiAgICAgICAgbGV0IHJhZCA9IHJhZGl1cyA+PiBOZXVRdWFudC5fcmFkaXVzQmlhc1NoaWZ0O1xyXG4gICAgICAgIGlmIChyYWQgPD0gMSlcclxuICAgICAgICAgICAgcmFkID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhZFBvd2VyW2ldID0gYWxwaGEgKiAoKChyYWQgKiByYWQgLSBpICogaSkgKiBOZXVRdWFudC5fcmFkQmlhcykgLyAocmFkICogcmFkKSkgPj4+IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzdGVwO1xyXG4gICAgICAgIGlmIChwb2ludHNOdW1iZXIgPCBOZXVRdWFudC5fbWlucGljdHVyZWJ5dGVzKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwb2ludHNOdW1iZXIgJSBOZXVRdWFudC5fcHJpbWUxICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudC5fcHJpbWUxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocG9pbnRzTnVtYmVyICUgTmV1UXVhbnQuX3ByaW1lMikgIT09IDApIHtcclxuICAgICAgICAgICAgc3RlcCA9IE5ldVF1YW50Ll9wcmltZTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwb2ludHNOdW1iZXIgJSBOZXVRdWFudC5fcHJpbWUzKSAhPT0gMCkge1xyXG4gICAgICAgICAgICBzdGVwID0gTmV1UXVhbnQuX3ByaW1lMztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudC5fcHJpbWU0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihwb2ludHNUb1NhbXBsZSwgOTkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb2ludEluZGV4ID0gMDsgaSA8IHBvaW50c1RvU2FtcGxlOykge1xyXG4gICAgICAgICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkoaSkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzcyxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9wb2ludEFycmF5W3BvaW50SW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCBiID0gcG9pbnQuYiA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICBjb25zdCBnID0gcG9pbnQuZyA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICBjb25zdCByID0gcG9pbnQuciA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQuYSA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICBjb25zdCBuZXVyb25JbmRleCA9IHRoaXMuX2NvbnRlc3QoYiwgZywgciwgYSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsdGVyU2luZ2xlKGFscGhhLCBuZXVyb25JbmRleCwgYiwgZywgciwgYSk7XHJcbiAgICAgICAgICAgIGlmIChyYWQgIT09IDApXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbHRlck5laWdoYm91cihyYWQsIG5ldXJvbkluZGV4LCBiLCBnLCByLCBhKTtcclxuICAgICAgICAgICAgLyogYWx0ZXIgbmVpZ2hib3VycyAqL1xyXG4gICAgICAgICAgICBwb2ludEluZGV4ICs9IHN0ZXA7XHJcbiAgICAgICAgICAgIGlmIChwb2ludEluZGV4ID49IHBvaW50c051bWJlcilcclxuICAgICAgICAgICAgICAgIHBvaW50SW5kZXggLT0gcG9pbnRzTnVtYmVyO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA9PT0gMClcclxuICAgICAgICAgICAgICAgIGRlbHRhID0gMTtcclxuICAgICAgICAgICAgaWYgKGkgJSBkZWx0YSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWxwaGEgLT0gKGFscGhhIC8gYWxwaGFkZWMpIHwgMDtcclxuICAgICAgICAgICAgICAgIHJhZGl1cyAtPSAocmFkaXVzIC8gTmV1UXVhbnQuX3JhZGl1c0RlY3JlYXNlKSB8IDA7XHJcbiAgICAgICAgICAgICAgICByYWQgPSByYWRpdXMgPj4gTmV1UXVhbnQuX3JhZGl1c0JpYXNTaGlmdDtcclxuICAgICAgICAgICAgICAgIGlmIChyYWQgPD0gMSlcclxuICAgICAgICAgICAgICAgICAgICByYWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYWQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYWRQb3dlcltqXSA9IGFscGhhICogKCgocmFkICogcmFkIC0gaiAqIGopICogTmV1UXVhbnQuX3JhZEJpYXMpIC8gKHJhZCAqIHJhZCkpID4+PiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2J1aWxkUGFsZXR0ZSgpIHtcclxuICAgICAgICBjb25zdCBwYWxldHRlID0gbmV3IFBhbGV0dGUoKTtcclxuICAgICAgICB0aGlzLl9uZXR3b3JrLmZvckVhY2gobmV1cm9uID0+IHtcclxuICAgICAgICAgICAgcGFsZXR0ZS5hZGQobmV1cm9uLnRvUG9pbnQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGFsZXR0ZS5zb3J0KCk7XHJcbiAgICAgICAgcmV0dXJuIHBhbGV0dGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgYWRqYWNlbnQgbmV1cm9ucyBieSBwcmVjb21wdXRlZCBhbHBoYSooMS0oKGktaileMi9bcl1eMikpIGluIHJhZHBvd2VyW3xpLWp8XVxyXG4gICAgICovXHJcbiAgICBfYWx0ZXJOZWlnaGJvdXIocmFkLCBpLCBiLCBnLCByLCBhbCkge1xyXG4gICAgICAgIGxldCBsbyA9IGkgLSByYWQ7XHJcbiAgICAgICAgaWYgKGxvIDwgLTEpXHJcbiAgICAgICAgICAgIGxvID0gLTE7XHJcbiAgICAgICAgbGV0IGhpID0gaSArIHJhZDtcclxuICAgICAgICBpZiAoaGkgPiB0aGlzLl9uZXR3b3JrU2l6ZSlcclxuICAgICAgICAgICAgaGkgPSB0aGlzLl9uZXR3b3JrU2l6ZTtcclxuICAgICAgICBsZXQgaiA9IGkgKyAxO1xyXG4gICAgICAgIGxldCBrID0gaSAtIDE7XHJcbiAgICAgICAgbGV0IG0gPSAxO1xyXG4gICAgICAgIHdoaWxlIChqIDwgaGkgfHwgayA+IGxvKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLl9yYWRQb3dlclttKytdIC8gTmV1UXVhbnQuX2FscGhhUmFkQmlhcztcclxuICAgICAgICAgICAgaWYgKGogPCBoaSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuX25ldHdvcmtbaisrXTtcclxuICAgICAgICAgICAgICAgIHAuc3VidHJhY3QoYSAqIChwLnIgLSByKSwgYSAqIChwLmcgLSBnKSwgYSAqIChwLmIgLSBiKSwgYSAqIChwLmEgLSBhbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrID4gbG8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9uZXR3b3JrW2stLV07XHJcbiAgICAgICAgICAgICAgICBwLnN1YnRyYWN0KGEgKiAocC5yIC0gciksIGEgKiAocC5nIC0gZyksIGEgKiAocC5iIC0gYiksIGEgKiAocC5hIC0gYWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTW92ZSBuZXVyb24gaSB0b3dhcmRzIGJpYXNlZCAoYixnLHIpIGJ5IGZhY3RvciBhbHBoYVxyXG4gICAgICovXHJcbiAgICBfYWx0ZXJTaW5nbGUoYWxwaGEsIGksIGIsIGcsIHIsIGEpIHtcclxuICAgICAgICBhbHBoYSAvPSBOZXVRdWFudC5faW5pdEFscGhhO1xyXG4gICAgICAgIC8qIGFsdGVyIGhpdCBuZXVyb24gKi9cclxuICAgICAgICBjb25zdCBuID0gdGhpcy5fbmV0d29ya1tpXTtcclxuICAgICAgICBuLnN1YnRyYWN0KGFscGhhICogKG4uciAtIHIpLCBhbHBoYSAqIChuLmcgLSBnKSwgYWxwaGEgKiAobi5iIC0gYiksIGFscGhhICogKG4uYSAtIGEpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoIGZvciBiaWFzZWQgQkdSIHZhbHVlc1xyXG4gICAgICogZGVzY3JpcHRpb246XHJcbiAgICAgKiAgICBmaW5kcyBjbG9zZXN0IG5ldXJvbiAobWluIGRpc3QpIGFuZCB1cGRhdGVzIGZyZXFcclxuICAgICAqICAgIGZpbmRzIGJlc3QgbmV1cm9uIChtaW4gZGlzdC1iaWFzKSBhbmQgcmV0dXJucyBwb3NpdGlvblxyXG4gICAgICogICAgZm9yIGZyZXF1ZW50bHkgY2hvc2VuIG5ldXJvbnMsIGZyZXFbaV0gaXMgaGlnaCBhbmQgYmlhc1tpXSBpcyBuZWdhdGl2ZVxyXG4gICAgICogICAgYmlhc1tpXSA9IF9nYW1tYSooKDEvdGhpcy5fbmV0d29ya1NpemUpLWZyZXFbaV0pXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgZGlzdGFuY2UgZXF1YXRpb246XHJcbiAgICAgKiAgICAgICAgZGlzdCA9IGFicyhkUikgKyBhYnMoZEcpICsgYWJzKGRCKVxyXG4gICAgICovXHJcbiAgICBfY29udGVzdChiLCBnLCByLCBhKSB7XHJcbiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9ICgyNTUgKiA0KSA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgIGxldCBiZXN0ZCA9IH4oMSA8PCAzMSk7XHJcbiAgICAgICAgbGV0IGJlc3RiaWFzZCA9IGJlc3RkO1xyXG4gICAgICAgIGxldCBiZXN0cG9zID0gLTE7XHJcbiAgICAgICAgbGV0IGJlc3RiaWFzcG9zID0gYmVzdHBvcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25ldHdvcmtTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLl9kaXN0YW5jZS5jYWxjdWxhdGVOb3JtYWxpemVkKG4sIHsgciwgZywgYiwgYSB9KSAqIG11bHRpcGxpZXIgfCAwO1xyXG4gICAgICAgICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0ZCA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBiZXN0cG9zID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiaWFzZGlzdCA9IGRpc3QgLSAoKHRoaXMuX2JpYXNbaV0pID4+IChOZXVRdWFudC5faW5pdGlhbEJpYXNTaGlmdCAtIG5ldHdvcmtCaWFzU2hpZnQpKTtcclxuICAgICAgICAgICAgaWYgKGJpYXNkaXN0IDwgYmVzdGJpYXNkKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0Ymlhc2QgPSBiaWFzZGlzdDtcclxuICAgICAgICAgICAgICAgIGJlc3RiaWFzcG9zID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiZXRhZnJlcSA9ICh0aGlzLl9mcmVxW2ldID4+IE5ldVF1YW50Ll9iZXRhU2hpZnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmVxW2ldIC09IGJldGFmcmVxO1xyXG4gICAgICAgICAgICB0aGlzLl9iaWFzW2ldICs9IChiZXRhZnJlcSA8PCBOZXVRdWFudC5fZ2FtbWFTaGlmdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZyZXFbYmVzdHBvc10gKz0gTmV1UXVhbnQuX2JldGE7XHJcbiAgICAgICAgdGhpcy5fYmlhc1tiZXN0cG9zXSAtPSBOZXVRdWFudC5fYmV0YUdhbW1hO1xyXG4gICAgICAgIHJldHVybiBiZXN0Ymlhc3BvcztcclxuICAgIH1cclxufVxyXG4vKlxyXG4gZm91ciBwcmltZXMgbmVhciA1MDAgLSBhc3N1bWUgbm8gaW1hZ2UgaGFzIGEgbGVuZ3RoIHNvIGxhcmdlXHJcbiB0aGF0IGl0IGlzIGRpdmlzaWJsZSBieSBhbGwgZm91ciBwcmltZXNcclxuICovXHJcbk5ldVF1YW50Ll9wcmltZTEgPSA0OTk7XHJcbk5ldVF1YW50Ll9wcmltZTIgPSA0OTE7XHJcbk5ldVF1YW50Ll9wcmltZTMgPSA0ODc7XHJcbk5ldVF1YW50Ll9wcmltZTQgPSA1MDM7XHJcbk5ldVF1YW50Ll9taW5waWN0dXJlYnl0ZXMgPSBOZXVRdWFudC5fcHJpbWU0O1xyXG4vLyBuby4gb2YgbGVhcm5pbmcgY3ljbGVzXHJcbk5ldVF1YW50Ll9uQ3ljbGVzID0gMTAwO1xyXG4vLyBkZWZzIGZvciBmcmVxIGFuZCBiaWFzXHJcbk5ldVF1YW50Ll9pbml0aWFsQmlhc1NoaWZ0ID0gMTY7XHJcbi8vIGJpYXMgZm9yIGZyYWN0aW9uc1xyXG5OZXVRdWFudC5faW5pdGlhbEJpYXMgPSAoMSA8PCBOZXVRdWFudC5faW5pdGlhbEJpYXNTaGlmdCk7XHJcbk5ldVF1YW50Ll9nYW1tYVNoaWZ0ID0gMTA7XHJcbi8vIGdhbW1hID0gMTAyNFxyXG4vLyBUT0RPOiB3aHkgZ2FtbWEgaXMgbmV2ZXIgdXNlZD9cclxuLy8gcHJpdmF0ZSBzdGF0aWMgX2dhbW1hIDogbnVtYmVyICAgICA9ICgxIDw8IE5ldVF1YW50Ll9nYW1tYVNoaWZ0KTtcclxuTmV1UXVhbnQuX2JldGFTaGlmdCA9IDEwO1xyXG5OZXVRdWFudC5fYmV0YSA9IChOZXVRdWFudC5faW5pdGlhbEJpYXMgPj4gTmV1UXVhbnQuX2JldGFTaGlmdCk7XHJcbi8vIGJldGEgPSAxLzEwMjRcclxuTmV1UXVhbnQuX2JldGFHYW1tYSA9IChOZXVRdWFudC5faW5pdGlhbEJpYXMgPDwgKE5ldVF1YW50Ll9nYW1tYVNoaWZ0IC0gTmV1UXVhbnQuX2JldGFTaGlmdCkpO1xyXG4vKlxyXG4gKiBmb3IgMjU2IGNvbHMsIHJhZGl1cyBzdGFydHNcclxuICovXHJcbk5ldVF1YW50Ll9yYWRpdXNCaWFzU2hpZnQgPSA2O1xyXG4vLyBhdCAzMi4wIGJpYXNlZCBieSA2IGJpdHNcclxuTmV1UXVhbnQuX3JhZGl1c0JpYXMgPSAxIDw8IE5ldVF1YW50Ll9yYWRpdXNCaWFzU2hpZnQ7XHJcbi8vIGFuZCBkZWNyZWFzZXMgYnkgYSBmYWN0b3Igb2YgMS8zMCBlYWNoIGN5Y2xlXHJcbk5ldVF1YW50Ll9yYWRpdXNEZWNyZWFzZSA9IDMwO1xyXG4vKiBkZWZzIGZvciBkZWNyZWFzaW5nIGFscGhhIGZhY3RvciAqL1xyXG4vLyBhbHBoYSBzdGFydHMgYXQgMS4wXHJcbk5ldVF1YW50Ll9hbHBoYUJpYXNTaGlmdCA9IDEwO1xyXG4vLyBiaWFzZWQgYnkgMTAgYml0c1xyXG5OZXVRdWFudC5faW5pdEFscGhhID0gKDEgPDwgTmV1UXVhbnQuX2FscGhhQmlhc1NoaWZ0KTtcclxuLyogcmFkQmlhcyBhbmQgYWxwaGFSYWRCaWFzIHVzZWQgZm9yIHJhZHBvd2VyIGNhbGN1bGF0aW9uICovXHJcbk5ldVF1YW50Ll9yYWRCaWFzU2hpZnQgPSA4O1xyXG5OZXVRdWFudC5fcmFkQmlhcyA9IDEgPDwgTmV1UXVhbnQuX3JhZEJpYXNTaGlmdDtcclxuTmV1UXVhbnQuX2FscGhhUmFkQmlhc1NoaWZ0ID0gTmV1UXVhbnQuX2FscGhhQmlhc1NoaWZ0ICsgTmV1UXVhbnQuX3JhZEJpYXNTaGlmdDtcclxuTmV1UXVhbnQuX2FscGhhUmFkQmlhcyA9IDEgPDwgTmV1UXVhbnQuX2FscGhhUmFkQmlhc1NoaWZ0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXVxdWFudC5qcy5tYXAiLCIvKlxyXG4gKiBOZXVRdWFudEZsb2F0IE5ldXJhbC1OZXQgUXVhbnRpemF0aW9uIEFsZ29yaXRobVxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAxOTk0IEFudGhvbnkgRGVra2VyXHJcbiAqXHJcbiAqIE5FVVFVQU5UIE5ldXJhbC1OZXQgcXVhbnRpemF0aW9uIGFsZ29yaXRobSBieSBBbnRob255IERla2tlciwgMTk5NC4gU2VlXHJcbiAqIFwiS29ob25lbiBuZXVyYWwgbmV0d29ya3MgZm9yIG9wdGltYWwgY29sb3VyIHF1YW50aXphdGlvblwiIGluIFwiTmV0d29yazpcclxuICogQ29tcHV0YXRpb24gaW4gTmV1cmFsIFN5c3RlbXNcIiBWb2wuIDUgKDE5OTQpIHBwIDM1MS0zNjcuIGZvciBhIGRpc2N1c3Npb24gb2ZcclxuICogdGhlIGFsZ29yaXRobS5cclxuICpcclxuICogQW55IHBhcnR5IG9idGFpbmluZyBhIGNvcHkgb2YgdGhlc2UgZmlsZXMgZnJvbSB0aGUgYXV0aG9yLCBkaXJlY3RseSBvclxyXG4gKiBpbmRpcmVjdGx5LCBpcyBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgYSBmdWxsIGFuZCB1bnJlc3RyaWN0ZWQgaXJyZXZvY2FibGUsXHJcbiAqIHdvcmxkLXdpZGUsIHBhaWQgdXAsIHJveWFsdHktZnJlZSwgbm9uZXhjbHVzaXZlIHJpZ2h0IGFuZCBsaWNlbnNlIHRvIGRlYWwgaW5cclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIGluY2x1ZGluZyB3aXRob3V0XHJcbiAqIGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXHJcbiAqIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB3aG9cclxuICogcmVjZWl2ZSBjb3BpZXMgZnJvbSBhbnkgc3VjaCBwYXJ0eSB0byBkbyBzbywgd2l0aCB0aGUgb25seSByZXF1aXJlbWVudCBiZWluZ1xyXG4gKiB0aGF0IHRoaXMgY29weXJpZ2h0IG5vdGljZSByZW1haW4gaW50YWN0LlxyXG4gKi9cclxuLyoqXHJcbiAqIEBwcmVzZXJ2ZSBUeXBlU2NyaXB0IHBvcnQ6XHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIG5ldXF1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgUGFsZXR0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3BhbGV0dGUnO1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3V0aWxzL3BvaW50JztcclxuaW1wb3J0IHsgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIH0gZnJvbSAnLi4vcGFsZXR0ZVF1YW50aXplcic7XHJcbmltcG9ydCB7IFByb2dyZXNzVHJhY2tlciB9IGZyb20gJy4uLy4uL3V0aWxzJztcclxuLy8gYmlhcyBmb3IgY29sb3VyIHZhbHVlc1xyXG5jb25zdCBuZXR3b3JrQmlhc1NoaWZ0ID0gMztcclxuY2xhc3MgTmV1cm9uRmxvYXQge1xyXG4gICAgY29uc3RydWN0b3IoZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gdGhpcy5hID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGVyZSBpcyBhIGZpeCBpbiBvcmlnaW5hbCBORVVRVUFOVCBieSBBbnRob255IERla2tlciAoaHR0cDovL21lbWJlcnMub3plbWFpbC5jb20uYXUvfmRla2tlci9ORVVRVUFOVC5IVE1MKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHIgPSBNYXRoLm1pbigyNTUsIChuZXVyb24uciArICgxIDw8IChuZXR3b3JrQmlhc1NoaWZ0IC0gMSkpKSA+PiBuZXR3b3JrQmlhc1NoaWZ0KTtcclxuICAgICAqL1xyXG4gICAgdG9Qb2ludCgpIHtcclxuICAgICAgICByZXR1cm4gUG9pbnQuY3JlYXRlQnlSR0JBKHRoaXMuciA+PiBuZXR3b3JrQmlhc1NoaWZ0LCB0aGlzLmcgPj4gbmV0d29ya0JpYXNTaGlmdCwgdGhpcy5iID4+IG5ldHdvcmtCaWFzU2hpZnQsIHRoaXMuYSA+PiBuZXR3b3JrQmlhc1NoaWZ0KTtcclxuICAgIH1cclxuICAgIHN1YnRyYWN0KHIsIGcsIGIsIGEpIHtcclxuICAgICAgICB0aGlzLnIgLT0gcjtcclxuICAgICAgICB0aGlzLmcgLT0gZztcclxuICAgICAgICB0aGlzLmIgLT0gYjtcclxuICAgICAgICB0aGlzLmEgLT0gYTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgTmV1UXVhbnRGbG9hdCBleHRlbmRzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzID0gMjU2KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xyXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkgPSBbXTtcclxuICAgICAgICB0aGlzLl9zYW1wbGVGYWN0b3IgPSAxO1xyXG4gICAgICAgIHRoaXMuX25ldHdvcmtTaXplID0gY29sb3JzO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnNldFdoaXRlUG9pbnQoMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0LCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQpO1xyXG4gICAgfVxyXG4gICAgc2FtcGxlKHBvaW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRBcnJheSA9IHRoaXMuX3BvaW50QXJyYXkuY29uY2F0KHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKSk7XHJcbiAgICB9XHJcbiAgICAqcXVhbnRpemUoKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdCgpO1xyXG4gICAgICAgIHlpZWxkKiB0aGlzLl9sZWFybigpO1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgcGFsZXR0ZTogdGhpcy5fYnVpbGRQYWxldHRlKCksXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9pbml0KCkge1xyXG4gICAgICAgIHRoaXMuX2ZyZXEgPSBbXTtcclxuICAgICAgICB0aGlzLl9iaWFzID0gW107XHJcbiAgICAgICAgdGhpcy5fcmFkUG93ZXIgPSBbXTtcclxuICAgICAgICB0aGlzLl9uZXR3b3JrID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9uZXR3b3JrU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtbaV0gPSBuZXcgTmV1cm9uRmxvYXQoKGkgPDwgKG5ldHdvcmtCaWFzU2hpZnQgKyA4KSkgLyB0aGlzLl9uZXR3b3JrU2l6ZSk7XHJcbiAgICAgICAgICAgIC8vIDEvdGhpcy5fbmV0d29ya1NpemVcclxuICAgICAgICAgICAgdGhpcy5fZnJlcVtpXSA9IE5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzIC8gdGhpcy5fbmV0d29ya1NpemU7XHJcbiAgICAgICAgICAgIHRoaXMuX2JpYXNbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFpbiBMZWFybmluZyBMb29wXHJcbiAgICAgKi9cclxuICAgICpfbGVhcm4oKSB7XHJcbiAgICAgICAgbGV0IHNhbXBsZUZhY3RvciA9IHRoaXMuX3NhbXBsZUZhY3RvcjtcclxuICAgICAgICBjb25zdCBwb2ludHNOdW1iZXIgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aDtcclxuICAgICAgICBpZiAocG9pbnRzTnVtYmVyIDwgTmV1UXVhbnRGbG9hdC5fbWlucGljdHVyZWJ5dGVzKVxyXG4gICAgICAgICAgICBzYW1wbGVGYWN0b3IgPSAxO1xyXG4gICAgICAgIGNvbnN0IGFscGhhZGVjID0gMzAgKyAoc2FtcGxlRmFjdG9yIC0gMSkgLyAzO1xyXG4gICAgICAgIGNvbnN0IHBvaW50c1RvU2FtcGxlID0gcG9pbnRzTnVtYmVyIC8gc2FtcGxlRmFjdG9yO1xyXG4gICAgICAgIGxldCBkZWx0YSA9IHBvaW50c1RvU2FtcGxlIC8gTmV1UXVhbnRGbG9hdC5fbkN5Y2xlcyB8IDA7XHJcbiAgICAgICAgbGV0IGFscGhhID0gTmV1UXVhbnRGbG9hdC5faW5pdEFscGhhO1xyXG4gICAgICAgIGxldCByYWRpdXMgPSAodGhpcy5fbmV0d29ya1NpemUgPj4gMykgKiBOZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzO1xyXG4gICAgICAgIGxldCByYWQgPSByYWRpdXMgPj4gTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhc1NoaWZ0O1xyXG4gICAgICAgIGlmIChyYWQgPD0gMSlcclxuICAgICAgICAgICAgcmFkID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhZFBvd2VyW2ldID0gYWxwaGEgKiAoKChyYWQgKiByYWQgLSBpICogaSkgKiBOZXVRdWFudEZsb2F0Ll9yYWRCaWFzKSAvIChyYWQgKiByYWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0ZXA7XHJcbiAgICAgICAgaWYgKHBvaW50c051bWJlciA8IE5ldVF1YW50RmxvYXQuX21pbnBpY3R1cmVieXRlcykge1xyXG4gICAgICAgICAgICBzdGVwID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocG9pbnRzTnVtYmVyICUgTmV1UXVhbnRGbG9hdC5fcHJpbWUxICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudEZsb2F0Ll9wcmltZTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwb2ludHNOdW1iZXIgJSBOZXVRdWFudEZsb2F0Ll9wcmltZTIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudEZsb2F0Ll9wcmltZTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwb2ludHNOdW1iZXIgJSBOZXVRdWFudEZsb2F0Ll9wcmltZTMpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudEZsb2F0Ll9wcmltZTM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGVwID0gTmV1UXVhbnRGbG9hdC5fcHJpbWU0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihwb2ludHNUb1NhbXBsZSwgOTkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb2ludEluZGV4ID0gMDsgaSA8IHBvaW50c1RvU2FtcGxlOykge1xyXG4gICAgICAgICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkoaSkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzcyxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9wb2ludEFycmF5W3BvaW50SW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCBiID0gcG9pbnQuYiA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICBjb25zdCBnID0gcG9pbnQuZyA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICBjb25zdCByID0gcG9pbnQuciA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQuYSA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICBjb25zdCBuZXVyb25JbmRleCA9IHRoaXMuX2NvbnRlc3QoYiwgZywgciwgYSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsdGVyU2luZ2xlKGFscGhhLCBuZXVyb25JbmRleCwgYiwgZywgciwgYSk7XHJcbiAgICAgICAgICAgIGlmIChyYWQgIT09IDApXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbHRlck5laWdoYm91cihyYWQsIG5ldXJvbkluZGV4LCBiLCBnLCByLCBhKTtcclxuICAgICAgICAgICAgLyogYWx0ZXIgbmVpZ2hib3VycyAqL1xyXG4gICAgICAgICAgICBwb2ludEluZGV4ICs9IHN0ZXA7XHJcbiAgICAgICAgICAgIGlmIChwb2ludEluZGV4ID49IHBvaW50c051bWJlcilcclxuICAgICAgICAgICAgICAgIHBvaW50SW5kZXggLT0gcG9pbnRzTnVtYmVyO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA9PT0gMClcclxuICAgICAgICAgICAgICAgIGRlbHRhID0gMTtcclxuICAgICAgICAgICAgaWYgKGkgJSBkZWx0YSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWxwaGEgLT0gKGFscGhhIC8gYWxwaGFkZWMpO1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzIC09IChyYWRpdXMgLyBOZXVRdWFudEZsb2F0Ll9yYWRpdXNEZWNyZWFzZSk7XHJcbiAgICAgICAgICAgICAgICByYWQgPSByYWRpdXMgPj4gTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhZCA8PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHJhZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJhZDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhZFBvd2VyW2pdID0gYWxwaGEgKiAoKChyYWQgKiByYWQgLSBqICogaikgKiBOZXVRdWFudEZsb2F0Ll9yYWRCaWFzKSAvIChyYWQgKiByYWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9idWlsZFBhbGV0dGUoKSB7XHJcbiAgICAgICAgY29uc3QgcGFsZXR0ZSA9IG5ldyBQYWxldHRlKCk7XHJcbiAgICAgICAgdGhpcy5fbmV0d29yay5mb3JFYWNoKG5ldXJvbiA9PiB7XHJcbiAgICAgICAgICAgIHBhbGV0dGUuYWRkKG5ldXJvbi50b1BvaW50KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBhbGV0dGUuc29ydCgpO1xyXG4gICAgICAgIHJldHVybiBwYWxldHRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIGFkamFjZW50IG5ldXJvbnMgYnkgcHJlY29tcHV0ZWQgYWxwaGEqKDEtKChpLWopXjIvW3JdXjIpKSBpbiByYWRwb3dlclt8aS1qfF1cclxuICAgICAqL1xyXG4gICAgX2FsdGVyTmVpZ2hib3VyKHJhZCwgaSwgYiwgZywgciwgYWwpIHtcclxuICAgICAgICBsZXQgbG8gPSBpIC0gcmFkO1xyXG4gICAgICAgIGlmIChsbyA8IC0xKVxyXG4gICAgICAgICAgICBsbyA9IC0xO1xyXG4gICAgICAgIGxldCBoaSA9IGkgKyByYWQ7XHJcbiAgICAgICAgaWYgKGhpID4gdGhpcy5fbmV0d29ya1NpemUpXHJcbiAgICAgICAgICAgIGhpID0gdGhpcy5fbmV0d29ya1NpemU7XHJcbiAgICAgICAgbGV0IGogPSBpICsgMTtcclxuICAgICAgICBsZXQgayA9IGkgLSAxO1xyXG4gICAgICAgIGxldCBtID0gMTtcclxuICAgICAgICB3aGlsZSAoaiA8IGhpIHx8IGsgPiBsbykge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5fcmFkUG93ZXJbbSsrXSAvIE5ldVF1YW50RmxvYXQuX2FscGhhUmFkQmlhcztcclxuICAgICAgICAgICAgaWYgKGogPCBoaSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuX25ldHdvcmtbaisrXTtcclxuICAgICAgICAgICAgICAgIHAuc3VidHJhY3QoYSAqIChwLnIgLSByKSwgYSAqIChwLmcgLSBnKSwgYSAqIChwLmIgLSBiKSwgYSAqIChwLmEgLSBhbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrID4gbG8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9uZXR3b3JrW2stLV07XHJcbiAgICAgICAgICAgICAgICBwLnN1YnRyYWN0KGEgKiAocC5yIC0gciksIGEgKiAocC5nIC0gZyksIGEgKiAocC5iIC0gYiksIGEgKiAocC5hIC0gYWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTW92ZSBuZXVyb24gaSB0b3dhcmRzIGJpYXNlZCAoYixnLHIpIGJ5IGZhY3RvciBhbHBoYVxyXG4gICAgICovXHJcbiAgICBfYWx0ZXJTaW5nbGUoYWxwaGEsIGksIGIsIGcsIHIsIGEpIHtcclxuICAgICAgICBhbHBoYSAvPSBOZXVRdWFudEZsb2F0Ll9pbml0QWxwaGE7XHJcbiAgICAgICAgLyogYWx0ZXIgaGl0IG5ldXJvbiAqL1xyXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9uZXR3b3JrW2ldO1xyXG4gICAgICAgIG4uc3VidHJhY3QoYWxwaGEgKiAobi5yIC0gciksIGFscGhhICogKG4uZyAtIGcpLCBhbHBoYSAqIChuLmIgLSBiKSwgYWxwaGEgKiAobi5hIC0gYSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2ggZm9yIGJpYXNlZCBCR1IgdmFsdWVzXHJcbiAgICAgKiBkZXNjcmlwdGlvbjpcclxuICAgICAqICAgIGZpbmRzIGNsb3Nlc3QgbmV1cm9uIChtaW4gZGlzdCkgYW5kIHVwZGF0ZXMgZnJlcVxyXG4gICAgICogICAgZmluZHMgYmVzdCBuZXVyb24gKG1pbiBkaXN0LWJpYXMpIGFuZCByZXR1cm5zIHBvc2l0aW9uXHJcbiAgICAgKiAgICBmb3IgZnJlcXVlbnRseSBjaG9zZW4gbmV1cm9ucywgZnJlcVtpXSBpcyBoaWdoIGFuZCBiaWFzW2ldIGlzIG5lZ2F0aXZlXHJcbiAgICAgKiAgICBiaWFzW2ldID0gX2dhbW1hKigoMS90aGlzLl9uZXR3b3JrU2l6ZSktZnJlcVtpXSlcclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBkaXN0YW5jZSBlcXVhdGlvbjpcclxuICAgICAqICAgICAgICBkaXN0ID0gYWJzKGRSKSArIGFicyhkRykgKyBhYnMoZEIpXHJcbiAgICAgKi9cclxuICAgIF9jb250ZXN0KGIsIGcsIHIsIGFsKSB7XHJcbiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9ICgyNTUgKiA0KSA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xyXG4gICAgICAgIGxldCBiZXN0ZCA9IH4oMSA8PCAzMSk7XHJcbiAgICAgICAgbGV0IGJlc3RiaWFzZCA9IGJlc3RkO1xyXG4gICAgICAgIGxldCBiZXN0cG9zID0gLTE7XHJcbiAgICAgICAgbGV0IGJlc3RiaWFzcG9zID0gYmVzdHBvcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25ldHdvcmtTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLl9kaXN0YW5jZS5jYWxjdWxhdGVOb3JtYWxpemVkKG4sIHsgciwgZywgYiwgYTogYWwgfSkgKiBtdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0ZCA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBiZXN0cG9zID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiaWFzZGlzdCA9IGRpc3QgLSAoKHRoaXMuX2JpYXNbaV0pID4+IChOZXVRdWFudEZsb2F0Ll9pbml0aWFsQmlhc1NoaWZ0IC0gbmV0d29ya0JpYXNTaGlmdCkpO1xyXG4gICAgICAgICAgICBpZiAoYmlhc2Rpc3QgPCBiZXN0Ymlhc2QpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RiaWFzZCA9IGJpYXNkaXN0O1xyXG4gICAgICAgICAgICAgICAgYmVzdGJpYXNwb3MgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJldGFmcmVxID0gKHRoaXMuX2ZyZXFbaV0gPj4gTmV1UXVhbnRGbG9hdC5fYmV0YVNoaWZ0KTtcclxuICAgICAgICAgICAgdGhpcy5fZnJlcVtpXSAtPSBiZXRhZnJlcTtcclxuICAgICAgICAgICAgdGhpcy5fYmlhc1tpXSArPSAoYmV0YWZyZXEgPDwgTmV1UXVhbnRGbG9hdC5fZ2FtbWFTaGlmdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZyZXFbYmVzdHBvc10gKz0gTmV1UXVhbnRGbG9hdC5fYmV0YTtcclxuICAgICAgICB0aGlzLl9iaWFzW2Jlc3Rwb3NdIC09IE5ldVF1YW50RmxvYXQuX2JldGFHYW1tYTtcclxuICAgICAgICByZXR1cm4gYmVzdGJpYXNwb3M7XHJcbiAgICB9XHJcbn1cclxuLypcclxuIGZvdXIgcHJpbWVzIG5lYXIgNTAwIC0gYXNzdW1lIG5vIGltYWdlIGhhcyBhIGxlbmd0aCBzbyBsYXJnZVxyXG4gdGhhdCBpdCBpcyBkaXZpc2libGUgYnkgYWxsIGZvdXIgcHJpbWVzXHJcbiAqL1xyXG5OZXVRdWFudEZsb2F0Ll9wcmltZTEgPSA0OTk7XHJcbk5ldVF1YW50RmxvYXQuX3ByaW1lMiA9IDQ5MTtcclxuTmV1UXVhbnRGbG9hdC5fcHJpbWUzID0gNDg3O1xyXG5OZXVRdWFudEZsb2F0Ll9wcmltZTQgPSA1MDM7XHJcbk5ldVF1YW50RmxvYXQuX21pbnBpY3R1cmVieXRlcyA9IE5ldVF1YW50RmxvYXQuX3ByaW1lNDtcclxuLy8gbm8uIG9mIGxlYXJuaW5nIGN5Y2xlc1xyXG5OZXVRdWFudEZsb2F0Ll9uQ3ljbGVzID0gMTAwO1xyXG4vLyBkZWZzIGZvciBmcmVxIGFuZCBiaWFzXHJcbk5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzU2hpZnQgPSAxNjtcclxuLy8gYmlhcyBmb3IgZnJhY3Rpb25zXHJcbk5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzID0gKDEgPDwgTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXNTaGlmdCk7XHJcbk5ldVF1YW50RmxvYXQuX2dhbW1hU2hpZnQgPSAxMDtcclxuLy8gZ2FtbWEgPSAxMDI0XHJcbi8vIFRPRE86IHdoeSBnYW1tYSBpcyBuZXZlciB1c2VkP1xyXG4vLyBwcml2YXRlIHN0YXRpYyBfZ2FtbWEgOiBudW1iZXIgICAgID0gKDEgPDwgTmV1UXVhbnRGbG9hdC5fZ2FtbWFTaGlmdCk7XHJcbk5ldVF1YW50RmxvYXQuX2JldGFTaGlmdCA9IDEwO1xyXG5OZXVRdWFudEZsb2F0Ll9iZXRhID0gKE5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzID4+IE5ldVF1YW50RmxvYXQuX2JldGFTaGlmdCk7XHJcbi8vIGJldGEgPSAxLzEwMjRcclxuTmV1UXVhbnRGbG9hdC5fYmV0YUdhbW1hID0gKE5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzIDw8IChOZXVRdWFudEZsb2F0Ll9nYW1tYVNoaWZ0IC0gTmV1UXVhbnRGbG9hdC5fYmV0YVNoaWZ0KSk7XHJcbi8qXHJcbiAqIGZvciAyNTYgY29scywgcmFkaXVzIHN0YXJ0c1xyXG4gKi9cclxuTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhc1NoaWZ0ID0gNjtcclxuLy8gYXQgMzIuMCBiaWFzZWQgYnkgNiBiaXRzXHJcbk5ldVF1YW50RmxvYXQuX3JhZGl1c0JpYXMgPSAxIDw8IE5ldVF1YW50RmxvYXQuX3JhZGl1c0JpYXNTaGlmdDtcclxuLy8gYW5kIGRlY3JlYXNlcyBieSBhIGZhY3RvciBvZiAxLzMwIGVhY2ggY3ljbGVcclxuTmV1UXVhbnRGbG9hdC5fcmFkaXVzRGVjcmVhc2UgPSAzMDtcclxuLyogZGVmcyBmb3IgZGVjcmVhc2luZyBhbHBoYSBmYWN0b3IgKi9cclxuLy8gYWxwaGEgc3RhcnRzIGF0IDEuMFxyXG5OZXVRdWFudEZsb2F0Ll9hbHBoYUJpYXNTaGlmdCA9IDEwO1xyXG4vLyBiaWFzZWQgYnkgMTAgYml0c1xyXG5OZXVRdWFudEZsb2F0Ll9pbml0QWxwaGEgPSAoMSA8PCBOZXVRdWFudEZsb2F0Ll9hbHBoYUJpYXNTaGlmdCk7XHJcbi8qIHJhZEJpYXMgYW5kIGFscGhhUmFkQmlhcyB1c2VkIGZvciByYWRwb3dlciBjYWxjdWxhdGlvbiAqL1xyXG5OZXVRdWFudEZsb2F0Ll9yYWRCaWFzU2hpZnQgPSA4O1xyXG5OZXVRdWFudEZsb2F0Ll9yYWRCaWFzID0gMSA8PCBOZXVRdWFudEZsb2F0Ll9yYWRCaWFzU2hpZnQ7XHJcbk5ldVF1YW50RmxvYXQuX2FscGhhUmFkQmlhc1NoaWZ0ID0gTmV1UXVhbnRGbG9hdC5fYWxwaGFCaWFzU2hpZnQgKyBOZXVRdWFudEZsb2F0Ll9yYWRCaWFzU2hpZnQ7XHJcbk5ldVF1YW50RmxvYXQuX2FscGhhUmFkQmlhcyA9IDEgPDwgTmV1UXVhbnRGbG9hdC5fYWxwaGFSYWRCaWFzU2hpZnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldXF1YW50RmxvYXQuanMubWFwIiwiZXhwb3J0IGNsYXNzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XHJcbiAgICBxdWFudGl6ZVN5bmMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLnF1YW50aXplKCkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnBhbGV0dGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wYWxldHRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWxldHRlUXVhbnRpemVyLmpzLm1hcCIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgTGVvbiBTb3Jva2luXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIENvbG9ySGlzdG9ncmFtLmpzIC0gYW4gaW1hZ2UgcXVhbnRpemF0aW9uIGxpYlxyXG4gKi9cclxuLyoqXHJcbiAqIEBwcmVzZXJ2ZSBUeXBlU2NyaXB0IHBvcnQ6XHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGNvbG9ySGlzdG9ncmFtLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgSHVlU3RhdGlzdGljcyB9IGZyb20gJy4uLy4uL3V0aWxzL2h1ZVN0YXRpc3RpY3MnO1xyXG5pbXBvcnQgeyBzdGFibGVTb3J0IH0gZnJvbSAnLi4vLi4vdXRpbHMvYXJpdGhtZXRpYyc7XHJcbmV4cG9ydCBjbGFzcyBDb2xvckhpc3RvZ3JhbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIGNvbG9ycykge1xyXG4gICAgICAgIC8vIDEgPSBieSBnbG9iYWwgcG9wdWxhdGlvbiwgMiA9IHN1YnJlZ2lvbiBwb3B1bGF0aW9uIHRocmVzaG9sZFxyXG4gICAgICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgICAvLyBpZiA+IDAsIGVuYWJsZXMgaHVlcyBzdGF0cyBhbmQgbWluLWNvbG9yIHJldGVudGlvbiBwZXIgZ3JvdXBcclxuICAgICAgICB0aGlzLl9taW5IdWVDb2xzID0gY29sb3JzIDw8IDI7IC8vIG9wdHMubWluSHVlQ29scyB8fCAwO1xyXG4gICAgICAgIC8vICMgb2YgaGlnaGVzdC1mcmVxdWVuY3kgY29sb3JzIHRvIHN0YXJ0IHdpdGggZm9yIHBhbGV0dGUgcmVkdWN0aW9uXHJcbiAgICAgICAgdGhpcy5faW5pdENvbG9ycyA9IGNvbG9ycyA8PCAyO1xyXG4gICAgICAgIC8vIEh1ZVN0YXRpc3RpY3MgaW5zdGFuY2VcclxuICAgICAgICB0aGlzLl9odWVTdGF0cyA9IG5ldyBIdWVTdGF0aXN0aWNzKENvbG9ySGlzdG9ncmFtLl9odWVHcm91cHMsIHRoaXMuX21pbkh1ZUNvbHMpO1xyXG4gICAgICAgIHRoaXMuX2hpc3RvZ3JhbSA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tbnVsbC1rZXl3b3JkXHJcbiAgICB9XHJcbiAgICBzYW1wbGUocG9pbnRDb250YWluZXIpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuX21ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvclN0YXRzMUQocG9pbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yU3RhdHMyRChwb2ludENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRJbXBvcnRhbmNlU29ydGVkQ29sb3JzSURYSTMyKCkge1xyXG4gICAgICAgIC8vIFRPRE86IGZpeCB0eXBpbmcgaXNzdWUgaW4gc3RhYmxlU29ydCBmdW5jXHJcbiAgICAgICAgY29uc3Qgc29ydGVkID0gc3RhYmxlU29ydChPYmplY3Qua2V5cyh0aGlzLl9oaXN0b2dyYW0pLCAoYSwgYikgPT4gdGhpcy5faGlzdG9ncmFtW2JdIC0gdGhpcy5faGlzdG9ncmFtW2FdKTtcclxuICAgICAgICBpZiAoc29ydGVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpZHhpMzI7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9tZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbENvbG9yc0xpbWl0ID0gTWF0aC5taW4oc29ydGVkLmxlbmd0aCwgdGhpcy5faW5pdENvbG9ycyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gc29ydGVkW2luaXRpYWxDb2xvcnNMaW1pdCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJlcSA9IHRoaXMuX2hpc3RvZ3JhbVtsYXN0XTtcclxuICAgICAgICAgICAgICAgIGlkeGkzMiA9IHNvcnRlZC5zbGljZSgwLCBpbml0aWFsQ29sb3JzTGltaXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkIGFueSBjdXQgb2ZmIGNvbG9ycyB3aXRoIHNhbWUgZnJlcSBhcyBsYXN0XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gaW5pdGlhbENvbG9yc0xpbWl0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gc29ydGVkLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBsZW4gJiYgdGhpcy5faGlzdG9ncmFtW3NvcnRlZFtwb3NdXSA9PT0gZnJlcSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkeGkzMi5wdXNoKHNvcnRlZFtwb3MrK10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaW5qZWN0IG1pbiBodWVncm91cCBjb2xvcnNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2h1ZVN0YXRzLmluamVjdEludG9BcnJheShpZHhpMzIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGlkeGkzMiA9IHNvcnRlZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmV0aGluayBlcnJvcnNcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG1ldGhvZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbnQzMi1pZnkgdmFsdWVzXHJcbiAgICAgICAgcmV0dXJuIGlkeGkzMi5tYXAoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuICt2O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gZ2xvYmFsIHRvcC1wb3B1bGF0aW9uXHJcbiAgICBfY29sb3JTdGF0czFEKHBvaW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgY29uc3QgaGlzdEcgPSB0aGlzLl9oaXN0b2dyYW07XHJcbiAgICAgICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBwb2ludEFycmF5Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHBvaW50QXJyYXlbaV0udWludDMyO1xyXG4gICAgICAgICAgICAvLyBjb2xsZWN0IGh1ZSBzdGF0c1xyXG4gICAgICAgICAgICB0aGlzLl9odWVTdGF0cy5jaGVjayhjb2wpO1xyXG4gICAgICAgICAgICBpZiAoY29sIGluIGhpc3RHKSB7XHJcbiAgICAgICAgICAgICAgICBoaXN0R1tjb2xdKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoaXN0R1tjb2xdID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHBvcHVsYXRpb24gdGhyZXNob2xkIHdpdGhpbiBzdWJyZWdpb25zXHJcbiAgICAvLyBGSVhNRTogdGhpcyBjYW4gb3Zlci1yZWR1Y2UgKGZldy9ubyBjb2xvcnMgc2FtZT8pLCBuZWVkIGEgd2F5IHRvIGtlZXBcclxuICAgIC8vIGltcG9ydGFudCBjb2xvcnMgdGhhdCBkb250IGV2ZXIgcmVhY2ggbG9jYWwgdGhyZXNob2xkcyAoZ3JhZGllbnRzPylcclxuICAgIF9jb2xvclN0YXRzMkQocG9pbnRDb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHBvaW50Q29udGFpbmVyLmdldFdpZHRoKCk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcG9pbnRDb250YWluZXIuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcclxuICAgICAgICBjb25zdCBib3hXID0gQ29sb3JIaXN0b2dyYW0uX2JveFNpemVbMF07XHJcbiAgICAgICAgY29uc3QgYm94SCA9IENvbG9ySGlzdG9ncmFtLl9ib3hTaXplWzFdO1xyXG4gICAgICAgIGNvbnN0IGFyZWEgPSBib3hXICogYm94SDtcclxuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuX21ha2VCb3hlcyh3aWR0aCwgaGVpZ2h0LCBib3hXLCBib3hIKTtcclxuICAgICAgICBjb25zdCBoaXN0RyA9IHRoaXMuX2hpc3RvZ3JhbTtcclxuICAgICAgICBib3hlcy5mb3JFYWNoKGJveCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBlZmZjID0gTWF0aC5yb3VuZCgoYm94LncgKiBib3guaCkgLyBhcmVhKSAqIENvbG9ySGlzdG9ncmFtLl9ib3hQaXhlbHM7XHJcbiAgICAgICAgICAgIGlmIChlZmZjIDwgMilcclxuICAgICAgICAgICAgICAgIGVmZmMgPSAyO1xyXG4gICAgICAgICAgICBjb25zdCBoaXN0TCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9pdGVyYXRlQm94KGJveCwgd2lkdGgsIChpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBwb2ludEFycmF5W2ldLnVpbnQzMjtcclxuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgaHVlIHN0YXRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9odWVTdGF0cy5jaGVjayhjb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbCBpbiBoaXN0Rykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpc3RHW2NvbF0rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbCBpbiBoaXN0TCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2hpc3RMW2NvbF0gPj0gZWZmYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0R1tjb2xdID0gaGlzdExbY29sXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoaXN0TFtjb2xdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gaW5qZWN0IG1pbiBodWVncm91cCBjb2xvcnNcclxuICAgICAgICB0aGlzLl9odWVTdGF0cy5pbmplY3RJbnRvRGljdGlvbmFyeShoaXN0Ryk7XHJcbiAgICB9XHJcbiAgICAvLyBpdGVyYXRlcyBAYmJveCB3aXRoaW4gYSBwYXJlbnQgcmVjdCBvZiB3aWR0aCBAd2lkOyBjYWxscyBAZm4sIHBhc3NpbmcgaW5kZXggd2l0aGluIHBhcmVudFxyXG4gICAgX2l0ZXJhdGVCb3goYmJveCwgd2lkLCBmbikge1xyXG4gICAgICAgIGNvbnN0IGIgPSBiYm94O1xyXG4gICAgICAgIGNvbnN0IGkwID0gYi55ICogd2lkICsgYi54O1xyXG4gICAgICAgIGNvbnN0IGkxID0gKGIueSArIGIuaCAtIDEpICogd2lkICsgKGIueCArIGIudyAtIDEpO1xyXG4gICAgICAgIGNvbnN0IGluY3IgPSB3aWQgLSBiLncgKyAxO1xyXG4gICAgICAgIGxldCBjbnQgPSAwO1xyXG4gICAgICAgIGxldCBpID0gaTA7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGkpO1xyXG4gICAgICAgICAgICBpICs9ICgrK2NudCAlIGIudyA9PT0gMCkgPyBpbmNyIDogMTtcclxuICAgICAgICB9IHdoaWxlIChpIDw9IGkxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogICAgcGFydGl0aW9ucyBhIHJlY3RhbmdsZSBvZiB3aWR0aCB4IGhlaWdodCBpbnRvXHJcbiAgICAgKiAgICBhcnJheSBvZiBib3hlcyBzdGVwWCB4IHN0ZXBZIChvciBsZXNzKVxyXG4gICAgICovXHJcbiAgICBfbWFrZUJveGVzKHdpZHRoLCBoZWlnaHQsIHN0ZXBYLCBzdGVwWSkge1xyXG4gICAgICAgIGNvbnN0IHdyZW0gPSB3aWR0aCAlIHN0ZXBYO1xyXG4gICAgICAgIGNvbnN0IGhyZW0gPSBoZWlnaHQgJSBzdGVwWTtcclxuICAgICAgICBjb25zdCB4ZW5kID0gd2lkdGggLSB3cmVtO1xyXG4gICAgICAgIGNvbnN0IHllbmQgPSBoZWlnaHQgLSBocmVtO1xyXG4gICAgICAgIGNvbnN0IGJveGVzQXJyYXkgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSBzdGVwWSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4ICs9IHN0ZXBYKSB7XHJcbiAgICAgICAgICAgICAgICBib3hlc0FycmF5LnB1c2goeyB4LCB5LCB3OiAoeCA9PT0geGVuZCA/IHdyZW0gOiBzdGVwWCksIGg6ICh5ID09PSB5ZW5kID8gaHJlbSA6IHN0ZXBZKSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYm94ZXNBcnJheTtcclxuICAgIH1cclxufVxyXG5Db2xvckhpc3RvZ3JhbS5fYm94U2l6ZSA9IFs2NCwgNjRdO1xyXG5Db2xvckhpc3RvZ3JhbS5fYm94UGl4ZWxzID0gMjtcclxuQ29sb3JIaXN0b2dyYW0uX2h1ZUdyb3VwcyA9IDEwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvckhpc3RvZ3JhbS5qcy5tYXAiLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIExlb24gU29yb2tpblxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBSR0JRdWFudC5qcyAtIGFuIGltYWdlIHF1YW50aXphdGlvbiBsaWJcclxuICovXHJcbi8qKlxyXG4gKiBAcHJlc2VydmUgVHlwZVNjcmlwdCBwb3J0OlxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiByZ2JxdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IFBhbGV0dGUgfSBmcm9tICcuLi8uLi91dGlscy9wYWxldHRlJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi91dGlscy9wb2ludCc7XHJcbmltcG9ydCB7IENvbG9ySGlzdG9ncmFtIH0gZnJvbSAnLi9jb2xvckhpc3RvZ3JhbSc7XHJcbmltcG9ydCB7IEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB9IGZyb20gJy4uL3BhbGV0dGVRdWFudGl6ZXInO1xyXG5pbXBvcnQgeyBzdGFibGVTb3J0IH0gZnJvbSAnLi4vLi4vdXRpbHMvYXJpdGhtZXRpYyc7XHJcbmltcG9ydCB7IFByb2dyZXNzVHJhY2tlciB9IGZyb20gJy4uLy4uL3V0aWxzJztcclxuY2xhc3MgUmVtb3ZlZENvbG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBjb2xvciwgZGlzdGFuY2UpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgIH1cclxufVxyXG4vLyBUT0RPOiBtYWtlIGlucHV0L291dHB1dCBpbWFnZSBhbmQgaW5wdXQvb3V0cHV0IHBhbGV0dGVzIHdpdGggaW5zdGFuY2VzIG9mIGNsYXNzIFBvaW50IG9ubHkhXHJcbmV4cG9ydCBjbGFzcyBSR0JRdWFudCBleHRlbmRzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzID0gMjU2LCBtZXRob2QgPSAyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xyXG4gICAgICAgIC8vIGRlc2lyZWQgZmluYWwgcGFsZXR0ZSBzaXplXHJcbiAgICAgICAgdGhpcy5fY29sb3JzID0gY29sb3JzO1xyXG4gICAgICAgIC8vIGhpc3RvZ3JhbSB0byBhY2N1bXVsYXRlXHJcbiAgICAgICAgdGhpcy5faGlzdG9ncmFtID0gbmV3IENvbG9ySGlzdG9ncmFtKG1ldGhvZCwgY29sb3JzKTtcclxuICAgICAgICB0aGlzLl9pbml0aWFsRGlzdGFuY2UgPSAwLjAxO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlSW5jcmVtZW50ID0gMC4wMDU7XHJcbiAgICB9XHJcbiAgICAvLyBnYXRoZXJzIGhpc3RvZ3JhbSBpbmZvXHJcbiAgICBzYW1wbGUoaW1hZ2UpIHtcclxuICAgICAgICAvKlxyXG4gICAgICAgICB2YXIgcG9pbnRBcnJheSA9IGltYWdlLmdldFBvaW50QXJyYXkoKSwgbWF4ID0gWzAsIDAsIDAsIDBdLCBtaW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcclxuICAgIFxyXG4gICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBvaW50QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgIHZhciBjb2xvciA9IHBvaW50QXJyYXlbaV07XHJcbiAgICAgICAgIGZvciAodmFyIGNvbXBvbmVudEluZGV4ID0gMDsgY29tcG9uZW50SW5kZXggPCA0OyBjb21wb25lbnRJbmRleCsrKSB7XHJcbiAgICAgICAgIGlmIChtYXhbY29tcG9uZW50SW5kZXhdIDwgY29sb3IucmdiYVtjb21wb25lbnRJbmRleF0pIG1heFtjb21wb25lbnRJbmRleF0gPSBjb2xvci5yZ2JhW2NvbXBvbmVudEluZGV4XTtcclxuICAgICAgICAgaWYgKG1pbltjb21wb25lbnRJbmRleF0gPiBjb2xvci5yZ2JhW2NvbXBvbmVudEluZGV4XSkgbWluW2NvbXBvbmVudEluZGV4XSA9IGNvbG9yLnJnYmFbY29tcG9uZW50SW5kZXhdO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdmFyIHJkID0gbWF4WzBdIC0gbWluWzBdLCBnZCA9IG1heFsxXSAtIG1pblsxXSwgYmQgPSBtYXhbMl0gLSBtaW5bMl0sIGFkID0gbWF4WzNdIC0gbWluWzNdO1xyXG4gICAgICAgICB0aGlzLl9kaXN0YW5jZS5zZXRXaGl0ZVBvaW50KHJkLCBnZCwgYmQsIGFkKTtcclxuICAgIFxyXG4gICAgICAgICB0aGlzLl9pbml0aWFsRGlzdGFuY2UgPSAoTWF0aC5zcXJ0KHJkICogcmQgKyBnZCAqIGdkICsgYmQgKiBiZCArIGFkICogYWQpIC8gTWF0aC5zcXJ0KDI1NSAqIDI1NSArIDI1NSAqIDI1NSArIDI1NSAqIDI1NSkpICogMC4wMTtcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oaXN0b2dyYW0uc2FtcGxlKGltYWdlKTtcclxuICAgIH1cclxuICAgIC8vIHJlZHVjZXMgaGlzdG9ncmFtIHRvIHBhbGV0dGUsIHJlbWFwcyAmIG1lbW9pemVzIHJlZHVjZWQgY29sb3JzXHJcbiAgICAqcXVhbnRpemUoKSB7XHJcbiAgICAgICAgY29uc3QgaWR4aTMyID0gdGhpcy5faGlzdG9ncmFtLmdldEltcG9ydGFuY2VTb3J0ZWRDb2xvcnNJRFhJMzIoKTtcclxuICAgICAgICBpZiAoaWR4aTMyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbG9ycyBpbiBpbWFnZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCogdGhpcy5fYnVpbGRQYWxldHRlKGlkeGkzMik7XHJcbiAgICB9XHJcbiAgICAvLyByZWR1Y2VzIHNpbWlsYXIgY29sb3JzIGZyb20gYW4gaW1wb3J0YW5jZS1zb3J0ZWQgVWludDMyIHJnYmEgYXJyYXlcclxuICAgICpfYnVpbGRQYWxldHRlKGlkeGkzMikge1xyXG4gICAgICAgIC8vIHJlZHVjZSBoaXN0b2dyYW0gdG8gY3JlYXRlIGluaXRpYWwgcGFsZXR0ZVxyXG4gICAgICAgIC8vIGJ1aWxkIGZ1bGwgcmdiIHBhbGV0dGVcclxuICAgICAgICBjb25zdCBwYWxldHRlID0gbmV3IFBhbGV0dGUoKTtcclxuICAgICAgICBjb25zdCBjb2xvckFycmF5ID0gcGFsZXR0ZS5nZXRQb2ludENvbnRhaW5lcigpLmdldFBvaW50QXJyYXkoKTtcclxuICAgICAgICBjb25zdCB1c2FnZUFycmF5ID0gbmV3IEFycmF5KGlkeGkzMi5sZW5ndGgpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOnByZWZlci1hcnJheS1saXRlcmFsXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHhpMzIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29sb3JBcnJheS5wdXNoKFBvaW50LmNyZWF0ZUJ5VWludDMyKGlkeGkzMltpXSkpO1xyXG4gICAgICAgICAgICB1c2FnZUFycmF5W2ldID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuID0gY29sb3JBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbWVtRGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCBwYWxMZW4gPSBsZW47XHJcbiAgICAgICAgbGV0IHRob2xkID0gdGhpcy5faW5pdGlhbERpc3RhbmNlO1xyXG4gICAgICAgIC8vIHBhbGV0dGUgYWxyZWFkeSBhdCBvciBiZWxvdyBkZXNpcmVkIGxlbmd0aFxyXG4gICAgICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKHBhbExlbiAtIHRoaXMuX2NvbG9ycywgOTkpO1xyXG4gICAgICAgIHdoaWxlIChwYWxMZW4gPiB0aGlzLl9jb2xvcnMpIHtcclxuICAgICAgICAgICAgbWVtRGlzdC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAvLyBpdGVyYXRlIHBhbGV0dGVcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZXIuc2hvdWxkTm90aWZ5KGxlbiAtIHBhbExlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodXNhZ2VBcnJheVtpXSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB4aSA9IGNvbG9yQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBpZiAoIXB4aSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2FnZUFycmF5W2pdID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBweGogPSBjb2xvckFycmF5W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICghcHhqKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlTm9ybWFsaXplZChweGksIHB4aik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCB0aG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBpbmRleCxyZ2IsZGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1EaXN0LnB1c2gobmV3IFJlbW92ZWRDb2xvcihqLCBweGosIGRpc3QpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2VBcnJheVtqXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbExlbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwYWxldHRlIHJlZHVjdGlvbiBwYXNzXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicGFsZXR0ZSBsZW5ndGg6IFwiICsgcGFsTGVuKTtcclxuICAgICAgICAgICAgLy8gaWYgcGFsZXR0ZSBpcyBzdGlsbCBtdWNoIGxhcmdlciB0aGFuIHRhcmdldCwgaW5jcmVtZW50IGJ5IGxhcmdlciBpbml0RGlzdFxyXG4gICAgICAgICAgICB0aG9sZCArPSAocGFsTGVuID4gdGhpcy5fY29sb3JzICogMykgPyB0aGlzLl9pbml0aWFsRGlzdGFuY2UgOiB0aGlzLl9kaXN0YW5jZUluY3JlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgcGFsZXR0ZSBpcyBvdmVyLXJlZHVjZWQsIHJlLWFkZCByZW1vdmVkIGNvbG9ycyB3aXRoIGxhcmdlc3QgZGlzdGFuY2VzIGZyb20gbGFzdCByb3VuZFxyXG4gICAgICAgIGlmIChwYWxMZW4gPCB0aGlzLl9jb2xvcnMpIHtcclxuICAgICAgICAgICAgLy8gc29ydCBkZXNjZW5kaW5nXHJcbiAgICAgICAgICAgIHN0YWJsZVNvcnQobWVtRGlzdCwgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiLmRpc3RhbmNlIC0gYS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBrID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKHBhbExlbiA8IHRoaXMuX2NvbG9ycyAmJiBrIDwgbWVtRGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRDb2xvciA9IG1lbURpc3Rba107XHJcbiAgICAgICAgICAgICAgICAvLyByZS1pbmplY3QgcmdiIGludG8gZmluYWwgcGFsZXR0ZVxyXG4gICAgICAgICAgICAgICAgdXNhZ2VBcnJheVtyZW1vdmVkQ29sb3IuaW5kZXhdID0gMTtcclxuICAgICAgICAgICAgICAgIHBhbExlbisrO1xyXG4gICAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2xvcnMgPSBjb2xvckFycmF5Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBjb2xvckluZGV4ID0gY29sb3JzIC0gMTsgY29sb3JJbmRleCA+PSAwOyBjb2xvckluZGV4LS0pIHtcclxuICAgICAgICAgICAgaWYgKHVzYWdlQXJyYXlbY29sb3JJbmRleF0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xvckluZGV4ICE9PSBjb2xvcnMgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBcnJheVtjb2xvckluZGV4XSA9IGNvbG9yQXJyYXlbY29sb3JzIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAtLWNvbG9ycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb2xvckFycmF5Lmxlbmd0aCA9IGNvbG9ycztcclxuICAgICAgICBwYWxldHRlLnNvcnQoKTtcclxuICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgIHBhbGV0dGUsXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZ2JxdWFudC5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIHd1UXVhbnQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBQYWxldHRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcGFsZXR0ZSc7XHJcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9pbnQnO1xyXG5pbXBvcnQgeyBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXIgfSBmcm9tICcuLi9wYWxldHRlUXVhbnRpemVyJztcclxuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xyXG5mdW5jdGlvbiBjcmVhdGVBcnJheTFEKGRpbWVuc2lvbjEpIHtcclxuICAgIGNvbnN0IGEgPSBbXTtcclxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZGltZW5zaW9uMTsgaysrKSB7XHJcbiAgICAgICAgYVtrXSA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheTREKGRpbWVuc2lvbjEsIGRpbWVuc2lvbjIsIGRpbWVuc2lvbjMsIGRpbWVuc2lvbjQpIHtcclxuICAgIGNvbnN0IGEgPSBuZXcgQXJyYXkoZGltZW5zaW9uMSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xyXG4gICAgICAgIGFbaV0gPSBuZXcgQXJyYXkoZGltZW5zaW9uMik7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW1lbnNpb24yOyBqKyspIHtcclxuICAgICAgICAgICAgYVtpXVtqXSA9IG5ldyBBcnJheShkaW1lbnNpb24zKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1lbnNpb24zOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGFbaV1bal1ba10gPSBuZXcgQXJyYXkoZGltZW5zaW9uNCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IGRpbWVuc2lvbjQ7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFbaV1bal1ba11bbF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXkzRChkaW1lbnNpb24xLCBkaW1lbnNpb24yLCBkaW1lbnNpb24zKSB7XHJcbiAgICBjb25zdCBhID0gbmV3IEFycmF5KGRpbWVuc2lvbjEpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1lbnNpb24xOyBpKyspIHtcclxuICAgICAgICBhW2ldID0gbmV3IEFycmF5KGRpbWVuc2lvbjIpO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9uMjsgaisrKSB7XHJcbiAgICAgICAgICAgIGFbaV1bal0gPSBuZXcgQXJyYXkoZGltZW5zaW9uMyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZGltZW5zaW9uMzsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBhW2ldW2pdW2tdID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59XHJcbmZ1bmN0aW9uIGZpbGxBcnJheTNEKGEsIGRpbWVuc2lvbjEsIGRpbWVuc2lvbjIsIGRpbWVuc2lvbjMsIHZhbHVlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xyXG4gICAgICAgIGFbaV0gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbjI7IGorKykge1xyXG4gICAgICAgICAgICBhW2ldW2pdID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZGltZW5zaW9uMzsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBhW2ldW2pdW2tdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmlsbEFycmF5MUQoYSwgZGltZW5zaW9uMSwgdmFsdWUpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uMTsgaSsrKSB7XHJcbiAgICAgICAgYVtpXSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBXdUNvbG9yQ3ViZSB7XHJcbn1cclxuZXhwb3J0IGNsYXNzIFd1UXVhbnQgZXh0ZW5kcyBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyA9IDI1Niwgc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbCA9IDUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XHJcbiAgICAgICAgdGhpcy5fc2V0UXVhbGl0eShzaWduaWZpY2FudEJpdHNQZXJDaGFubmVsKTtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplKGNvbG9ycyk7XHJcbiAgICB9XHJcbiAgICBzYW1wbGUoaW1hZ2UpIHtcclxuICAgICAgICBjb25zdCBwb2ludEFycmF5ID0gaW1hZ2UuZ2V0UG9pbnRBcnJheSgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gcG9pbnRBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkQ29sb3IocG9pbnRBcnJheVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3BpeGVscyA9IHRoaXMuX3BpeGVscy5jb25jYXQocG9pbnRBcnJheSk7XHJcbiAgICB9XHJcbiAgICAqcXVhbnRpemUoKSB7XHJcbiAgICAgICAgeWllbGQqIHRoaXMuX3ByZXBhcmVQYWxldHRlKCk7XHJcbiAgICAgICAgY29uc3QgcGFsZXR0ZSA9IG5ldyBQYWxldHRlKCk7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGVzIHBhbGV0dGVcclxuICAgICAgICBmb3IgKGxldCBwYWxldHRlSW5kZXggPSAwOyBwYWxldHRlSW5kZXggPCB0aGlzLl9jb2xvcnM7IHBhbGV0dGVJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdW1zW3BhbGV0dGVJbmRleF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSB0aGlzLl9zdW1zW3BhbGV0dGVJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fcmVkc1twYWxldHRlSW5kZXhdIC8gc3VtO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMuX2dyZWVuc1twYWxldHRlSW5kZXhdIC8gc3VtO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMuX2JsdWVzW3BhbGV0dGVJbmRleF0gLyBzdW07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gdGhpcy5fYWxwaGFzW3BhbGV0dGVJbmRleF0gLyBzdW07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IFBvaW50LmNyZWF0ZUJ5UkdCQShyIHwgMCwgZyB8IDAsIGIgfCAwLCBhIHwgMCk7XHJcbiAgICAgICAgICAgICAgICBwYWxldHRlLmFkZChjb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcGFsZXR0ZS5zb3J0KCk7XHJcbiAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICBwYWxldHRlLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogMTAwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAqX3ByZXBhcmVQYWxldHRlKCkge1xyXG4gICAgICAgIC8vIHByZXByb2Nlc3MgdGhlIGNvbG9yc1xyXG4gICAgICAgIHlpZWxkKiB0aGlzLl9jYWxjdWxhdGVNb21lbnRzKCk7XHJcbiAgICAgICAgbGV0IG5leHQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHZvbHVtZVZhcmlhbmNlID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMpO1xyXG4gICAgICAgIC8vIHByb2Nlc3NlcyB0aGUgY3ViZXNcclxuICAgICAgICBmb3IgKGxldCBjdWJlSW5kZXggPSAxOyBjdWJlSW5kZXggPCB0aGlzLl9jb2xvcnM7ICsrY3ViZUluZGV4KSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGN1dCBpcyBwb3NzaWJsZTsgbWFrZSBpdFxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3V0KHRoaXMuX2N1YmVzW25leHRdLCB0aGlzLl9jdWJlc1tjdWJlSW5kZXhdKSkge1xyXG4gICAgICAgICAgICAgICAgdm9sdW1lVmFyaWFuY2VbbmV4dF0gPSB0aGlzLl9jdWJlc1tuZXh0XS52b2x1bWUgPiAxID8gdGhpcy5fY2FsY3VsYXRlVmFyaWFuY2UodGhpcy5fY3ViZXNbbmV4dF0pIDogMC4wO1xyXG4gICAgICAgICAgICAgICAgdm9sdW1lVmFyaWFuY2VbY3ViZUluZGV4XSA9IHRoaXMuX2N1YmVzW2N1YmVJbmRleF0udm9sdW1lID4gMSA/IHRoaXMuX2NhbGN1bGF0ZVZhcmlhbmNlKHRoaXMuX2N1YmVzW2N1YmVJbmRleF0pIDogMC4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1dCB3YXMgbm90IHBvc3NpYmxlLCByZXZlcnQgdGhlIGluZGV4XHJcbiAgICAgICAgICAgICAgICB2b2x1bWVWYXJpYW5jZVtuZXh0XSA9IDAuMDtcclxuICAgICAgICAgICAgICAgIGN1YmVJbmRleC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5leHQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgdGVtcCA9IHZvbHVtZVZhcmlhbmNlWzBdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDw9IGN1YmVJbmRleDsgKytpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvbHVtZVZhcmlhbmNlW2luZGV4XSA+IHRlbXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdm9sdW1lVmFyaWFuY2VbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGVtcCA8PSAwLjApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9ycyA9IGN1YmVJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsb29rdXBSZWQgPSBbXTtcclxuICAgICAgICBjb25zdCBsb29rdXBHcmVlbiA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGxvb2t1cEJsdWUgPSBbXTtcclxuICAgICAgICBjb25zdCBsb29rdXBBbHBoYSA9IFtdO1xyXG4gICAgICAgIC8vIHByZWNhbGN1bGF0ZXMgbG9va3VwIHRhYmxlc1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5fY29sb3JzOyArK2spIHtcclxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gV3VRdWFudC5fdm9sdW1lKHRoaXMuX2N1YmVzW2tdLCB0aGlzLl93ZWlnaHRzKTtcclxuICAgICAgICAgICAgaWYgKHdlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxvb2t1cFJlZFtrXSA9IChXdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX21vbWVudHNSZWQpIC8gd2VpZ2h0KSB8IDA7XHJcbiAgICAgICAgICAgICAgICBsb29rdXBHcmVlbltrXSA9IChXdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX21vbWVudHNHcmVlbikgLyB3ZWlnaHQpIHwgMDtcclxuICAgICAgICAgICAgICAgIGxvb2t1cEJsdWVba10gPSAoV3VRdWFudC5fdm9sdW1lKHRoaXMuX2N1YmVzW2tdLCB0aGlzLl9tb21lbnRzQmx1ZSkgLyB3ZWlnaHQpIHwgMDtcclxuICAgICAgICAgICAgICAgIGxvb2t1cEFscGhhW2tdID0gKFd1UXVhbnQuX3ZvbHVtZSh0aGlzLl9jdWJlc1trXSwgdGhpcy5fbW9tZW50c0FscGhhKSAvIHdlaWdodCkgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9va3VwUmVkW2tdID0gMDtcclxuICAgICAgICAgICAgICAgIGxvb2t1cEdyZWVuW2tdID0gMDtcclxuICAgICAgICAgICAgICAgIGxvb2t1cEJsdWVba10gPSAwO1xyXG4gICAgICAgICAgICAgICAgbG9va3VwQWxwaGFba10gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlZHMgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyArIDEpO1xyXG4gICAgICAgIHRoaXMuX2dyZWVucyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XHJcbiAgICAgICAgdGhpcy5fYmx1ZXMgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyArIDEpO1xyXG4gICAgICAgIHRoaXMuX2FscGhhcyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XHJcbiAgICAgICAgdGhpcy5fc3VtcyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XHJcbiAgICAgICAgLy8gc2NhbnMgYW5kIGFkZHMgY29sb3JzXHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsID0gdGhpcy5fcGl4ZWxzLmxlbmd0aDsgaW5kZXggPCBsOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fcGl4ZWxzW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSAtMTtcclxuICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IG1hdGNoO1xyXG4gICAgICAgICAgICBsZXQgYmVzdERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgZm9yIChsZXQgbG9va3VwID0gMDsgbG9va3VwIDwgdGhpcy5fY29sb3JzOyBsb29rdXArKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRSZWQgPSBsb29rdXBSZWRbbG9va3VwXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kR3JlZW4gPSBsb29rdXBHcmVlbltsb29rdXBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRCbHVlID0gbG9va3VwQmx1ZVtsb29rdXBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRBbHBoYSA9IGxvb2t1cEFscGhhW2xvb2t1cF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlLmNhbGN1bGF0ZVJhdyhmb3VuZFJlZCwgZm91bmRHcmVlbiwgZm91bmRCbHVlLCBmb3VuZEFscGhhLCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IGJlc3REaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IGxvb2t1cDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZWRzW2Jlc3RNYXRjaF0gKz0gY29sb3IucjtcclxuICAgICAgICAgICAgdGhpcy5fZ3JlZW5zW2Jlc3RNYXRjaF0gKz0gY29sb3IuZztcclxuICAgICAgICAgICAgdGhpcy5fYmx1ZXNbYmVzdE1hdGNoXSArPSBjb2xvci5iO1xyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYXNbYmVzdE1hdGNoXSArPSBjb2xvci5hO1xyXG4gICAgICAgICAgICB0aGlzLl9zdW1zW2Jlc3RNYXRjaF0rKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWRkQ29sb3IoY29sb3IpIHtcclxuICAgICAgICBjb25zdCBiaXRzVG9SZW1vdmUgPSA4IC0gdGhpcy5fc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbDtcclxuICAgICAgICBjb25zdCBpbmRleFJlZCA9IChjb2xvci5yID4+IGJpdHNUb1JlbW92ZSkgKyAxO1xyXG4gICAgICAgIGNvbnN0IGluZGV4R3JlZW4gPSAoY29sb3IuZyA+PiBiaXRzVG9SZW1vdmUpICsgMTtcclxuICAgICAgICBjb25zdCBpbmRleEJsdWUgPSAoY29sb3IuYiA+PiBiaXRzVG9SZW1vdmUpICsgMTtcclxuICAgICAgICBjb25zdCBpbmRleEFscGhhID0gKGNvbG9yLmEgPj4gYml0c1RvUmVtb3ZlKSArIDE7XHJcbiAgICAgICAgLy8gaWYoY29sb3IuYSA+IDEwKSB7XHJcbiAgICAgICAgdGhpcy5fd2VpZ2h0c1tpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSsrO1xyXG4gICAgICAgIHRoaXMuX21vbWVudHNSZWRbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gY29sb3IucjtcclxuICAgICAgICB0aGlzLl9tb21lbnRzR3JlZW5baW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gY29sb3IuZztcclxuICAgICAgICB0aGlzLl9tb21lbnRzQmx1ZVtpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSBjb2xvci5iO1xyXG4gICAgICAgIHRoaXMuX21vbWVudHNBbHBoYVtpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSBjb2xvci5hO1xyXG4gICAgICAgIHRoaXMuX21vbWVudHNbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gdGhpcy5fdGFibGVbY29sb3Iucl0gKyB0aGlzLl90YWJsZVtjb2xvci5nXSArIHRoaXMuX3RhYmxlW2NvbG9yLmJdICsgdGhpcy5fdGFibGVbY29sb3IuYV07XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgaGlzdG9ncmFtIHRvIGEgc2VyaWVzIG9mIF9tb21lbnRzLlxyXG4gICAgICovXHJcbiAgICAqX2NhbGN1bGF0ZU1vbWVudHMoKSB7XHJcbiAgICAgICAgY29uc3QgYXJlYSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFyZWFSZWQgPSBbXTtcclxuICAgICAgICBjb25zdCBhcmVhR3JlZW4gPSBbXTtcclxuICAgICAgICBjb25zdCBhcmVhQmx1ZSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFyZWFBbHBoYSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFyZWEyID0gW107XHJcbiAgICAgICAgY29uc3QgeGFyZWEgPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xyXG4gICAgICAgIGNvbnN0IHhhcmVhUmVkID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICBjb25zdCB4YXJlYUdyZWVuID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICBjb25zdCB4YXJlYUJsdWUgPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xyXG4gICAgICAgIGNvbnN0IHhhcmVhQWxwaGEgPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xyXG4gICAgICAgIGNvbnN0IHhhcmVhMiA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XHJcbiAgICAgICAgbGV0IHRyYWNrZXJQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIodGhpcy5fYWxwaGFNYXhTaWRlSW5kZXggKiB0aGlzLl9tYXhTaWRlSW5kZXgsIDk5KTtcclxuICAgICAgICBmb3IgKGxldCBhbHBoYUluZGV4ID0gMTsgYWxwaGFJbmRleCA8PSB0aGlzLl9hbHBoYU1heFNpZGVJbmRleDsgKythbHBoYUluZGV4KSB7XHJcbiAgICAgICAgICAgIGZpbGxBcnJheTNEKHhhcmVhLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgZmlsbEFycmF5M0QoeGFyZWFSZWQsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xyXG4gICAgICAgICAgICBmaWxsQXJyYXkzRCh4YXJlYUdyZWVuLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgZmlsbEFycmF5M0QoeGFyZWFCbHVlLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgZmlsbEFycmF5M0QoeGFyZWFBbHBoYSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgIGZpbGxBcnJheTNEKHhhcmVhMiwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHJlZEluZGV4ID0gMTsgcmVkSW5kZXggPD0gdGhpcy5fbWF4U2lkZUluZGV4OyArK3JlZEluZGV4LCArK3RyYWNrZXJQcm9ncmVzcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZXIuc2hvdWxkTm90aWZ5KHRyYWNrZXJQcm9ncmVzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWxsQXJyYXkxRChhcmVhLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgICAgICBmaWxsQXJyYXkxRChhcmVhUmVkLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgICAgICBmaWxsQXJyYXkxRChhcmVhR3JlZW4sIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgICAgIGZpbGxBcnJheTFEKGFyZWFCbHVlLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgICAgICBmaWxsQXJyYXkxRChhcmVhQWxwaGEsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgICAgIGZpbGxBcnJheTFEKGFyZWEyLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBncmVlbkluZGV4ID0gMTsgZ3JlZW5JbmRleCA8PSB0aGlzLl9tYXhTaWRlSW5kZXg7ICsrZ3JlZW5JbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZVJlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVHcmVlbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVCbHVlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZUFscGhhID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZTIgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYmx1ZUluZGV4ID0gMTsgYmx1ZUluZGV4IDw9IHRoaXMuX21heFNpZGVJbmRleDsgKytibHVlSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSArPSB0aGlzLl93ZWlnaHRzW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lUmVkICs9IHRoaXMuX21vbWVudHNSZWRbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVHcmVlbiArPSB0aGlzLl9tb21lbnRzR3JlZW5bYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVCbHVlICs9IHRoaXMuX21vbWVudHNCbHVlW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQWxwaGEgKz0gdGhpcy5fbW9tZW50c0FscGhhW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lMiArPSB0aGlzLl9tb21lbnRzW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhW2JsdWVJbmRleF0gKz0gbGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYVJlZFtibHVlSW5kZXhdICs9IGxpbmVSZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWFHcmVlbltibHVlSW5kZXhdICs9IGxpbmVHcmVlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYUJsdWVbYmx1ZUluZGV4XSArPSBsaW5lQmx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYUFscGhhW2JsdWVJbmRleF0gKz0gbGluZUFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhMltibHVlSW5kZXhdICs9IGxpbmUyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4YXJlYVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWFbYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGFyZWFSZWRbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYVJlZFtyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhUmVkW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhR3JlZW5bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYUdyZWVuW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWFHcmVlbltibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4YXJlYUJsdWVbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYUJsdWVbcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYUJsdWVbYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGFyZWFBbHBoYVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhQWxwaGFbcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYUFscGhhW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhMltyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhMltyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhMltibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93ZWlnaHRzW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fd2VpZ2h0c1thbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9tZW50c1JlZFthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX21vbWVudHNSZWRbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFSZWRbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbWVudHNHcmVlblthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX21vbWVudHNHcmVlblthbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYUdyZWVuW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb21lbnRzQmx1ZVthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX21vbWVudHNCbHVlW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhQmx1ZVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9tZW50c0FscGhhW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c0FscGhhW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhQWxwaGFbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbWVudHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl9tb21lbnRzW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhMltyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSB2b2x1bWUgb2YgdGhlIGN1YmUgaW4gYSBzcGVjaWZpYyBtb21lbnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBfdm9sdW1lRmxvYXQoY3ViZSwgbW9tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtXHJcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xyXG4gICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xyXG4gICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSkgLVxyXG4gICAgICAgICAgICAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIHZvbHVtZSBvZiB0aGUgY3ViZSBpbiBhIHNwZWNpZmljIG1vbWVudC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIF92b2x1bWUoY3ViZSwgbW9tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIFd1UXVhbnQuX3ZvbHVtZUZsb2F0KGN1YmUsIG1vbWVudCkgfCAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGxpdHMgdGhlIGN1YmUgaW4gZ2l2ZW4gcG9zaXRpb25dW2FuZCBjb2xvciBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBfdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIG1vbWVudCkge1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9hbHBoYTpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fcmVkOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSkgLVxyXG4gICAgICAgICAgICAgICAgICAgIChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fZ3JlZW46XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSkgLVxyXG4gICAgICAgICAgICAgICAgICAgIChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1pbmltdW1dKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX2JsdWU6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtwb3NpdGlvbl0gLVxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bcG9zaXRpb25dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW3Bvc2l0aW9uXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtwb3NpdGlvbl0pIC1cclxuICAgICAgICAgICAgICAgICAgICAobW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtwb3NpdGlvbl0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bcG9zaXRpb25dICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtwb3NpdGlvbl0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltcG9zc2libGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNwbGl0cyB0aGUgY3ViZSBpbiBhIGdpdmVuIGNvbG9yIGRpcmVjdGlvbiBhdCBpdHMgbWluaW11bS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIF9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCBtb21lbnQpIHtcclxuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX2FscGhhOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgtbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICgtbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fcmVkOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICgtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fZ3JlZW46XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9ibHVlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICgtbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aHkgaGVyZSBpcyByZXR1cm4gMCwgYW5kIGluIHRoaXMuX3RvcCB0aGVyZSBpcyBubyBkZWZhdWx0IGF0IGFsbCAobm93IGl0IGlzIHRocm93IGVycm9yKT9cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBzdGF0aXN0aWNhbCB2YXJpYW5jZSBmb3IgYSBnaXZlbiBjdWJlLlxyXG4gICAgICovXHJcbiAgICBfY2FsY3VsYXRlVmFyaWFuY2UoY3ViZSkge1xyXG4gICAgICAgIGNvbnN0IHZvbHVtZVJlZCA9IFd1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzUmVkKTtcclxuICAgICAgICBjb25zdCB2b2x1bWVHcmVlbiA9IFd1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzR3JlZW4pO1xyXG4gICAgICAgIGNvbnN0IHZvbHVtZUJsdWUgPSBXdVF1YW50Ll92b2x1bWUoY3ViZSwgdGhpcy5fbW9tZW50c0JsdWUpO1xyXG4gICAgICAgIGNvbnN0IHZvbHVtZUFscGhhID0gV3VRdWFudC5fdm9sdW1lKGN1YmUsIHRoaXMuX21vbWVudHNBbHBoYSk7XHJcbiAgICAgICAgY29uc3Qgdm9sdW1lTW9tZW50ID0gV3VRdWFudC5fdm9sdW1lRmxvYXQoY3ViZSwgdGhpcy5fbW9tZW50cyk7XHJcbiAgICAgICAgY29uc3Qgdm9sdW1lV2VpZ2h0ID0gV3VRdWFudC5fdm9sdW1lKGN1YmUsIHRoaXMuX3dlaWdodHMpO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdm9sdW1lUmVkICogdm9sdW1lUmVkICsgdm9sdW1lR3JlZW4gKiB2b2x1bWVHcmVlbiArIHZvbHVtZUJsdWUgKiB2b2x1bWVCbHVlICsgdm9sdW1lQWxwaGEgKiB2b2x1bWVBbHBoYTtcclxuICAgICAgICByZXR1cm4gdm9sdW1lTW9tZW50IC0gKGRpc3RhbmNlIC8gdm9sdW1lV2VpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIG9wdGltYWwgKG1heGltYWwpIHBvc2l0aW9uIGZvciB0aGUgY3V0LlxyXG4gICAgICovXHJcbiAgICBfbWF4aW1pemUoY3ViZSwgZGlyZWN0aW9uLCBmaXJzdCwgbGFzdCwgd2hvbGVSZWQsIHdob2xlR3JlZW4sIHdob2xlQmx1ZSwgd2hvbGVBbHBoYSwgd2hvbGVXZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBib3R0b21SZWQgPSBXdVF1YW50Ll9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCB0aGlzLl9tb21lbnRzUmVkKSB8IDA7XHJcbiAgICAgICAgY29uc3QgYm90dG9tR3JlZW4gPSBXdVF1YW50Ll9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCB0aGlzLl9tb21lbnRzR3JlZW4pIHwgMDtcclxuICAgICAgICBjb25zdCBib3R0b21CbHVlID0gV3VRdWFudC5fYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgdGhpcy5fbW9tZW50c0JsdWUpIHwgMDtcclxuICAgICAgICBjb25zdCBib3R0b21BbHBoYSA9IFd1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX21vbWVudHNBbHBoYSkgfCAwO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVdlaWdodCA9IFd1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX3dlaWdodHMpIHwgMDtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gMC4wO1xyXG4gICAgICAgIGxldCBjdXRQb3NpdGlvbiA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IHBvc2l0aW9uID0gZmlyc3Q7IHBvc2l0aW9uIDwgbGFzdDsgKytwb3NpdGlvbikge1xyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmVzIHRoZSBjdWJlIGN1dCBhdCBhIGNlcnRhaW4gcG9zaXRpb25cclxuICAgICAgICAgICAgbGV0IGhhbGZSZWQgPSBib3R0b21SZWQgKyBXdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fbW9tZW50c1JlZCk7XHJcbiAgICAgICAgICAgIGxldCBoYWxmR3JlZW4gPSBib3R0b21HcmVlbiArIFd1UXVhbnQuX3RvcChjdWJlLCBkaXJlY3Rpb24sIHBvc2l0aW9uLCB0aGlzLl9tb21lbnRzR3JlZW4pO1xyXG4gICAgICAgICAgICBsZXQgaGFsZkJsdWUgPSBib3R0b21CbHVlICsgV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX21vbWVudHNCbHVlKTtcclxuICAgICAgICAgICAgbGV0IGhhbGZBbHBoYSA9IGJvdHRvbUFscGhhICsgV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX21vbWVudHNBbHBoYSk7XHJcbiAgICAgICAgICAgIGxldCBoYWxmV2VpZ2h0ID0gYm90dG9tV2VpZ2h0ICsgV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX3dlaWdodHMpO1xyXG4gICAgICAgICAgICAvLyB0aGUgY3ViZSBjYW5ub3QgYmUgY3V0IGF0IGJvdHRvbSAodGhpcyB3b3VsZCBsZWFkIHRvIGVtcHR5IGN1YmUpXHJcbiAgICAgICAgICAgIGlmIChoYWxmV2VpZ2h0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFsZkRpc3RhbmNlID0gaGFsZlJlZCAqIGhhbGZSZWQgKyBoYWxmR3JlZW4gKiBoYWxmR3JlZW4gKyBoYWxmQmx1ZSAqIGhhbGZCbHVlICsgaGFsZkFscGhhICogaGFsZkFscGhhO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBoYWxmRGlzdGFuY2UgLyBoYWxmV2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaGFsZlJlZCA9IHdob2xlUmVkIC0gaGFsZlJlZDtcclxuICAgICAgICAgICAgICAgIGhhbGZHcmVlbiA9IHdob2xlR3JlZW4gLSBoYWxmR3JlZW47XHJcbiAgICAgICAgICAgICAgICBoYWxmQmx1ZSA9IHdob2xlQmx1ZSAtIGhhbGZCbHVlO1xyXG4gICAgICAgICAgICAgICAgaGFsZkFscGhhID0gd2hvbGVBbHBoYSAtIGhhbGZBbHBoYTtcclxuICAgICAgICAgICAgICAgIGhhbGZXZWlnaHQgPSB3aG9sZVdlaWdodCAtIGhhbGZXZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFsZldlaWdodCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbGZEaXN0YW5jZSA9IGhhbGZSZWQgKiBoYWxmUmVkICsgaGFsZkdyZWVuICogaGFsZkdyZWVuICsgaGFsZkJsdWUgKiBoYWxmQmx1ZSArIGhhbGZBbHBoYSAqIGhhbGZBbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wICs9IGhhbGZEaXN0YW5jZSAvIGhhbGZXZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAgPiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGVtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3V0UG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgbWF4OiByZXN1bHQsIHBvc2l0aW9uOiBjdXRQb3NpdGlvbiB9O1xyXG4gICAgfVxyXG4gICAgLy8gQ3V0cyBhIGN1YmUgd2l0aCBhbm90aGVyIG9uZS5cclxuICAgIF9jdXQoZmlyc3QsIHNlY29uZCkge1xyXG4gICAgICAgIGxldCBkaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3Qgd2hvbGVSZWQgPSBXdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNSZWQpO1xyXG4gICAgICAgIGNvbnN0IHdob2xlR3JlZW4gPSBXdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNHcmVlbik7XHJcbiAgICAgICAgY29uc3Qgd2hvbGVCbHVlID0gV3VRdWFudC5fdm9sdW1lKGZpcnN0LCB0aGlzLl9tb21lbnRzQmx1ZSk7XHJcbiAgICAgICAgY29uc3Qgd2hvbGVBbHBoYSA9IFd1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fbW9tZW50c0FscGhhKTtcclxuICAgICAgICBjb25zdCB3aG9sZVdlaWdodCA9IFd1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fd2VpZ2h0cyk7XHJcbiAgICAgICAgY29uc3QgcmVkID0gdGhpcy5fbWF4aW1pemUoZmlyc3QsIFd1UXVhbnQuX3JlZCwgZmlyc3QucmVkTWluaW11bSArIDEsIGZpcnN0LnJlZE1heGltdW0sIHdob2xlUmVkLCB3aG9sZUdyZWVuLCB3aG9sZUJsdWUsIHdob2xlQWxwaGEsIHdob2xlV2VpZ2h0KTtcclxuICAgICAgICBjb25zdCBncmVlbiA9IHRoaXMuX21heGltaXplKGZpcnN0LCBXdVF1YW50Ll9ncmVlbiwgZmlyc3QuZ3JlZW5NaW5pbXVtICsgMSwgZmlyc3QuZ3JlZW5NYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XHJcbiAgICAgICAgY29uc3QgYmx1ZSA9IHRoaXMuX21heGltaXplKGZpcnN0LCBXdVF1YW50Ll9ibHVlLCBmaXJzdC5ibHVlTWluaW11bSArIDEsIGZpcnN0LmJsdWVNYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XHJcbiAgICAgICAgY29uc3QgYWxwaGEgPSB0aGlzLl9tYXhpbWl6ZShmaXJzdCwgV3VRdWFudC5fYWxwaGEsIGZpcnN0LmFscGhhTWluaW11bSArIDEsIGZpcnN0LmFscGhhTWF4aW11bSwgd2hvbGVSZWQsIHdob2xlR3JlZW4sIHdob2xlQmx1ZSwgd2hvbGVBbHBoYSwgd2hvbGVXZWlnaHQpO1xyXG4gICAgICAgIGlmIChhbHBoYS5tYXggPj0gcmVkLm1heCAmJiBhbHBoYS5tYXggPj0gZ3JlZW4ubWF4ICYmIGFscGhhLm1heCA+PSBibHVlLm1heCkge1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBXdVF1YW50Ll9hbHBoYTtcclxuICAgICAgICAgICAgLy8gY2Fubm90IHNwbGl0IGVtcHR5IGN1YmVcclxuICAgICAgICAgICAgaWYgKGFscGhhLnBvc2l0aW9uIDwgMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyZWQubWF4ID49IGFscGhhLm1heCAmJiByZWQubWF4ID49IGdyZWVuLm1heCAmJiByZWQubWF4ID49IGJsdWUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBXdVF1YW50Ll9yZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZ3JlZW4ubWF4ID49IGFscGhhLm1heCAmJiBncmVlbi5tYXggPj0gcmVkLm1heCAmJiBncmVlbi5tYXggPj0gYmx1ZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFd1UXVhbnQuX2dyZWVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gV3VRdWFudC5fYmx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZWNvbmQucmVkTWF4aW11bSA9IGZpcnN0LnJlZE1heGltdW07XHJcbiAgICAgICAgc2Vjb25kLmdyZWVuTWF4aW11bSA9IGZpcnN0LmdyZWVuTWF4aW11bTtcclxuICAgICAgICBzZWNvbmQuYmx1ZU1heGltdW0gPSBmaXJzdC5ibHVlTWF4aW11bTtcclxuICAgICAgICBzZWNvbmQuYWxwaGFNYXhpbXVtID0gZmlyc3QuYWxwaGFNYXhpbXVtO1xyXG4gICAgICAgIC8vIGN1dHMgaW4gYSBjZXJ0YWluIGRpcmVjdGlvblxyXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fcmVkOlxyXG4gICAgICAgICAgICAgICAgc2Vjb25kLnJlZE1pbmltdW0gPSBmaXJzdC5yZWRNYXhpbXVtID0gcmVkLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLmdyZWVuTWluaW11bSA9IGZpcnN0LmdyZWVuTWluaW11bTtcclxuICAgICAgICAgICAgICAgIHNlY29uZC5ibHVlTWluaW11bSA9IGZpcnN0LmJsdWVNaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLmFscGhhTWluaW11bSA9IGZpcnN0LmFscGhhTWluaW11bTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX2dyZWVuOlxyXG4gICAgICAgICAgICAgICAgc2Vjb25kLmdyZWVuTWluaW11bSA9IGZpcnN0LmdyZWVuTWF4aW11bSA9IGdyZWVuLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLnJlZE1pbmltdW0gPSBmaXJzdC5yZWRNaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLmJsdWVNaW5pbXVtID0gZmlyc3QuYmx1ZU1pbmltdW07XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQuYWxwaGFNaW5pbXVtID0gZmlyc3QuYWxwaGFNaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fYmx1ZTpcclxuICAgICAgICAgICAgICAgIHNlY29uZC5ibHVlTWluaW11bSA9IGZpcnN0LmJsdWVNYXhpbXVtID0gYmx1ZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHNlY29uZC5yZWRNaW5pbXVtID0gZmlyc3QucmVkTWluaW11bTtcclxuICAgICAgICAgICAgICAgIHNlY29uZC5ncmVlbk1pbmltdW0gPSBmaXJzdC5ncmVlbk1pbmltdW07XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQuYWxwaGFNaW5pbXVtID0gZmlyc3QuYWxwaGFNaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fYWxwaGE6XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQuYWxwaGFNaW5pbXVtID0gZmlyc3QuYWxwaGFNYXhpbXVtID0gYWxwaGEucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQuYmx1ZU1pbmltdW0gPSBmaXJzdC5ibHVlTWluaW11bTtcclxuICAgICAgICAgICAgICAgIHNlY29uZC5yZWRNaW5pbXVtID0gZmlyc3QucmVkTWluaW11bTtcclxuICAgICAgICAgICAgICAgIHNlY29uZC5ncmVlbk1pbmltdW0gPSBmaXJzdC5ncmVlbk1pbmltdW07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lcyB0aGUgdm9sdW1lcyBhZnRlciBjdXRcclxuICAgICAgICBmaXJzdC52b2x1bWUgPSAoZmlyc3QucmVkTWF4aW11bSAtIGZpcnN0LnJlZE1pbmltdW0pICogKGZpcnN0LmdyZWVuTWF4aW11bSAtIGZpcnN0LmdyZWVuTWluaW11bSkgKiAoZmlyc3QuYmx1ZU1heGltdW0gLSBmaXJzdC5ibHVlTWluaW11bSkgKiAoZmlyc3QuYWxwaGFNYXhpbXVtIC0gZmlyc3QuYWxwaGFNaW5pbXVtKTtcclxuICAgICAgICBzZWNvbmQudm9sdW1lID0gKHNlY29uZC5yZWRNYXhpbXVtIC0gc2Vjb25kLnJlZE1pbmltdW0pICogKHNlY29uZC5ncmVlbk1heGltdW0gLSBzZWNvbmQuZ3JlZW5NaW5pbXVtKSAqIChzZWNvbmQuYmx1ZU1heGltdW0gLSBzZWNvbmQuYmx1ZU1pbmltdW0pICogKHNlY29uZC5hbHBoYU1heGltdW0gLSBzZWNvbmQuYWxwaGFNaW5pbXVtKTtcclxuICAgICAgICAvLyB0aGUgY3V0IHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZShjb2xvcnMpIHtcclxuICAgICAgICB0aGlzLl9jb2xvcnMgPSBjb2xvcnM7XHJcbiAgICAgICAgLy8gY3JlYXRlcyBhbGwgdGhlIF9jdWJlc1xyXG4gICAgICAgIHRoaXMuX2N1YmVzID0gW107XHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZXMgYWxsIHRoZSBfY3ViZXNcclxuICAgICAgICBmb3IgKGxldCBjdWJlSW5kZXggPSAwOyBjdWJlSW5kZXggPCBjb2xvcnM7IGN1YmVJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1YmVzW2N1YmVJbmRleF0gPSBuZXcgV3VDb2xvckN1YmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzZXRzIHRoZSByZWZlcmVuY2UgbWluaW11bXNcclxuICAgICAgICB0aGlzLl9jdWJlc1swXS5yZWRNaW5pbXVtID0gMDtcclxuICAgICAgICB0aGlzLl9jdWJlc1swXS5ncmVlbk1pbmltdW0gPSAwO1xyXG4gICAgICAgIHRoaXMuX2N1YmVzWzBdLmJsdWVNaW5pbXVtID0gMDtcclxuICAgICAgICB0aGlzLl9jdWJlc1swXS5hbHBoYU1pbmltdW0gPSAwO1xyXG4gICAgICAgIC8vIHJlc2V0cyB0aGUgcmVmZXJlbmNlIG1heGltdW1zXHJcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0ucmVkTWF4aW11bSA9IHRoaXMuX21heFNpZGVJbmRleDtcclxuICAgICAgICB0aGlzLl9jdWJlc1swXS5ncmVlbk1heGltdW0gPSB0aGlzLl9tYXhTaWRlSW5kZXg7XHJcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0uYmx1ZU1heGltdW0gPSB0aGlzLl9tYXhTaWRlSW5kZXg7XHJcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0uYWxwaGFNYXhpbXVtID0gdGhpcy5fYWxwaGFNYXhTaWRlSW5kZXg7XHJcbiAgICAgICAgdGhpcy5fd2VpZ2h0cyA9IGNyZWF0ZUFycmF5NEQodGhpcy5fYWxwaGFTaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fbW9tZW50c1JlZCA9IGNyZWF0ZUFycmF5NEQodGhpcy5fYWxwaGFTaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fbW9tZW50c0dyZWVuID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICB0aGlzLl9tb21lbnRzQmx1ZSA9IGNyZWF0ZUFycmF5NEQodGhpcy5fYWxwaGFTaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fbW9tZW50c0FscGhhID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICB0aGlzLl9tb21lbnRzID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICB0aGlzLl90YWJsZSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHRhYmxlSW5kZXggPSAwOyB0YWJsZUluZGV4IDwgMjU2OyArK3RhYmxlSW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGFibGVbdGFibGVJbmRleF0gPSB0YWJsZUluZGV4ICogdGFibGVJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxzID0gW107XHJcbiAgICB9XHJcbiAgICBfc2V0UXVhbGl0eShzaWduaWZpY2FudEJpdHNQZXJDaGFubmVsID0gNSkge1xyXG4gICAgICAgIHRoaXMuX3NpZ25pZmljYW50Qml0c1BlckNoYW5uZWwgPSBzaWduaWZpY2FudEJpdHNQZXJDaGFubmVsO1xyXG4gICAgICAgIHRoaXMuX21heFNpZGVJbmRleCA9IDEgPDwgdGhpcy5fc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbDtcclxuICAgICAgICB0aGlzLl9hbHBoYU1heFNpZGVJbmRleCA9IHRoaXMuX21heFNpZGVJbmRleDtcclxuICAgICAgICB0aGlzLl9zaWRlU2l6ZSA9IHRoaXMuX21heFNpZGVJbmRleCArIDE7XHJcbiAgICAgICAgdGhpcy5fYWxwaGFTaWRlU2l6ZSA9IHRoaXMuX2FscGhhTWF4U2lkZUluZGV4ICsgMTtcclxuICAgIH1cclxufVxyXG5XdVF1YW50Ll9hbHBoYSA9IDM7XHJcbld1UXVhbnQuX3JlZCA9IDI7XHJcbld1UXVhbnQuX2dyZWVuID0gMTtcclxuV3VRdWFudC5fYmx1ZSA9IDA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXd1UXVhbnQuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5leHBvcnQgeyBzc2ltIH0gZnJvbSAnLi9zc2ltJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgWSB9IGZyb20gJy4uL2NvbnN0YW50cy9idDcwOSc7XHJcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9yaHlzLWUvc3RydWN0dXJhbC1zaW1pbGFyaXR5XHJcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RydWN0dXJhbF9zaW1pbGFyaXR5XHJcbmNvbnN0IEsxID0gMC4wMTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuYW1pbmctY29udmVudGlvblxyXG5jb25zdCBLMiA9IDAuMDM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIHNzaW0oaW1hZ2UxLCBpbWFnZTIpIHtcclxuICAgIGlmIChpbWFnZTEuZ2V0SGVpZ2h0KCkgIT09IGltYWdlMi5nZXRIZWlnaHQoKSB8fCBpbWFnZTEuZ2V0V2lkdGgoKSAhPT0gaW1hZ2UyLmdldFdpZHRoKCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlcyBoYXZlIGRpZmZlcmVudCBzaXplcyEnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGJpdHNQZXJDb21wb25lbnQgPSA4O1xyXG4gICAgY29uc3QgTCA9ICgxIDw8IGJpdHNQZXJDb21wb25lbnQpIC0gMTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuYW1pbmctY29udmVudGlvblxyXG4gICAgY29uc3QgYzEgPSBNYXRoLnBvdygoSzEgKiBMKSwgMik7XHJcbiAgICBjb25zdCBjMiA9IE1hdGgucG93KChLMiAqIEwpLCAyKTtcclxuICAgIGxldCBudW1XaW5kb3dzID0gMDtcclxuICAgIGxldCBtc3NpbSA9IDAuMDtcclxuICAgIC8vIGNhbGN1bGF0ZSBzc2ltIGZvciBlYWNoIHdpbmRvd1xyXG4gICAgaXRlcmF0ZShpbWFnZTEsIGltYWdlMiwgKGx1bWFWYWx1ZXMxLCBsdW1hVmFsdWVzMiwgYXZlcmFnZUx1bWFWYWx1ZTEsIGF2ZXJhZ2VMdW1hVmFsdWUyKSA9PiB7XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHZhcmlhbmNlIGFuZCBjb3ZhcmlhbmNlXHJcbiAgICAgICAgbGV0IHNpZ3h5ID0gMC4wO1xyXG4gICAgICAgIGxldCBzaWdzcXggPSAwLjA7XHJcbiAgICAgICAgbGV0IHNpZ3NxeSA9IDAuMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGx1bWFWYWx1ZXMxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNpZ3NxeCArPSBNYXRoLnBvdygobHVtYVZhbHVlczFbaV0gLSBhdmVyYWdlTHVtYVZhbHVlMSksIDIpO1xyXG4gICAgICAgICAgICBzaWdzcXkgKz0gTWF0aC5wb3coKGx1bWFWYWx1ZXMyW2ldIC0gYXZlcmFnZUx1bWFWYWx1ZTIpLCAyKTtcclxuICAgICAgICAgICAgc2lneHkgKz0gKGx1bWFWYWx1ZXMxW2ldIC0gYXZlcmFnZUx1bWFWYWx1ZTEpICogKGx1bWFWYWx1ZXMyW2ldIC0gYXZlcmFnZUx1bWFWYWx1ZTIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBudW1QaXhlbHNJbldpbiA9IGx1bWFWYWx1ZXMxLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgc2lnc3F4IC89IG51bVBpeGVsc0luV2luO1xyXG4gICAgICAgIHNpZ3NxeSAvPSBudW1QaXhlbHNJbldpbjtcclxuICAgICAgICBzaWd4eSAvPSBudW1QaXhlbHNJbldpbjtcclxuICAgICAgICAvLyBwZXJmb3JtIHNzaW0gY2FsY3VsYXRpb24gb24gd2luZG93XHJcbiAgICAgICAgY29uc3QgbnVtZXJhdG9yID0gKDIgKiBhdmVyYWdlTHVtYVZhbHVlMSAqIGF2ZXJhZ2VMdW1hVmFsdWUyICsgYzEpICogKDIgKiBzaWd4eSArIGMyKTtcclxuICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IChNYXRoLnBvdyhhdmVyYWdlTHVtYVZhbHVlMSwgMikgKyBNYXRoLnBvdyhhdmVyYWdlTHVtYVZhbHVlMiwgMikgKyBjMSkgKiAoc2lnc3F4ICsgc2lnc3F5ICsgYzIpO1xyXG4gICAgICAgIGNvbnN0IHNzaW0gPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcclxuICAgICAgICBtc3NpbSArPSBzc2ltO1xyXG4gICAgICAgIG51bVdpbmRvd3MrKztcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1zc2ltIC8gbnVtV2luZG93cztcclxufVxyXG5mdW5jdGlvbiBpdGVyYXRlKGltYWdlMSwgaW1hZ2UyLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDg7XHJcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlMS5nZXRXaWR0aCgpO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UxLmdldEhlaWdodCgpO1xyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gd2luZG93U2l6ZSkge1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHggKz0gd2luZG93U2l6ZSkge1xyXG4gICAgICAgICAgICAvLyBhdm9pZCBvdXQtb2Ytd2lkdGgvaGVpZ2h0XHJcbiAgICAgICAgICAgIGNvbnN0IHdpbmRvd1dpZHRoID0gTWF0aC5taW4od2luZG93U2l6ZSwgd2lkdGggLSB4KTtcclxuICAgICAgICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gTWF0aC5taW4od2luZG93U2l6ZSwgaGVpZ2h0IC0geSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGx1bWFWYWx1ZXMxID0gY2FsY3VsYXRlTHVtYVZhbHVlc0ZvcldpbmRvdyhpbWFnZTEsIHgsIHksIHdpbmRvd1dpZHRoLCB3aW5kb3dIZWlnaHQpO1xyXG4gICAgICAgICAgICBjb25zdCBsdW1hVmFsdWVzMiA9IGNhbGN1bGF0ZUx1bWFWYWx1ZXNGb3JXaW5kb3coaW1hZ2UyLCB4LCB5LCB3aW5kb3dXaWR0aCwgd2luZG93SGVpZ2h0KTtcclxuICAgICAgICAgICAgY29uc3QgYXZlcmFnZUx1bWExID0gY2FsY3VsYXRlQXZlcmFnZUx1bWEobHVtYVZhbHVlczEpO1xyXG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlTHVtYTIgPSBjYWxjdWxhdGVBdmVyYWdlTHVtYShsdW1hVmFsdWVzMik7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGx1bWFWYWx1ZXMxLCBsdW1hVmFsdWVzMiwgYXZlcmFnZUx1bWExLCBhdmVyYWdlTHVtYTIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVMdW1hVmFsdWVzRm9yV2luZG93KGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBjb25zdCBwb2ludEFycmF5ID0gaW1hZ2UuZ2V0UG9pbnRBcnJheSgpO1xyXG4gICAgY29uc3QgbHVtYVZhbHVlcyA9IFtdO1xyXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xyXG4gICAgZm9yIChsZXQgaiA9IHk7IGogPCB5ICsgaGVpZ2h0OyBqKyspIHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSBqICogaW1hZ2UuZ2V0V2lkdGgoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0geDsgaSA8IHggKyB3aWR0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRBcnJheVtvZmZzZXQgKyBpXTtcclxuICAgICAgICAgICAgbHVtYVZhbHVlc1tjb3VudGVyXSA9IHBvaW50LnIgKiBZLlJFRCArIHBvaW50LmcgKiBZLkdSRUVOICsgcG9pbnQuYiAqIFkuQkxVRTtcclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsdW1hVmFsdWVzO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUF2ZXJhZ2VMdW1hKGx1bWFWYWx1ZXMpIHtcclxuICAgIGxldCBzdW1MdW1hID0gMC4wO1xyXG4gICAgZm9yIChjb25zdCBsdW1hIG9mIGx1bWFWYWx1ZXMpIHtcclxuICAgICAgICBzdW1MdW1hICs9IGx1bWE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VtTHVtYSAvIGx1bWFWYWx1ZXMubGVuZ3RoO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNzaW0uanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXMycmFkaWFucyhuKSB7XHJcbiAgICByZXR1cm4gbiAqIChNYXRoLlBJIC8gMTgwKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbWF4MyhhLCBiLCBjKSB7XHJcbiAgICBsZXQgbSA9IGE7XHJcbiAgICBpZiAobSA8IGIpXHJcbiAgICAgICAgbSA9IGI7XHJcbiAgICBpZiAobSA8IGMpXHJcbiAgICAgICAgbSA9IGM7XHJcbiAgICByZXR1cm4gbTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbWluMyhhLCBiLCBjKSB7XHJcbiAgICBsZXQgbSA9IGE7XHJcbiAgICBpZiAobSA+IGIpXHJcbiAgICAgICAgbSA9IGI7XHJcbiAgICBpZiAobSA+IGMpXHJcbiAgICAgICAgbSA9IGM7XHJcbiAgICByZXR1cm4gbTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaW50SW5SYW5nZSh2YWx1ZSwgbG93LCBoaWdoKSB7XHJcbiAgICBpZiAodmFsdWUgPiBoaWdoKVxyXG4gICAgICAgIHZhbHVlID0gaGlnaDtcclxuICAgIGlmICh2YWx1ZSA8IGxvdylcclxuICAgICAgICB2YWx1ZSA9IGxvdztcclxuICAgIHJldHVybiB2YWx1ZSB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGluUmFuZ2UwdG8yNTVSb3VuZGVkKG4pIHtcclxuICAgIG4gPSBNYXRoLnJvdW5kKG4pO1xyXG4gICAgaWYgKG4gPiAyNTUpXHJcbiAgICAgICAgbiA9IDI1NTtcclxuICAgIGVsc2UgaWYgKG4gPCAwKVxyXG4gICAgICAgIG4gPSAwO1xyXG4gICAgcmV0dXJuIG47XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGluUmFuZ2UwdG8yNTUobikge1xyXG4gICAgaWYgKG4gPiAyNTUpXHJcbiAgICAgICAgbiA9IDI1NTtcclxuICAgIGVsc2UgaWYgKG4gPCAwKVxyXG4gICAgICAgIG4gPSAwO1xyXG4gICAgcmV0dXJuIG47XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YWJsZVNvcnQoYXJyYXlUb1NvcnQsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGFycmF5VG9Tb3J0WzBdO1xyXG4gICAgbGV0IHNvcnRlZDtcclxuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IG9yZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tbnVsbC1rZXl3b3JkXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcnJheVRvU29ydC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsID0gYXJyYXlUb1NvcnRbaV07IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgIGlmIChvcmRbdmFsXSB8fCBvcmRbdmFsXSA9PT0gMClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBvcmRbdmFsXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvcnRlZCA9IGFycmF5VG9Tb3J0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIpIHx8IG9yZFthXSAtIG9yZFtiXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG9yZDIgPSBhcnJheVRvU29ydC5zbGljZSgwKTtcclxuICAgICAgICBzb3J0ZWQgPSBhcnJheVRvU29ydC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhLCBiKSB8fCBvcmQyLmluZGV4T2YoYSkgLSBvcmQyLmluZGV4T2YoYik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc29ydGVkO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyaXRobWV0aWMuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBodWVTdGF0aXN0aWNzLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgcmdiMmhzbCB9IGZyb20gJy4uL2NvbnZlcnNpb24vcmdiMmhzbCc7XHJcbmltcG9ydCB7IGh1ZUdyb3VwIH0gZnJvbSAnLi9wYWxldHRlJztcclxuY2xhc3MgSHVlR3JvdXAge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5udW0gPSAwO1xyXG4gICAgICAgIHRoaXMuY29scyA9IFtdO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBIdWVTdGF0aXN0aWNzIHtcclxuICAgIGNvbnN0cnVjdG9yKG51bUdyb3VwcywgbWluQ29scykge1xyXG4gICAgICAgIHRoaXMuX251bUdyb3VwcyA9IG51bUdyb3VwcztcclxuICAgICAgICB0aGlzLl9taW5Db2xzID0gbWluQ29scztcclxuICAgICAgICB0aGlzLl9zdGF0cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bUdyb3VwczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzW2ldID0gbmV3IEh1ZUdyb3VwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dyb3Vwc0Z1bGwgPSAwO1xyXG4gICAgfVxyXG4gICAgY2hlY2soaTMyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2dyb3Vwc0Z1bGwgPT09IHRoaXMuX251bUdyb3VwcyArIDEpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgciA9IChpMzIgJiAweGZmKTtcclxuICAgICAgICBjb25zdCBnID0gKGkzMiA+Pj4gOCkgJiAweGZmO1xyXG4gICAgICAgIGNvbnN0IGIgPSAoaTMyID4+PiAxNikgJiAweGZmO1xyXG4gICAgICAgIGNvbnN0IGhnID0gKHIgPT09IGcgJiYgZyA9PT0gYikgPyAwIDogMSArIGh1ZUdyb3VwKHJnYjJoc2wociwgZywgYikuaCwgdGhpcy5fbnVtR3JvdXBzKTtcclxuICAgICAgICBjb25zdCBnciA9IHRoaXMuX3N0YXRzW2hnXTtcclxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLl9taW5Db2xzO1xyXG4gICAgICAgIGdyLm51bSsrO1xyXG4gICAgICAgIGlmIChnci5udW0gPiBtaW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3IubnVtID09PSBtaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzRnVsbCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3IubnVtIDw9IG1pbikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0c1toZ10uY29scy5wdXNoKGkzMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5qZWN0SW50b0RpY3Rpb25hcnkoaGlzdEcpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLl9udW1Hcm91cHM7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdHNbaV0ubnVtIDw9IHRoaXMuX21pbkNvbHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRzW2ldLmNvbHMuZm9yRWFjaCgoY29sKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoaXN0R1tjb2xdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RHW2NvbF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdEdbY29sXSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5qZWN0SW50b0FycmF5KGhpc3RHKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5fbnVtR3JvdXBzOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRzW2ldLm51bSA8PSB0aGlzLl9taW5Db2xzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0c1tpXS5jb2xzLmZvckVhY2goKGNvbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXN0Ry5pbmRleE9mKGNvbCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RHLnB1c2goY29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1odWVTdGF0aXN0aWNzLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0ICogYXMgYXJpdGhtZXRpYyBmcm9tICcuL2FyaXRobWV0aWMnO1xyXG5pbXBvcnQgeyBIdWVTdGF0aXN0aWNzIH0gZnJvbSAnLi9odWVTdGF0aXN0aWNzJztcclxuaW1wb3J0IHsgUGFsZXR0ZSB9IGZyb20gJy4vcGFsZXR0ZSc7XHJcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludCc7XHJcbmltcG9ydCB7IFBvaW50Q29udGFpbmVyIH0gZnJvbSAnLi9wb2ludENvbnRhaW5lcic7XHJcbmltcG9ydCB7IFByb2dyZXNzVHJhY2tlciB9IGZyb20gJy4vcHJvZ3Jlc3NUcmFja2VyJztcclxuZXhwb3J0IHsgUG9pbnQsIFBvaW50Q29udGFpbmVyLCBQYWxldHRlLCBIdWVTdGF0aXN0aWNzLCBQcm9ncmVzc1RyYWNrZXIsIGFyaXRobWV0aWMsIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogcGFsZXR0ZS50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IFBvaW50Q29udGFpbmVyIH0gZnJvbSAnLi9wb2ludENvbnRhaW5lcic7XHJcbmltcG9ydCB7IHJnYjJoc2wgfSBmcm9tICcuLi9jb252ZXJzaW9uL3JnYjJoc2wnO1xyXG4vLyBUT0RPOiBtYWtlIHBhbGV0dGVBcnJheSB2aWEgcG9pbnRDb250YWluZXIsIHNvLCBleHBvcnQgd2lsbCBiZSBhdmFpbGFibGUgdmlhIHBvaW50Q29udGFpbmVyLmV4cG9ydFhYWFxyXG5jb25zdCBodWVHcm91cHMgPSAxMDtcclxuZXhwb3J0IGZ1bmN0aW9uIGh1ZUdyb3VwKGh1ZSwgc2VnbWVudHNOdW1iZXIpIHtcclxuICAgIGNvbnN0IG1heEh1ZSA9IDM2MDtcclxuICAgIGNvbnN0IHNlZyA9IG1heEh1ZSAvIHNlZ21lbnRzTnVtYmVyO1xyXG4gICAgY29uc3QgaGFsZiA9IHNlZyAvIDI7XHJcbiAgICBmb3IgKGxldCBpID0gMSwgbWlkID0gc2VnIC0gaGFsZjsgaSA8IHNlZ21lbnRzTnVtYmVyOyBpKyssIG1pZCArPSBzZWcpIHtcclxuICAgICAgICBpZiAoaHVlID49IG1pZCAmJiBodWUgPCBtaWQgKyBzZWcpXHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZXhwb3J0IGNsYXNzIFBhbGV0dGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRBcnJheSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2kzMmlkeCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3BvaW50Q29udGFpbmVyID0gbmV3IFBvaW50Q29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRDb250YWluZXIuc2V0SGVpZ2h0KDEpO1xyXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkgPSB0aGlzLl9wb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XHJcbiAgICB9XHJcbiAgICBhZGQoY29sb3IpIHtcclxuICAgICAgICB0aGlzLl9wb2ludEFycmF5LnB1c2goY29sb3IpO1xyXG4gICAgICAgIHRoaXMuX3BvaW50Q29udGFpbmVyLnNldFdpZHRoKHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGhhcyhjb2xvcikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xvci51aW50MzIgPT09IHRoaXMuX3BvaW50QXJyYXlbaV0udWludDMyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIFRPVFJZOiB1c2UgSFVTTCAtIGh0dHA6Ly9ib3JvbmluZS5jb20vaHVzbC8gaHR0cDovL3d3dy5odXNsLWNvbG9ycy5vcmcvIGh0dHBzOi8vZ2l0aHViLmNvbS9odXNsLWNvbG9ycy9odXNsXHJcbiAgICBnZXROZWFyZXN0Q29sb3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50QXJyYXlbdGhpcy5fZ2V0TmVhcmVzdEluZGV4KGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcikgfCAwXTtcclxuICAgIH1cclxuICAgIGdldFBvaW50Q29udGFpbmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludENvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIC8vIFRPVFJZOiB1c2UgSFVTTCAtIGh0dHA6Ly9ib3JvbmluZS5jb20vaHVzbC9cclxuICAgIC8qXHJcbiAgICAgcHVibGljIG5lYXJlc3RJbmRleEJ5VWludDMyKGkzMikge1xyXG4gICAgIHZhciBpZHggOiBudW1iZXIgPSB0aGlzLl9uZWFyZXN0UG9pbnRGcm9tQ2FjaGUoXCJcIiArIGkzMik7XHJcbiAgICAgaWYgKGlkeCA+PSAwKSByZXR1cm4gaWR4O1xyXG4gIFxyXG4gICAgIHZhciBtaW4gPSAxMDAwLFxyXG4gICAgIHJnYiA9IFtcclxuICAgICAoaTMyICYgMHhmZiksXHJcbiAgICAgKGkzMiA+Pj4gOCkgJiAweGZmLFxyXG4gICAgIChpMzIgPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgKGkzMiA+Pj4gMjQpICYgMHhmZlxyXG4gICAgIF0sXHJcbiAgICAgbGVuID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7XHJcbiAgXHJcbiAgICAgaWR4ID0gMDtcclxuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgdmFyIGRpc3QgPSBVdGlscy5kaXN0RXVjbGlkZWFuKHJnYiwgdGhpcy5fcG9pbnRBcnJheVtpXS5yZ2JhKTtcclxuICBcclxuICAgICBpZiAoZGlzdCA8IG1pbikge1xyXG4gICAgIG1pbiA9IGRpc3Q7XHJcbiAgICAgaWR4ID0gaTtcclxuICAgICB9XHJcbiAgICAgfVxyXG4gIFxyXG4gICAgIHRoaXMuX2kzMmlkeFtpMzJdID0gaWR4O1xyXG4gICAgIHJldHVybiBpZHg7XHJcbiAgICAgfVxyXG4gICAgICovXHJcbiAgICBfbmVhcmVzdFBvaW50RnJvbUNhY2hlKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5faTMyaWR4W2tleV0gPT09ICdudW1iZXInID8gdGhpcy5faTMyaWR4W2tleV0gOiAtMTtcclxuICAgIH1cclxuICAgIF9nZXROZWFyZXN0SW5kZXgoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIHBvaW50KSB7XHJcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuX25lYXJlc3RQb2ludEZyb21DYWNoZSgnJyArIHBvaW50LnVpbnQzMik7XHJcbiAgICAgICAgaWYgKGlkeCA+PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gaWR4O1xyXG4gICAgICAgIGxldCBtaW5pbWFsRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGlkeCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fcG9pbnRBcnJheVtpXTtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvci5jYWxjdWxhdGVSYXcocG9pbnQuciwgcG9pbnQuZywgcG9pbnQuYiwgcG9pbnQuYSwgcC5yLCBwLmcsIHAuYiwgcC5hKTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluaW1hbERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5pbWFsRGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlkeCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faTMyaWR4W3BvaW50LnVpbnQzMl0gPSBpZHg7XHJcbiAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgcHVibGljIHJlZHVjZShoaXN0b2dyYW0gOiBDb2xvckhpc3RvZ3JhbSwgY29sb3JzIDogbnVtYmVyKSB7XHJcbiAgICAgaWYgKHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoID4gY29sb3JzKSB7XHJcbiAgICAgdmFyIGlkeGkzMiA9IGhpc3RvZ3JhbS5nZXRJbXBvcnRhbmNlU29ydGVkQ29sb3JzSURYSTMyKCk7XHJcbiAgXHJcbiAgICAgLy8gcXVhbnRpemUgaGlzdG9ncmFtIHRvIGV4aXN0aW5nIHBhbGV0dGVcclxuICAgICB2YXIga2VlcCA9IFtdLCB1bmlxdWVDb2xvcnMgPSAwLCBpZHgsIHBydW5lZCA9IGZhbHNlO1xyXG4gIFxyXG4gICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHhpMzIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAvLyBwYWxldHRlIGxlbmd0aCByZWFjaGVkLCB1bnNldCBhbGwgcmVtYWluaW5nIGNvbG9ycyAoc3BhcnNlIHBhbGV0dGUpXHJcbiAgICAgaWYgKHVuaXF1ZUNvbG9ycyA+PSBjb2xvcnMpIHtcclxuICAgICB0aGlzLnBydW5lUGFsKGtlZXApO1xyXG4gICAgIHBydW5lZCA9IHRydWU7XHJcbiAgICAgYnJlYWs7XHJcbiAgICAgfSBlbHNlIHtcclxuICAgICBpZHggPSB0aGlzLm5lYXJlc3RJbmRleEJ5VWludDMyKGlkeGkzMltpXSk7XHJcbiAgICAgaWYgKGtlZXAuaW5kZXhPZihpZHgpIDwgMCkge1xyXG4gICAgIGtlZXAucHVzaChpZHgpO1xyXG4gICAgIHVuaXF1ZUNvbG9ycysrO1xyXG4gICAgIH1cclxuICAgICB9XHJcbiAgICAgfVxyXG4gIFxyXG4gICAgIGlmICghcHJ1bmVkKSB7XHJcbiAgICAgdGhpcy5wcnVuZVBhbChrZWVwKTtcclxuICAgICB9XHJcbiAgICAgfVxyXG4gICAgIH1cclxuICBcclxuICAgICAvLyBUT0RPOiBjaGVjayB1c2FnZSwgbm90IHRlc3RlZCFcclxuICAgICBwdWJsaWMgcHJ1bmVQYWwoa2VlcCA6IG51bWJlcltdKSB7XHJcbiAgICAgdmFyIGNvbG9ycyA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xyXG4gICAgIGZvciAodmFyIGNvbG9ySW5kZXggPSBjb2xvcnMgLSAxOyBjb2xvckluZGV4ID49IDA7IGNvbG9ySW5kZXgtLSkge1xyXG4gICAgIGlmIChrZWVwLmluZGV4T2YoY29sb3JJbmRleCkgPCAwKSB7XHJcbiAgXHJcbiAgICAgaWYoY29sb3JJbmRleCArIDEgPCBjb2xvcnMpIHtcclxuICAgICB0aGlzLl9wb2ludEFycmF5WyBjb2xvckluZGV4IF0gPSB0aGlzLl9wb2ludEFycmF5IFsgY29sb3JzIC0gMSBdO1xyXG4gICAgIH1cclxuICAgICAtLWNvbG9ycztcclxuICAgICAvL3RoaXMuX3BvaW50QXJyYXlbY29sb3JJbmRleF0gPSBudWxsO1xyXG4gICAgIH1cclxuICAgICB9XHJcbiAgICAgY29uc29sZS5sb2coXCJjb2xvcnMgcHJ1bmVkOiBcIiArICh0aGlzLl9wb2ludEFycmF5Lmxlbmd0aCAtIGNvbG9ycykpO1xyXG4gICAgIHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoID0gY29sb3JzO1xyXG4gICAgIHRoaXMuX2kzMmlkeCA9IHt9O1xyXG4gICAgIH1cclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogZ3JvdXAgdmVyeSBsb3cgbHVtIGFuZCB2ZXJ5IGhpZ2ggbHVtIGNvbG9yc1xyXG4gICAgLy8gVE9ETzogcGFzcyBjdXN0b20gc29ydCBvcmRlclxyXG4gICAgLy8gVE9ETzogc29ydCBjcml0ZXJpYSBmdW5jdGlvbiBzaG91bGQgYmUgcGxhY2VkIHRvIEh1ZVN0YXRzIGNsYXNzXHJcbiAgICBzb3J0KCkge1xyXG4gICAgICAgIHRoaXMuX2kzMmlkeCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBoc2xBID0gcmdiMmhzbChhLnIsIGEuZywgYS5iKTtcclxuICAgICAgICAgICAgY29uc3QgaHNsQiA9IHJnYjJoc2woYi5yLCBiLmcsIGIuYik7XHJcbiAgICAgICAgICAgIC8vIHNvcnQgYWxsIGdyYXlzICsgd2hpdGVzIHRvZ2V0aGVyXHJcbiAgICAgICAgICAgIGNvbnN0IGh1ZUEgPSAoYS5yID09PSBhLmcgJiYgYS5nID09PSBhLmIpID8gMCA6IDEgKyBodWVHcm91cChoc2xBLmgsIGh1ZUdyb3Vwcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGh1ZUIgPSAoYi5yID09PSBiLmcgJiYgYi5nID09PSBiLmIpID8gMCA6IDEgKyBodWVHcm91cChoc2xCLmgsIGh1ZUdyb3Vwcyk7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICB2YXIgaHVlQSA9IChhLnIgPT09IGEuZyAmJiBhLmcgPT09IGEuYikgPyAwIDogMSArIFV0aWxzLmh1ZUdyb3VwKGhzbEEuaCwgaHVlR3JvdXBzKTtcclxuICAgICAgICAgICAgIHZhciBodWVCID0gKGIuciA9PT0gYi5nICYmIGIuZyA9PT0gYi5iKSA/IDAgOiAxICsgVXRpbHMuaHVlR3JvdXAoaHNsQi5oLCBodWVHcm91cHMpO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgaHVlRGlmZiA9IGh1ZUIgLSBodWVBO1xyXG4gICAgICAgICAgICBpZiAoaHVlRGlmZilcclxuICAgICAgICAgICAgICAgIHJldHVybiAtaHVlRGlmZjtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgIHZhciBsdW1EaWZmID0gVXRpbHMubHVtR3JvdXAoK2hzbEIubC50b0ZpeGVkKDIpKSAtIFV0aWxzLmx1bUdyb3VwKCtoc2xBLmwudG9GaXhlZCgyKSk7XHJcbiAgICAgICAgICAgICBpZiAobHVtRGlmZikgcmV0dXJuIC1sdW1EaWZmO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgbEEgPSBhLmdldEx1bWlub3NpdHkodHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxCID0gYi5nZXRMdW1pbm9zaXR5KHRydWUpO1xyXG4gICAgICAgICAgICBpZiAobEIgLSBsQSAhPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBsQiAtIGxBO1xyXG4gICAgICAgICAgICBjb25zdCBzYXREaWZmID0gKChoc2xCLnMgKiAxMDApIHwgMCkgLSAoKGhzbEEucyAqIDEwMCkgfCAwKTtcclxuICAgICAgICAgICAgaWYgKHNhdERpZmYpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLXNhdERpZmY7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbGV0dGUuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBwb2ludC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IFkgfSBmcm9tICcuLi9jb25zdGFudHMvYnQ3MDknO1xyXG4vKipcclxuICogdjggb3B0aW1pemVkIGNsYXNzXHJcbiAqIDEpIFwiY29uc3RydWN0b3JcIiBzaG91bGQgaGF2ZSBpbml0aWFsaXphdGlvbiB3aXRoIHdvcnN0IHR5cGVzXHJcbiAqIDIpIFwic2V0XCIgc2hvdWxkIGhhdmUgfDAgLyA+Pj4gMFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvaW50IHtcclxuICAgIC8vIExhYiA6IHsgTCA6IG51bWJlcjsgYSA6IG51bWJlcjsgYiA6IG51bWJlciB9O1xyXG4gICAgc3RhdGljIGNyZWF0ZUJ5UXVhZHJ1cGxldChxdWFkcnVwbGV0KSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoKTtcclxuICAgICAgICBwb2ludC5yID0gcXVhZHJ1cGxldFswXSB8IDA7XHJcbiAgICAgICAgcG9pbnQuZyA9IHF1YWRydXBsZXRbMV0gfCAwO1xyXG4gICAgICAgIHBvaW50LmIgPSBxdWFkcnVwbGV0WzJdIHwgMDtcclxuICAgICAgICBwb2ludC5hID0gcXVhZHJ1cGxldFszXSB8IDA7XHJcbiAgICAgICAgcG9pbnQuX2xvYWRVSU5UMzIoKTtcclxuICAgICAgICBwb2ludC5fbG9hZFF1YWRydXBsZXQoKTtcclxuICAgICAgICAvLyBwb2ludC5fbG9hZExhYigpO1xyXG4gICAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGVCeVJHQkEocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCgpO1xyXG4gICAgICAgIHBvaW50LnIgPSByZWQgfCAwO1xyXG4gICAgICAgIHBvaW50LmcgPSBncmVlbiB8IDA7XHJcbiAgICAgICAgcG9pbnQuYiA9IGJsdWUgfCAwO1xyXG4gICAgICAgIHBvaW50LmEgPSBhbHBoYSB8IDA7XHJcbiAgICAgICAgcG9pbnQuX2xvYWRVSU5UMzIoKTtcclxuICAgICAgICBwb2ludC5fbG9hZFF1YWRydXBsZXQoKTtcclxuICAgICAgICAvLyBwb2ludC5fbG9hZExhYigpO1xyXG4gICAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGVCeVVpbnQzMih1aW50MzIpIHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCgpO1xyXG4gICAgICAgIHBvaW50LnVpbnQzMiA9IHVpbnQzMiA+Pj4gMDtcclxuICAgICAgICBwb2ludC5fbG9hZFJHQkEoKTtcclxuICAgICAgICBwb2ludC5fbG9hZFF1YWRydXBsZXQoKTtcclxuICAgICAgICAvLyBwb2ludC5fbG9hZExhYigpO1xyXG4gICAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudWludDMyID0gLTEgPj4+IDA7XHJcbiAgICAgICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gdGhpcy5hID0gMDtcclxuICAgICAgICB0aGlzLnJnYmEgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzBdID0gMDtcclxuICAgICAgICB0aGlzLnJnYmFbMV0gPSAwO1xyXG4gICAgICAgIHRoaXMucmdiYVsyXSA9IDA7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzNdID0gMDtcclxuICAgICAgICAvKlxyXG4gICAgICAgICB0aGlzLkxhYiA9IHtcclxuICAgICAgICAgTCA6IDAuMCxcclxuICAgICAgICAgYSA6IDAuMCxcclxuICAgICAgICAgYiA6IDAuMFxyXG4gICAgICAgICB9O1xyXG4gICAgICAgICAqL1xyXG4gICAgfVxyXG4gICAgZnJvbShwb2ludCkge1xyXG4gICAgICAgIHRoaXMuciA9IHBvaW50LnI7XHJcbiAgICAgICAgdGhpcy5nID0gcG9pbnQuZztcclxuICAgICAgICB0aGlzLmIgPSBwb2ludC5iO1xyXG4gICAgICAgIHRoaXMuYSA9IHBvaW50LmE7XHJcbiAgICAgICAgdGhpcy51aW50MzIgPSBwb2ludC51aW50MzI7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzBdID0gcG9pbnQucjtcclxuICAgICAgICB0aGlzLnJnYmFbMV0gPSBwb2ludC5nO1xyXG4gICAgICAgIHRoaXMucmdiYVsyXSA9IHBvaW50LmI7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzNdID0gcG9pbnQuYTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICB0aGlzLkxhYi5MID0gcG9pbnQuTGFiLkw7XHJcbiAgICAgICAgIHRoaXMuTGFiLmEgPSBwb2ludC5MYWIuYTtcclxuICAgICAgICAgdGhpcy5MYWIuYiA9IHBvaW50LkxhYi5iO1xyXG4gICAgICAgICAqL1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAqIFRPRE86XHJcbiAgICAgTHVtaW5hbmNlIGZyb20gUkdCOlxyXG4gIFxyXG4gICAgIEx1bWluYW5jZSAoc3RhbmRhcmQgZm9yIGNlcnRhaW4gY29sb3VyIHNwYWNlcyk6ICgwLjIxMjYqUiArIDAuNzE1MipHICsgMC4wNzIyKkIpIFsxXVxyXG4gICAgIEx1bWluYW5jZSAocGVyY2VpdmVkIG9wdGlvbiAxKTogKDAuMjk5KlIgKyAwLjU4NypHICsgMC4xMTQqQikgWzJdXHJcbiAgICAgTHVtaW5hbmNlIChwZXJjZWl2ZWQgb3B0aW9uIDIsIHNsb3dlciB0byBjYWxjdWxhdGUpOiAgc3FydCggMC4yNDEqUl4yICsgMC42OTEqR14yICsgMC4wNjgqQl4yICkgPyBzcXJ0KCAwLjI5OSpSXjIgKyAwLjU4NypHXjIgKyAwLjExNCpCXjIgKSAodGhhbmtzIHRvIEBNYXR0aGV3SGVyYnN0KSBbaHR0cDovL2FsaWVucnlkZXJmbGV4LmNvbS9oc3AuaHRtbF1cclxuICAgICAqL1xyXG4gICAgZ2V0THVtaW5vc2l0eSh1c2VBbHBoYUNoYW5uZWwpIHtcclxuICAgICAgICBsZXQgciA9IHRoaXMucjtcclxuICAgICAgICBsZXQgZyA9IHRoaXMuZztcclxuICAgICAgICBsZXQgYiA9IHRoaXMuYjtcclxuICAgICAgICBpZiAodXNlQWxwaGFDaGFubmVsKSB7XHJcbiAgICAgICAgICAgIHIgPSBNYXRoLm1pbigyNTUsIDI1NSAtIHRoaXMuYSArIHRoaXMuYSAqIHIgLyAyNTUpO1xyXG4gICAgICAgICAgICBnID0gTWF0aC5taW4oMjU1LCAyNTUgLSB0aGlzLmEgKyB0aGlzLmEgKiBnIC8gMjU1KTtcclxuICAgICAgICAgICAgYiA9IE1hdGgubWluKDI1NSwgMjU1IC0gdGhpcy5hICsgdGhpcy5hICogYiAvIDI1NSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZhciBsdW1hID0gdGhpcy5yICogUG9pbnQuX1JFRF9DT0VGRklDSUVOVCArIHRoaXMuZyAqIFBvaW50Ll9HUkVFTl9DT0VGRklDSUVOVCArIHRoaXMuYiAqIFBvaW50Ll9CTFVFX0NPRUZGSUNJRU5UO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIGlmKHVzZUFscGhhQ2hhbm5lbCkge1xyXG4gICAgICAgICBsdW1hID0gKGx1bWEgKiAoMjU1IC0gdGhpcy5hKSkgLyAyNTU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXR1cm4gciAqIFkuUkVEICsgZyAqIFkuR1JFRU4gKyBiICogWS5CTFVFO1xyXG4gICAgfVxyXG4gICAgX2xvYWRVSU5UMzIoKSB7XHJcbiAgICAgICAgdGhpcy51aW50MzIgPSAodGhpcy5hIDw8IDI0IHwgdGhpcy5iIDw8IDE2IHwgdGhpcy5nIDw8IDggfCB0aGlzLnIpID4+PiAwO1xyXG4gICAgfVxyXG4gICAgX2xvYWRSR0JBKCkge1xyXG4gICAgICAgIHRoaXMuciA9IHRoaXMudWludDMyICYgMHhmZjtcclxuICAgICAgICB0aGlzLmcgPSAodGhpcy51aW50MzIgPj4+IDgpICYgMHhmZjtcclxuICAgICAgICB0aGlzLmIgPSAodGhpcy51aW50MzIgPj4+IDE2KSAmIDB4ZmY7XHJcbiAgICAgICAgdGhpcy5hID0gKHRoaXMudWludDMyID4+PiAyNCkgJiAweGZmO1xyXG4gICAgfVxyXG4gICAgX2xvYWRRdWFkcnVwbGV0KCkge1xyXG4gICAgICAgIHRoaXMucmdiYVswXSA9IHRoaXMucjtcclxuICAgICAgICB0aGlzLnJnYmFbMV0gPSB0aGlzLmc7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzJdID0gdGhpcy5iO1xyXG4gICAgICAgIHRoaXMucmdiYVszXSA9IHRoaXMuYTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICB2YXIgeHl6ID0gcmdiMnh5eih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcclxuICAgICAgICAgdmFyIGxhYiA9IHh5ejJsYWIoeHl6LngsIHh5ei55LCB4eXoueik7XHJcbiAgICAgICAgIHRoaXMubGFiLmwgPSBsYWIubDtcclxuICAgICAgICAgdGhpcy5sYWIuYSA9IGxhYi5hO1xyXG4gICAgICAgICB0aGlzLmxhYi5iID0gbGFiLmI7XHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9pbnQuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBwb2ludENvbnRhaW5lci50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludCc7XHJcbi8qKlxyXG4gKiB2OCBvcHRpbWl6YXRpb25zIGRvbmUuXHJcbiAqIGZyb21YWFggbWV0aG9kcyBhcmUgc3RhdGljIHRvIG1vdmUgb3V0IHBvbHltb3JwaGljIGNvZGUgZnJvbSBjbGFzcyBpbnN0YW5jZSBpdHNlbGYuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9pbnRDb250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRBcnJheSA9IFtdO1xyXG4gICAgfVxyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBzZXRXaWR0aCh3aWR0aCkge1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICB9XHJcbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZ2V0UG9pbnRBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRBcnJheTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IFBvaW50Q29udGFpbmVyKCk7XHJcbiAgICAgICAgY2xvbmUuX3dpZHRoID0gdGhpcy5fd2lkdGg7XHJcbiAgICAgICAgY2xvbmUuX2hlaWdodCA9IHRoaXMuX2hlaWdodDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsb25lLl9wb2ludEFycmF5W2ldID0gUG9pbnQuY3JlYXRlQnlVaW50MzIodGhpcy5fcG9pbnRBcnJheVtpXS51aW50MzIgfCAwKTsgLy8gXCJ8IDBcIiBpcyBhZGRlZCBmb3Igdjggb3B0aW1pemF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgIH1cclxuICAgIHRvVWludDMyQXJyYXkoKSB7XHJcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGwpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVpbnQzMkFycmF5W2ldID0gdGhpcy5fcG9pbnRBcnJheVtpXS51aW50MzI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1aW50MzJBcnJheTtcclxuICAgIH1cclxuICAgIHRvVWludDhBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy50b1VpbnQzMkFycmF5KCkuYnVmZmVyKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tSFRNTEltYWdlRWxlbWVudChpbWcpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGltZy5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1nLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21IVE1MQ2FudmFzRWxlbWVudChjYW52YXMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21IVE1MQ2FudmFzRWxlbWVudChjYW52YXMpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgIGNvbnN0IGltZ0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tSW1hZ2VEYXRhKGltZ0RhdGEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21JbWFnZURhdGEoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZURhdGEud2lkdGg7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gUG9pbnRDb250YWluZXIuZnJvbVVpbnQ4QXJyYXkoaW1hZ2VEYXRhLmRhdGEsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KHVpbnQ4QXJyYXksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh1aW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDhBcnJheV0nOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodWludDhBcnJheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KHVpbnQ4QXJyYXkuYnVmZmVyKTtcclxuICAgICAgICByZXR1cm4gUG9pbnRDb250YWluZXIuZnJvbVVpbnQzMkFycmF5KHVpbnQzMkFycmF5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tVWludDMyQXJyYXkodWludDMyQXJyYXksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBuZXcgUG9pbnRDb250YWluZXIoKTtcclxuICAgICAgICBjb250YWluZXIuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY29udGFpbmVyLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB1aW50MzJBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLl9wb2ludEFycmF5W2ldID0gUG9pbnQuY3JlYXRlQnlVaW50MzIodWludDMyQXJyYXlbaV0gfCAwKTsgLy8gXCJ8IDBcIiBpcyBhZGRlZCBmb3Igdjggb3B0aW1pemF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheShidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGggLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XHJcbiAgICAgICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21VaW50MzJBcnJheSh1aW50MzJBcnJheSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9pbnRDb250YWluZXIuanMubWFwIiwiZXhwb3J0IGNsYXNzIFByb2dyZXNzVHJhY2tlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZVJhbmdlLCBwcm9ncmVzc1JhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5fcmFuZ2UgPSB2YWx1ZVJhbmdlO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzUmFuZ2UgPSBwcm9ncmVzc1JhbmdlO1xyXG4gICAgICAgIHRoaXMuX3N0ZXAgPSBNYXRoLm1heCgxLCB0aGlzLl9yYW5nZSAvIChQcm9ncmVzc1RyYWNrZXIuc3RlcHMgKyAxKSB8IDApO1xyXG4gICAgICAgIHRoaXMuX2xhc3QgPSAtdGhpcy5fc3RlcDtcclxuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcclxuICAgIH1cclxuICAgIHNob3VsZE5vdGlmeShjdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgLSB0aGlzLl9sYXN0ID49IHRoaXMuX3N0ZXApIHtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBNYXRoLm1pbih0aGlzLl9wcm9ncmVzc1JhbmdlICogdGhpcy5fbGFzdCAvIHRoaXMuX3JhbmdlLCB0aGlzLl9wcm9ncmVzc1JhbmdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5Qcm9ncmVzc1RyYWNrZXIuc3RlcHMgPSAxMDA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2dyZXNzVHJhY2tlci5qcy5tYXAiLCJpbXBvcnQgeyBhcHBseVBhbGV0dGVTeW5jLCBidWlsZFBhbGV0dGVTeW5jLCB1dGlscyB9IGZyb20gJ2ltYWdlLXEnXG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIGFuIHVudXNlZCBjb2xvdXIgaW4gdGhlIGltYWdlIGRhdGEgc28gaXQgY2FuIGJlIHVzZWQgYXMgYSB1bmlxdWUgY29sb3VyXG4gKiBmb3IgdHJhbnNwYXJlbnQgcGl4ZWxzLiBCdWlsZHMgdXAgYSBzZXQgb2YgYWxsIGtub3duIGNvbG91cnMgdGhlbiBzZWFyY2hlcyBmcm9tXG4gKiAweDAwMDAwMCB0byAweEZGRkZGRiBmb3IgYSBjb2xvdXIgbm90IGluIHRoZSBzZXQuIFRoZXkncmUgaXMgcHJvYmFibHkgYSBtdWNoIG1vcmUgZWZmZWNpZW50XG4gKiB3YXkgb2YgZG9pbmcgdGhpcy4gVGhlcmUgaXMgYWxzbyBhIHBvc3NpYmlsdHkgYWxsIGNvbG91cnMgYXJlIHVzZWQsIGJ1dCB0aGF0J3MgcHJvYmFibHlcbiAqIGp1c3QgYSB0ZXN0IGltYWdlLlxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0geyp9IHdpZHRoXG4gKiBAcGFyYW0geyp9IGhlaWdodFxuICovXG5mdW5jdGlvbiBzZWFyY2hGb3JVbnVzZWRDb2xvdXIoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgaSA9IDBcbiAgY29uc3QgbGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiA0XG4gIGNvbnN0IGtub3duQ29sb3VycyA9IG5ldyBTZXQoKVxuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgY29uc3QgciA9IGRhdGFbaSsrXVxuICAgIGNvbnN0IGcgPSBkYXRhW2krK11cbiAgICBjb25zdCBiID0gZGF0YVtpKytdXG4gICAgaSsrIC8vIGRvbid0IHRyYWNrIHRoZSB0cmFuc3BhcmVuY3kgaGVyZSBqdXN0IHRoZSByZ2IgdmFsdWVzXG4gICAgY29uc3QgcGl4ZWxDb2xvdXIgPSAociA8PCAxNikgfCAoZyA8PCA4KSB8IGJcbiAgICBrbm93bkNvbG91cnMuYWRkKHBpeGVsQ29sb3VyKVxuICB9XG5cbiAgbGV0IHVudXNlZENvbG91ciA9IDB4MDBcbiAgd2hpbGUgKHVudXNlZENvbG91ciA8IDB4ZmZmZmZmKSB7XG4gICAgaWYgKCFrbm93bkNvbG91cnMuaGFzKHVudXNlZENvbG91cikpIGJyZWFrXG4gICAgdW51c2VkQ29sb3VyKytcbiAgfVxuXG4gIHJldHVybiB1bnVzZWRDb2xvdXJcbn1cblxuZnVuY3Rpb24gZGF0YVRvUkdCQU5vcm1hbGl6ZWQoXG4gIGRhdGEsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIHVudXNlZENvbG91cixcbiAgdHJhbnNwYXJlbmN5Q3V0T2ZmID0gMC43XG4pIHtcbiAgbGV0IGkgPSAwXG4gIGNvbnN0IGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogNFxuICBjb25zdCByZ2JhID0gW11cbiAgY29uc3QgdHJhbnNwYXJlbmN5Q3V0T2ZmVmFsdWUgPSBNYXRoLnRydW5jKDI1NSAqIHRyYW5zcGFyZW5jeUN1dE9mZilcbiAgbGV0IGhhc1RyYW5zcGFyZW5jeSA9IGZhbHNlXG5cbiAgY29uc3QgdW51c2VkQ29sb3VyUiA9ICh1bnVzZWRDb2xvdXIgJiAweGZmMDAwMCkgPj4gMTZcbiAgY29uc3QgdW51c2VkQ29sb3VyRyA9ICh1bnVzZWRDb2xvdXIgJiAweDAwZmYwMCkgPj4gOFxuICBjb25zdCB1bnVzZWRDb2xvdXJCID0gdW51c2VkQ29sb3VyICYgMHgwMDAwZmZcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGNvbnN0IHIgPSBkYXRhW2krK11cbiAgICBjb25zdCBnID0gZGF0YVtpKytdXG4gICAgY29uc3QgYiA9IGRhdGFbaSsrXVxuICAgIGxldCBhID0gZGF0YVtpKytdXG4gICAgYSA9IGEgPj0gdHJhbnNwYXJlbmN5Q3V0T2ZmVmFsdWUgPyAweGZmIDogMHgwMFxuXG4gICAgaWYgKHVudXNlZENvbG91ciAhPT0gdW5kZWZpbmVkICYmIGEgPT09IDApIHtcbiAgICAgIHJnYmEucHVzaCh1bnVzZWRDb2xvdXJSKVxuICAgICAgcmdiYS5wdXNoKHVudXNlZENvbG91ckcpXG4gICAgICByZ2JhLnB1c2godW51c2VkQ29sb3VyQilcbiAgICAgIHJnYmEucHVzaCgweDAwKVxuICAgICAgaGFzVHJhbnNwYXJlbmN5ID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZ2JhLnB1c2gocilcbiAgICAgIHJnYmEucHVzaChnKVxuICAgICAgcmdiYS5wdXNoKGIpXG4gICAgICByZ2JhLnB1c2goMHhmZilcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyByZ2JhLCBoYXNUcmFuc3BhcmVuY3kgfVxufVxuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHBvaW50cyBmcm9tIGltYWdlLXEgYW5kIGNvbnZlcnRzIHRoZW0gdG8gYW4gYXJyYXkgb2Ygc29ydGVkIHJnYiB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXlbUG9pbnRzXX0gcG9pbnRzXG4gKiByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9pbnRzVG9SZ2IocG9pbnRzKSB7XG4gIHJldHVybiBwb2ludHMubWFwKHBvaW50ID0+IChwb2ludC5yIDw8IDE2KSB8IChwb2ludC5nIDw8IDgpIHwgcG9pbnQuYilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBwaXhlbHNcbiAqIEBwYXJhbSB7VWludDMyQXJyYXl9IHBhbGV0dGVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBpbmRleFBpeGVsc1dpdGhQYWxldHRlKHBpeGVscywgcGFsZXR0ZSkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHBpeGVscy5tYXAocGl4ZWwgPT4gcGFsZXR0ZS5pbmRleE9mKHBpeGVsKSkpXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGcmFtZVdpdGhRdWFudGl6ZXIoXG4gIGltYWdlRGF0YSxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgdHJhbnNwYXJlbmN5Q3V0T2ZmLFxuICBkaXRoZXJpbmdcbikge1xuICBjb25zdCB1bnVzZWRDb2xvdXIgPSBzZWFyY2hGb3JVbnVzZWRDb2xvdXIoaW1hZ2VEYXRhLCB3aWR0aCwgaGVpZ2h0KVxuICBjb25zdCB7IHJnYmEsIGhhc1RyYW5zcGFyZW5jeSB9ID0gZGF0YVRvUkdCQU5vcm1hbGl6ZWQoXG4gICAgaW1hZ2VEYXRhLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB1bnVzZWRDb2xvdXIsXG4gICAgdHJhbnNwYXJlbmN5Q3V0T2ZmXG4gIClcblxuICBjb25zdCBwb2ludENvbnRhaW5lciA9IHV0aWxzLlBvaW50Q29udGFpbmVyLmZyb21VaW50OEFycmF5KFxuICAgIG5ldyBVaW50OEFycmF5KHJnYmEpLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICApXG4gIGNvbnN0IHBhbGV0dGUgPSBidWlsZFBhbGV0dGVTeW5jKFtwb2ludENvbnRhaW5lcl0sIHtcbiAgICBwYWxldHRlUXVhbnRpemF0aW9uOiAncmdicXVhbnQnLFxuICAgIGNvbG9yczogaGFzVHJhbnNwYXJlbmN5ICYmIHVudXNlZENvbG91ciA/IDI1NSA6IDI1NiwgLy8gbGVhdmUgb25lIGZvciB0cmFuc3BhcmVuY3lcbiAgfSlcbiAgaWYgKGhhc1RyYW5zcGFyZW5jeSAmJiB1bnVzZWRDb2xvdXIpIHtcbiAgICBwYWxldHRlLmFkZCh1dGlscy5Qb2ludC5jcmVhdGVCeVVpbnQzMih1bnVzZWRDb2xvdXIpKVxuICB9XG4gIGNvbnN0IG91dFBvaW50Q29udGFpbmVyID0gYXBwbHlQYWxldHRlU3luYyhwb2ludENvbnRhaW5lciwgcGFsZXR0ZSwge1xuICAgIGltYWdlUXVhbnRpemF0aW9uOiBkaXRoZXJpbmcsXG4gIH0pXG4gIGNvbnN0IHBhbGV0dGVSZ2JBcnJheSA9IHBvaW50c1RvUmdiKFxuICAgIHBhbGV0dGUuZ2V0UG9pbnRDb250YWluZXIoKS5nZXRQb2ludEFycmF5KClcbiAgKVxuICBwYWxldHRlUmdiQXJyYXkuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gIGNvbnN0IHRyYW5zcGFyZW5jeUluZGV4ID0gcGFsZXR0ZVJnYkFycmF5LmluZGV4T2YodW51c2VkQ29sb3VyKVxuXG4gIGNvbnN0IGluZGV4ZWRQaXhlbHMgPSBpbmRleFBpeGVsc1dpdGhQYWxldHRlKFxuICAgIHBvaW50c1RvUmdiKG91dFBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKSksXG4gICAgcGFsZXR0ZVJnYkFycmF5XG4gIClcblxuICByZXR1cm4ge1xuICAgIHBpeGVsczogaW5kZXhlZFBpeGVscyxcbiAgICBwYWxldHRlOiBBcnJheS5mcm9tKHBhbGV0dGVSZ2JBcnJheSksXG4gICAgdHJhbnNwYXJlbmN5SW5kZXg6IHRyYW5zcGFyZW5jeUluZGV4ID4gLTEgPyB0cmFuc3BhcmVuY3lJbmRleCA6IHVuZGVmaW5lZCxcbiAgfVxufVxuXG4vLyB+fn5cblxuZnVuY3Rpb24gcnVuKGZyYW1lKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgZGF0YSwgZGl0aGVyaW5nLCB0cmFuc3BhcmVuY3lDdXRPZmYgfSA9IGZyYW1lXG5cbiAgcmV0dXJuIHByb2Nlc3NGcmFtZVdpdGhRdWFudGl6ZXIoXG4gICAgZGF0YSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdHJhbnNwYXJlbmN5Q3V0T2ZmLFxuICAgIGRpdGhlcmluZ1xuICApXG59XG5cbnNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgdmFyIGRhdGEgPSBldi5kYXRhXG4gIHZhciByZXNwb25zZSA9IHJ1bihkYXRhKVxuICBwb3N0TWVzc2FnZShyZXNwb25zZSlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=", null);
};

/***/ }),

/***/ 0:
/*!*************************************************************************************!*\
  !*** multi (webpack)-dev-server/client?http://localhost:9000 ./src/Animated_GIF.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! /mnt/c/Users/Adrian/Projects/Animated_GIF/node_modules/webpack-dev-server/client/index.js?http://localhost:9000 */"./node_modules/webpack-dev-server/client/index.js?http://localhost:9000");
module.exports = __webpack_require__(/*! /mnt/c/Users/Adrian/Projects/Animated_GIF/src/Animated_GIF.js */"./src/Animated_GIF.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fuc2ktaHRtbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zZXQtaW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIveG1sLWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Jhc2ljQVBJLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9idDcwOS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb25zdGFudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL2xhYjJyZ2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9sYWIyeHl6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMmhzbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3JnYjJsYWIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9yZ2IyeHl6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24veHl6MmxhYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3h5ejJyZ2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvY2llOTQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvY2llZGUyMDAwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2NtZXRyaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvZGlzdGFuY2VDYWxjdWxhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2V1Y2xpZGVhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9tYW5oYXR0YW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvcG5nUXVhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UtcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbWFnZVF1YW50aXplci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9uZWFyZXN0Q29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvcmllbWVyc21hLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2ltYWdlL3NwYWNlRmlsbGluZ0N1cnZlcy9oaWxiZXJ0Q3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL25ldXF1YW50L25ldXF1YW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvbmV1cXVhbnQvbmV1cXVhbnRGbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3BhbGV0dGVRdWFudGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9yZ2JxdWFudC9jb2xvckhpc3RvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3JnYnF1YW50L3JnYnF1YW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvd3Uvd3VRdWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9xdWFsaXR5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3F1YWxpdHkvc3NpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9hcml0aG1ldGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2h1ZVN0YXRpc3RpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcGFsZXR0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wb2ludENvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wcm9ncmVzc1RyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29tZ2dpZi9vbWdnaWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9CYXNlQ2xpZW50LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9jcmVhdGVTb2NrZXRVcmwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvbG9nLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvcmVsb2FkQXBwLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc2VuZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3Qgc3luYyBub25yZWN1cnNpdmUgXlxcLlxcL2xvZyQiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dvcmtlci1sb2FkZXIvZGlzdC93b3JrZXJzL0lubGluZVdvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQW5pbWF0ZWRfR0lGLmpzIiwid2VicGFjazovLy8uL3NyYy9BbmltYXRlZF9HSUYud29ya2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7O0FDM1BBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzNRRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsdUlBQXVJO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLDhYQUE4WDtBQUNqWTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixzQ0FBc0MsRUFBRTs7QUFFOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjs7O0FBRzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdDQUFnQztBQUM5RSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLDBRQUEwUTtBQUM3UTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsZ0ZBQWdGO0FBQ25GO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0dBQXdHO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxxRkFBcUY7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLCtJQUErSTtBQUNsSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxtRkFBbUY7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFxRCxtQkFBbUIsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsa0lBQWtJO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsd0RBQXdEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsaUNBQWlDO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEMsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUseUJBQXlCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGlDQUFpQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsa0dBQWtHO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsQ0FBQyxFQUFFLCtGQUErRjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQSxDQUFDLEVBQUUsMEVBQTBFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsQ0FBQyxFQUFFLHVHQUF1RztBQUMxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSw2SEFBNkg7QUFDaEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMsRUFBRSxXQUFXO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLGNBQWM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM3RCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZmE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxHOzs7Ozs7Ozs7Ozs7QUMxQlk7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFN1YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4saURBQWlELDBFQUEwRSxhQUFhLEVBQUUscUNBQXFDOztBQUUvSyx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSwwQ0FBMEMsK0RBQStELDJFQUEyRSxFQUFFLHlFQUF5RSxlQUFlLHNEQUFzRCxFQUFFLEVBQUUsdURBQXVEOztBQUUvWCxnQ0FBZ0MsNEVBQTRFLGlCQUFpQixVQUFVLEdBQUcsOEJBQThCOztBQUV4SyxhQUFhLG1CQUFPLENBQUMsOEVBQTJCOztBQUVoRCxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBYzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsbUJBQWUsQ0FBQyx3RkFBZ0I7QUFDN0M7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxhOzs7Ozs7Ozs7Ozs7QUN6RUQsdURBQWE7QUFDYjs7QUFFQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBWTs7QUFFcEMsYUFBYSxtQkFBTyxDQUFDLG9FQUFVOztBQUUvQixjQUFjLG1CQUFPLENBQUMsc0VBQVc7O0FBRWpDLGVBQWUsbUJBQU8sQ0FBQywwRUFBYTtBQUNwQztBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLDBGQUFxQjs7QUFFL0MsZ0JBQWdCLG1CQUFPLENBQUMsc0ZBQW1COztBQUUzQyxzQkFBc0IsbUJBQU8sQ0FBQyxrR0FBeUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLGtFQUFrRDs7QUFFbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7Ozs7OztBQy9LYTtBQUNiOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxvREFBVzs7QUFFbEMsZUFBZSxtQkFBTyxDQUFDLDREQUFlO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0EsR0FBRyxFQUFFO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7QUN2SEEscUVBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLGdHQUF3QjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx3Qjs7Ozs7Ozs7Ozs7OztBQ25EYTtBQUNiOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxzQ0FBSzs7QUFFdkIsa0JBQWtCLG1CQUFPLENBQUMsNERBQWE7O0FBRXZDLDZCQUE2QixtQkFBTyxDQUFDLDBHQUEwQjs7QUFFL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUM7Ozs7Ozs7Ozs7OztBQ3JGYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQSx3Qzs7Ozs7Ozs7Ozs7O0FDckJhOztBQUViLFVBQVUsbUJBQU8sQ0FBQyx5REFBVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7OztBQ2hEYTtBQUNiOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxvRUFBTztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsa0VBQXFCOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkI7Ozs7Ozs7Ozs7OztBQ3REYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHlCOzs7Ozs7Ozs7Ozs7QUNiYTtBQUNiO0FBQ0EsNkJBQTZCLFlBQVksSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUMzRDs7Ozs7Ozs7Ozs7OztBQ0hhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsc0ZBQVk7O0FBRXBDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0U7Ozs7Ozs7Ozs7O0FDdEJBLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFRO0FBQ25DOzs7Ozs7Ozs7Ozs7QUNEQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFEYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7QUNwQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtDO0FBQ2lDO0FBQ3RCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtCQUFrQiwyREFBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsbUJBQW1CLHFDQUFxQztBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixnREFBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUE2QixTQUFTLGtEQUFrRCxxSUFBcUksOEVBQThFLFNBQVMsS0FBSyx5REFBeUQsOFlBQThZLG1CQUFtQiw2Q0FBNkMsNkdBQTZHLHdCQUF3QixFQUFFLEVBQUUseUJBQXlCLGdEQUFnRCxxQ0FBcUMsZ0RBQWdELG9GQUFvRixxQ0FBcUMsOEJBQThCLFNBQVMsK0JBQStCLHFEQUFxRCxxQ0FBcUMsOEdBQThHLDRCQUE0QixhQUFhLHlCQUF5QixTQUFTLEtBQUssZ0NBQWdDLDBEQUEwRCxnUkFBZ1IsbUJBQW1CLDZDQUE2QyxxSkFBcUosc1pBQXNaLEVBQUUsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUUsbUVBQW1FLDhHQUE4Ryx1T0FBdU8sa0VBQWtFLHlFQUF5RSw0QkFBNEIsa0hBQWtILDBXQUEwVywwTUFBME0sNEpBQTRKLE9BQU8sMEZBQTBGLEtBQUssY0FBYyx3QkFBd0IsR0FBRyxpSEFBaUgsY0FBYyxxQkFBcUIsTUFBTSxxQ0FBcUMsNkVBQTZFLG9CQUFvQixZQUFZLG9CQUFvQixZQUFZLHVCQUF1QixXQUFXLHlEQUF5RCwwRUFBMEUsbUhBQW1ILG1GQUFtRix3QkFBd0IsOFhBQThYLG1JQUFtSSwyQ0FBMkMsMEdBQTBHLDJIQUEySCx3Q0FBd0MsMlZBQTJWLDRKQUE0SixHQUFHLG1DQUFtQyxXQUFXLHFEQUFxRCxtSUFBbUksbUNBQW1DLDhFQUE4RSxhQUFhLGVBQWUsRUFBRSw2Q0FBNkMsY0FBYztBQUM5cWdPLEUiLCJmaWxlIjoiQW5pbWF0ZWRfR0lGLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLnNldEltbWVkaWF0ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMicgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFNSQyA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR107XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFhtbEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi94bWwtZW50aXRpZXMuanMnKSxcbiAgSHRtbDRFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDQtZW50aXRpZXMuanMnKSxcbiAgSHRtbDVFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKSxcbiAgQWxsSHRtbEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNS1lbnRpdGllcy5qcycpXG59O1xuIiwidmFyIEhUTUxfQUxQSEEgPSBbJ2Fwb3MnLCAnbmJzcCcsICdpZXhjbCcsICdjZW50JywgJ3BvdW5kJywgJ2N1cnJlbicsICd5ZW4nLCAnYnJ2YmFyJywgJ3NlY3QnLCAndW1sJywgJ2NvcHknLCAnb3JkZicsICdsYXF1bycsICdub3QnLCAnc2h5JywgJ3JlZycsICdtYWNyJywgJ2RlZycsICdwbHVzbW4nLCAnc3VwMicsICdzdXAzJywgJ2FjdXRlJywgJ21pY3JvJywgJ3BhcmEnLCAnbWlkZG90JywgJ2NlZGlsJywgJ3N1cDEnLCAnb3JkbScsICdyYXF1bycsICdmcmFjMTQnLCAnZnJhYzEyJywgJ2ZyYWMzNCcsICdpcXVlc3QnLCAnQWdyYXZlJywgJ0FhY3V0ZScsICdBY2lyYycsICdBdGlsZGUnLCAnQXVtbCcsICdBcmluZycsICdBZWxpZycsICdDY2VkaWwnLCAnRWdyYXZlJywgJ0VhY3V0ZScsICdFY2lyYycsICdFdW1sJywgJ0lncmF2ZScsICdJYWN1dGUnLCAnSWNpcmMnLCAnSXVtbCcsICdFVEgnLCAnTnRpbGRlJywgJ09ncmF2ZScsICdPYWN1dGUnLCAnT2NpcmMnLCAnT3RpbGRlJywgJ091bWwnLCAndGltZXMnLCAnT3NsYXNoJywgJ1VncmF2ZScsICdVYWN1dGUnLCAnVWNpcmMnLCAnVXVtbCcsICdZYWN1dGUnLCAnVEhPUk4nLCAnc3psaWcnLCAnYWdyYXZlJywgJ2FhY3V0ZScsICdhY2lyYycsICdhdGlsZGUnLCAnYXVtbCcsICdhcmluZycsICdhZWxpZycsICdjY2VkaWwnLCAnZWdyYXZlJywgJ2VhY3V0ZScsICdlY2lyYycsICdldW1sJywgJ2lncmF2ZScsICdpYWN1dGUnLCAnaWNpcmMnLCAnaXVtbCcsICdldGgnLCAnbnRpbGRlJywgJ29ncmF2ZScsICdvYWN1dGUnLCAnb2NpcmMnLCAnb3RpbGRlJywgJ291bWwnLCAnZGl2aWRlJywgJ29zbGFzaCcsICd1Z3JhdmUnLCAndWFjdXRlJywgJ3VjaXJjJywgJ3V1bWwnLCAneWFjdXRlJywgJ3Rob3JuJywgJ3l1bWwnLCAncXVvdCcsICdhbXAnLCAnbHQnLCAnZ3QnLCAnT0VsaWcnLCAnb2VsaWcnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdZdW1sJywgJ2NpcmMnLCAndGlsZGUnLCAnZW5zcCcsICdlbXNwJywgJ3RoaW5zcCcsICd6d25qJywgJ3p3aicsICdscm0nLCAncmxtJywgJ25kYXNoJywgJ21kYXNoJywgJ2xzcXVvJywgJ3JzcXVvJywgJ3NicXVvJywgJ2xkcXVvJywgJ3JkcXVvJywgJ2JkcXVvJywgJ2RhZ2dlcicsICdEYWdnZXInLCAncGVybWlsJywgJ2xzYXF1bycsICdyc2FxdW8nLCAnZXVybycsICdmbm9mJywgJ0FscGhhJywgJ0JldGEnLCAnR2FtbWEnLCAnRGVsdGEnLCAnRXBzaWxvbicsICdaZXRhJywgJ0V0YScsICdUaGV0YScsICdJb3RhJywgJ0thcHBhJywgJ0xhbWJkYScsICdNdScsICdOdScsICdYaScsICdPbWljcm9uJywgJ1BpJywgJ1JobycsICdTaWdtYScsICdUYXUnLCAnVXBzaWxvbicsICdQaGknLCAnQ2hpJywgJ1BzaScsICdPbWVnYScsICdhbHBoYScsICdiZXRhJywgJ2dhbW1hJywgJ2RlbHRhJywgJ2Vwc2lsb24nLCAnemV0YScsICdldGEnLCAndGhldGEnLCAnaW90YScsICdrYXBwYScsICdsYW1iZGEnLCAnbXUnLCAnbnUnLCAneGknLCAnb21pY3JvbicsICdwaScsICdyaG8nLCAnc2lnbWFmJywgJ3NpZ21hJywgJ3RhdScsICd1cHNpbG9uJywgJ3BoaScsICdjaGknLCAncHNpJywgJ29tZWdhJywgJ3RoZXRhc3ltJywgJ3Vwc2loJywgJ3BpdicsICdidWxsJywgJ2hlbGxpcCcsICdwcmltZScsICdQcmltZScsICdvbGluZScsICdmcmFzbCcsICd3ZWllcnAnLCAnaW1hZ2UnLCAncmVhbCcsICd0cmFkZScsICdhbGVmc3ltJywgJ2xhcnInLCAndWFycicsICdyYXJyJywgJ2RhcnInLCAnaGFycicsICdjcmFycicsICdsQXJyJywgJ3VBcnInLCAnckFycicsICdkQXJyJywgJ2hBcnInLCAnZm9yYWxsJywgJ3BhcnQnLCAnZXhpc3QnLCAnZW1wdHknLCAnbmFibGEnLCAnaXNpbicsICdub3RpbicsICduaScsICdwcm9kJywgJ3N1bScsICdtaW51cycsICdsb3dhc3QnLCAncmFkaWMnLCAncHJvcCcsICdpbmZpbicsICdhbmcnLCAnYW5kJywgJ29yJywgJ2NhcCcsICdjdXAnLCAnaW50JywgJ3RoZXJlNCcsICdzaW0nLCAnY29uZycsICdhc3ltcCcsICduZScsICdlcXVpdicsICdsZScsICdnZScsICdzdWInLCAnc3VwJywgJ25zdWInLCAnc3ViZScsICdzdXBlJywgJ29wbHVzJywgJ290aW1lcycsICdwZXJwJywgJ3Nkb3QnLCAnbGNlaWwnLCAncmNlaWwnLCAnbGZsb29yJywgJ3JmbG9vcicsICdsYW5nJywgJ3JhbmcnLCAnbG96JywgJ3NwYWRlcycsICdjbHVicycsICdoZWFydHMnLCAnZGlhbXMnXTtcbnZhciBIVE1MX0NPREVTID0gWzM5LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LCAxNjksIDE3MCwgMTcxLCAxNzIsIDE3MywgMTc0LCAxNzUsIDE3NiwgMTc3LCAxNzgsIDE3OSwgMTgwLCAxODEsIDE4MiwgMTgzLCAxODQsIDE4NSwgMTg2LCAxODcsIDE4OCwgMTg5LCAxOTAsIDE5MSwgMTkyLCAxOTMsIDE5NCwgMTk1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LCAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjEwLCAyMTEsIDIxMiwgMjEzLCAyMTQsIDIxNSwgMjE2LCAyMTcsIDIxOCwgMjE5LCAyMjAsIDIyMSwgMjIyLCAyMjMsIDIyNCwgMjI1LCAyMjYsIDIyNywgMjI4LCAyMjksIDIzMCwgMjMxLCAyMzIsIDIzMywgMjM0LCAyMzUsIDIzNiwgMjM3LCAyMzgsIDIzOSwgMjQwLCAyNDEsIDI0MiwgMjQzLCAyNDQsIDI0NSwgMjQ2LCAyNDcsIDI0OCwgMjQ5LCAyNTAsIDI1MSwgMjUyLCAyNTMsIDI1NCwgMjU1LCAzNCwgMzgsIDYwLCA2MiwgMzM4LCAzMzksIDM1MiwgMzUzLCAzNzYsIDcxMCwgNzMyLCA4MTk0LCA4MTk1LCA4MjAxLCA4MjA0LCA4MjA1LCA4MjA2LCA4MjA3LCA4MjExLCA4MjEyLCA4MjE2LCA4MjE3LCA4MjE4LCA4MjIwLCA4MjIxLCA4MjIyLCA4MjI0LCA4MjI1LCA4MjQwLCA4MjQ5LCA4MjUwLCA4MzY0LCA0MDIsIDkxMywgOTE0LCA5MTUsIDkxNiwgOTE3LCA5MTgsIDkxOSwgOTIwLCA5MjEsIDkyMiwgOTIzLCA5MjQsIDkyNSwgOTI2LCA5MjcsIDkyOCwgOTI5LCA5MzEsIDkzMiwgOTMzLCA5MzQsIDkzNSwgOTM2LCA5MzcsIDk0NSwgOTQ2LCA5NDcsIDk0OCwgOTQ5LCA5NTAsIDk1MSwgOTUyLCA5NTMsIDk1NCwgOTU1LCA5NTYsIDk1NywgOTU4LCA5NTksIDk2MCwgOTYxLCA5NjIsIDk2MywgOTY0LCA5NjUsIDk2NiwgOTY3LCA5NjgsIDk2OSwgOTc3LCA5NzgsIDk4MiwgODIyNiwgODIzMCwgODI0MiwgODI0MywgODI1NCwgODI2MCwgODQ3MiwgODQ2NSwgODQ3NiwgODQ4MiwgODUwMSwgODU5MiwgODU5MywgODU5NCwgODU5NSwgODU5NiwgODYyOSwgODY1NiwgODY1NywgODY1OCwgODY1OSwgODY2MCwgODcwNCwgODcwNiwgODcwNywgODcwOSwgODcxMSwgODcxMiwgODcxMywgODcxNSwgODcxOSwgODcyMSwgODcyMiwgODcyNywgODczMCwgODczMywgODczNCwgODczNiwgODc0MywgODc0NCwgODc0NSwgODc0NiwgODc0NywgODc1NiwgODc2NCwgODc3MywgODc3NiwgODgwMCwgODgwMSwgODgwNCwgODgwNSwgODgzNCwgODgzNSwgODgzNiwgODgzOCwgODgzOSwgODg1MywgODg1NSwgODg2OSwgODkwMSwgODk2OCwgODk2OSwgODk3MCwgODk3MSwgOTAwMSwgOTAwMiwgOTY3NCwgOTgyNCwgOTgyNywgOTgyOSwgOTgzMF07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgbnVtSW5kZXggPSB7fTtcblxudmFyIGkgPSAwO1xudmFyIGxlbmd0aCA9IEhUTUxfQUxQSEEubGVuZ3RoO1xud2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICB2YXIgYSA9IEhUTUxfQUxQSEFbaV07XG4gICAgdmFyIGMgPSBIVE1MX0NPREVTW2ldO1xuICAgIGFscGhhSW5kZXhbYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgIG51bUluZGV4W2NdID0gYTtcbiAgICBpKys7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw0RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMiksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmRlY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICByZXN1bHQgKz0gYWxwaGEgPyBcIiZcIiArIGFscGhhICsgXCI7XCIgOiBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2MgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbY2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2MgPCAzMiB8fCBjYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJiNcIiArIGNjICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNEVudGl0aWVzO1xuIiwidmFyIEVOVElUSUVTID0gW1snQWFjdXRlJywgWzE5M11dLCBbJ2FhY3V0ZScsIFsyMjVdXSwgWydBYnJldmUnLCBbMjU4XV0sIFsnYWJyZXZlJywgWzI1OV1dLCBbJ2FjJywgWzg3NjZdXSwgWydhY2QnLCBbODc2N11dLCBbJ2FjRScsIFs4NzY2LCA4MTldXSwgWydBY2lyYycsIFsxOTRdXSwgWydhY2lyYycsIFsyMjZdXSwgWydhY3V0ZScsIFsxODBdXSwgWydBY3knLCBbMTA0MF1dLCBbJ2FjeScsIFsxMDcyXV0sIFsnQUVsaWcnLCBbMTk4XV0sIFsnYWVsaWcnLCBbMjMwXV0sIFsnYWYnLCBbODI4OV1dLCBbJ0FmcicsIFsxMjAwNjhdXSwgWydhZnInLCBbMTIwMDk0XV0sIFsnQWdyYXZlJywgWzE5Ml1dLCBbJ2FncmF2ZScsIFsyMjRdXSwgWydhbGVmc3ltJywgWzg1MDFdXSwgWydhbGVwaCcsIFs4NTAxXV0sIFsnQWxwaGEnLCBbOTEzXV0sIFsnYWxwaGEnLCBbOTQ1XV0sIFsnQW1hY3InLCBbMjU2XV0sIFsnYW1hY3InLCBbMjU3XV0sIFsnYW1hbGcnLCBbMTA4MTVdXSwgWydhbXAnLCBbMzhdXSwgWydBTVAnLCBbMzhdXSwgWydhbmRhbmQnLCBbMTA4MzddXSwgWydBbmQnLCBbMTA4MzVdXSwgWydhbmQnLCBbODc0M11dLCBbJ2FuZGQnLCBbMTA4NDRdXSwgWydhbmRzbG9wZScsIFsxMDg0MF1dLCBbJ2FuZHYnLCBbMTA4NDJdXSwgWydhbmcnLCBbODczNl1dLCBbJ2FuZ2UnLCBbMTA2NjBdXSwgWydhbmdsZScsIFs4NzM2XV0sIFsnYW5nbXNkYWEnLCBbMTA2NjRdXSwgWydhbmdtc2RhYicsIFsxMDY2NV1dLCBbJ2FuZ21zZGFjJywgWzEwNjY2XV0sIFsnYW5nbXNkYWQnLCBbMTA2NjddXSwgWydhbmdtc2RhZScsIFsxMDY2OF1dLCBbJ2FuZ21zZGFmJywgWzEwNjY5XV0sIFsnYW5nbXNkYWcnLCBbMTA2NzBdXSwgWydhbmdtc2RhaCcsIFsxMDY3MV1dLCBbJ2FuZ21zZCcsIFs4NzM3XV0sIFsnYW5ncnQnLCBbODczNV1dLCBbJ2FuZ3J0dmInLCBbODg5NF1dLCBbJ2FuZ3J0dmJkJywgWzEwNjUzXV0sIFsnYW5nc3BoJywgWzg3MzhdXSwgWydhbmdzdCcsIFsxOTddXSwgWydhbmd6YXJyJywgWzkwODRdXSwgWydBb2dvbicsIFsyNjBdXSwgWydhb2dvbicsIFsyNjFdXSwgWydBb3BmJywgWzEyMDEyMF1dLCBbJ2FvcGYnLCBbMTIwMTQ2XV0sIFsnYXBhY2lyJywgWzEwODYzXV0sIFsnYXAnLCBbODc3Nl1dLCBbJ2FwRScsIFsxMDg2NF1dLCBbJ2FwZScsIFs4Nzc4XV0sIFsnYXBpZCcsIFs4Nzc5XV0sIFsnYXBvcycsIFszOV1dLCBbJ0FwcGx5RnVuY3Rpb24nLCBbODI4OV1dLCBbJ2FwcHJveCcsIFs4Nzc2XV0sIFsnYXBwcm94ZXEnLCBbODc3OF1dLCBbJ0FyaW5nJywgWzE5N11dLCBbJ2FyaW5nJywgWzIyOV1dLCBbJ0FzY3InLCBbMTE5OTY0XV0sIFsnYXNjcicsIFsxMTk5OTBdXSwgWydBc3NpZ24nLCBbODc4OF1dLCBbJ2FzdCcsIFs0Ml1dLCBbJ2FzeW1wJywgWzg3NzZdXSwgWydhc3ltcGVxJywgWzg3ODFdXSwgWydBdGlsZGUnLCBbMTk1XV0sIFsnYXRpbGRlJywgWzIyN11dLCBbJ0F1bWwnLCBbMTk2XV0sIFsnYXVtbCcsIFsyMjhdXSwgWydhd2NvbmludCcsIFs4NzU1XV0sIFsnYXdpbnQnLCBbMTA3NjldXSwgWydiYWNrY29uZycsIFs4NzgwXV0sIFsnYmFja2Vwc2lsb24nLCBbMTAxNF1dLCBbJ2JhY2twcmltZScsIFs4MjQ1XV0sIFsnYmFja3NpbScsIFs4NzY1XV0sIFsnYmFja3NpbWVxJywgWzg5MDldXSwgWydCYWNrc2xhc2gnLCBbODcyNl1dLCBbJ0JhcnYnLCBbMTA5ODNdXSwgWydiYXJ2ZWUnLCBbODg5M11dLCBbJ2JhcndlZCcsIFs4OTY1XV0sIFsnQmFyd2VkJywgWzg5NjZdXSwgWydiYXJ3ZWRnZScsIFs4OTY1XV0sIFsnYmJyaycsIFs5MTQxXV0sIFsnYmJya3RicmsnLCBbOTE0Ml1dLCBbJ2Jjb25nJywgWzg3ODBdXSwgWydCY3knLCBbMTA0MV1dLCBbJ2JjeScsIFsxMDczXV0sIFsnYmRxdW8nLCBbODIyMl1dLCBbJ2JlY2F1cycsIFs4NzU3XV0sIFsnYmVjYXVzZScsIFs4NzU3XV0sIFsnQmVjYXVzZScsIFs4NzU3XV0sIFsnYmVtcHR5dicsIFsxMDY3Ml1dLCBbJ2JlcHNpJywgWzEwMTRdXSwgWydiZXJub3UnLCBbODQ5Ml1dLCBbJ0Jlcm5vdWxsaXMnLCBbODQ5Ml1dLCBbJ0JldGEnLCBbOTE0XV0sIFsnYmV0YScsIFs5NDZdXSwgWydiZXRoJywgWzg1MDJdXSwgWydiZXR3ZWVuJywgWzg4MTJdXSwgWydCZnInLCBbMTIwMDY5XV0sIFsnYmZyJywgWzEyMDA5NV1dLCBbJ2JpZ2NhcCcsIFs4ODk4XV0sIFsnYmlnY2lyYycsIFs5NzExXV0sIFsnYmlnY3VwJywgWzg4OTldXSwgWydiaWdvZG90JywgWzEwNzUyXV0sIFsnYmlnb3BsdXMnLCBbMTA3NTNdXSwgWydiaWdvdGltZXMnLCBbMTA3NTRdXSwgWydiaWdzcWN1cCcsIFsxMDc1OF1dLCBbJ2JpZ3N0YXInLCBbOTczM11dLCBbJ2JpZ3RyaWFuZ2xlZG93bicsIFs5NjYxXV0sIFsnYmlndHJpYW5nbGV1cCcsIFs5NjUxXV0sIFsnYmlndXBsdXMnLCBbMTA3NTZdXSwgWydiaWd2ZWUnLCBbODg5N11dLCBbJ2JpZ3dlZGdlJywgWzg4OTZdXSwgWydia2Fyb3cnLCBbMTA1MDldXSwgWydibGFja2xvemVuZ2UnLCBbMTA3MzFdXSwgWydibGFja3NxdWFyZScsIFs5NjQyXV0sIFsnYmxhY2t0cmlhbmdsZScsIFs5NjUyXV0sIFsnYmxhY2t0cmlhbmdsZWRvd24nLCBbOTY2Ml1dLCBbJ2JsYWNrdHJpYW5nbGVsZWZ0JywgWzk2NjZdXSwgWydibGFja3RyaWFuZ2xlcmlnaHQnLCBbOTY1Nl1dLCBbJ2JsYW5rJywgWzkyNTFdXSwgWydibGsxMicsIFs5NjE4XV0sIFsnYmxrMTQnLCBbOTYxN11dLCBbJ2JsazM0JywgWzk2MTldXSwgWydibG9jaycsIFs5NjA4XV0sIFsnYm5lJywgWzYxLCA4NDIxXV0sIFsnYm5lcXVpdicsIFs4ODAxLCA4NDIxXV0sIFsnYk5vdCcsIFsxMDk4OV1dLCBbJ2Jub3QnLCBbODk3Nl1dLCBbJ0JvcGYnLCBbMTIwMTIxXV0sIFsnYm9wZicsIFsxMjAxNDddXSwgWydib3QnLCBbODg2OV1dLCBbJ2JvdHRvbScsIFs4ODY5XV0sIFsnYm93dGllJywgWzg5MDRdXSwgWydib3hib3gnLCBbMTA2OTddXSwgWydib3hkbCcsIFs5NDg4XV0sIFsnYm94ZEwnLCBbOTU1N11dLCBbJ2JveERsJywgWzk1NThdXSwgWydib3hETCcsIFs5NTU5XV0sIFsnYm94ZHInLCBbOTQ4NF1dLCBbJ2JveGRSJywgWzk1NTRdXSwgWydib3hEcicsIFs5NTU1XV0sIFsnYm94RFInLCBbOTU1Nl1dLCBbJ2JveGgnLCBbOTQ3Ml1dLCBbJ2JveEgnLCBbOTU1Ml1dLCBbJ2JveGhkJywgWzk1MTZdXSwgWydib3hIZCcsIFs5NTcyXV0sIFsnYm94aEQnLCBbOTU3M11dLCBbJ2JveEhEJywgWzk1NzRdXSwgWydib3hodScsIFs5NTI0XV0sIFsnYm94SHUnLCBbOTU3NV1dLCBbJ2JveGhVJywgWzk1NzZdXSwgWydib3hIVScsIFs5NTc3XV0sIFsnYm94bWludXMnLCBbODg2M11dLCBbJ2JveHBsdXMnLCBbODg2Ml1dLCBbJ2JveHRpbWVzJywgWzg4NjRdXSwgWydib3h1bCcsIFs5NDk2XV0sIFsnYm94dUwnLCBbOTU2M11dLCBbJ2JveFVsJywgWzk1NjRdXSwgWydib3hVTCcsIFs5NTY1XV0sIFsnYm94dXInLCBbOTQ5Ml1dLCBbJ2JveHVSJywgWzk1NjBdXSwgWydib3hVcicsIFs5NTYxXV0sIFsnYm94VVInLCBbOTU2Ml1dLCBbJ2JveHYnLCBbOTQ3NF1dLCBbJ2JveFYnLCBbOTU1M11dLCBbJ2JveHZoJywgWzk1MzJdXSwgWydib3h2SCcsIFs5NTc4XV0sIFsnYm94VmgnLCBbOTU3OV1dLCBbJ2JveFZIJywgWzk1ODBdXSwgWydib3h2bCcsIFs5NTA4XV0sIFsnYm94dkwnLCBbOTU2OV1dLCBbJ2JveFZsJywgWzk1NzBdXSwgWydib3hWTCcsIFs5NTcxXV0sIFsnYm94dnInLCBbOTUwMF1dLCBbJ2JveHZSJywgWzk1NjZdXSwgWydib3hWcicsIFs5NTY3XV0sIFsnYm94VlInLCBbOTU2OF1dLCBbJ2JwcmltZScsIFs4MjQ1XV0sIFsnYnJldmUnLCBbNzI4XV0sIFsnQnJldmUnLCBbNzI4XV0sIFsnYnJ2YmFyJywgWzE2Nl1dLCBbJ2JzY3InLCBbMTE5OTkxXV0sIFsnQnNjcicsIFs4NDkyXV0sIFsnYnNlbWknLCBbODI3MV1dLCBbJ2JzaW0nLCBbODc2NV1dLCBbJ2JzaW1lJywgWzg5MDldXSwgWydic29sYicsIFsxMDY5M11dLCBbJ2Jzb2wnLCBbOTJdXSwgWydic29saHN1YicsIFsxMDE4NF1dLCBbJ2J1bGwnLCBbODIyNl1dLCBbJ2J1bGxldCcsIFs4MjI2XV0sIFsnYnVtcCcsIFs4NzgyXV0sIFsnYnVtcEUnLCBbMTA5MjZdXSwgWydidW1wZScsIFs4NzgzXV0sIFsnQnVtcGVxJywgWzg3ODJdXSwgWydidW1wZXEnLCBbODc4M11dLCBbJ0NhY3V0ZScsIFsyNjJdXSwgWydjYWN1dGUnLCBbMjYzXV0sIFsnY2FwYW5kJywgWzEwODIwXV0sIFsnY2FwYnJjdXAnLCBbMTA4MjVdXSwgWydjYXBjYXAnLCBbMTA4MjddXSwgWydjYXAnLCBbODc0NV1dLCBbJ0NhcCcsIFs4OTE0XV0sIFsnY2FwY3VwJywgWzEwODIzXV0sIFsnY2FwZG90JywgWzEwODE2XV0sIFsnQ2FwaXRhbERpZmZlcmVudGlhbEQnLCBbODUxN11dLCBbJ2NhcHMnLCBbODc0NSwgNjUwMjRdXSwgWydjYXJldCcsIFs4MjU3XV0sIFsnY2Fyb24nLCBbNzExXV0sIFsnQ2F5bGV5cycsIFs4NDkzXV0sIFsnY2NhcHMnLCBbMTA4MjldXSwgWydDY2Fyb24nLCBbMjY4XV0sIFsnY2Nhcm9uJywgWzI2OV1dLCBbJ0NjZWRpbCcsIFsxOTldXSwgWydjY2VkaWwnLCBbMjMxXV0sIFsnQ2NpcmMnLCBbMjY0XV0sIFsnY2NpcmMnLCBbMjY1XV0sIFsnQ2NvbmludCcsIFs4NzUyXV0sIFsnY2N1cHMnLCBbMTA4MjhdXSwgWydjY3Vwc3NtJywgWzEwODMyXV0sIFsnQ2RvdCcsIFsyNjZdXSwgWydjZG90JywgWzI2N11dLCBbJ2NlZGlsJywgWzE4NF1dLCBbJ0NlZGlsbGEnLCBbMTg0XV0sIFsnY2VtcHR5dicsIFsxMDY3NF1dLCBbJ2NlbnQnLCBbMTYyXV0sIFsnY2VudGVyZG90JywgWzE4M11dLCBbJ0NlbnRlckRvdCcsIFsxODNdXSwgWydjZnInLCBbMTIwMDk2XV0sIFsnQ2ZyJywgWzg0OTNdXSwgWydDSGN5JywgWzEwNjNdXSwgWydjaGN5JywgWzEwOTVdXSwgWydjaGVjaycsIFsxMDAwM11dLCBbJ2NoZWNrbWFyaycsIFsxMDAwM11dLCBbJ0NoaScsIFs5MzVdXSwgWydjaGknLCBbOTY3XV0sIFsnY2lyYycsIFs3MTBdXSwgWydjaXJjZXEnLCBbODc5MV1dLCBbJ2NpcmNsZWFycm93bGVmdCcsIFs4NjM0XV0sIFsnY2lyY2xlYXJyb3dyaWdodCcsIFs4NjM1XV0sIFsnY2lyY2xlZGFzdCcsIFs4ODU5XV0sIFsnY2lyY2xlZGNpcmMnLCBbODg1OF1dLCBbJ2NpcmNsZWRkYXNoJywgWzg4NjFdXSwgWydDaXJjbGVEb3QnLCBbODg1N11dLCBbJ2NpcmNsZWRSJywgWzE3NF1dLCBbJ2NpcmNsZWRTJywgWzk0MTZdXSwgWydDaXJjbGVNaW51cycsIFs4ODU0XV0sIFsnQ2lyY2xlUGx1cycsIFs4ODUzXV0sIFsnQ2lyY2xlVGltZXMnLCBbODg1NV1dLCBbJ2NpcicsIFs5Njc1XV0sIFsnY2lyRScsIFsxMDY5MV1dLCBbJ2NpcmUnLCBbODc5MV1dLCBbJ2NpcmZuaW50JywgWzEwNzY4XV0sIFsnY2lybWlkJywgWzEwOTkxXV0sIFsnY2lyc2NpcicsIFsxMDY5MF1dLCBbJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU0XV0sIFsnY2x1YnMnLCBbOTgyN11dLCBbJ2NsdWJzdWl0JywgWzk4MjddXSwgWydjb2xvbicsIFs1OF1dLCBbJ0NvbG9uJywgWzg3NTldXSwgWydDb2xvbmUnLCBbMTA4NjhdXSwgWydjb2xvbmUnLCBbODc4OF1dLCBbJ2NvbG9uZXEnLCBbODc4OF1dLCBbJ2NvbW1hJywgWzQ0XV0sIFsnY29tbWF0JywgWzY0XV0sIFsnY29tcCcsIFs4NzA1XV0sIFsnY29tcGZuJywgWzg3MjhdXSwgWydjb21wbGVtZW50JywgWzg3MDVdXSwgWydjb21wbGV4ZXMnLCBbODQ1MF1dLCBbJ2NvbmcnLCBbODc3M11dLCBbJ2Nvbmdkb3QnLCBbMTA4NjFdXSwgWydDb25ncnVlbnQnLCBbODgwMV1dLCBbJ2NvbmludCcsIFs4NzUwXV0sIFsnQ29uaW50JywgWzg3NTFdXSwgWydDb250b3VySW50ZWdyYWwnLCBbODc1MF1dLCBbJ2NvcGYnLCBbMTIwMTQ4XV0sIFsnQ29wZicsIFs4NDUwXV0sIFsnY29wcm9kJywgWzg3MjBdXSwgWydDb3Byb2R1Y3QnLCBbODcyMF1dLCBbJ2NvcHknLCBbMTY5XV0sIFsnQ09QWScsIFsxNjldXSwgWydjb3B5c3InLCBbODQ3MV1dLCBbJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NV1dLCBbJ2NyYXJyJywgWzg2MjldXSwgWydjcm9zcycsIFsxMDAwN11dLCBbJ0Nyb3NzJywgWzEwNzk5XV0sIFsnQ3NjcicsIFsxMTk5NjZdXSwgWydjc2NyJywgWzExOTk5Ml1dLCBbJ2NzdWInLCBbMTA5NTldXSwgWydjc3ViZScsIFsxMDk2MV1dLCBbJ2NzdXAnLCBbMTA5NjBdXSwgWydjc3VwZScsIFsxMDk2Ml1dLCBbJ2N0ZG90JywgWzg5NDNdXSwgWydjdWRhcnJsJywgWzEwNTUyXV0sIFsnY3VkYXJycicsIFsxMDU0OV1dLCBbJ2N1ZXByJywgWzg5MjZdXSwgWydjdWVzYycsIFs4OTI3XV0sIFsnY3VsYXJyJywgWzg2MzBdXSwgWydjdWxhcnJwJywgWzEwNTU3XV0sIFsnY3VwYnJjYXAnLCBbMTA4MjRdXSwgWydjdXBjYXAnLCBbMTA4MjJdXSwgWydDdXBDYXAnLCBbODc4MV1dLCBbJ2N1cCcsIFs4NzQ2XV0sIFsnQ3VwJywgWzg5MTVdXSwgWydjdXBjdXAnLCBbMTA4MjZdXSwgWydjdXBkb3QnLCBbODg0NV1dLCBbJ2N1cG9yJywgWzEwODIxXV0sIFsnY3VwcycsIFs4NzQ2LCA2NTAyNF1dLCBbJ2N1cmFycicsIFs4NjMxXV0sIFsnY3VyYXJybScsIFsxMDU1Nl1dLCBbJ2N1cmx5ZXFwcmVjJywgWzg5MjZdXSwgWydjdXJseWVxc3VjYycsIFs4OTI3XV0sIFsnY3VybHl2ZWUnLCBbODkxMF1dLCBbJ2N1cmx5d2VkZ2UnLCBbODkxMV1dLCBbJ2N1cnJlbicsIFsxNjRdXSwgWydjdXJ2ZWFycm93bGVmdCcsIFs4NjMwXV0sIFsnY3VydmVhcnJvd3JpZ2h0JywgWzg2MzFdXSwgWydjdXZlZScsIFs4OTEwXV0sIFsnY3V3ZWQnLCBbODkxMV1dLCBbJ2N3Y29uaW50JywgWzg3NTRdXSwgWydjd2ludCcsIFs4NzUzXV0sIFsnY3lsY3R5JywgWzkwMDVdXSwgWydkYWdnZXInLCBbODIyNF1dLCBbJ0RhZ2dlcicsIFs4MjI1XV0sIFsnZGFsZXRoJywgWzg1MDRdXSwgWydkYXJyJywgWzg1OTVdXSwgWydEYXJyJywgWzg2MDldXSwgWydkQXJyJywgWzg2NTldXSwgWydkYXNoJywgWzgyMDhdXSwgWydEYXNodicsIFsxMDk4MF1dLCBbJ2Rhc2h2JywgWzg4NjddXSwgWydkYmthcm93JywgWzEwNTExXV0sIFsnZGJsYWMnLCBbNzMzXV0sIFsnRGNhcm9uJywgWzI3MF1dLCBbJ2RjYXJvbicsIFsyNzFdXSwgWydEY3knLCBbMTA0NF1dLCBbJ2RjeScsIFsxMDc2XV0sIFsnZGRhZ2dlcicsIFs4MjI1XV0sIFsnZGRhcnInLCBbODY1MF1dLCBbJ0REJywgWzg1MTddXSwgWydkZCcsIFs4NTE4XV0sIFsnRERvdHJhaGQnLCBbMTA1MTNdXSwgWydkZG90c2VxJywgWzEwODcxXV0sIFsnZGVnJywgWzE3Nl1dLCBbJ0RlbCcsIFs4NzExXV0sIFsnRGVsdGEnLCBbOTE2XV0sIFsnZGVsdGEnLCBbOTQ4XV0sIFsnZGVtcHR5dicsIFsxMDY3M11dLCBbJ2RmaXNodCcsIFsxMDYyM11dLCBbJ0RmcicsIFsxMjAwNzFdXSwgWydkZnInLCBbMTIwMDk3XV0sIFsnZEhhcicsIFsxMDU5N11dLCBbJ2RoYXJsJywgWzg2NDNdXSwgWydkaGFycicsIFs4NjQyXV0sIFsnRGlhY3JpdGljYWxBY3V0ZScsIFsxODBdXSwgWydEaWFjcml0aWNhbERvdCcsIFs3MjldXSwgWydEaWFjcml0aWNhbERvdWJsZUFjdXRlJywgWzczM11dLCBbJ0RpYWNyaXRpY2FsR3JhdmUnLCBbOTZdXSwgWydEaWFjcml0aWNhbFRpbGRlJywgWzczMl1dLCBbJ2RpYW0nLCBbODkwMF1dLCBbJ2RpYW1vbmQnLCBbODkwMF1dLCBbJ0RpYW1vbmQnLCBbODkwMF1dLCBbJ2RpYW1vbmRzdWl0JywgWzk4MzBdXSwgWydkaWFtcycsIFs5ODMwXV0sIFsnZGllJywgWzE2OF1dLCBbJ0RpZmZlcmVudGlhbEQnLCBbODUxOF1dLCBbJ2RpZ2FtbWEnLCBbOTg5XV0sIFsnZGlzaW4nLCBbODk0Nl1dLCBbJ2RpdicsIFsyNDddXSwgWydkaXZpZGUnLCBbMjQ3XV0sIFsnZGl2aWRlb250aW1lcycsIFs4OTAzXV0sIFsnZGl2b254JywgWzg5MDNdXSwgWydESmN5JywgWzEwMjZdXSwgWydkamN5JywgWzExMDZdXSwgWydkbGNvcm4nLCBbODk5MF1dLCBbJ2RsY3JvcCcsIFs4OTczXV0sIFsnZG9sbGFyJywgWzM2XV0sIFsnRG9wZicsIFsxMjAxMjNdXSwgWydkb3BmJywgWzEyMDE0OV1dLCBbJ0RvdCcsIFsxNjhdXSwgWydkb3QnLCBbNzI5XV0sIFsnRG90RG90JywgWzg0MTJdXSwgWydkb3RlcScsIFs4Nzg0XV0sIFsnZG90ZXFkb3QnLCBbODc4NV1dLCBbJ0RvdEVxdWFsJywgWzg3ODRdXSwgWydkb3RtaW51cycsIFs4NzYwXV0sIFsnZG90cGx1cycsIFs4NzI0XV0sIFsnZG90c3F1YXJlJywgWzg4NjVdXSwgWydkb3VibGViYXJ3ZWRnZScsIFs4OTY2XV0sIFsnRG91YmxlQ29udG91ckludGVncmFsJywgWzg3NTFdXSwgWydEb3VibGVEb3QnLCBbMTY4XV0sIFsnRG91YmxlRG93bkFycm93JywgWzg2NTldXSwgWydEb3VibGVMZWZ0QXJyb3cnLCBbODY1Nl1dLCBbJ0RvdWJsZUxlZnRSaWdodEFycm93JywgWzg2NjBdXSwgWydEb3VibGVMZWZ0VGVlJywgWzEwOTgwXV0sIFsnRG91YmxlTG9uZ0xlZnRBcnJvdycsIFsxMDIzMl1dLCBbJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzNF1dLCBbJ0RvdWJsZUxvbmdSaWdodEFycm93JywgWzEwMjMzXV0sIFsnRG91YmxlUmlnaHRBcnJvdycsIFs4NjU4XV0sIFsnRG91YmxlUmlnaHRUZWUnLCBbODg3Ml1dLCBbJ0RvdWJsZVVwQXJyb3cnLCBbODY1N11dLCBbJ0RvdWJsZVVwRG93bkFycm93JywgWzg2NjFdXSwgWydEb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQxXV0sIFsnRG93bkFycm93QmFyJywgWzEwNTE1XV0sIFsnZG93bmFycm93JywgWzg1OTVdXSwgWydEb3duQXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25hcnJvdycsIFs4NjU5XV0sIFsnRG93bkFycm93VXBBcnJvdycsIFs4NjkzXV0sIFsnRG93bkJyZXZlJywgWzc4NV1dLCBbJ2Rvd25kb3duYXJyb3dzJywgWzg2NTBdXSwgWydkb3duaGFycG9vbmxlZnQnLCBbODY0M11dLCBbJ2Rvd25oYXJwb29ucmlnaHQnLCBbODY0Ml1dLCBbJ0Rvd25MZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzZdXSwgWydEb3duTGVmdFRlZVZlY3RvcicsIFsxMDU5MF1dLCBbJ0Rvd25MZWZ0VmVjdG9yQmFyJywgWzEwNTgyXV0sIFsnRG93bkxlZnRWZWN0b3InLCBbODYzN11dLCBbJ0Rvd25SaWdodFRlZVZlY3RvcicsIFsxMDU5MV1dLCBbJ0Rvd25SaWdodFZlY3RvckJhcicsIFsxMDU4M11dLCBbJ0Rvd25SaWdodFZlY3RvcicsIFs4NjQxXV0sIFsnRG93blRlZUFycm93JywgWzg2MTVdXSwgWydEb3duVGVlJywgWzg4NjhdXSwgWydkcmJrYXJvdycsIFsxMDUxMl1dLCBbJ2RyY29ybicsIFs4OTkxXV0sIFsnZHJjcm9wJywgWzg5NzJdXSwgWydEc2NyJywgWzExOTk2N11dLCBbJ2RzY3InLCBbMTE5OTkzXV0sIFsnRFNjeScsIFsxMDI5XV0sIFsnZHNjeScsIFsxMTA5XV0sIFsnZHNvbCcsIFsxMDc0Ml1dLCBbJ0RzdHJvaycsIFsyNzJdXSwgWydkc3Ryb2snLCBbMjczXV0sIFsnZHRkb3QnLCBbODk0NV1dLCBbJ2R0cmknLCBbOTY2M11dLCBbJ2R0cmlmJywgWzk2NjJdXSwgWydkdWFycicsIFs4NjkzXV0sIFsnZHVoYXInLCBbMTA2MDddXSwgWydkd2FuZ2xlJywgWzEwNjYyXV0sIFsnRFpjeScsIFsxMDM5XV0sIFsnZHpjeScsIFsxMTE5XV0sIFsnZHppZ3JhcnInLCBbMTAyMzldXSwgWydFYWN1dGUnLCBbMjAxXV0sIFsnZWFjdXRlJywgWzIzM11dLCBbJ2Vhc3RlcicsIFsxMDg2Ml1dLCBbJ0VjYXJvbicsIFsyODJdXSwgWydlY2Fyb24nLCBbMjgzXV0sIFsnRWNpcmMnLCBbMjAyXV0sIFsnZWNpcmMnLCBbMjM0XV0sIFsnZWNpcicsIFs4NzkwXV0sIFsnZWNvbG9uJywgWzg3ODldXSwgWydFY3knLCBbMTA2OV1dLCBbJ2VjeScsIFsxMTAxXV0sIFsnZUREb3QnLCBbMTA4NzFdXSwgWydFZG90JywgWzI3OF1dLCBbJ2Vkb3QnLCBbMjc5XV0sIFsnZURvdCcsIFs4Nzg1XV0sIFsnZWUnLCBbODUxOV1dLCBbJ2VmRG90JywgWzg3ODZdXSwgWydFZnInLCBbMTIwMDcyXV0sIFsnZWZyJywgWzEyMDA5OF1dLCBbJ2VnJywgWzEwOTA2XV0sIFsnRWdyYXZlJywgWzIwMF1dLCBbJ2VncmF2ZScsIFsyMzJdXSwgWydlZ3MnLCBbMTA5MDJdXSwgWydlZ3Nkb3QnLCBbMTA5MDRdXSwgWydlbCcsIFsxMDkwNV1dLCBbJ0VsZW1lbnQnLCBbODcxMl1dLCBbJ2VsaW50ZXJzJywgWzkxOTFdXSwgWydlbGwnLCBbODQ2N11dLCBbJ2VscycsIFsxMDkwMV1dLCBbJ2Vsc2RvdCcsIFsxMDkwM11dLCBbJ0VtYWNyJywgWzI3NF1dLCBbJ2VtYWNyJywgWzI3NV1dLCBbJ2VtcHR5JywgWzg3MDldXSwgWydlbXB0eXNldCcsIFs4NzA5XV0sIFsnRW1wdHlTbWFsbFNxdWFyZScsIFs5NzIzXV0sIFsnZW1wdHl2JywgWzg3MDldXSwgWydFbXB0eVZlcnlTbWFsbFNxdWFyZScsIFs5NjQzXV0sIFsnZW1zcDEzJywgWzgxOTZdXSwgWydlbXNwMTQnLCBbODE5N11dLCBbJ2Vtc3AnLCBbODE5NV1dLCBbJ0VORycsIFszMzBdXSwgWydlbmcnLCBbMzMxXV0sIFsnZW5zcCcsIFs4MTk0XV0sIFsnRW9nb24nLCBbMjgwXV0sIFsnZW9nb24nLCBbMjgxXV0sIFsnRW9wZicsIFsxMjAxMjRdXSwgWydlb3BmJywgWzEyMDE1MF1dLCBbJ2VwYXInLCBbODkxN11dLCBbJ2VwYXJzbCcsIFsxMDcyM11dLCBbJ2VwbHVzJywgWzEwODY1XV0sIFsnZXBzaScsIFs5NDldXSwgWydFcHNpbG9uJywgWzkxN11dLCBbJ2Vwc2lsb24nLCBbOTQ5XV0sIFsnZXBzaXYnLCBbMTAxM11dLCBbJ2VxY2lyYycsIFs4NzkwXV0sIFsnZXFjb2xvbicsIFs4Nzg5XV0sIFsnZXFzaW0nLCBbODc3MF1dLCBbJ2Vxc2xhbnRndHInLCBbMTA5MDJdXSwgWydlcXNsYW50bGVzcycsIFsxMDkwMV1dLCBbJ0VxdWFsJywgWzEwODY5XV0sIFsnZXF1YWxzJywgWzYxXV0sIFsnRXF1YWxUaWxkZScsIFs4NzcwXV0sIFsnZXF1ZXN0JywgWzg3OTldXSwgWydFcXVpbGlicml1bScsIFs4NjUyXV0sIFsnZXF1aXYnLCBbODgwMV1dLCBbJ2VxdWl2REQnLCBbMTA4NzJdXSwgWydlcXZwYXJzbCcsIFsxMDcyNV1dLCBbJ2VyYXJyJywgWzEwNjA5XV0sIFsnZXJEb3QnLCBbODc4N11dLCBbJ2VzY3InLCBbODQ5NV1dLCBbJ0VzY3InLCBbODQ5Nl1dLCBbJ2VzZG90JywgWzg3ODRdXSwgWydFc2ltJywgWzEwODY3XV0sIFsnZXNpbScsIFs4NzcwXV0sIFsnRXRhJywgWzkxOV1dLCBbJ2V0YScsIFs5NTFdXSwgWydFVEgnLCBbMjA4XV0sIFsnZXRoJywgWzI0MF1dLCBbJ0V1bWwnLCBbMjAzXV0sIFsnZXVtbCcsIFsyMzVdXSwgWydldXJvJywgWzgzNjRdXSwgWydleGNsJywgWzMzXV0sIFsnZXhpc3QnLCBbODcwN11dLCBbJ0V4aXN0cycsIFs4NzA3XV0sIFsnZXhwZWN0YXRpb24nLCBbODQ5Nl1dLCBbJ2V4cG9uZW50aWFsZScsIFs4NTE5XV0sIFsnRXhwb25lbnRpYWxFJywgWzg1MTldXSwgWydmYWxsaW5nZG90c2VxJywgWzg3ODZdXSwgWydGY3knLCBbMTA2MF1dLCBbJ2ZjeScsIFsxMDkyXV0sIFsnZmVtYWxlJywgWzk3OTJdXSwgWydmZmlsaWcnLCBbNjQyNTldXSwgWydmZmxpZycsIFs2NDI1Nl1dLCBbJ2ZmbGxpZycsIFs2NDI2MF1dLCBbJ0ZmcicsIFsxMjAwNzNdXSwgWydmZnInLCBbMTIwMDk5XV0sIFsnZmlsaWcnLCBbNjQyNTddXSwgWydGaWxsZWRTbWFsbFNxdWFyZScsIFs5NzI0XV0sIFsnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJywgWzk2NDJdXSwgWydmamxpZycsIFsxMDIsIDEwNl1dLCBbJ2ZsYXQnLCBbOTgzN11dLCBbJ2ZsbGlnJywgWzY0MjU4XV0sIFsnZmx0bnMnLCBbOTY0OV1dLCBbJ2Zub2YnLCBbNDAyXV0sIFsnRm9wZicsIFsxMjAxMjVdXSwgWydmb3BmJywgWzEyMDE1MV1dLCBbJ2ZvcmFsbCcsIFs4NzA0XV0sIFsnRm9yQWxsJywgWzg3MDRdXSwgWydmb3JrJywgWzg5MTZdXSwgWydmb3JrdicsIFsxMDk2OV1dLCBbJ0ZvdXJpZXJ0cmYnLCBbODQ5N11dLCBbJ2ZwYXJ0aW50JywgWzEwNzY1XV0sIFsnZnJhYzEyJywgWzE4OV1dLCBbJ2ZyYWMxMycsIFs4NTMxXV0sIFsnZnJhYzE0JywgWzE4OF1dLCBbJ2ZyYWMxNScsIFs4NTMzXV0sIFsnZnJhYzE2JywgWzg1MzddXSwgWydmcmFjMTgnLCBbODUzOV1dLCBbJ2ZyYWMyMycsIFs4NTMyXV0sIFsnZnJhYzI1JywgWzg1MzRdXSwgWydmcmFjMzQnLCBbMTkwXV0sIFsnZnJhYzM1JywgWzg1MzVdXSwgWydmcmFjMzgnLCBbODU0MF1dLCBbJ2ZyYWM0NScsIFs4NTM2XV0sIFsnZnJhYzU2JywgWzg1MzhdXSwgWydmcmFjNTgnLCBbODU0MV1dLCBbJ2ZyYWM3OCcsIFs4NTQyXV0sIFsnZnJhc2wnLCBbODI2MF1dLCBbJ2Zyb3duJywgWzg5OTRdXSwgWydmc2NyJywgWzExOTk5NV1dLCBbJ0ZzY3InLCBbODQ5N11dLCBbJ2dhY3V0ZScsIFs1MDFdXSwgWydHYW1tYScsIFs5MTVdXSwgWydnYW1tYScsIFs5NDddXSwgWydHYW1tYWQnLCBbOTg4XV0sIFsnZ2FtbWFkJywgWzk4OV1dLCBbJ2dhcCcsIFsxMDg4Nl1dLCBbJ0dicmV2ZScsIFsyODZdXSwgWydnYnJldmUnLCBbMjg3XV0sIFsnR2NlZGlsJywgWzI5MF1dLCBbJ0djaXJjJywgWzI4NF1dLCBbJ2djaXJjJywgWzI4NV1dLCBbJ0djeScsIFsxMDQzXV0sIFsnZ2N5JywgWzEwNzVdXSwgWydHZG90JywgWzI4OF1dLCBbJ2dkb3QnLCBbMjg5XV0sIFsnZ2UnLCBbODgwNV1dLCBbJ2dFJywgWzg4MDddXSwgWydnRWwnLCBbMTA4OTJdXSwgWydnZWwnLCBbODkyM11dLCBbJ2dlcScsIFs4ODA1XV0sIFsnZ2VxcScsIFs4ODA3XV0sIFsnZ2Vxc2xhbnQnLCBbMTA4NzhdXSwgWydnZXNjYycsIFsxMDkyMV1dLCBbJ2dlcycsIFsxMDg3OF1dLCBbJ2dlc2RvdCcsIFsxMDg4MF1dLCBbJ2dlc2RvdG8nLCBbMTA4ODJdXSwgWydnZXNkb3RvbCcsIFsxMDg4NF1dLCBbJ2dlc2wnLCBbODkyMywgNjUwMjRdXSwgWydnZXNsZXMnLCBbMTA5MDBdXSwgWydHZnInLCBbMTIwMDc0XV0sIFsnZ2ZyJywgWzEyMDEwMF1dLCBbJ2dnJywgWzg4MTFdXSwgWydHZycsIFs4OTIxXV0sIFsnZ2dnJywgWzg5MjFdXSwgWydnaW1lbCcsIFs4NTAzXV0sIFsnR0pjeScsIFsxMDI3XV0sIFsnZ2pjeScsIFsxMTA3XV0sIFsnZ2xhJywgWzEwOTE3XV0sIFsnZ2wnLCBbODgyM11dLCBbJ2dsRScsIFsxMDg5OF1dLCBbJ2dsaicsIFsxMDkxNl1dLCBbJ2duYXAnLCBbMTA4OTBdXSwgWydnbmFwcHJveCcsIFsxMDg5MF1dLCBbJ2duZScsIFsxMDg4OF1dLCBbJ2duRScsIFs4ODA5XV0sIFsnZ25lcScsIFsxMDg4OF1dLCBbJ2duZXFxJywgWzg4MDldXSwgWydnbnNpbScsIFs4OTM1XV0sIFsnR29wZicsIFsxMjAxMjZdXSwgWydnb3BmJywgWzEyMDE1Ml1dLCBbJ2dyYXZlJywgWzk2XV0sIFsnR3JlYXRlckVxdWFsJywgWzg4MDVdXSwgWydHcmVhdGVyRXF1YWxMZXNzJywgWzg5MjNdXSwgWydHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDddXSwgWydHcmVhdGVyR3JlYXRlcicsIFsxMDkxNF1dLCBbJ0dyZWF0ZXJMZXNzJywgWzg4MjNdXSwgWydHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OF1dLCBbJ0dyZWF0ZXJUaWxkZScsIFs4ODE5XV0sIFsnR3NjcicsIFsxMTk5NzBdXSwgWydnc2NyJywgWzg0NThdXSwgWydnc2ltJywgWzg4MTldXSwgWydnc2ltZScsIFsxMDg5NF1dLCBbJ2dzaW1sJywgWzEwODk2XV0sIFsnZ3RjYycsIFsxMDkxOV1dLCBbJ2d0Y2lyJywgWzEwODc0XV0sIFsnZ3QnLCBbNjJdXSwgWydHVCcsIFs2Ml1dLCBbJ0d0JywgWzg4MTFdXSwgWydndGRvdCcsIFs4OTE5XV0sIFsnZ3RsUGFyJywgWzEwNjQ1XV0sIFsnZ3RxdWVzdCcsIFsxMDg3Nl1dLCBbJ2d0cmFwcHJveCcsIFsxMDg4Nl1dLCBbJ2d0cmFycicsIFsxMDYxNl1dLCBbJ2d0cmRvdCcsIFs4OTE5XV0sIFsnZ3RyZXFsZXNzJywgWzg5MjNdXSwgWydndHJlcXFsZXNzJywgWzEwODkyXV0sIFsnZ3RybGVzcycsIFs4ODIzXV0sIFsnZ3Ryc2ltJywgWzg4MTldXSwgWydndmVydG5lcXEnLCBbODgwOSwgNjUwMjRdXSwgWydndm5FJywgWzg4MDksIDY1MDI0XV0sIFsnSGFjZWsnLCBbNzExXV0sIFsnaGFpcnNwJywgWzgyMDJdXSwgWydoYWxmJywgWzE4OV1dLCBbJ2hhbWlsdCcsIFs4NDU5XV0sIFsnSEFSRGN5JywgWzEwNjZdXSwgWydoYXJkY3knLCBbMTA5OF1dLCBbJ2hhcnJjaXInLCBbMTA1NjhdXSwgWydoYXJyJywgWzg1OTZdXSwgWydoQXJyJywgWzg2NjBdXSwgWydoYXJydycsIFs4NjIxXV0sIFsnSGF0JywgWzk0XV0sIFsnaGJhcicsIFs4NDYzXV0sIFsnSGNpcmMnLCBbMjkyXV0sIFsnaGNpcmMnLCBbMjkzXV0sIFsnaGVhcnRzJywgWzk4MjldXSwgWydoZWFydHN1aXQnLCBbOTgyOV1dLCBbJ2hlbGxpcCcsIFs4MjMwXV0sIFsnaGVyY29uJywgWzg4ODldXSwgWydoZnInLCBbMTIwMTAxXV0sIFsnSGZyJywgWzg0NjBdXSwgWydIaWxiZXJ0U3BhY2UnLCBbODQ1OV1dLCBbJ2hrc2Vhcm93JywgWzEwNTMzXV0sIFsnaGtzd2Fyb3cnLCBbMTA1MzRdXSwgWydob2FycicsIFs4NzAzXV0sIFsnaG9tdGh0JywgWzg3NjNdXSwgWydob29rbGVmdGFycm93JywgWzg2MTddXSwgWydob29rcmlnaHRhcnJvdycsIFs4NjE4XV0sIFsnaG9wZicsIFsxMjAxNTNdXSwgWydIb3BmJywgWzg0NjFdXSwgWydob3JiYXInLCBbODIxM11dLCBbJ0hvcml6b250YWxMaW5lJywgWzk0NzJdXSwgWydoc2NyJywgWzExOTk5N11dLCBbJ0hzY3InLCBbODQ1OV1dLCBbJ2hzbGFzaCcsIFs4NDYzXV0sIFsnSHN0cm9rJywgWzI5NF1dLCBbJ2hzdHJvaycsIFsyOTVdXSwgWydIdW1wRG93bkh1bXAnLCBbODc4Ml1dLCBbJ0h1bXBFcXVhbCcsIFs4NzgzXV0sIFsnaHlidWxsJywgWzgyNTldXSwgWydoeXBoZW4nLCBbODIwOF1dLCBbJ0lhY3V0ZScsIFsyMDVdXSwgWydpYWN1dGUnLCBbMjM3XV0sIFsnaWMnLCBbODI5MV1dLCBbJ0ljaXJjJywgWzIwNl1dLCBbJ2ljaXJjJywgWzIzOF1dLCBbJ0ljeScsIFsxMDQ4XV0sIFsnaWN5JywgWzEwODBdXSwgWydJZG90JywgWzMwNF1dLCBbJ0lFY3knLCBbMTA0NV1dLCBbJ2llY3knLCBbMTA3N11dLCBbJ2lleGNsJywgWzE2MV1dLCBbJ2lmZicsIFs4NjYwXV0sIFsnaWZyJywgWzEyMDEwMl1dLCBbJ0lmcicsIFs4NDY1XV0sIFsnSWdyYXZlJywgWzIwNF1dLCBbJ2lncmF2ZScsIFsyMzZdXSwgWydpaScsIFs4NTIwXV0sIFsnaWlpaW50JywgWzEwNzY0XV0sIFsnaWlpbnQnLCBbODc0OV1dLCBbJ2lpbmZpbicsIFsxMDcxNl1dLCBbJ2lpb3RhJywgWzg0ODldXSwgWydJSmxpZycsIFszMDZdXSwgWydpamxpZycsIFszMDddXSwgWydJbWFjcicsIFsyOThdXSwgWydpbWFjcicsIFsyOTldXSwgWydpbWFnZScsIFs4NDY1XV0sIFsnSW1hZ2luYXJ5SScsIFs4NTIwXV0sIFsnaW1hZ2xpbmUnLCBbODQ2NF1dLCBbJ2ltYWdwYXJ0JywgWzg0NjVdXSwgWydpbWF0aCcsIFszMDVdXSwgWydJbScsIFs4NDY1XV0sIFsnaW1vZicsIFs4ODg3XV0sIFsnaW1wZWQnLCBbNDM3XV0sIFsnSW1wbGllcycsIFs4NjU4XV0sIFsnaW5jYXJlJywgWzg0NTNdXSwgWydpbicsIFs4NzEyXV0sIFsnaW5maW4nLCBbODczNF1dLCBbJ2luZmludGllJywgWzEwNzE3XV0sIFsnaW5vZG90JywgWzMwNV1dLCBbJ2ludGNhbCcsIFs4ODkwXV0sIFsnaW50JywgWzg3NDddXSwgWydJbnQnLCBbODc0OF1dLCBbJ2ludGVnZXJzJywgWzg0ODRdXSwgWydJbnRlZ3JhbCcsIFs4NzQ3XV0sIFsnaW50ZXJjYWwnLCBbODg5MF1dLCBbJ0ludGVyc2VjdGlvbicsIFs4ODk4XV0sIFsnaW50bGFyaGsnLCBbMTA3NzVdXSwgWydpbnRwcm9kJywgWzEwODEyXV0sIFsnSW52aXNpYmxlQ29tbWEnLCBbODI5MV1dLCBbJ0ludmlzaWJsZVRpbWVzJywgWzgyOTBdXSwgWydJT2N5JywgWzEwMjVdXSwgWydpb2N5JywgWzExMDVdXSwgWydJb2dvbicsIFszMDJdXSwgWydpb2dvbicsIFszMDNdXSwgWydJb3BmJywgWzEyMDEyOF1dLCBbJ2lvcGYnLCBbMTIwMTU0XV0sIFsnSW90YScsIFs5MjFdXSwgWydpb3RhJywgWzk1M11dLCBbJ2lwcm9kJywgWzEwODEyXV0sIFsnaXF1ZXN0JywgWzE5MV1dLCBbJ2lzY3InLCBbMTE5OTk4XV0sIFsnSXNjcicsIFs4NDY0XV0sIFsnaXNpbicsIFs4NzEyXV0sIFsnaXNpbmRvdCcsIFs4OTQ5XV0sIFsnaXNpbkUnLCBbODk1M11dLCBbJ2lzaW5zJywgWzg5NDhdXSwgWydpc2luc3YnLCBbODk0N11dLCBbJ2lzaW52JywgWzg3MTJdXSwgWydpdCcsIFs4MjkwXV0sIFsnSXRpbGRlJywgWzI5Nl1dLCBbJ2l0aWxkZScsIFsyOTddXSwgWydJdWtjeScsIFsxMDMwXV0sIFsnaXVrY3knLCBbMTExMF1dLCBbJ0l1bWwnLCBbMjA3XV0sIFsnaXVtbCcsIFsyMzldXSwgWydKY2lyYycsIFszMDhdXSwgWydqY2lyYycsIFszMDldXSwgWydKY3knLCBbMTA0OV1dLCBbJ2pjeScsIFsxMDgxXV0sIFsnSmZyJywgWzEyMDA3N11dLCBbJ2pmcicsIFsxMjAxMDNdXSwgWydqbWF0aCcsIFs1NjddXSwgWydKb3BmJywgWzEyMDEyOV1dLCBbJ2pvcGYnLCBbMTIwMTU1XV0sIFsnSnNjcicsIFsxMTk5NzNdXSwgWydqc2NyJywgWzExOTk5OV1dLCBbJ0pzZXJjeScsIFsxMDMyXV0sIFsnanNlcmN5JywgWzExMTJdXSwgWydKdWtjeScsIFsxMDI4XV0sIFsnanVrY3knLCBbMTEwOF1dLCBbJ0thcHBhJywgWzkyMl1dLCBbJ2thcHBhJywgWzk1NF1dLCBbJ2thcHBhdicsIFsxMDA4XV0sIFsnS2NlZGlsJywgWzMxMF1dLCBbJ2tjZWRpbCcsIFszMTFdXSwgWydLY3knLCBbMTA1MF1dLCBbJ2tjeScsIFsxMDgyXV0sIFsnS2ZyJywgWzEyMDA3OF1dLCBbJ2tmcicsIFsxMjAxMDRdXSwgWydrZ3JlZW4nLCBbMzEyXV0sIFsnS0hjeScsIFsxMDYxXV0sIFsna2hjeScsIFsxMDkzXV0sIFsnS0pjeScsIFsxMDM2XV0sIFsna2pjeScsIFsxMTE2XV0sIFsnS29wZicsIFsxMjAxMzBdXSwgWydrb3BmJywgWzEyMDE1Nl1dLCBbJ0tzY3InLCBbMTE5OTc0XV0sIFsna3NjcicsIFsxMjAwMDBdXSwgWydsQWFycicsIFs4NjY2XV0sIFsnTGFjdXRlJywgWzMxM11dLCBbJ2xhY3V0ZScsIFszMTRdXSwgWydsYWVtcHR5dicsIFsxMDY3Nl1dLCBbJ2xhZ3JhbicsIFs4NDY2XV0sIFsnTGFtYmRhJywgWzkyM11dLCBbJ2xhbWJkYScsIFs5NTVdXSwgWydsYW5nJywgWzEwMjE2XV0sIFsnTGFuZycsIFsxMDIxOF1dLCBbJ2xhbmdkJywgWzEwNjQxXV0sIFsnbGFuZ2xlJywgWzEwMjE2XV0sIFsnbGFwJywgWzEwODg1XV0sIFsnTGFwbGFjZXRyZicsIFs4NDY2XV0sIFsnbGFxdW8nLCBbMTcxXV0sIFsnbGFycmInLCBbODY3Nl1dLCBbJ2xhcnJiZnMnLCBbMTA1MjddXSwgWydsYXJyJywgWzg1OTJdXSwgWydMYXJyJywgWzg2MDZdXSwgWydsQXJyJywgWzg2NTZdXSwgWydsYXJyZnMnLCBbMTA1MjVdXSwgWydsYXJyaGsnLCBbODYxN11dLCBbJ2xhcnJscCcsIFs4NjE5XV0sIFsnbGFycnBsJywgWzEwNTUzXV0sIFsnbGFycnNpbScsIFsxMDYxMV1dLCBbJ2xhcnJ0bCcsIFs4NjEwXV0sIFsnbGF0YWlsJywgWzEwNTIxXV0sIFsnbEF0YWlsJywgWzEwNTIzXV0sIFsnbGF0JywgWzEwOTIzXV0sIFsnbGF0ZScsIFsxMDkyNV1dLCBbJ2xhdGVzJywgWzEwOTI1LCA2NTAyNF1dLCBbJ2xiYXJyJywgWzEwNTA4XV0sIFsnbEJhcnInLCBbMTA1MTBdXSwgWydsYmJyaycsIFsxMDA5OF1dLCBbJ2xicmFjZScsIFsxMjNdXSwgWydsYnJhY2snLCBbOTFdXSwgWydsYnJrZScsIFsxMDYzNV1dLCBbJ2xicmtzbGQnLCBbMTA2MzldXSwgWydsYnJrc2x1JywgWzEwNjM3XV0sIFsnTGNhcm9uJywgWzMxN11dLCBbJ2xjYXJvbicsIFszMThdXSwgWydMY2VkaWwnLCBbMzE1XV0sIFsnbGNlZGlsJywgWzMxNl1dLCBbJ2xjZWlsJywgWzg5NjhdXSwgWydsY3ViJywgWzEyM11dLCBbJ0xjeScsIFsxMDUxXV0sIFsnbGN5JywgWzEwODNdXSwgWydsZGNhJywgWzEwNTUwXV0sIFsnbGRxdW8nLCBbODIyMF1dLCBbJ2xkcXVvcicsIFs4MjIyXV0sIFsnbGRyZGhhcicsIFsxMDU5OV1dLCBbJ2xkcnVzaGFyJywgWzEwNTcxXV0sIFsnbGRzaCcsIFs4NjI2XV0sIFsnbGUnLCBbODgwNF1dLCBbJ2xFJywgWzg4MDZdXSwgWydMZWZ0QW5nbGVCcmFja2V0JywgWzEwMjE2XV0sIFsnTGVmdEFycm93QmFyJywgWzg2NzZdXSwgWydsZWZ0YXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRBcnJvdycsIFs4NTkyXV0sIFsnTGVmdGFycm93JywgWzg2NTZdXSwgWydMZWZ0QXJyb3dSaWdodEFycm93JywgWzg2NDZdXSwgWydsZWZ0YXJyb3d0YWlsJywgWzg2MTBdXSwgWydMZWZ0Q2VpbGluZycsIFs4OTY4XV0sIFsnTGVmdERvdWJsZUJyYWNrZXQnLCBbMTAyMTRdXSwgWydMZWZ0RG93blRlZVZlY3RvcicsIFsxMDU5M11dLCBbJ0xlZnREb3duVmVjdG9yQmFyJywgWzEwNTg1XV0sIFsnTGVmdERvd25WZWN0b3InLCBbODY0M11dLCBbJ0xlZnRGbG9vcicsIFs4OTcwXV0sIFsnbGVmdGhhcnBvb25kb3duJywgWzg2MzddXSwgWydsZWZ0aGFycG9vbnVwJywgWzg2MzZdXSwgWydsZWZ0bGVmdGFycm93cycsIFs4NjQ3XV0sIFsnbGVmdHJpZ2h0YXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRSaWdodEFycm93JywgWzg1OTZdXSwgWydMZWZ0cmlnaHRhcnJvdycsIFs4NjYwXV0sIFsnbGVmdHJpZ2h0YXJyb3dzJywgWzg2NDZdXSwgWydsZWZ0cmlnaHRoYXJwb29ucycsIFs4NjUxXV0sIFsnbGVmdHJpZ2h0c3F1aWdhcnJvdycsIFs4NjIxXV0sIFsnTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc0XV0sIFsnTGVmdFRlZUFycm93JywgWzg2MTJdXSwgWydMZWZ0VGVlJywgWzg4NjddXSwgWydMZWZ0VGVlVmVjdG9yJywgWzEwNTg2XV0sIFsnbGVmdHRocmVldGltZXMnLCBbODkwN11dLCBbJ0xlZnRUcmlhbmdsZUJhcicsIFsxMDcwM11dLCBbJ0xlZnRUcmlhbmdsZScsIFs4ODgyXV0sIFsnTGVmdFRyaWFuZ2xlRXF1YWwnLCBbODg4NF1dLCBbJ0xlZnRVcERvd25WZWN0b3InLCBbMTA1NzddXSwgWydMZWZ0VXBUZWVWZWN0b3InLCBbMTA1OTJdXSwgWydMZWZ0VXBWZWN0b3JCYXInLCBbMTA1ODRdXSwgWydMZWZ0VXBWZWN0b3InLCBbODYzOV1dLCBbJ0xlZnRWZWN0b3JCYXInLCBbMTA1NzhdXSwgWydMZWZ0VmVjdG9yJywgWzg2MzZdXSwgWydsRWcnLCBbMTA4OTFdXSwgWydsZWcnLCBbODkyMl1dLCBbJ2xlcScsIFs4ODA0XV0sIFsnbGVxcScsIFs4ODA2XV0sIFsnbGVxc2xhbnQnLCBbMTA4NzddXSwgWydsZXNjYycsIFsxMDkyMF1dLCBbJ2xlcycsIFsxMDg3N11dLCBbJ2xlc2RvdCcsIFsxMDg3OV1dLCBbJ2xlc2RvdG8nLCBbMTA4ODFdXSwgWydsZXNkb3RvcicsIFsxMDg4M11dLCBbJ2xlc2cnLCBbODkyMiwgNjUwMjRdXSwgWydsZXNnZXMnLCBbMTA4OTldXSwgWydsZXNzYXBwcm94JywgWzEwODg1XV0sIFsnbGVzc2RvdCcsIFs4OTE4XV0sIFsnbGVzc2VxZ3RyJywgWzg5MjJdXSwgWydsZXNzZXFxZ3RyJywgWzEwODkxXV0sIFsnTGVzc0VxdWFsR3JlYXRlcicsIFs4OTIyXV0sIFsnTGVzc0Z1bGxFcXVhbCcsIFs4ODA2XV0sIFsnTGVzc0dyZWF0ZXInLCBbODgyMl1dLCBbJ2xlc3NndHInLCBbODgyMl1dLCBbJ0xlc3NMZXNzJywgWzEwOTEzXV0sIFsnbGVzc3NpbScsIFs4ODE4XV0sIFsnTGVzc1NsYW50RXF1YWwnLCBbMTA4NzddXSwgWydMZXNzVGlsZGUnLCBbODgxOF1dLCBbJ2xmaXNodCcsIFsxMDYyMF1dLCBbJ2xmbG9vcicsIFs4OTcwXV0sIFsnTGZyJywgWzEyMDA3OV1dLCBbJ2xmcicsIFsxMjAxMDVdXSwgWydsZycsIFs4ODIyXV0sIFsnbGdFJywgWzEwODk3XV0sIFsnbEhhcicsIFsxMDU5NF1dLCBbJ2xoYXJkJywgWzg2MzddXSwgWydsaGFydScsIFs4NjM2XV0sIFsnbGhhcnVsJywgWzEwNjAyXV0sIFsnbGhibGsnLCBbOTYwNF1dLCBbJ0xKY3knLCBbMTAzM11dLCBbJ2xqY3knLCBbMTExM11dLCBbJ2xsYXJyJywgWzg2NDddXSwgWydsbCcsIFs4ODEwXV0sIFsnTGwnLCBbODkyMF1dLCBbJ2xsY29ybmVyJywgWzg5OTBdXSwgWydMbGVmdGFycm93JywgWzg2NjZdXSwgWydsbGhhcmQnLCBbMTA2MDNdXSwgWydsbHRyaScsIFs5NzIyXV0sIFsnTG1pZG90JywgWzMxOV1dLCBbJ2xtaWRvdCcsIFszMjBdXSwgWydsbW91c3RhY2hlJywgWzkxMzZdXSwgWydsbW91c3QnLCBbOTEzNl1dLCBbJ2xuYXAnLCBbMTA4ODldXSwgWydsbmFwcHJveCcsIFsxMDg4OV1dLCBbJ2xuZScsIFsxMDg4N11dLCBbJ2xuRScsIFs4ODA4XV0sIFsnbG5lcScsIFsxMDg4N11dLCBbJ2xuZXFxJywgWzg4MDhdXSwgWydsbnNpbScsIFs4OTM0XV0sIFsnbG9hbmcnLCBbMTAyMjBdXSwgWydsb2FycicsIFs4NzAxXV0sIFsnbG9icmsnLCBbMTAyMTRdXSwgWydsb25nbGVmdGFycm93JywgWzEwMjI5XV0sIFsnTG9uZ0xlZnRBcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdsZWZ0YXJyb3cnLCBbMTAyMzJdXSwgWydsb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzFdXSwgWydMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzFdXSwgWydMb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzRdXSwgWydsb25nbWFwc3RvJywgWzEwMjM2XV0sIFsnbG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzBdXSwgWydMb25nUmlnaHRBcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdyaWdodGFycm93JywgWzEwMjMzXV0sIFsnbG9vcGFycm93bGVmdCcsIFs4NjE5XV0sIFsnbG9vcGFycm93cmlnaHQnLCBbODYyMF1dLCBbJ2xvcGFyJywgWzEwNjI5XV0sIFsnTG9wZicsIFsxMjAxMzFdXSwgWydsb3BmJywgWzEyMDE1N11dLCBbJ2xvcGx1cycsIFsxMDc5N11dLCBbJ2xvdGltZXMnLCBbMTA4MDRdXSwgWydsb3dhc3QnLCBbODcyN11dLCBbJ2xvd2JhcicsIFs5NV1dLCBbJ0xvd2VyTGVmdEFycm93JywgWzg2MDFdXSwgWydMb3dlclJpZ2h0QXJyb3cnLCBbODYwMF1dLCBbJ2xveicsIFs5Njc0XV0sIFsnbG96ZW5nZScsIFs5Njc0XV0sIFsnbG96ZicsIFsxMDczMV1dLCBbJ2xwYXInLCBbNDBdXSwgWydscGFybHQnLCBbMTA2NDNdXSwgWydscmFycicsIFs4NjQ2XV0sIFsnbHJjb3JuZXInLCBbODk5MV1dLCBbJ2xyaGFyJywgWzg2NTFdXSwgWydscmhhcmQnLCBbMTA2MDVdXSwgWydscm0nLCBbODIwNl1dLCBbJ2xydHJpJywgWzg4OTVdXSwgWydsc2FxdW8nLCBbODI0OV1dLCBbJ2xzY3InLCBbMTIwMDAxXV0sIFsnTHNjcicsIFs4NDY2XV0sIFsnbHNoJywgWzg2MjRdXSwgWydMc2gnLCBbODYyNF1dLCBbJ2xzaW0nLCBbODgxOF1dLCBbJ2xzaW1lJywgWzEwODkzXV0sIFsnbHNpbWcnLCBbMTA4OTVdXSwgWydsc3FiJywgWzkxXV0sIFsnbHNxdW8nLCBbODIxNl1dLCBbJ2xzcXVvcicsIFs4MjE4XV0sIFsnTHN0cm9rJywgWzMyMV1dLCBbJ2xzdHJvaycsIFszMjJdXSwgWydsdGNjJywgWzEwOTE4XV0sIFsnbHRjaXInLCBbMTA4NzNdXSwgWydsdCcsIFs2MF1dLCBbJ0xUJywgWzYwXV0sIFsnTHQnLCBbODgxMF1dLCBbJ2x0ZG90JywgWzg5MThdXSwgWydsdGhyZWUnLCBbODkwN11dLCBbJ2x0aW1lcycsIFs4OTA1XV0sIFsnbHRsYXJyJywgWzEwNjE0XV0sIFsnbHRxdWVzdCcsIFsxMDg3NV1dLCBbJ2x0cmknLCBbOTY2N11dLCBbJ2x0cmllJywgWzg4ODRdXSwgWydsdHJpZicsIFs5NjY2XV0sIFsnbHRyUGFyJywgWzEwNjQ2XV0sIFsnbHVyZHNoYXInLCBbMTA1NzBdXSwgWydsdXJ1aGFyJywgWzEwNTk4XV0sIFsnbHZlcnRuZXFxJywgWzg4MDgsIDY1MDI0XV0sIFsnbHZuRScsIFs4ODA4LCA2NTAyNF1dLCBbJ21hY3InLCBbMTc1XV0sIFsnbWFsZScsIFs5Nzk0XV0sIFsnbWFsdCcsIFsxMDAxNl1dLCBbJ21hbHRlc2UnLCBbMTAwMTZdXSwgWydNYXAnLCBbMTA1MDFdXSwgWydtYXAnLCBbODYxNF1dLCBbJ21hcHN0bycsIFs4NjE0XV0sIFsnbWFwc3RvZG93bicsIFs4NjE1XV0sIFsnbWFwc3RvbGVmdCcsIFs4NjEyXV0sIFsnbWFwc3RvdXAnLCBbODYxM11dLCBbJ21hcmtlcicsIFs5NjQ2XV0sIFsnbWNvbW1hJywgWzEwNzkzXV0sIFsnTWN5JywgWzEwNTJdXSwgWydtY3knLCBbMTA4NF1dLCBbJ21kYXNoJywgWzgyMTJdXSwgWydtRERvdCcsIFs4NzYyXV0sIFsnbWVhc3VyZWRhbmdsZScsIFs4NzM3XV0sIFsnTWVkaXVtU3BhY2UnLCBbODI4N11dLCBbJ01lbGxpbnRyZicsIFs4NDk5XV0sIFsnTWZyJywgWzEyMDA4MF1dLCBbJ21mcicsIFsxMjAxMDZdXSwgWydtaG8nLCBbODQ4N11dLCBbJ21pY3JvJywgWzE4MV1dLCBbJ21pZGFzdCcsIFs0Ml1dLCBbJ21pZGNpcicsIFsxMDk5Ml1dLCBbJ21pZCcsIFs4NzM5XV0sIFsnbWlkZG90JywgWzE4M11dLCBbJ21pbnVzYicsIFs4ODYzXV0sIFsnbWludXMnLCBbODcyMl1dLCBbJ21pbnVzZCcsIFs4NzYwXV0sIFsnbWludXNkdScsIFsxMDc5NF1dLCBbJ01pbnVzUGx1cycsIFs4NzIzXV0sIFsnbWxjcCcsIFsxMDk3MV1dLCBbJ21sZHInLCBbODIzMF1dLCBbJ21ucGx1cycsIFs4NzIzXV0sIFsnbW9kZWxzJywgWzg4NzFdXSwgWydNb3BmJywgWzEyMDEzMl1dLCBbJ21vcGYnLCBbMTIwMTU4XV0sIFsnbXAnLCBbODcyM11dLCBbJ21zY3InLCBbMTIwMDAyXV0sIFsnTXNjcicsIFs4NDk5XV0sIFsnbXN0cG9zJywgWzg3NjZdXSwgWydNdScsIFs5MjRdXSwgWydtdScsIFs5NTZdXSwgWydtdWx0aW1hcCcsIFs4ODg4XV0sIFsnbXVtYXAnLCBbODg4OF1dLCBbJ25hYmxhJywgWzg3MTFdXSwgWydOYWN1dGUnLCBbMzIzXV0sIFsnbmFjdXRlJywgWzMyNF1dLCBbJ25hbmcnLCBbODczNiwgODQwMl1dLCBbJ25hcCcsIFs4Nzc3XV0sIFsnbmFwRScsIFsxMDg2NCwgODI0XV0sIFsnbmFwaWQnLCBbODc3OSwgODI0XV0sIFsnbmFwb3MnLCBbMzI5XV0sIFsnbmFwcHJveCcsIFs4Nzc3XV0sIFsnbmF0dXJhbCcsIFs5ODM4XV0sIFsnbmF0dXJhbHMnLCBbODQ2OV1dLCBbJ25hdHVyJywgWzk4MzhdXSwgWyduYnNwJywgWzE2MF1dLCBbJ25idW1wJywgWzg3ODIsIDgyNF1dLCBbJ25idW1wZScsIFs4NzgzLCA4MjRdXSwgWyduY2FwJywgWzEwODE5XV0sIFsnTmNhcm9uJywgWzMyN11dLCBbJ25jYXJvbicsIFszMjhdXSwgWydOY2VkaWwnLCBbMzI1XV0sIFsnbmNlZGlsJywgWzMyNl1dLCBbJ25jb25nJywgWzg3NzVdXSwgWyduY29uZ2RvdCcsIFsxMDg2MSwgODI0XV0sIFsnbmN1cCcsIFsxMDgxOF1dLCBbJ05jeScsIFsxMDUzXV0sIFsnbmN5JywgWzEwODVdXSwgWyduZGFzaCcsIFs4MjExXV0sIFsnbmVhcmhrJywgWzEwNTMyXV0sIFsnbmVhcnInLCBbODU5OV1dLCBbJ25lQXJyJywgWzg2NjNdXSwgWyduZWFycm93JywgWzg1OTldXSwgWyduZScsIFs4ODAwXV0sIFsnbmVkb3QnLCBbODc4NCwgODI0XV0sIFsnTmVnYXRpdmVNZWRpdW1TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGlja1NwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJywgWzgyMDNdXSwgWyduZXF1aXYnLCBbODgwMl1dLCBbJ25lc2VhcicsIFsxMDUzNl1dLCBbJ25lc2ltJywgWzg3NzAsIDgyNF1dLCBbJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzg4MTFdXSwgWydOZXN0ZWRMZXNzTGVzcycsIFs4ODEwXV0sIFsnbmV4aXN0JywgWzg3MDhdXSwgWyduZXhpc3RzJywgWzg3MDhdXSwgWydOZnInLCBbMTIwMDgxXV0sIFsnbmZyJywgWzEyMDEwN11dLCBbJ25nRScsIFs4ODA3LCA4MjRdXSwgWyduZ2UnLCBbODgxN11dLCBbJ25nZXEnLCBbODgxN11dLCBbJ25nZXFxJywgWzg4MDcsIDgyNF1dLCBbJ25nZXFzbGFudCcsIFsxMDg3OCwgODI0XV0sIFsnbmdlcycsIFsxMDg3OCwgODI0XV0sIFsnbkdnJywgWzg5MjEsIDgyNF1dLCBbJ25nc2ltJywgWzg4MjFdXSwgWyduR3QnLCBbODgxMSwgODQwMl1dLCBbJ25ndCcsIFs4ODE1XV0sIFsnbmd0cicsIFs4ODE1XV0sIFsnbkd0dicsIFs4ODExLCA4MjRdXSwgWyduaGFycicsIFs4NjIyXV0sIFsnbmhBcnInLCBbODY1NF1dLCBbJ25ocGFyJywgWzEwOTk0XV0sIFsnbmknLCBbODcxNV1dLCBbJ25pcycsIFs4OTU2XV0sIFsnbmlzZCcsIFs4OTU0XV0sIFsnbml2JywgWzg3MTVdXSwgWydOSmN5JywgWzEwMzRdXSwgWyduamN5JywgWzExMTRdXSwgWydubGFycicsIFs4NjAyXV0sIFsnbmxBcnInLCBbODY1M11dLCBbJ25sZHInLCBbODIyOV1dLCBbJ25sRScsIFs4ODA2LCA4MjRdXSwgWydubGUnLCBbODgxNl1dLCBbJ25sZWZ0YXJyb3cnLCBbODYwMl1dLCBbJ25MZWZ0YXJyb3cnLCBbODY1M11dLCBbJ25sZWZ0cmlnaHRhcnJvdycsIFs4NjIyXV0sIFsnbkxlZnRyaWdodGFycm93JywgWzg2NTRdXSwgWydubGVxJywgWzg4MTZdXSwgWydubGVxcScsIFs4ODA2LCA4MjRdXSwgWydubGVxc2xhbnQnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXMnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXNzJywgWzg4MTRdXSwgWyduTGwnLCBbODkyMCwgODI0XV0sIFsnbmxzaW0nLCBbODgyMF1dLCBbJ25MdCcsIFs4ODEwLCA4NDAyXV0sIFsnbmx0JywgWzg4MTRdXSwgWydubHRyaScsIFs4OTM4XV0sIFsnbmx0cmllJywgWzg5NDBdXSwgWyduTHR2JywgWzg4MTAsIDgyNF1dLCBbJ25taWQnLCBbODc0MF1dLCBbJ05vQnJlYWsnLCBbODI4OF1dLCBbJ05vbkJyZWFraW5nU3BhY2UnLCBbMTYwXV0sIFsnbm9wZicsIFsxMjAxNTldXSwgWydOb3BmJywgWzg0NjldXSwgWydOb3QnLCBbMTA5ODhdXSwgWydub3QnLCBbMTcyXV0sIFsnTm90Q29uZ3J1ZW50JywgWzg4MDJdXSwgWydOb3RDdXBDYXAnLCBbODgxM11dLCBbJ05vdERvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDJdXSwgWydOb3RFbGVtZW50JywgWzg3MTNdXSwgWydOb3RFcXVhbCcsIFs4ODAwXV0sIFsnTm90RXF1YWxUaWxkZScsIFs4NzcwLCA4MjRdXSwgWydOb3RFeGlzdHMnLCBbODcwOF1dLCBbJ05vdEdyZWF0ZXInLCBbODgxNV1dLCBbJ05vdEdyZWF0ZXJFcXVhbCcsIFs4ODE3XV0sIFsnTm90R3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3LCA4MjRdXSwgWydOb3RHcmVhdGVyR3JlYXRlcicsIFs4ODExLCA4MjRdXSwgWydOb3RHcmVhdGVyTGVzcycsIFs4ODI1XV0sIFsnTm90R3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzgsIDgyNF1dLCBbJ05vdEdyZWF0ZXJUaWxkZScsIFs4ODIxXV0sIFsnTm90SHVtcERvd25IdW1wJywgWzg3ODIsIDgyNF1dLCBbJ05vdEh1bXBFcXVhbCcsIFs4NzgzLCA4MjRdXSwgWydub3RpbicsIFs4NzEzXV0sIFsnbm90aW5kb3QnLCBbODk0OSwgODI0XV0sIFsnbm90aW5FJywgWzg5NTMsIDgyNF1dLCBbJ25vdGludmEnLCBbODcxM11dLCBbJ25vdGludmInLCBbODk1MV1dLCBbJ25vdGludmMnLCBbODk1MF1dLCBbJ05vdExlZnRUcmlhbmdsZUJhcicsIFsxMDcwMywgODI0XV0sIFsnTm90TGVmdFRyaWFuZ2xlJywgWzg5MzhdXSwgWydOb3RMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4OTQwXV0sIFsnTm90TGVzcycsIFs4ODE0XV0sIFsnTm90TGVzc0VxdWFsJywgWzg4MTZdXSwgWydOb3RMZXNzR3JlYXRlcicsIFs4ODI0XV0sIFsnTm90TGVzc0xlc3MnLCBbODgxMCwgODI0XV0sIFsnTm90TGVzc1NsYW50RXF1YWwnLCBbMTA4NzcsIDgyNF1dLCBbJ05vdExlc3NUaWxkZScsIFs4ODIwXV0sIFsnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbMTA5MTQsIDgyNF1dLCBbJ05vdE5lc3RlZExlc3NMZXNzJywgWzEwOTEzLCA4MjRdXSwgWydub3RuaScsIFs4NzE2XV0sIFsnbm90bml2YScsIFs4NzE2XV0sIFsnbm90bml2YicsIFs4OTU4XV0sIFsnbm90bml2YycsIFs4OTU3XV0sIFsnTm90UHJlY2VkZXMnLCBbODgzMl1dLCBbJ05vdFByZWNlZGVzRXF1YWwnLCBbMTA5MjcsIDgyNF1dLCBbJ05vdFByZWNlZGVzU2xhbnRFcXVhbCcsIFs4OTI4XV0sIFsnTm90UmV2ZXJzZUVsZW1lbnQnLCBbODcxNl1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDQsIDgyNF1dLCBbJ05vdFJpZ2h0VHJpYW5nbGUnLCBbODkzOV1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4OTQxXV0sIFsnTm90U3F1YXJlU3Vic2V0JywgWzg4NDcsIDgyNF1dLCBbJ05vdFNxdWFyZVN1YnNldEVxdWFsJywgWzg5MzBdXSwgWydOb3RTcXVhcmVTdXBlcnNldCcsIFs4ODQ4LCA4MjRdXSwgWydOb3RTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg5MzFdXSwgWydOb3RTdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ05vdFN1YnNldEVxdWFsJywgWzg4NDBdXSwgWydOb3RTdWNjZWVkcycsIFs4ODMzXV0sIFsnTm90U3VjY2VlZHNFcXVhbCcsIFsxMDkyOCwgODI0XV0sIFsnTm90U3VjY2VlZHNTbGFudEVxdWFsJywgWzg5MjldXSwgWydOb3RTdWNjZWVkc1RpbGRlJywgWzg4MzEsIDgyNF1dLCBbJ05vdFN1cGVyc2V0JywgWzg4MzUsIDg0MDJdXSwgWydOb3RTdXBlcnNldEVxdWFsJywgWzg4NDFdXSwgWydOb3RUaWxkZScsIFs4NzY5XV0sIFsnTm90VGlsZGVFcXVhbCcsIFs4NzcyXV0sIFsnTm90VGlsZGVGdWxsRXF1YWwnLCBbODc3NV1dLCBbJ05vdFRpbGRlVGlsZGUnLCBbODc3N11dLCBbJ05vdFZlcnRpY2FsQmFyJywgWzg3NDBdXSwgWyducGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25wYXInLCBbODc0Ml1dLCBbJ25wYXJzbCcsIFsxMTAwNSwgODQyMV1dLCBbJ25wYXJ0JywgWzg3MDYsIDgyNF1dLCBbJ25wb2xpbnQnLCBbMTA3NzJdXSwgWyducHInLCBbODgzMl1dLCBbJ25wcmN1ZScsIFs4OTI4XV0sIFsnbnByZWMnLCBbODgzMl1dLCBbJ25wcmVjZXEnLCBbMTA5MjcsIDgyNF1dLCBbJ25wcmUnLCBbMTA5MjcsIDgyNF1dLCBbJ25yYXJyYycsIFsxMDU0NywgODI0XV0sIFsnbnJhcnInLCBbODYwM11dLCBbJ25yQXJyJywgWzg2NTVdXSwgWyducmFycncnLCBbODYwNSwgODI0XV0sIFsnbnJpZ2h0YXJyb3cnLCBbODYwM11dLCBbJ25SaWdodGFycm93JywgWzg2NTVdXSwgWyducnRyaScsIFs4OTM5XV0sIFsnbnJ0cmllJywgWzg5NDFdXSwgWyduc2MnLCBbODgzM11dLCBbJ25zY2N1ZScsIFs4OTI5XV0sIFsnbnNjZScsIFsxMDkyOCwgODI0XV0sIFsnTnNjcicsIFsxMTk5NzddXSwgWyduc2NyJywgWzEyMDAwM11dLCBbJ25zaG9ydG1pZCcsIFs4NzQwXV0sIFsnbnNob3J0cGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25zaW0nLCBbODc2OV1dLCBbJ25zaW1lJywgWzg3NzJdXSwgWyduc2ltZXEnLCBbODc3Ml1dLCBbJ25zbWlkJywgWzg3NDBdXSwgWyduc3BhcicsIFs4NzQyXV0sIFsnbnNxc3ViZScsIFs4OTMwXV0sIFsnbnNxc3VwZScsIFs4OTMxXV0sIFsnbnN1YicsIFs4ODM2XV0sIFsnbnN1YkUnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWJlJywgWzg4NDBdXSwgWyduc3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWyduc3Vic2V0ZXEnLCBbODg0MF1dLCBbJ25zdWJzZXRlcXEnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWNjJywgWzg4MzNdXSwgWyduc3VjY2VxJywgWzEwOTI4LCA4MjRdXSwgWyduc3VwJywgWzg4MzddXSwgWyduc3VwRScsIFsxMDk1MCwgODI0XV0sIFsnbnN1cGUnLCBbODg0MV1dLCBbJ25zdXBzZXQnLCBbODgzNSwgODQwMl1dLCBbJ25zdXBzZXRlcScsIFs4ODQxXV0sIFsnbnN1cHNldGVxcScsIFsxMDk1MCwgODI0XV0sIFsnbnRnbCcsIFs4ODI1XV0sIFsnTnRpbGRlJywgWzIwOV1dLCBbJ250aWxkZScsIFsyNDFdXSwgWydudGxnJywgWzg4MjRdXSwgWydudHJpYW5nbGVsZWZ0JywgWzg5MzhdXSwgWydudHJpYW5nbGVsZWZ0ZXEnLCBbODk0MF1dLCBbJ250cmlhbmdsZXJpZ2h0JywgWzg5MzldXSwgWydudHJpYW5nbGVyaWdodGVxJywgWzg5NDFdXSwgWydOdScsIFs5MjVdXSwgWydudScsIFs5NTddXSwgWydudW0nLCBbMzVdXSwgWydudW1lcm8nLCBbODQ3MF1dLCBbJ251bXNwJywgWzgxOTldXSwgWydudmFwJywgWzg3ODEsIDg0MDJdXSwgWydudmRhc2gnLCBbODg3Nl1dLCBbJ252RGFzaCcsIFs4ODc3XV0sIFsnblZkYXNoJywgWzg4NzhdXSwgWyduVkRhc2gnLCBbODg3OV1dLCBbJ252Z2UnLCBbODgwNSwgODQwMl1dLCBbJ252Z3QnLCBbNjIsIDg0MDJdXSwgWydudkhhcnInLCBbMTA1MDBdXSwgWydudmluZmluJywgWzEwNzE4XV0sIFsnbnZsQXJyJywgWzEwNDk4XV0sIFsnbnZsZScsIFs4ODA0LCA4NDAyXV0sIFsnbnZsdCcsIFs2MCwgODQwMl1dLCBbJ252bHRyaWUnLCBbODg4NCwgODQwMl1dLCBbJ252ckFycicsIFsxMDQ5OV1dLCBbJ252cnRyaWUnLCBbODg4NSwgODQwMl1dLCBbJ252c2ltJywgWzg3NjQsIDg0MDJdXSwgWydud2FyaGsnLCBbMTA1MzFdXSwgWydud2FycicsIFs4NTk4XV0sIFsnbndBcnInLCBbODY2Ml1dLCBbJ253YXJyb3cnLCBbODU5OF1dLCBbJ253bmVhcicsIFsxMDUzNV1dLCBbJ09hY3V0ZScsIFsyMTFdXSwgWydvYWN1dGUnLCBbMjQzXV0sIFsnb2FzdCcsIFs4ODU5XV0sIFsnT2NpcmMnLCBbMjEyXV0sIFsnb2NpcmMnLCBbMjQ0XV0sIFsnb2NpcicsIFs4ODU4XV0sIFsnT2N5JywgWzEwNTRdXSwgWydvY3knLCBbMTA4Nl1dLCBbJ29kYXNoJywgWzg4NjFdXSwgWydPZGJsYWMnLCBbMzM2XV0sIFsnb2RibGFjJywgWzMzN11dLCBbJ29kaXYnLCBbMTA4MDhdXSwgWydvZG90JywgWzg4NTddXSwgWydvZHNvbGQnLCBbMTA2ODRdXSwgWydPRWxpZycsIFszMzhdXSwgWydvZWxpZycsIFszMzldXSwgWydvZmNpcicsIFsxMDY4N11dLCBbJ09mcicsIFsxMjAwODJdXSwgWydvZnInLCBbMTIwMTA4XV0sIFsnb2dvbicsIFs3MzFdXSwgWydPZ3JhdmUnLCBbMjEwXV0sIFsnb2dyYXZlJywgWzI0Ml1dLCBbJ29ndCcsIFsxMDY4OV1dLCBbJ29oYmFyJywgWzEwNjc3XV0sIFsnb2htJywgWzkzN11dLCBbJ29pbnQnLCBbODc1MF1dLCBbJ29sYXJyJywgWzg2MzRdXSwgWydvbGNpcicsIFsxMDY4Nl1dLCBbJ29sY3Jvc3MnLCBbMTA2ODNdXSwgWydvbGluZScsIFs4MjU0XV0sIFsnb2x0JywgWzEwNjg4XV0sIFsnT21hY3InLCBbMzMyXV0sIFsnb21hY3InLCBbMzMzXV0sIFsnT21lZ2EnLCBbOTM3XV0sIFsnb21lZ2EnLCBbOTY5XV0sIFsnT21pY3JvbicsIFs5MjddXSwgWydvbWljcm9uJywgWzk1OV1dLCBbJ29taWQnLCBbMTA2NzhdXSwgWydvbWludXMnLCBbODg1NF1dLCBbJ09vcGYnLCBbMTIwMTM0XV0sIFsnb29wZicsIFsxMjAxNjBdXSwgWydvcGFyJywgWzEwNjc5XV0sIFsnT3BlbkN1cmx5RG91YmxlUXVvdGUnLCBbODIyMF1dLCBbJ09wZW5DdXJseVF1b3RlJywgWzgyMTZdXSwgWydvcGVycCcsIFsxMDY4MV1dLCBbJ29wbHVzJywgWzg4NTNdXSwgWydvcmFycicsIFs4NjM1XV0sIFsnT3InLCBbMTA4MzZdXSwgWydvcicsIFs4NzQ0XV0sIFsnb3JkJywgWzEwODQ1XV0sIFsnb3JkZXInLCBbODUwMF1dLCBbJ29yZGVyb2YnLCBbODUwMF1dLCBbJ29yZGYnLCBbMTcwXV0sIFsnb3JkbScsIFsxODZdXSwgWydvcmlnb2YnLCBbODg4Nl1dLCBbJ29yb3InLCBbMTA4MzhdXSwgWydvcnNsb3BlJywgWzEwODM5XV0sIFsnb3J2JywgWzEwODQzXV0sIFsnb1MnLCBbOTQxNl1dLCBbJ09zY3InLCBbMTE5OTc4XV0sIFsnb3NjcicsIFs4NTAwXV0sIFsnT3NsYXNoJywgWzIxNl1dLCBbJ29zbGFzaCcsIFsyNDhdXSwgWydvc29sJywgWzg4NTZdXSwgWydPdGlsZGUnLCBbMjEzXV0sIFsnb3RpbGRlJywgWzI0NV1dLCBbJ290aW1lc2FzJywgWzEwODA2XV0sIFsnT3RpbWVzJywgWzEwODA3XV0sIFsnb3RpbWVzJywgWzg4NTVdXSwgWydPdW1sJywgWzIxNF1dLCBbJ291bWwnLCBbMjQ2XV0sIFsnb3ZiYXInLCBbOTAyMV1dLCBbJ092ZXJCYXInLCBbODI1NF1dLCBbJ092ZXJCcmFjZScsIFs5MTgyXV0sIFsnT3ZlckJyYWNrZXQnLCBbOTE0MF1dLCBbJ092ZXJQYXJlbnRoZXNpcycsIFs5MTgwXV0sIFsncGFyYScsIFsxODJdXSwgWydwYXJhbGxlbCcsIFs4NzQxXV0sIFsncGFyJywgWzg3NDFdXSwgWydwYXJzaW0nLCBbMTA5OTVdXSwgWydwYXJzbCcsIFsxMTAwNV1dLCBbJ3BhcnQnLCBbODcwNl1dLCBbJ1BhcnRpYWxEJywgWzg3MDZdXSwgWydQY3knLCBbMTA1NV1dLCBbJ3BjeScsIFsxMDg3XV0sIFsncGVyY250JywgWzM3XV0sIFsncGVyaW9kJywgWzQ2XV0sIFsncGVybWlsJywgWzgyNDBdXSwgWydwZXJwJywgWzg4NjldXSwgWydwZXJ0ZW5rJywgWzgyNDFdXSwgWydQZnInLCBbMTIwMDgzXV0sIFsncGZyJywgWzEyMDEwOV1dLCBbJ1BoaScsIFs5MzRdXSwgWydwaGknLCBbOTY2XV0sIFsncGhpdicsIFs5ODFdXSwgWydwaG1tYXQnLCBbODQ5OV1dLCBbJ3Bob25lJywgWzk3NDJdXSwgWydQaScsIFs5MjhdXSwgWydwaScsIFs5NjBdXSwgWydwaXRjaGZvcmsnLCBbODkxNl1dLCBbJ3BpdicsIFs5ODJdXSwgWydwbGFuY2snLCBbODQ2M11dLCBbJ3BsYW5ja2gnLCBbODQ2Ml1dLCBbJ3BsYW5rdicsIFs4NDYzXV0sIFsncGx1c2FjaXInLCBbMTA3ODddXSwgWydwbHVzYicsIFs4ODYyXV0sIFsncGx1c2NpcicsIFsxMDc4Nl1dLCBbJ3BsdXMnLCBbNDNdXSwgWydwbHVzZG8nLCBbODcyNF1dLCBbJ3BsdXNkdScsIFsxMDc4OV1dLCBbJ3BsdXNlJywgWzEwODY2XV0sIFsnUGx1c01pbnVzJywgWzE3N11dLCBbJ3BsdXNtbicsIFsxNzddXSwgWydwbHVzc2ltJywgWzEwNzkwXV0sIFsncGx1c3R3bycsIFsxMDc5MV1dLCBbJ3BtJywgWzE3N11dLCBbJ1BvaW5jYXJlcGxhbmUnLCBbODQ2MF1dLCBbJ3BvaW50aW50JywgWzEwNzczXV0sIFsncG9wZicsIFsxMjAxNjFdXSwgWydQb3BmJywgWzg0NzNdXSwgWydwb3VuZCcsIFsxNjNdXSwgWydwcmFwJywgWzEwOTM1XV0sIFsnUHInLCBbMTA5MzldXSwgWydwcicsIFs4ODI2XV0sIFsncHJjdWUnLCBbODgyOF1dLCBbJ3ByZWNhcHByb3gnLCBbMTA5MzVdXSwgWydwcmVjJywgWzg4MjZdXSwgWydwcmVjY3VybHllcScsIFs4ODI4XV0sIFsnUHJlY2VkZXMnLCBbODgyNl1dLCBbJ1ByZWNlZGVzRXF1YWwnLCBbMTA5MjddXSwgWydQcmVjZWRlc1NsYW50RXF1YWwnLCBbODgyOF1dLCBbJ1ByZWNlZGVzVGlsZGUnLCBbODgzMF1dLCBbJ3ByZWNlcScsIFsxMDkyN11dLCBbJ3ByZWNuYXBwcm94JywgWzEwOTM3XV0sIFsncHJlY25lcXEnLCBbMTA5MzNdXSwgWydwcmVjbnNpbScsIFs4OTM2XV0sIFsncHJlJywgWzEwOTI3XV0sIFsncHJFJywgWzEwOTMxXV0sIFsncHJlY3NpbScsIFs4ODMwXV0sIFsncHJpbWUnLCBbODI0Ml1dLCBbJ1ByaW1lJywgWzgyNDNdXSwgWydwcmltZXMnLCBbODQ3M11dLCBbJ3BybmFwJywgWzEwOTM3XV0sIFsncHJuRScsIFsxMDkzM11dLCBbJ3BybnNpbScsIFs4OTM2XV0sIFsncHJvZCcsIFs4NzE5XV0sIFsnUHJvZHVjdCcsIFs4NzE5XV0sIFsncHJvZmFsYXInLCBbOTAwNl1dLCBbJ3Byb2ZsaW5lJywgWzg5NzhdXSwgWydwcm9mc3VyZicsIFs4OTc5XV0sIFsncHJvcCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbmFsJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uJywgWzg3NTldXSwgWydwcm9wdG8nLCBbODczM11dLCBbJ3Byc2ltJywgWzg4MzBdXSwgWydwcnVyZWwnLCBbODg4MF1dLCBbJ1BzY3InLCBbMTE5OTc5XV0sIFsncHNjcicsIFsxMjAwMDVdXSwgWydQc2knLCBbOTM2XV0sIFsncHNpJywgWzk2OF1dLCBbJ3B1bmNzcCcsIFs4MjAwXV0sIFsnUWZyJywgWzEyMDA4NF1dLCBbJ3FmcicsIFsxMjAxMTBdXSwgWydxaW50JywgWzEwNzY0XV0sIFsncW9wZicsIFsxMjAxNjJdXSwgWydRb3BmJywgWzg0NzRdXSwgWydxcHJpbWUnLCBbODI3OV1dLCBbJ1FzY3InLCBbMTE5OTgwXV0sIFsncXNjcicsIFsxMjAwMDZdXSwgWydxdWF0ZXJuaW9ucycsIFs4NDYxXV0sIFsncXVhdGludCcsIFsxMDc3NF1dLCBbJ3F1ZXN0JywgWzYzXV0sIFsncXVlc3RlcScsIFs4Nzk5XV0sIFsncXVvdCcsIFszNF1dLCBbJ1FVT1QnLCBbMzRdXSwgWydyQWFycicsIFs4NjY3XV0sIFsncmFjZScsIFs4NzY1LCA4MTddXSwgWydSYWN1dGUnLCBbMzQwXV0sIFsncmFjdXRlJywgWzM0MV1dLCBbJ3JhZGljJywgWzg3MzBdXSwgWydyYWVtcHR5dicsIFsxMDY3NV1dLCBbJ3JhbmcnLCBbMTAyMTddXSwgWydSYW5nJywgWzEwMjE5XV0sIFsncmFuZ2QnLCBbMTA2NDJdXSwgWydyYW5nZScsIFsxMDY2MV1dLCBbJ3JhbmdsZScsIFsxMDIxN11dLCBbJ3JhcXVvJywgWzE4N11dLCBbJ3JhcnJhcCcsIFsxMDYxM11dLCBbJ3JhcnJiJywgWzg2NzddXSwgWydyYXJyYmZzJywgWzEwNTI4XV0sIFsncmFycmMnLCBbMTA1NDddXSwgWydyYXJyJywgWzg1OTRdXSwgWydSYXJyJywgWzg2MDhdXSwgWydyQXJyJywgWzg2NThdXSwgWydyYXJyZnMnLCBbMTA1MjZdXSwgWydyYXJyaGsnLCBbODYxOF1dLCBbJ3JhcnJscCcsIFs4NjIwXV0sIFsncmFycnBsJywgWzEwNTY1XV0sIFsncmFycnNpbScsIFsxMDYxMl1dLCBbJ1JhcnJ0bCcsIFsxMDUxOF1dLCBbJ3JhcnJ0bCcsIFs4NjExXV0sIFsncmFycncnLCBbODYwNV1dLCBbJ3JhdGFpbCcsIFsxMDUyMl1dLCBbJ3JBdGFpbCcsIFsxMDUyNF1dLCBbJ3JhdGlvJywgWzg3NThdXSwgWydyYXRpb25hbHMnLCBbODQ3NF1dLCBbJ3JiYXJyJywgWzEwNTA5XV0sIFsnckJhcnInLCBbMTA1MTFdXSwgWydSQmFycicsIFsxMDUxMl1dLCBbJ3JiYnJrJywgWzEwMDk5XV0sIFsncmJyYWNlJywgWzEyNV1dLCBbJ3JicmFjaycsIFs5M11dLCBbJ3JicmtlJywgWzEwNjM2XV0sIFsncmJya3NsZCcsIFsxMDYzOF1dLCBbJ3JicmtzbHUnLCBbMTA2NDBdXSwgWydSY2Fyb24nLCBbMzQ0XV0sIFsncmNhcm9uJywgWzM0NV1dLCBbJ1JjZWRpbCcsIFszNDJdXSwgWydyY2VkaWwnLCBbMzQzXV0sIFsncmNlaWwnLCBbODk2OV1dLCBbJ3JjdWInLCBbMTI1XV0sIFsnUmN5JywgWzEwNTZdXSwgWydyY3knLCBbMTA4OF1dLCBbJ3JkY2EnLCBbMTA1NTFdXSwgWydyZGxkaGFyJywgWzEwNjAxXV0sIFsncmRxdW8nLCBbODIyMV1dLCBbJ3JkcXVvcicsIFs4MjIxXV0sIFsnQ2xvc2VDdXJseURvdWJsZVF1b3RlJywgWzgyMjFdXSwgWydyZHNoJywgWzg2MjddXSwgWydyZWFsJywgWzg0NzZdXSwgWydyZWFsaW5lJywgWzg0NzVdXSwgWydyZWFscGFydCcsIFs4NDc2XV0sIFsncmVhbHMnLCBbODQ3N11dLCBbJ1JlJywgWzg0NzZdXSwgWydyZWN0JywgWzk2NDVdXSwgWydyZWcnLCBbMTc0XV0sIFsnUkVHJywgWzE3NF1dLCBbJ1JldmVyc2VFbGVtZW50JywgWzg3MTVdXSwgWydSZXZlcnNlRXF1aWxpYnJpdW0nLCBbODY1MV1dLCBbJ1JldmVyc2VVcEVxdWlsaWJyaXVtJywgWzEwNjA3XV0sIFsncmZpc2h0JywgWzEwNjIxXV0sIFsncmZsb29yJywgWzg5NzFdXSwgWydyZnInLCBbMTIwMTExXV0sIFsnUmZyJywgWzg0NzZdXSwgWydySGFyJywgWzEwNTk2XV0sIFsncmhhcmQnLCBbODY0MV1dLCBbJ3JoYXJ1JywgWzg2NDBdXSwgWydyaGFydWwnLCBbMTA2MDRdXSwgWydSaG8nLCBbOTI5XV0sIFsncmhvJywgWzk2MV1dLCBbJ3Job3YnLCBbMTAwOV1dLCBbJ1JpZ2h0QW5nbGVCcmFja2V0JywgWzEwMjE3XV0sIFsnUmlnaHRBcnJvd0JhcicsIFs4Njc3XV0sIFsncmlnaHRhcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRhcnJvdycsIFs4NjU4XV0sIFsnUmlnaHRBcnJvd0xlZnRBcnJvdycsIFs4NjQ0XV0sIFsncmlnaHRhcnJvd3RhaWwnLCBbODYxMV1dLCBbJ1JpZ2h0Q2VpbGluZycsIFs4OTY5XV0sIFsnUmlnaHREb3VibGVCcmFja2V0JywgWzEwMjE1XV0sIFsnUmlnaHREb3duVGVlVmVjdG9yJywgWzEwNTg5XV0sIFsnUmlnaHREb3duVmVjdG9yQmFyJywgWzEwNTgxXV0sIFsnUmlnaHREb3duVmVjdG9yJywgWzg2NDJdXSwgWydSaWdodEZsb29yJywgWzg5NzFdXSwgWydyaWdodGhhcnBvb25kb3duJywgWzg2NDFdXSwgWydyaWdodGhhcnBvb251cCcsIFs4NjQwXV0sIFsncmlnaHRsZWZ0YXJyb3dzJywgWzg2NDRdXSwgWydyaWdodGxlZnRoYXJwb29ucycsIFs4NjUyXV0sIFsncmlnaHRyaWdodGFycm93cycsIFs4NjQ5XV0sIFsncmlnaHRzcXVpZ2Fycm93JywgWzg2MDVdXSwgWydSaWdodFRlZUFycm93JywgWzg2MTRdXSwgWydSaWdodFRlZScsIFs4ODY2XV0sIFsnUmlnaHRUZWVWZWN0b3InLCBbMTA1ODddXSwgWydyaWdodHRocmVldGltZXMnLCBbODkwOF1dLCBbJ1JpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDRdXSwgWydSaWdodFRyaWFuZ2xlJywgWzg4ODNdXSwgWydSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODg4NV1dLCBbJ1JpZ2h0VXBEb3duVmVjdG9yJywgWzEwNTc1XV0sIFsnUmlnaHRVcFRlZVZlY3RvcicsIFsxMDU4OF1dLCBbJ1JpZ2h0VXBWZWN0b3JCYXInLCBbMTA1ODBdXSwgWydSaWdodFVwVmVjdG9yJywgWzg2MzhdXSwgWydSaWdodFZlY3RvckJhcicsIFsxMDU3OV1dLCBbJ1JpZ2h0VmVjdG9yJywgWzg2NDBdXSwgWydyaW5nJywgWzczMF1dLCBbJ3Jpc2luZ2RvdHNlcScsIFs4Nzg3XV0sIFsncmxhcnInLCBbODY0NF1dLCBbJ3JsaGFyJywgWzg2NTJdXSwgWydybG0nLCBbODIwN11dLCBbJ3Jtb3VzdGFjaGUnLCBbOTEzN11dLCBbJ3Jtb3VzdCcsIFs5MTM3XV0sIFsncm5taWQnLCBbMTA5OTBdXSwgWydyb2FuZycsIFsxMDIyMV1dLCBbJ3JvYXJyJywgWzg3MDJdXSwgWydyb2JyaycsIFsxMDIxNV1dLCBbJ3JvcGFyJywgWzEwNjMwXV0sIFsncm9wZicsIFsxMjAxNjNdXSwgWydSb3BmJywgWzg0NzddXSwgWydyb3BsdXMnLCBbMTA3OThdXSwgWydyb3RpbWVzJywgWzEwODA1XV0sIFsnUm91bmRJbXBsaWVzJywgWzEwNjA4XV0sIFsncnBhcicsIFs0MV1dLCBbJ3JwYXJndCcsIFsxMDY0NF1dLCBbJ3JwcG9saW50JywgWzEwNzcwXV0sIFsncnJhcnInLCBbODY0OV1dLCBbJ1JyaWdodGFycm93JywgWzg2NjddXSwgWydyc2FxdW8nLCBbODI1MF1dLCBbJ3JzY3InLCBbMTIwMDA3XV0sIFsnUnNjcicsIFs4NDc1XV0sIFsncnNoJywgWzg2MjVdXSwgWydSc2gnLCBbODYyNV1dLCBbJ3JzcWInLCBbOTNdXSwgWydyc3F1bycsIFs4MjE3XV0sIFsncnNxdW9yJywgWzgyMTddXSwgWydDbG9zZUN1cmx5UXVvdGUnLCBbODIxN11dLCBbJ3J0aHJlZScsIFs4OTA4XV0sIFsncnRpbWVzJywgWzg5MDZdXSwgWydydHJpJywgWzk2NTddXSwgWydydHJpZScsIFs4ODg1XV0sIFsncnRyaWYnLCBbOTY1Nl1dLCBbJ3J0cmlsdHJpJywgWzEwNzAyXV0sIFsnUnVsZURlbGF5ZWQnLCBbMTA3NDBdXSwgWydydWx1aGFyJywgWzEwNjAwXV0sIFsncngnLCBbODQ3OF1dLCBbJ1NhY3V0ZScsIFszNDZdXSwgWydzYWN1dGUnLCBbMzQ3XV0sIFsnc2JxdW8nLCBbODIxOF1dLCBbJ3NjYXAnLCBbMTA5MzZdXSwgWydTY2Fyb24nLCBbMzUyXV0sIFsnc2Nhcm9uJywgWzM1M11dLCBbJ1NjJywgWzEwOTQwXV0sIFsnc2MnLCBbODgyN11dLCBbJ3NjY3VlJywgWzg4MjldXSwgWydzY2UnLCBbMTA5MjhdXSwgWydzY0UnLCBbMTA5MzJdXSwgWydTY2VkaWwnLCBbMzUwXV0sIFsnc2NlZGlsJywgWzM1MV1dLCBbJ1NjaXJjJywgWzM0OF1dLCBbJ3NjaXJjJywgWzM0OV1dLCBbJ3NjbmFwJywgWzEwOTM4XV0sIFsnc2NuRScsIFsxMDkzNF1dLCBbJ3NjbnNpbScsIFs4OTM3XV0sIFsnc2Nwb2xpbnQnLCBbMTA3NzFdXSwgWydzY3NpbScsIFs4ODMxXV0sIFsnU2N5JywgWzEwNTddXSwgWydzY3knLCBbMTA4OV1dLCBbJ3Nkb3RiJywgWzg4NjVdXSwgWydzZG90JywgWzg5MDFdXSwgWydzZG90ZScsIFsxMDg1NF1dLCBbJ3NlYXJoaycsIFsxMDUzM11dLCBbJ3NlYXJyJywgWzg2MDBdXSwgWydzZUFycicsIFs4NjY0XV0sIFsnc2VhcnJvdycsIFs4NjAwXV0sIFsnc2VjdCcsIFsxNjddXSwgWydzZW1pJywgWzU5XV0sIFsnc2Vzd2FyJywgWzEwNTM3XV0sIFsnc2V0bWludXMnLCBbODcyNl1dLCBbJ3NldG1uJywgWzg3MjZdXSwgWydzZXh0JywgWzEwMDM4XV0sIFsnU2ZyJywgWzEyMDA4Nl1dLCBbJ3NmcicsIFsxMjAxMTJdXSwgWydzZnJvd24nLCBbODk5NF1dLCBbJ3NoYXJwJywgWzk4MzldXSwgWydTSENIY3knLCBbMTA2NV1dLCBbJ3NoY2hjeScsIFsxMDk3XV0sIFsnU0hjeScsIFsxMDY0XV0sIFsnc2hjeScsIFsxMDk2XV0sIFsnU2hvcnREb3duQXJyb3cnLCBbODU5NV1dLCBbJ1Nob3J0TGVmdEFycm93JywgWzg1OTJdXSwgWydzaG9ydG1pZCcsIFs4NzM5XV0sIFsnc2hvcnRwYXJhbGxlbCcsIFs4NzQxXV0sIFsnU2hvcnRSaWdodEFycm93JywgWzg1OTRdXSwgWydTaG9ydFVwQXJyb3cnLCBbODU5M11dLCBbJ3NoeScsIFsxNzNdXSwgWydTaWdtYScsIFs5MzFdXSwgWydzaWdtYScsIFs5NjNdXSwgWydzaWdtYWYnLCBbOTYyXV0sIFsnc2lnbWF2JywgWzk2Ml1dLCBbJ3NpbScsIFs4NzY0XV0sIFsnc2ltZG90JywgWzEwODU4XV0sIFsnc2ltZScsIFs4NzcxXV0sIFsnc2ltZXEnLCBbODc3MV1dLCBbJ3NpbWcnLCBbMTA5MTBdXSwgWydzaW1nRScsIFsxMDkxMl1dLCBbJ3NpbWwnLCBbMTA5MDldXSwgWydzaW1sRScsIFsxMDkxMV1dLCBbJ3NpbW5lJywgWzg3NzRdXSwgWydzaW1wbHVzJywgWzEwNzg4XV0sIFsnc2ltcmFycicsIFsxMDYxMF1dLCBbJ3NsYXJyJywgWzg1OTJdXSwgWydTbWFsbENpcmNsZScsIFs4NzI4XV0sIFsnc21hbGxzZXRtaW51cycsIFs4NzI2XV0sIFsnc21hc2hwJywgWzEwODAzXV0sIFsnc21lcGFyc2wnLCBbMTA3MjRdXSwgWydzbWlkJywgWzg3MzldXSwgWydzbWlsZScsIFs4OTk1XV0sIFsnc210JywgWzEwOTIyXV0sIFsnc210ZScsIFsxMDkyNF1dLCBbJ3NtdGVzJywgWzEwOTI0LCA2NTAyNF1dLCBbJ1NPRlRjeScsIFsxMDY4XV0sIFsnc29mdGN5JywgWzExMDBdXSwgWydzb2xiYXInLCBbOTAyM11dLCBbJ3NvbGInLCBbMTA2OTJdXSwgWydzb2wnLCBbNDddXSwgWydTb3BmJywgWzEyMDEzOF1dLCBbJ3NvcGYnLCBbMTIwMTY0XV0sIFsnc3BhZGVzJywgWzk4MjRdXSwgWydzcGFkZXN1aXQnLCBbOTgyNF1dLCBbJ3NwYXInLCBbODc0MV1dLCBbJ3NxY2FwJywgWzg4NTFdXSwgWydzcWNhcHMnLCBbODg1MSwgNjUwMjRdXSwgWydzcWN1cCcsIFs4ODUyXV0sIFsnc3FjdXBzJywgWzg4NTIsIDY1MDI0XV0sIFsnU3FydCcsIFs4NzMwXV0sIFsnc3FzdWInLCBbODg0N11dLCBbJ3Nxc3ViZScsIFs4ODQ5XV0sIFsnc3FzdWJzZXQnLCBbODg0N11dLCBbJ3Nxc3Vic2V0ZXEnLCBbODg0OV1dLCBbJ3Nxc3VwJywgWzg4NDhdXSwgWydzcXN1cGUnLCBbODg1MF1dLCBbJ3Nxc3Vwc2V0JywgWzg4NDhdXSwgWydzcXN1cHNldGVxJywgWzg4NTBdXSwgWydzcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlSW50ZXJzZWN0aW9uJywgWzg4NTFdXSwgWydTcXVhcmVTdWJzZXQnLCBbODg0N11dLCBbJ1NxdWFyZVN1YnNldEVxdWFsJywgWzg4NDldXSwgWydTcXVhcmVTdXBlcnNldCcsIFs4ODQ4XV0sIFsnU3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4ODUwXV0sIFsnU3F1YXJlVW5pb24nLCBbODg1Ml1dLCBbJ3NxdWFyZicsIFs5NjQyXV0sIFsnc3F1JywgWzk2MzNdXSwgWydzcXVmJywgWzk2NDJdXSwgWydzcmFycicsIFs4NTk0XV0sIFsnU3NjcicsIFsxMTk5ODJdXSwgWydzc2NyJywgWzEyMDAwOF1dLCBbJ3NzZXRtbicsIFs4NzI2XV0sIFsnc3NtaWxlJywgWzg5OTVdXSwgWydzc3RhcmYnLCBbODkwMl1dLCBbJ1N0YXInLCBbODkwMl1dLCBbJ3N0YXInLCBbOTczNF1dLCBbJ3N0YXJmJywgWzk3MzNdXSwgWydzdHJhaWdodGVwc2lsb24nLCBbMTAxM11dLCBbJ3N0cmFpZ2h0cGhpJywgWzk4MV1dLCBbJ3N0cm5zJywgWzE3NV1dLCBbJ3N1YicsIFs4ODM0XV0sIFsnU3ViJywgWzg5MTJdXSwgWydzdWJkb3QnLCBbMTA5NDFdXSwgWydzdWJFJywgWzEwOTQ5XV0sIFsnc3ViZScsIFs4ODM4XV0sIFsnc3ViZWRvdCcsIFsxMDk0N11dLCBbJ3N1Ym11bHQnLCBbMTA5NDVdXSwgWydzdWJuRScsIFsxMDk1NV1dLCBbJ3N1Ym5lJywgWzg4NDJdXSwgWydzdWJwbHVzJywgWzEwOTQzXV0sIFsnc3VicmFycicsIFsxMDYxN11dLCBbJ3N1YnNldCcsIFs4ODM0XV0sIFsnU3Vic2V0JywgWzg5MTJdXSwgWydzdWJzZXRlcScsIFs4ODM4XV0sIFsnc3Vic2V0ZXFxJywgWzEwOTQ5XV0sIFsnU3Vic2V0RXF1YWwnLCBbODgzOF1dLCBbJ3N1YnNldG5lcScsIFs4ODQyXV0sIFsnc3Vic2V0bmVxcScsIFsxMDk1NV1dLCBbJ3N1YnNpbScsIFsxMDk1MV1dLCBbJ3N1YnN1YicsIFsxMDk2NV1dLCBbJ3N1YnN1cCcsIFsxMDk2M11dLCBbJ3N1Y2NhcHByb3gnLCBbMTA5MzZdXSwgWydzdWNjJywgWzg4MjddXSwgWydzdWNjY3VybHllcScsIFs4ODI5XV0sIFsnU3VjY2VlZHMnLCBbODgyN11dLCBbJ1N1Y2NlZWRzRXF1YWwnLCBbMTA5MjhdXSwgWydTdWNjZWVkc1NsYW50RXF1YWwnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzVGlsZGUnLCBbODgzMV1dLCBbJ3N1Y2NlcScsIFsxMDkyOF1dLCBbJ3N1Y2NuYXBwcm94JywgWzEwOTM4XV0sIFsnc3VjY25lcXEnLCBbMTA5MzRdXSwgWydzdWNjbnNpbScsIFs4OTM3XV0sIFsnc3VjY3NpbScsIFs4ODMxXV0sIFsnU3VjaFRoYXQnLCBbODcxNV1dLCBbJ3N1bScsIFs4NzIxXV0sIFsnU3VtJywgWzg3MjFdXSwgWydzdW5nJywgWzk4MzRdXSwgWydzdXAxJywgWzE4NV1dLCBbJ3N1cDInLCBbMTc4XV0sIFsnc3VwMycsIFsxNzldXSwgWydzdXAnLCBbODgzNV1dLCBbJ1N1cCcsIFs4OTEzXV0sIFsnc3VwZG90JywgWzEwOTQyXV0sIFsnc3VwZHN1YicsIFsxMDk2OF1dLCBbJ3N1cEUnLCBbMTA5NTBdXSwgWydzdXBlJywgWzg4MzldXSwgWydzdXBlZG90JywgWzEwOTQ4XV0sIFsnU3VwZXJzZXQnLCBbODgzNV1dLCBbJ1N1cGVyc2V0RXF1YWwnLCBbODgzOV1dLCBbJ3N1cGhzb2wnLCBbMTAxODVdXSwgWydzdXBoc3ViJywgWzEwOTY3XV0sIFsnc3VwbGFycicsIFsxMDYxOV1dLCBbJ3N1cG11bHQnLCBbMTA5NDZdXSwgWydzdXBuRScsIFsxMDk1Nl1dLCBbJ3N1cG5lJywgWzg4NDNdXSwgWydzdXBwbHVzJywgWzEwOTQ0XV0sIFsnc3Vwc2V0JywgWzg4MzVdXSwgWydTdXBzZXQnLCBbODkxM11dLCBbJ3N1cHNldGVxJywgWzg4MzldXSwgWydzdXBzZXRlcXEnLCBbMTA5NTBdXSwgWydzdXBzZXRuZXEnLCBbODg0M11dLCBbJ3N1cHNldG5lcXEnLCBbMTA5NTZdXSwgWydzdXBzaW0nLCBbMTA5NTJdXSwgWydzdXBzdWInLCBbMTA5NjRdXSwgWydzdXBzdXAnLCBbMTA5NjZdXSwgWydzd2FyaGsnLCBbMTA1MzRdXSwgWydzd2FycicsIFs4NjAxXV0sIFsnc3dBcnInLCBbODY2NV1dLCBbJ3N3YXJyb3cnLCBbODYwMV1dLCBbJ3N3bndhcicsIFsxMDUzOF1dLCBbJ3N6bGlnJywgWzIyM11dLCBbJ1RhYicsIFs5XV0sIFsndGFyZ2V0JywgWzg5ODJdXSwgWydUYXUnLCBbOTMyXV0sIFsndGF1JywgWzk2NF1dLCBbJ3RicmsnLCBbOTE0MF1dLCBbJ1RjYXJvbicsIFszNTZdXSwgWyd0Y2Fyb24nLCBbMzU3XV0sIFsnVGNlZGlsJywgWzM1NF1dLCBbJ3RjZWRpbCcsIFszNTVdXSwgWydUY3knLCBbMTA1OF1dLCBbJ3RjeScsIFsxMDkwXV0sIFsndGRvdCcsIFs4NDExXV0sIFsndGVscmVjJywgWzg5ODFdXSwgWydUZnInLCBbMTIwMDg3XV0sIFsndGZyJywgWzEyMDExM11dLCBbJ3RoZXJlNCcsIFs4NzU2XV0sIFsndGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXRhJywgWzkyMF1dLCBbJ3RoZXRhJywgWzk1Ml1dLCBbJ3RoZXRhc3ltJywgWzk3N11dLCBbJ3RoZXRhdicsIFs5NzddXSwgWyd0aGlja2FwcHJveCcsIFs4Nzc2XV0sIFsndGhpY2tzaW0nLCBbODc2NF1dLCBbJ1RoaWNrU3BhY2UnLCBbODI4NywgODIwMl1dLCBbJ1RoaW5TcGFjZScsIFs4MjAxXV0sIFsndGhpbnNwJywgWzgyMDFdXSwgWyd0aGthcCcsIFs4Nzc2XV0sIFsndGhrc2ltJywgWzg3NjRdXSwgWydUSE9STicsIFsyMjJdXSwgWyd0aG9ybicsIFsyNTRdXSwgWyd0aWxkZScsIFs3MzJdXSwgWydUaWxkZScsIFs4NzY0XV0sIFsnVGlsZGVFcXVhbCcsIFs4NzcxXV0sIFsnVGlsZGVGdWxsRXF1YWwnLCBbODc3M11dLCBbJ1RpbGRlVGlsZGUnLCBbODc3Nl1dLCBbJ3RpbWVzYmFyJywgWzEwODAxXV0sIFsndGltZXNiJywgWzg4NjRdXSwgWyd0aW1lcycsIFsyMTVdXSwgWyd0aW1lc2QnLCBbMTA4MDBdXSwgWyd0aW50JywgWzg3NDldXSwgWyd0b2VhJywgWzEwNTM2XV0sIFsndG9wYm90JywgWzkwMTRdXSwgWyd0b3BjaXInLCBbMTA5OTNdXSwgWyd0b3AnLCBbODg2OF1dLCBbJ1RvcGYnLCBbMTIwMTM5XV0sIFsndG9wZicsIFsxMjAxNjVdXSwgWyd0b3Bmb3JrJywgWzEwOTcwXV0sIFsndG9zYScsIFsxMDUzN11dLCBbJ3RwcmltZScsIFs4MjQ0XV0sIFsndHJhZGUnLCBbODQ4Ml1dLCBbJ1RSQURFJywgWzg0ODJdXSwgWyd0cmlhbmdsZScsIFs5NjUzXV0sIFsndHJpYW5nbGVkb3duJywgWzk2NjNdXSwgWyd0cmlhbmdsZWxlZnQnLCBbOTY2N11dLCBbJ3RyaWFuZ2xlbGVmdGVxJywgWzg4ODRdXSwgWyd0cmlhbmdsZXEnLCBbODc5Nl1dLCBbJ3RyaWFuZ2xlcmlnaHQnLCBbOTY1N11dLCBbJ3RyaWFuZ2xlcmlnaHRlcScsIFs4ODg1XV0sIFsndHJpZG90JywgWzk3MDhdXSwgWyd0cmllJywgWzg3OTZdXSwgWyd0cmltaW51cycsIFsxMDgxMF1dLCBbJ1RyaXBsZURvdCcsIFs4NDExXV0sIFsndHJpcGx1cycsIFsxMDgwOV1dLCBbJ3RyaXNiJywgWzEwNzAxXV0sIFsndHJpdGltZScsIFsxMDgxMV1dLCBbJ3RycGV6aXVtJywgWzkxODZdXSwgWydUc2NyJywgWzExOTk4M11dLCBbJ3RzY3InLCBbMTIwMDA5XV0sIFsnVFNjeScsIFsxMDYyXV0sIFsndHNjeScsIFsxMDk0XV0sIFsnVFNIY3knLCBbMTAzNV1dLCBbJ3RzaGN5JywgWzExMTVdXSwgWydUc3Ryb2snLCBbMzU4XV0sIFsndHN0cm9rJywgWzM1OV1dLCBbJ3R3aXh0JywgWzg4MTJdXSwgWyd0d29oZWFkbGVmdGFycm93JywgWzg2MDZdXSwgWyd0d29oZWFkcmlnaHRhcnJvdycsIFs4NjA4XV0sIFsnVWFjdXRlJywgWzIxOF1dLCBbJ3VhY3V0ZScsIFsyNTBdXSwgWyd1YXJyJywgWzg1OTNdXSwgWydVYXJyJywgWzg2MDddXSwgWyd1QXJyJywgWzg2NTddXSwgWydVYXJyb2NpcicsIFsxMDU2OV1dLCBbJ1VicmN5JywgWzEwMzhdXSwgWyd1YnJjeScsIFsxMTE4XV0sIFsnVWJyZXZlJywgWzM2NF1dLCBbJ3VicmV2ZScsIFszNjVdXSwgWydVY2lyYycsIFsyMTldXSwgWyd1Y2lyYycsIFsyNTFdXSwgWydVY3knLCBbMTA1OV1dLCBbJ3VjeScsIFsxMDkxXV0sIFsndWRhcnInLCBbODY0NV1dLCBbJ1VkYmxhYycsIFszNjhdXSwgWyd1ZGJsYWMnLCBbMzY5XV0sIFsndWRoYXInLCBbMTA2MDZdXSwgWyd1ZmlzaHQnLCBbMTA2MjJdXSwgWydVZnInLCBbMTIwMDg4XV0sIFsndWZyJywgWzEyMDExNF1dLCBbJ1VncmF2ZScsIFsyMTddXSwgWyd1Z3JhdmUnLCBbMjQ5XV0sIFsndUhhcicsIFsxMDU5NV1dLCBbJ3VoYXJsJywgWzg2MzldXSwgWyd1aGFycicsIFs4NjM4XV0sIFsndWhibGsnLCBbOTYwMF1dLCBbJ3VsY29ybicsIFs4OTg4XV0sIFsndWxjb3JuZXInLCBbODk4OF1dLCBbJ3VsY3JvcCcsIFs4OTc1XV0sIFsndWx0cmknLCBbOTcyMF1dLCBbJ1VtYWNyJywgWzM2Ml1dLCBbJ3VtYWNyJywgWzM2M11dLCBbJ3VtbCcsIFsxNjhdXSwgWydVbmRlckJhcicsIFs5NV1dLCBbJ1VuZGVyQnJhY2UnLCBbOTE4M11dLCBbJ1VuZGVyQnJhY2tldCcsIFs5MTQxXV0sIFsnVW5kZXJQYXJlbnRoZXNpcycsIFs5MTgxXV0sIFsnVW5pb24nLCBbODg5OV1dLCBbJ1VuaW9uUGx1cycsIFs4ODQ2XV0sIFsnVW9nb24nLCBbMzcwXV0sIFsndW9nb24nLCBbMzcxXV0sIFsnVW9wZicsIFsxMjAxNDBdXSwgWyd1b3BmJywgWzEyMDE2Nl1dLCBbJ1VwQXJyb3dCYXInLCBbMTA1MTRdXSwgWyd1cGFycm93JywgWzg1OTNdXSwgWydVcEFycm93JywgWzg1OTNdXSwgWydVcGFycm93JywgWzg2NTddXSwgWydVcEFycm93RG93bkFycm93JywgWzg2NDVdXSwgWyd1cGRvd25hcnJvdycsIFs4NTk3XV0sIFsnVXBEb3duQXJyb3cnLCBbODU5N11dLCBbJ1VwZG93bmFycm93JywgWzg2NjFdXSwgWydVcEVxdWlsaWJyaXVtJywgWzEwNjA2XV0sIFsndXBoYXJwb29ubGVmdCcsIFs4NjM5XV0sIFsndXBoYXJwb29ucmlnaHQnLCBbODYzOF1dLCBbJ3VwbHVzJywgWzg4NDZdXSwgWydVcHBlckxlZnRBcnJvdycsIFs4NTk4XV0sIFsnVXBwZXJSaWdodEFycm93JywgWzg1OTldXSwgWyd1cHNpJywgWzk2NV1dLCBbJ1Vwc2knLCBbOTc4XV0sIFsndXBzaWgnLCBbOTc4XV0sIFsnVXBzaWxvbicsIFs5MzNdXSwgWyd1cHNpbG9uJywgWzk2NV1dLCBbJ1VwVGVlQXJyb3cnLCBbODYxM11dLCBbJ1VwVGVlJywgWzg4NjldXSwgWyd1cHVwYXJyb3dzJywgWzg2NDhdXSwgWyd1cmNvcm4nLCBbODk4OV1dLCBbJ3VyY29ybmVyJywgWzg5ODldXSwgWyd1cmNyb3AnLCBbODk3NF1dLCBbJ1VyaW5nJywgWzM2Nl1dLCBbJ3VyaW5nJywgWzM2N11dLCBbJ3VydHJpJywgWzk3MjFdXSwgWydVc2NyJywgWzExOTk4NF1dLCBbJ3VzY3InLCBbMTIwMDEwXV0sIFsndXRkb3QnLCBbODk0NF1dLCBbJ1V0aWxkZScsIFszNjBdXSwgWyd1dGlsZGUnLCBbMzYxXV0sIFsndXRyaScsIFs5NjUzXV0sIFsndXRyaWYnLCBbOTY1Ml1dLCBbJ3V1YXJyJywgWzg2NDhdXSwgWydVdW1sJywgWzIyMF1dLCBbJ3V1bWwnLCBbMjUyXV0sIFsndXdhbmdsZScsIFsxMDY2M11dLCBbJ3ZhbmdydCcsIFsxMDY1Ml1dLCBbJ3ZhcmVwc2lsb24nLCBbMTAxM11dLCBbJ3ZhcmthcHBhJywgWzEwMDhdXSwgWyd2YXJub3RoaW5nJywgWzg3MDldXSwgWyd2YXJwaGknLCBbOTgxXV0sIFsndmFycGknLCBbOTgyXV0sIFsndmFycHJvcHRvJywgWzg3MzNdXSwgWyd2YXJyJywgWzg1OTddXSwgWyd2QXJyJywgWzg2NjFdXSwgWyd2YXJyaG8nLCBbMTAwOV1dLCBbJ3ZhcnNpZ21hJywgWzk2Ml1dLCBbJ3ZhcnN1YnNldG5lcScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZhcnN1YnNldG5lcXEnLCBbMTA5NTUsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxJywgWzg4NDMsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxcScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2YXJ0aGV0YScsIFs5NzddXSwgWyd2YXJ0cmlhbmdsZWxlZnQnLCBbODg4Ml1dLCBbJ3ZhcnRyaWFuZ2xlcmlnaHQnLCBbODg4M11dLCBbJ3ZCYXInLCBbMTA5ODRdXSwgWydWYmFyJywgWzEwOTg3XV0sIFsndkJhcnYnLCBbMTA5ODVdXSwgWydWY3knLCBbMTA0Ml1dLCBbJ3ZjeScsIFsxMDc0XV0sIFsndmRhc2gnLCBbODg2Nl1dLCBbJ3ZEYXNoJywgWzg4NzJdXSwgWydWZGFzaCcsIFs4ODczXV0sIFsnVkRhc2gnLCBbODg3NV1dLCBbJ1ZkYXNobCcsIFsxMDk4Ml1dLCBbJ3ZlZWJhcicsIFs4ODkxXV0sIFsndmVlJywgWzg3NDRdXSwgWydWZWUnLCBbODg5N11dLCBbJ3ZlZWVxJywgWzg3OTRdXSwgWyd2ZWxsaXAnLCBbODk0Ml1dLCBbJ3ZlcmJhcicsIFsxMjRdXSwgWydWZXJiYXInLCBbODIxNF1dLCBbJ3ZlcnQnLCBbMTI0XV0sIFsnVmVydCcsIFs4MjE0XV0sIFsnVmVydGljYWxCYXInLCBbODczOV1dLCBbJ1ZlcnRpY2FsTGluZScsIFsxMjRdXSwgWydWZXJ0aWNhbFNlcGFyYXRvcicsIFsxMDA3Ml1dLCBbJ1ZlcnRpY2FsVGlsZGUnLCBbODc2OF1dLCBbJ1ZlcnlUaGluU3BhY2UnLCBbODIwMl1dLCBbJ1ZmcicsIFsxMjAwODldXSwgWyd2ZnInLCBbMTIwMTE1XV0sIFsndmx0cmknLCBbODg4Ml1dLCBbJ3Zuc3ViJywgWzg4MzQsIDg0MDJdXSwgWyd2bnN1cCcsIFs4ODM1LCA4NDAyXV0sIFsnVm9wZicsIFsxMjAxNDFdXSwgWyd2b3BmJywgWzEyMDE2N11dLCBbJ3Zwcm9wJywgWzg3MzNdXSwgWyd2cnRyaScsIFs4ODgzXV0sIFsnVnNjcicsIFsxMTk5ODVdXSwgWyd2c2NyJywgWzEyMDAxMV1dLCBbJ3ZzdWJuRScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2c3VibmUnLCBbODg0MiwgNjUwMjRdXSwgWyd2c3VwbkUnLCBbMTA5NTYsIDY1MDI0XV0sIFsndnN1cG5lJywgWzg4NDMsIDY1MDI0XV0sIFsnVnZkYXNoJywgWzg4NzRdXSwgWyd2emlnemFnJywgWzEwNjUwXV0sIFsnV2NpcmMnLCBbMzcyXV0sIFsnd2NpcmMnLCBbMzczXV0sIFsnd2VkYmFyJywgWzEwODQ3XV0sIFsnd2VkZ2UnLCBbODc0M11dLCBbJ1dlZGdlJywgWzg4OTZdXSwgWyd3ZWRnZXEnLCBbODc5M11dLCBbJ3dlaWVycCcsIFs4NDcyXV0sIFsnV2ZyJywgWzEyMDA5MF1dLCBbJ3dmcicsIFsxMjAxMTZdXSwgWydXb3BmJywgWzEyMDE0Ml1dLCBbJ3dvcGYnLCBbMTIwMTY4XV0sIFsnd3AnLCBbODQ3Ml1dLCBbJ3dyJywgWzg3NjhdXSwgWyd3cmVhdGgnLCBbODc2OF1dLCBbJ1dzY3InLCBbMTE5OTg2XV0sIFsnd3NjcicsIFsxMjAwMTJdXSwgWyd4Y2FwJywgWzg4OThdXSwgWyd4Y2lyYycsIFs5NzExXV0sIFsneGN1cCcsIFs4ODk5XV0sIFsneGR0cmknLCBbOTY2MV1dLCBbJ1hmcicsIFsxMjAwOTFdXSwgWyd4ZnInLCBbMTIwMTE3XV0sIFsneGhhcnInLCBbMTAyMzFdXSwgWyd4aEFycicsIFsxMDIzNF1dLCBbJ1hpJywgWzkyNl1dLCBbJ3hpJywgWzk1OF1dLCBbJ3hsYXJyJywgWzEwMjI5XV0sIFsneGxBcnInLCBbMTAyMzJdXSwgWyd4bWFwJywgWzEwMjM2XV0sIFsneG5pcycsIFs4OTU1XV0sIFsneG9kb3QnLCBbMTA3NTJdXSwgWydYb3BmJywgWzEyMDE0M11dLCBbJ3hvcGYnLCBbMTIwMTY5XV0sIFsneG9wbHVzJywgWzEwNzUzXV0sIFsneG90aW1lJywgWzEwNzU0XV0sIFsneHJhcnInLCBbMTAyMzBdXSwgWyd4ckFycicsIFsxMDIzM11dLCBbJ1hzY3InLCBbMTE5OTg3XV0sIFsneHNjcicsIFsxMjAwMTNdXSwgWyd4c3FjdXAnLCBbMTA3NThdXSwgWyd4dXBsdXMnLCBbMTA3NTZdXSwgWyd4dXRyaScsIFs5NjUxXV0sIFsneHZlZScsIFs4ODk3XV0sIFsneHdlZGdlJywgWzg4OTZdXSwgWydZYWN1dGUnLCBbMjIxXV0sIFsneWFjdXRlJywgWzI1M11dLCBbJ1lBY3knLCBbMTA3MV1dLCBbJ3lhY3knLCBbMTEwM11dLCBbJ1ljaXJjJywgWzM3NF1dLCBbJ3ljaXJjJywgWzM3NV1dLCBbJ1ljeScsIFsxMDY3XV0sIFsneWN5JywgWzEwOTldXSwgWyd5ZW4nLCBbMTY1XV0sIFsnWWZyJywgWzEyMDA5Ml1dLCBbJ3lmcicsIFsxMjAxMThdXSwgWydZSWN5JywgWzEwMzFdXSwgWyd5aWN5JywgWzExMTFdXSwgWydZb3BmJywgWzEyMDE0NF1dLCBbJ3lvcGYnLCBbMTIwMTcwXV0sIFsnWXNjcicsIFsxMTk5ODhdXSwgWyd5c2NyJywgWzEyMDAxNF1dLCBbJ1lVY3knLCBbMTA3MF1dLCBbJ3l1Y3knLCBbMTEwMl1dLCBbJ3l1bWwnLCBbMjU1XV0sIFsnWXVtbCcsIFszNzZdXSwgWydaYWN1dGUnLCBbMzc3XV0sIFsnemFjdXRlJywgWzM3OF1dLCBbJ1pjYXJvbicsIFszODFdXSwgWyd6Y2Fyb24nLCBbMzgyXV0sIFsnWmN5JywgWzEwNDddXSwgWyd6Y3knLCBbMTA3OV1dLCBbJ1pkb3QnLCBbMzc5XV0sIFsnemRvdCcsIFszODBdXSwgWyd6ZWV0cmYnLCBbODQ4OF1dLCBbJ1plcm9XaWR0aFNwYWNlJywgWzgyMDNdXSwgWydaZXRhJywgWzkxOF1dLCBbJ3pldGEnLCBbOTUwXV0sIFsnemZyJywgWzEyMDExOV1dLCBbJ1pmcicsIFs4NDg4XV0sIFsnWkhjeScsIFsxMDQ2XV0sIFsnemhjeScsIFsxMDc4XV0sIFsnemlncmFycicsIFs4NjY5XV0sIFsnem9wZicsIFsxMjAxNzFdXSwgWydab3BmJywgWzg0ODRdXSwgWydac2NyJywgWzExOTk4OV1dLCBbJ3pzY3InLCBbMTIwMDE1XV0sIFsnendqJywgWzgyMDVdXSwgWyd6d25qJywgWzgyMDRdXV07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgY2hhckluZGV4ID0ge307XG5cbmNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDVFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbY107XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbHBoYUluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhckluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIGkgPSBFTlRJVElFUy5sZW5ndGg7XG4gICAgdmFyIF9yZXN1bHRzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZSA9IEVOVElUSUVTW2ldO1xuICAgICAgICB2YXIgYWxwaGEgPSBlWzBdO1xuICAgICAgICB2YXIgY2hhcnMgPSBlWzFdO1xuICAgICAgICB2YXIgY2hyID0gY2hhcnNbMF07XG4gICAgICAgIHZhciBhZGRDaGFyID0gKGNociA8IDMyIHx8IGNociA+IDEyNikgfHwgY2hyID09PSA2MiB8fCBjaHIgPT09IDYwIHx8IGNociA9PT0gMzggfHwgY2hyID09PSAzNCB8fCBjaHIgPT09IDM5O1xuICAgICAgICB2YXIgY2hhckluZm87XG4gICAgICAgIGlmIChhZGRDaGFyKSB7XG4gICAgICAgICAgICBjaGFySW5mbyA9IGNoYXJJbmRleFtjaHJdID0gY2hhckluZGV4W2Nocl0gfHwge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJzWzFdKSB7XG4gICAgICAgICAgICB2YXIgY2hyMiA9IGNoYXJzWzFdO1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1tjaHIyXSA9IGFscGhhKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bJyddID0gYWxwaGEpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNUVudGl0aWVzO1xuIiwidmFyIEFMUEhBX0lOREVYID0ge1xuICAgICcmbHQnOiAnPCcsXG4gICAgJyZndCc6ICc+JyxcbiAgICAnJnF1b3QnOiAnXCInLFxuICAgICcmYXBvcyc6ICdcXCcnLFxuICAgICcmYW1wJzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYXBvczsnOiAnXFwnJyxcbiAgICAnJmFtcDsnOiAnJidcbn07XG5cbnZhciBDSEFSX0lOREVYID0ge1xuICAgIDYwOiAnbHQnLFxuICAgIDYyOiAnZ3QnLFxuICAgIDM0OiAncXVvdCcsXG4gICAgMzk6ICdhcG9zJyxcbiAgICAzODogJ2FtcCdcbn07XG5cbnZhciBDSEFSX1NfSU5ERVggPSB7XG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgJ1xcJyc6ICcmYXBvczsnLFxuICAgICcmJzogJyZhbXA7J1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gWG1sRW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvPHw+fFwifCd8Ji9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBDSEFSX1NfSU5ERVhbc107XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjP1swLTlhLXpBLVpdKzs/L2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMuY2hhckF0KDEpID09PSAnIycpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcy5jaGFyQXQoMikudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigzKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigyKSk7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBTFBIQV9JTkRFWFtzXSB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBDSEFSX0lOREVYW2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmdodCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmdodCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhtbEVudGl0aWVzO1xuIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBoZWxwZXIudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgKiBhcyBzZXRJbW1lZGlhdGUgZnJvbSAnY29yZS1qcy9mbi9zZXQtaW1tZWRpYXRlJztcclxuaW1wb3J0ICogYXMgZGlzdGFuY2UgZnJvbSAnLi9kaXN0YW5jZSc7XHJcbmltcG9ydCAqIGFzIGltYWdlIGZyb20gJy4vaW1hZ2UnO1xyXG5pbXBvcnQgKiBhcyBwYWxldHRlIGZyb20gJy4vcGFsZXR0ZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFBhbGV0dGVTeW5jKGltYWdlcywgeyBjb2xvckRpc3RhbmNlRm9ybXVsYSwgcGFsZXR0ZVF1YW50aXphdGlvbiwgY29sb3JzIH0gPSB7fSkge1xyXG4gICAgY29uc3QgZGlzdGFuY2VDYWxjdWxhdG9yID0gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEpO1xyXG4gICAgY29uc3QgcGFsZXR0ZVF1YW50aXplciA9IHBhbGV0dGVRdWFudGl6YXRpb25Ub1BhbGV0dGVRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBwYWxldHRlUXVhbnRpemF0aW9uLCBjb2xvcnMpO1xyXG4gICAgaW1hZ2VzLmZvckVhY2goaW1hZ2UgPT4gcGFsZXR0ZVF1YW50aXplci5zYW1wbGUoaW1hZ2UpKTtcclxuICAgIHJldHVybiBwYWxldHRlUXVhbnRpemVyLnF1YW50aXplU3luYygpO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZFBhbGV0dGUoaW1hZ2VzLCB7IGNvbG9yRGlzdGFuY2VGb3JtdWxhLCBwYWxldHRlUXVhbnRpemF0aW9uLCBjb2xvcnMsIG9uUHJvZ3Jlc3MgfSA9IHt9KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlQ2FsY3VsYXRvciA9IGNvbG9yRGlzdGFuY2VGb3JtdWxhVG9Db2xvckRpc3RhbmNlKGNvbG9yRGlzdGFuY2VGb3JtdWxhKTtcclxuICAgICAgICBjb25zdCBwYWxldHRlUXVhbnRpemVyID0gcGFsZXR0ZVF1YW50aXphdGlvblRvUGFsZXR0ZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIHBhbGV0dGVRdWFudGl6YXRpb24sIGNvbG9ycyk7XHJcbiAgICAgICAgaW1hZ2VzLmZvckVhY2goaW1hZ2UgPT4gcGFsZXR0ZVF1YW50aXplci5zYW1wbGUoaW1hZ2UpKTtcclxuICAgICAgICBsZXQgcGFsZXR0ZTtcclxuICAgICAgICBsZXQgdGltZXJJZDtcclxuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHBhbGV0dGVRdWFudGl6ZXIucXVhbnRpemUoKTtcclxuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYWxldHRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUucGFsZXR0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZSA9IHJlc3VsdC52YWx1ZS5wYWxldHRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvblByb2dyZXNzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzKHJlc3VsdC52YWx1ZS5wcm9ncmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXJJZCA9IHNldEltbWVkaWF0ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRpbWVySWQgPSBzZXRJbW1lZGlhdGUobmV4dCk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYWxldHRlU3luYyhpbWFnZSwgcGFsZXR0ZSwgeyBjb2xvckRpc3RhbmNlRm9ybXVsYSwgaW1hZ2VRdWFudGl6YXRpb24gfSA9IHt9KSB7XHJcbiAgICBjb25zdCBkaXN0YW5jZUNhbGN1bGF0b3IgPSBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSk7XHJcbiAgICBjb25zdCBpbWFnZVF1YW50aXplciA9IGltYWdlUXVhbnRpemF0aW9uVG9JbWFnZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlUXVhbnRpemF0aW9uKTtcclxuICAgIHJldHVybiBpbWFnZVF1YW50aXplci5xdWFudGl6ZVN5bmMoaW1hZ2UsIHBhbGV0dGUpO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHBseVBhbGV0dGUoaW1hZ2UsIHBhbGV0dGUsIHsgY29sb3JEaXN0YW5jZUZvcm11bGEsIGltYWdlUXVhbnRpemF0aW9uLCBvblByb2dyZXNzIH0gPSB7fSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZUNhbGN1bGF0b3IgPSBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSk7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VRdWFudGl6ZXIgPSBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbik7XHJcbiAgICAgICAgbGV0IG91dFBvaW50Q29udGFpbmVyO1xyXG4gICAgICAgIGxldCB0aW1lcklkO1xyXG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gaW1hZ2VRdWFudGl6ZXIucXVhbnRpemUoaW1hZ2UsIHBhbGV0dGUpO1xyXG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dFBvaW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUucG9pbnRDb250YWluZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFBvaW50Q29udGFpbmVyID0gcmVzdWx0LnZhbHVlLnBvaW50Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvblByb2dyZXNzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzKHJlc3VsdC52YWx1ZS5wcm9ncmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXJJZCA9IHNldEltbWVkaWF0ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRpbWVySWQgPSBzZXRJbW1lZGlhdGUobmV4dCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSA9ICdldWNsaWRlYW4tYnQ3MDknKSB7XHJcbiAgICBzd2l0Y2ggKGNvbG9yRGlzdGFuY2VGb3JtdWxhKSB7XHJcbiAgICAgICAgY2FzZSAnY2llOTQtZ3JhcGhpYy1hcnRzJzogcmV0dXJuIG5ldyBkaXN0YW5jZS5DSUU5NEdyYXBoaWNBcnRzKCk7XHJcbiAgICAgICAgY2FzZSAnY2llOTQtdGV4dGlsZXMnOiByZXR1cm4gbmV3IGRpc3RhbmNlLkNJRTk0VGV4dGlsZXMoKTtcclxuICAgICAgICBjYXNlICdjaWVkZTIwMDAnOiByZXR1cm4gbmV3IGRpc3RhbmNlLkNJRURFMjAwMCgpO1xyXG4gICAgICAgIGNhc2UgJ2NvbG9yLW1ldHJpYyc6IHJldHVybiBuZXcgZGlzdGFuY2UuQ01ldHJpYygpO1xyXG4gICAgICAgIGNhc2UgJ2V1Y2xpZGVhbic6IHJldHVybiBuZXcgZGlzdGFuY2UuRXVjbGlkZWFuKCk7XHJcbiAgICAgICAgY2FzZSAnZXVjbGlkZWFuLWJ0NzA5JzogcmV0dXJuIG5ldyBkaXN0YW5jZS5FdWNsaWRlYW5CVDcwOSgpO1xyXG4gICAgICAgIGNhc2UgJ2V1Y2xpZGVhbi1idDcwOS1ub2FscGhhJzogcmV0dXJuIG5ldyBkaXN0YW5jZS5FdWNsaWRlYW5CVDcwOU5vQWxwaGEoKTtcclxuICAgICAgICBjYXNlICdtYW5oYXR0YW4nOiByZXR1cm4gbmV3IGRpc3RhbmNlLk1hbmhhdHRhbigpO1xyXG4gICAgICAgIGNhc2UgJ21hbmhhdHRhbi1idDcwOSc6IHJldHVybiBuZXcgZGlzdGFuY2UuTWFuaGF0dGFuQlQ3MDkoKTtcclxuICAgICAgICBjYXNlICdtYW5oYXR0YW4tbm9tbXlkZSc6IHJldHVybiBuZXcgZGlzdGFuY2UuTWFuaGF0dGFuTm9tbXlkZSgpO1xyXG4gICAgICAgIGNhc2UgJ3BuZ3F1YW50JzogcmV0dXJuIG5ldyBkaXN0YW5jZS5QTkdRdWFudCgpO1xyXG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb2xvckRpc3RhbmNlRm9ybXVsYSAke2NvbG9yRGlzdGFuY2VGb3JtdWxhfWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGltYWdlUXVhbnRpemF0aW9uVG9JbWFnZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlUXVhbnRpemF0aW9uID0gJ2Zsb3lkLXN0ZWluYmVyZycpIHtcclxuICAgIHN3aXRjaCAoaW1hZ2VRdWFudGl6YXRpb24pIHtcclxuICAgICAgICBjYXNlICduZWFyZXN0JzogcmV0dXJuIG5ldyBpbWFnZS5OZWFyZXN0Q29sb3IoZGlzdGFuY2VDYWxjdWxhdG9yKTtcclxuICAgICAgICBjYXNlICdyaWVtZXJzbWEnOiByZXR1cm4gbmV3IGltYWdlLkVycm9yRGlmZnVzaW9uUmllbWVyc21hKGRpc3RhbmNlQ2FsY3VsYXRvcik7XHJcbiAgICAgICAgY2FzZSAnZmxveWQtc3RlaW5iZXJnJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5GbG95ZFN0ZWluYmVyZyk7XHJcbiAgICAgICAgY2FzZSAnZmFsc2UtZmxveWQtc3RlaW5iZXJnJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5GYWxzZUZsb3lkU3RlaW5iZXJnKTtcclxuICAgICAgICBjYXNlICdzdHVja2knOiByZXR1cm4gbmV3IGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlN0dWNraSk7XHJcbiAgICAgICAgY2FzZSAnYXRraW5zb24nOiByZXR1cm4gbmV3IGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLkF0a2luc29uKTtcclxuICAgICAgICBjYXNlICdqYXJ2aXMnOiByZXR1cm4gbmV3IGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLkphcnZpcyk7XHJcbiAgICAgICAgY2FzZSAnYnVya2VzJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5CdXJrZXMpO1xyXG4gICAgICAgIGNhc2UgJ3NpZXJyYSc6IHJldHVybiBuZXcgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlLkVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuU2llcnJhKTtcclxuICAgICAgICBjYXNlICd0d28tc2llcnJhJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5Ud29TaWVycmEpO1xyXG4gICAgICAgIGNhc2UgJ3NpZXJyYS1saXRlJzogcmV0dXJuIG5ldyBpbWFnZS5FcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2UuRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5TaWVycmFMaXRlKTtcclxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaW1hZ2VRdWFudGl6YXRpb24gJHtpbWFnZVF1YW50aXphdGlvbn1gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYWxldHRlUXVhbnRpemF0aW9uVG9QYWxldHRlUXVhbnRpemVyKGRpc3RhbmNlQ2FsY3VsYXRvciwgcGFsZXR0ZVF1YW50aXphdGlvbiA9ICd3dXF1YW50JywgY29sb3JzID0gMjU2KSB7XHJcbiAgICBzd2l0Y2ggKHBhbGV0dGVRdWFudGl6YXRpb24pIHtcclxuICAgICAgICBjYXNlICduZXVxdWFudCc6IHJldHVybiBuZXcgcGFsZXR0ZS5OZXVRdWFudChkaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyk7XHJcbiAgICAgICAgY2FzZSAncmdicXVhbnQnOiByZXR1cm4gbmV3IHBhbGV0dGUuUkdCUXVhbnQoZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xyXG4gICAgICAgIGNhc2UgJ3d1cXVhbnQnOiByZXR1cm4gbmV3IHBhbGV0dGUuV3VRdWFudChkaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyk7XHJcbiAgICAgICAgY2FzZSAnbmV1cXVhbnQtZmxvYXQnOiByZXR1cm4gbmV3IHBhbGV0dGUuTmV1UXVhbnRGbG9hdChkaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyk7XHJcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhbGV0dGVRdWFudGl6YXRpb24gJHtwYWxldHRlUXVhbnRpemF0aW9ufWApO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2ljQVBJLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogY29uc3RhbnRzLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuLyoqXHJcbiAqIHNSR0IgKGJhc2VkIG9uIElUVS1SIFJlY29tbWVuZGF0aW9uIEJULjcwOSlcclxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TUkdCXHJcbiAqL1xyXG5leHBvcnQgdmFyIFk7XHJcbihmdW5jdGlvbiAoWSkge1xyXG4gICAgWVtZW1wiUkVEXCJdID0gMC4yMTI2XSA9IFwiUkVEXCI7XHJcbiAgICBZW1lbXCJHUkVFTlwiXSA9IDAuNzE1Ml0gPSBcIkdSRUVOXCI7XHJcbiAgICBZW1lbXCJCTFVFXCJdID0gMC4wNzIyXSA9IFwiQkxVRVwiO1xyXG4gICAgWVtZW1wiV0hJVEVcIl0gPSAxXSA9IFwiV0hJVEVcIjtcclxufSkoWSB8fCAoWSA9IHt9KSk7XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgdmFyIHg7XHJcbihmdW5jdGlvbiAoeCkge1xyXG4gICAgeFt4W1wiUkVEXCJdID0gMC42NF0gPSBcIlJFRFwiO1xyXG4gICAgeFt4W1wiR1JFRU5cIl0gPSAwLjNdID0gXCJHUkVFTlwiO1xyXG4gICAgeFt4W1wiQkxVRVwiXSA9IDAuMTVdID0gXCJCTFVFXCI7XHJcbiAgICB4W3hbXCJXSElURVwiXSA9IDAuMzEyN10gPSBcIldISVRFXCI7XHJcbn0pKHggfHwgKHggPSB7fSkpO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IHZhciB5O1xyXG4oZnVuY3Rpb24gKHkpIHtcclxuICAgIHlbeVtcIlJFRFwiXSA9IDAuMzNdID0gXCJSRURcIjtcclxuICAgIHlbeVtcIkdSRUVOXCJdID0gMC42XSA9IFwiR1JFRU5cIjtcclxuICAgIHlbeVtcIkJMVUVcIl0gPSAwLjA2XSA9IFwiQkxVRVwiO1xyXG4gICAgeVt5W1wiV0hJVEVcIl0gPSAwLjMyOV0gPSBcIldISVRFXCI7XHJcbn0pKHkgfHwgKHkgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idDcwOS5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGNvbnN0YW50cy50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCAqIGFzIGJ0NzA5IGZyb20gJy4vYnQ3MDknO1xyXG5leHBvcnQgeyBidDcwOSwgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5leHBvcnQgeyByZ2IyeHl6IH0gZnJvbSAnLi9yZ2IyeHl6JztcclxuZXhwb3J0IHsgcmdiMmhzbCB9IGZyb20gJy4vcmdiMmhzbCc7XHJcbmV4cG9ydCB7IHJnYjJsYWIgfSBmcm9tICcuL3JnYjJsYWInO1xyXG5leHBvcnQgeyBsYWIyeHl6IH0gZnJvbSAnLi9sYWIyeHl6JztcclxuZXhwb3J0IHsgbGFiMnJnYiB9IGZyb20gJy4vbGFiMnJnYic7XHJcbmV4cG9ydCB7IHh5ejJsYWIgfSBmcm9tICcuL3h5ejJsYWInO1xyXG5leHBvcnQgeyB4eXoycmdiIH0gZnJvbSAnLi94eXoycmdiJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBsYWIycmdiLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgbGFiMnh5eiB9IGZyb20gJy4vbGFiMnh5eic7XHJcbmltcG9ydCB7IHh5ejJyZ2IgfSBmcm9tICcuL3h5ejJyZ2InO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGxhYjJyZ2IoTCwgYSwgYikge1xyXG4gICAgY29uc3QgeHl6ID0gbGFiMnh5eihMLCBhLCBiKTtcclxuICAgIHJldHVybiB4eXoycmdiKHh5ei54LCB4eXoueSwgeHl6LnopO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhYjJyZ2IuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBsYWIyeHl6LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuY29uc3QgcmVmWCA9IDAuOTUwNDc7IC8vIHJlZl9YID0gIDk1LjA0NyAgIE9ic2VydmVyPSAywrAsIElsbHVtaW5hbnQgPSBENjVcclxuY29uc3QgcmVmWSA9IDEuMDAwMDA7IC8vIHJlZl9ZID0gMTAwLjAwMFxyXG5jb25zdCByZWZaID0gMS4wODg4MzsgLy8gcmVmX1ogPSAxMDguODgzXHJcbmZ1bmN0aW9uIHBpdm90KG4pIHtcclxuICAgIHJldHVybiBuID4gMC4yMDY4OTMwMzQgPyBNYXRoLnBvdyhuLCAzKSA6IChuIC0gMTYgLyAxMTYpIC8gNy43ODc7XHJcbn1cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBsYWIyeHl6KEwsIGEsIGIpIHtcclxuICAgIGNvbnN0IHkgPSAoTCArIDE2KSAvIDExNjtcclxuICAgIGNvbnN0IHggPSBhIC8gNTAwICsgeTtcclxuICAgIGNvbnN0IHogPSB5IC0gYiAvIDIwMDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogcmVmWCAqIHBpdm90KHgpLFxyXG4gICAgICAgIHk6IHJlZlkgKiBwaXZvdCh5KSxcclxuICAgICAgICB6OiByZWZaICogcGl2b3QoeiksXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhYjJ4eXouanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiByZ2IyaHNsLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgbWluMywgbWF4MyB9IGZyb20gJy4uL3V0aWxzL2FyaXRobWV0aWMnO1xyXG4vKipcclxuICogQ2FsY3VsYXRlIEhTTCBmcm9tIFJHQlxyXG4gKiBIdWUgaXMgaW4gZGVncmVlcyBbMC4uMzYwXVxyXG4gKiBMaWdodG5lc3M6IFswLi4xXVxyXG4gKiBTYXR1cmF0aW9uOiBbMC4uMV1cclxuICogaHR0cDovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAwNjA5MTQwNDA0MzYvaHR0cDovL2xvY2FsLndhc3AudXdhLmVkdS5hdS9+cGJvdXJrZS9jb2xvdXIvaHNsL1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJnYjJoc2wociwgZywgYikge1xyXG4gICAgY29uc3QgbWluID0gbWluMyhyLCBnLCBiKTtcclxuICAgIGNvbnN0IG1heCA9IG1heDMociwgZywgYik7XHJcbiAgICBjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcclxuICAgIGNvbnN0IGwgPSAobWluICsgbWF4KSAvIDUxMDtcclxuICAgIGxldCBzID0gMDtcclxuICAgIGlmIChsID4gMCAmJiBsIDwgMSlcclxuICAgICAgICBzID0gZGVsdGEgLyAobCA8IDAuNSA/IChtYXggKyBtaW4pIDogKDUxMCAtIG1heCAtIG1pbikpO1xyXG4gICAgbGV0IGggPSAwO1xyXG4gICAgaWYgKGRlbHRhID4gMCkge1xyXG4gICAgICAgIGlmIChtYXggPT09IHIpIHtcclxuICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF4ID09PSBnKSB7XHJcbiAgICAgICAgICAgIGggPSAoMiArIChiIC0gcikgLyBkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoID0gKDQgKyAociAtIGcpIC8gZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoICo9IDYwO1xyXG4gICAgICAgIGlmIChoIDwgMClcclxuICAgICAgICAgICAgaCArPSAzNjA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBoLCBzLCBsIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmdiMmhzbC5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIHJnYjJsYWIudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyByZ2IyeHl6IH0gZnJvbSAnLi9yZ2IyeHl6JztcclxuaW1wb3J0IHsgeHl6MmxhYiB9IGZyb20gJy4veHl6MmxhYic7XHJcbmV4cG9ydCBmdW5jdGlvbiByZ2IybGFiKHIsIGcsIGIpIHtcclxuICAgIGNvbnN0IHh5eiA9IHJnYjJ4eXoociwgZywgYik7XHJcbiAgICByZXR1cm4geHl6MmxhYih4eXoueCwgeHl6LnksIHh5ei56KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZ2IybGFiLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogcmdiMnh5ei50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmZ1bmN0aW9uIGNvcnJlY3RHYW1tYShuKSB7XHJcbiAgICByZXR1cm4gbiA+IDAuMDQwNDUgPyBNYXRoLnBvdygobiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogbiAvIDEyLjkyO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByZ2IyeHl6KHIsIGcsIGIpIHtcclxuICAgIC8vIGdhbW1hIGNvcnJlY3Rpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TUkdCI1RoZV9yZXZlcnNlX3RyYW5zZm9ybWF0aW9uXHJcbiAgICByID0gY29ycmVjdEdhbW1hKHIgLyAyNTUpO1xyXG4gICAgZyA9IGNvcnJlY3RHYW1tYShnIC8gMjU1KTtcclxuICAgIGIgPSBjb3JyZWN0R2FtbWEoYiAvIDI1NSk7XHJcbiAgICAvLyBPYnNlcnZlci4gPSAywrAsIElsbHVtaW5hbnQgPSBENjVcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogciAqIDAuNDEyNCArIGcgKiAwLjM1NzYgKyBiICogMC4xODA1LFxyXG4gICAgICAgIHk6IHIgKiAwLjIxMjYgKyBnICogMC43MTUyICsgYiAqIDAuMDcyMixcclxuICAgICAgICB6OiByICogMC4wMTkzICsgZyAqIDAuMTE5MiArIGIgKiAwLjk1MDUsXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJnYjJ4eXouanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiB4eXoybGFiLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuY29uc3QgcmVmWCA9IDAuOTUwNDc7IC8vIHJlZl9YID0gIDk1LjA0NyAgIE9ic2VydmVyPSAywrAsIElsbHVtaW5hbnQ9IEQ2NVxyXG5jb25zdCByZWZZID0gMS4wMDAwMDsgLy8gcmVmX1kgPSAxMDAuMDAwXHJcbmNvbnN0IHJlZlogPSAxLjA4ODgzOyAvLyByZWZfWiA9IDEwOC44ODNcclxuZnVuY3Rpb24gcGl2b3Qobikge1xyXG4gICAgcmV0dXJuIG4gPiAwLjAwODg1NiA/IE1hdGgucG93KG4sIDEgLyAzKSA6ICg3Ljc4NyAqIG4gKyAxNiAvIDExNik7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHh5ejJsYWIoeCwgeSwgeikge1xyXG4gICAgeCA9IHBpdm90KHggLyByZWZYKTtcclxuICAgIHkgPSBwaXZvdCh5IC8gcmVmWSk7XHJcbiAgICB6ID0gcGl2b3QoeiAvIHJlZlopO1xyXG4gICAgaWYgKCgxMTYgKiB5KSAtIDE2IDwgMClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3h4eCcpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBMOiBNYXRoLm1heCgwLCAoMTE2ICogeSkgLSAxNiksXHJcbiAgICAgICAgYTogNTAwICogKHggLSB5KSxcclxuICAgICAgICBiOiAyMDAgKiAoeSAtIHopLFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD14eXoybGFiLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogeHl6MnJnYi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IGluUmFuZ2UwdG8yNTVSb3VuZGVkIH0gZnJvbSAnLi4vdXRpbHMvYXJpdGhtZXRpYyc7XHJcbi8vIGdhbW1hIGNvcnJlY3Rpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TUkdCI1RoZV9yZXZlcnNlX3RyYW5zZm9ybWF0aW9uXHJcbmZ1bmN0aW9uIGNvcnJlY3RHYW1tYShuKSB7XHJcbiAgICByZXR1cm4gbiA+IDAuMDAzMTMwOCA/IDEuMDU1ICogTWF0aC5wb3cobiwgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogbjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24geHl6MnJnYih4LCB5LCB6KSB7XHJcbiAgICAvLyBPYnNlcnZlci4gPSAywrAsIElsbHVtaW5hbnQgPSBENjVcclxuICAgIGNvbnN0IHIgPSBjb3JyZWN0R2FtbWEoeCAqIDMuMjQwNiArIHkgKiAtMS41MzcyICsgeiAqIC0wLjQ5ODYpO1xyXG4gICAgY29uc3QgZyA9IGNvcnJlY3RHYW1tYSh4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1KTtcclxuICAgIGNvbnN0IGIgPSBjb3JyZWN0R2FtbWEoeCAqIDAuMDU1NyArIHkgKiAtMC4yMDQwICsgeiAqIDEuMDU3MCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHI6IGluUmFuZ2UwdG8yNTVSb3VuZGVkKHIgKiAyNTUpLFxyXG4gICAgICAgIGc6IGluUmFuZ2UwdG8yNTVSb3VuZGVkKGcgKiAyNTUpLFxyXG4gICAgICAgIGI6IGluUmFuZ2UwdG8yNTVSb3VuZGVkKGIgKiAyNTUpLFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD14eXoycmdiLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogY2llOTQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB9IGZyb20gJy4vZGlzdGFuY2VDYWxjdWxhdG9yJztcclxuaW1wb3J0IHsgcmdiMmxhYiB9IGZyb20gJy4uL2NvbnZlcnNpb24vcmdiMmxhYic7XHJcbmltcG9ydCB7IGluUmFuZ2UwdG8yNTUgfSBmcm9tICcuLi91dGlscy9hcml0aG1ldGljJztcclxuLyoqXHJcbiAqIENJRTk0IG1ldGhvZCBvZiBkZWx0YS1lXHJcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29sb3JfZGlmZmVyZW5jZSNDSUU5NFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFic3RyYWN0Q0lFOTQgZXh0ZW5kcyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB7XHJcbiAgICBjYWxjdWxhdGVSYXcocjEsIGcxLCBiMSwgYTEsIHIyLCBnMiwgYjIsIGEyKSB7XHJcbiAgICAgICAgY29uc3QgbGFiMSA9IHJnYjJsYWIoaW5SYW5nZTB0bzI1NShyMSAqIHRoaXMuX3doaXRlUG9pbnQuciksIGluUmFuZ2UwdG8yNTUoZzEgKiB0aGlzLl93aGl0ZVBvaW50LmcpLCBpblJhbmdlMHRvMjU1KGIxICogdGhpcy5fd2hpdGVQb2ludC5iKSk7XHJcbiAgICAgICAgY29uc3QgbGFiMiA9IHJnYjJsYWIoaW5SYW5nZTB0bzI1NShyMiAqIHRoaXMuX3doaXRlUG9pbnQuciksIGluUmFuZ2UwdG8yNTUoZzIgKiB0aGlzLl93aGl0ZVBvaW50LmcpLCBpblJhbmdlMHRvMjU1KGIyICogdGhpcy5fd2hpdGVQb2ludC5iKSk7XHJcbiAgICAgICAgY29uc3QgZEwgPSBsYWIxLkwgLSBsYWIyLkw7XHJcbiAgICAgICAgY29uc3QgZEEgPSBsYWIxLmEgLSBsYWIyLmE7XHJcbiAgICAgICAgY29uc3QgZEIgPSBsYWIxLmIgLSBsYWIyLmI7XHJcbiAgICAgICAgY29uc3QgYzEgPSBNYXRoLnNxcnQobGFiMS5hICogbGFiMS5hICsgbGFiMS5iICogbGFiMS5iKTtcclxuICAgICAgICBjb25zdCBjMiA9IE1hdGguc3FydChsYWIyLmEgKiBsYWIyLmEgKyBsYWIyLmIgKiBsYWIyLmIpO1xyXG4gICAgICAgIGNvbnN0IGRDID0gYzEgLSBjMjtcclxuICAgICAgICBsZXQgZGVsdGFIID0gZEEgKiBkQSArIGRCICogZEIgLSBkQyAqIGRDO1xyXG4gICAgICAgIGRlbHRhSCA9IGRlbHRhSCA8IDAgPyAwIDogTWF0aC5zcXJ0KGRlbHRhSCk7XHJcbiAgICAgICAgY29uc3QgZEFscGhhID0gKGEyIC0gYTEpICogdGhpcy5fd2hpdGVQb2ludC5hICogdGhpcy5fa0E7XHJcbiAgICAgICAgLy8gVE9ETzogYWRkIGFscGhhIGNoYW5uZWwgc3VwcG9ydFxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZEwgLyB0aGlzLl9LbCwgMikgK1xyXG4gICAgICAgICAgICBNYXRoLnBvdyhkQyAvICgxLjAgKyB0aGlzLl9LMSAqIGMxKSwgMikgK1xyXG4gICAgICAgICAgICBNYXRoLnBvdyhkZWx0YUggLyAoMS4wICsgdGhpcy5fSzIgKiBjMSksIDIpICtcclxuICAgICAgICAgICAgTWF0aC5wb3coZEFscGhhLCAyKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIENJRTk0VGV4dGlsZXMgZXh0ZW5kcyBBYnN0cmFjdENJRTk0IHtcclxuICAgIF9zZXREZWZhdWx0cygpIHtcclxuICAgICAgICB0aGlzLl9LbCA9IDIuMDtcclxuICAgICAgICB0aGlzLl9LMSA9IDAuMDQ4O1xyXG4gICAgICAgIHRoaXMuX0syID0gMC4wMTQ7XHJcbiAgICAgICAgdGhpcy5fa0EgPSAwLjI1ICogNTAgLyAyNTU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIENJRTk0R3JhcGhpY0FydHMgZXh0ZW5kcyBBYnN0cmFjdENJRTk0IHtcclxuICAgIF9zZXREZWZhdWx0cygpIHtcclxuICAgICAgICB0aGlzLl9LbCA9IDEuMDtcclxuICAgICAgICB0aGlzLl9LMSA9IDAuMDQ1O1xyXG4gICAgICAgIHRoaXMuX0syID0gMC4wMTU7XHJcbiAgICAgICAgdGhpcy5fa0EgPSAwLjI1ICogMTAwIC8gMjU1O1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNpZTk0LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogY2llZGUyMDAwLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IgfSBmcm9tICcuL2Rpc3RhbmNlQ2FsY3VsYXRvcic7XHJcbmltcG9ydCB7IHJnYjJsYWIgfSBmcm9tICcuLi9jb252ZXJzaW9uL3JnYjJsYWInO1xyXG5pbXBvcnQgeyBkZWdyZWVzMnJhZGlhbnMsIGluUmFuZ2UwdG8yNTUgfSBmcm9tICcuLi91dGlscy9hcml0aG1ldGljJztcclxuLy8gdHNsaW50OmRpc2FibGU6dmFyaWFibGUtbmFtZVxyXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuYW1pbmctY29udmVudGlvblxyXG4vKipcclxuICogQ0lFREUyMDAwIGFsZ29yaXRobSAtIEFkYXB0ZWQgZnJvbSBTaGFybWEgZXQgYWwncyBNQVRMQUIgaW1wbGVtZW50YXRpb24gYXRcclxuICogaHR0cDovL3d3dy5lY2Uucm9jaGVzdGVyLmVkdS9+Z3NoYXJtYS9jaWVkZTIwMDAvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ0lFREUyMDAwIGV4dGVuZHMgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3Ige1xyXG4gICAgX3NldERlZmF1bHRzKCkgeyB9XHJcbiAgICBzdGF0aWMgX2NhbGN1bGF0ZWhwKGIsIGFwKSB7XHJcbiAgICAgICAgY29uc3QgaHAgPSBNYXRoLmF0YW4yKGIsIGFwKTtcclxuICAgICAgICBpZiAoaHAgPj0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGhwO1xyXG4gICAgICAgIHJldHVybiBocCArIENJRURFMjAwMC5fZGVnMzYwSW5SYWQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NhbGN1bGF0ZVJUKGFocCwgYUNwKSB7XHJcbiAgICAgICAgY29uc3QgYUNwX3RvXzcgPSBNYXRoLnBvdyhhQ3AsIDcuMCk7XHJcbiAgICAgICAgY29uc3QgUl9DID0gMi4wICogTWF0aC5zcXJ0KGFDcF90b183IC8gKGFDcF90b183ICsgQ0lFREUyMDAwLl9wb3cyNXRvNykpOyAvLyAyNV43XHJcbiAgICAgICAgY29uc3QgZGVsdGFfdGhldGEgPSBDSUVERTIwMDAuX2RlZzMwSW5SYWQgKiBNYXRoLmV4cCgtTWF0aC5wb3coKGFocCAtIENJRURFMjAwMC5fZGVnMjc1SW5SYWQpIC8gQ0lFREUyMDAwLl9kZWcyNUluUmFkLCAyLjApKTtcclxuICAgICAgICByZXR1cm4gLU1hdGguc2luKDIuMCAqIGRlbHRhX3RoZXRhKSAqIFJfQztcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY2FsY3VsYXRlVChhaHApIHtcclxuICAgICAgICByZXR1cm4gMS4wIC0gLjE3ICogTWF0aC5jb3MoYWhwIC0gQ0lFREUyMDAwLl9kZWczMEluUmFkKSArIC4yNCAqIE1hdGguY29zKGFocCAqIDIuMCkgKyAuMzIgKiBNYXRoLmNvcyhhaHAgKiAzLjAgKyBDSUVERTIwMDAuX2RlZzZJblJhZCkgLSAuMiAqIE1hdGguY29zKGFocCAqIDQuMCAtIENJRURFMjAwMC5fZGVnNjNJblJhZCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2NhbGN1bGF0ZV9haHAoQzFwQzJwLCBoX2JhciwgaDFwLCBoMnApIHtcclxuICAgICAgICBjb25zdCBocFN1bSA9IGgxcCArIGgycDtcclxuICAgICAgICBpZiAoQzFwQzJwID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gaHBTdW07XHJcbiAgICAgICAgaWYgKGhfYmFyIDw9IENJRURFMjAwMC5fZGVnMTgwSW5SYWQpXHJcbiAgICAgICAgICAgIHJldHVybiBocFN1bSAvIDIuMDtcclxuICAgICAgICBpZiAoaHBTdW0gPCBDSUVERTIwMDAuX2RlZzM2MEluUmFkKVxyXG4gICAgICAgICAgICByZXR1cm4gKGhwU3VtICsgQ0lFREUyMDAwLl9kZWczNjBJblJhZCkgLyAyLjA7XHJcbiAgICAgICAgcmV0dXJuIChocFN1bSAtIENJRURFMjAwMC5fZGVnMzYwSW5SYWQpIC8gMi4wO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jYWxjdWxhdGVfZEhwKEMxcEMycCwgaF9iYXIsIGgycCwgaDFwKSB7XHJcbiAgICAgICAgbGV0IGRocDtcclxuICAgICAgICBpZiAoQzFwQzJwID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRocCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhfYmFyIDw9IENJRURFMjAwMC5fZGVnMTgwSW5SYWQpIHtcclxuICAgICAgICAgICAgZGhwID0gaDJwIC0gaDFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoMnAgPD0gaDFwKSB7XHJcbiAgICAgICAgICAgIGRocCA9IGgycCAtIGgxcCArIENJRURFMjAwMC5fZGVnMzYwSW5SYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkaHAgPSBoMnAgLSBoMXAgLSBDSUVERTIwMDAuX2RlZzM2MEluUmFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMi4wICogTWF0aC5zcXJ0KEMxcEMycCkgKiBNYXRoLnNpbihkaHAgLyAyLjApO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xyXG4gICAgICAgIGNvbnN0IGxhYjEgPSByZ2IybGFiKGluUmFuZ2UwdG8yNTUocjEgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBpblJhbmdlMHRvMjU1KGcxICogdGhpcy5fd2hpdGVQb2ludC5nKSwgaW5SYW5nZTB0bzI1NShiMSAqIHRoaXMuX3doaXRlUG9pbnQuYikpO1xyXG4gICAgICAgIGNvbnN0IGxhYjIgPSByZ2IybGFiKGluUmFuZ2UwdG8yNTUocjIgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBpblJhbmdlMHRvMjU1KGcyICogdGhpcy5fd2hpdGVQb2ludC5nKSwgaW5SYW5nZTB0bzI1NShiMiAqIHRoaXMuX3doaXRlUG9pbnQuYikpO1xyXG4gICAgICAgIGNvbnN0IGRBID0gKGEyIC0gYTEpICogdGhpcy5fd2hpdGVQb2ludC5hICogQ0lFREUyMDAwLl9rQTtcclxuICAgICAgICBjb25zdCBkRTIgPSB0aGlzLmNhbGN1bGF0ZVJhd0luTGFiKGxhYjEsIGxhYjIpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZEUyICsgZEEgKiBkQSk7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVSYXdJbkxhYihMYWIxLCBMYWIyKSB7XHJcbiAgICAgICAgLy8gR2V0IEwsYSxiIHZhbHVlcyBmb3IgY29sb3IgMVxyXG4gICAgICAgIGNvbnN0IEwxID0gTGFiMS5MO1xyXG4gICAgICAgIGNvbnN0IGExID0gTGFiMS5hO1xyXG4gICAgICAgIGNvbnN0IGIxID0gTGFiMS5iO1xyXG4gICAgICAgIC8vIEdldCBMLGEsYiB2YWx1ZXMgZm9yIGNvbG9yIDJcclxuICAgICAgICBjb25zdCBMMiA9IExhYjIuTDtcclxuICAgICAgICBjb25zdCBhMiA9IExhYjIuYTtcclxuICAgICAgICBjb25zdCBiMiA9IExhYjIuYjtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgQ3ByaW1lMSwgQ3ByaW1lMiwgQ2FiYmFyXHJcbiAgICAgICAgY29uc3QgQzEgPSBNYXRoLnNxcnQoYTEgKiBhMSArIGIxICogYjEpO1xyXG4gICAgICAgIGNvbnN0IEMyID0gTWF0aC5zcXJ0KGEyICogYTIgKyBiMiAqIGIyKTtcclxuICAgICAgICBjb25zdCBwb3dfYV9DMV9DMl90b183ID0gTWF0aC5wb3coKEMxICsgQzIpIC8gMi4wLCA3LjApO1xyXG4gICAgICAgIGNvbnN0IEcgPSAwLjUgKiAoMS4wIC0gTWF0aC5zcXJ0KHBvd19hX0MxX0MyX3RvXzcgLyAocG93X2FfQzFfQzJfdG9fNyArIENJRURFMjAwMC5fcG93MjV0bzcpKSk7IC8vIDI1XjdcclxuICAgICAgICBjb25zdCBhMXAgPSAoMS4wICsgRykgKiBhMTtcclxuICAgICAgICBjb25zdCBhMnAgPSAoMS4wICsgRykgKiBhMjtcclxuICAgICAgICBjb25zdCBDMXAgPSBNYXRoLnNxcnQoYTFwICogYTFwICsgYjEgKiBiMSk7XHJcbiAgICAgICAgY29uc3QgQzJwID0gTWF0aC5zcXJ0KGEycCAqIGEycCArIGIyICogYjIpO1xyXG4gICAgICAgIGNvbnN0IEMxcEMycCA9IEMxcCAqIEMycDtcclxuICAgICAgICAvLyBBbmdsZXMgaW4gRGVncmVlLlxyXG4gICAgICAgIGNvbnN0IGgxcCA9IENJRURFMjAwMC5fY2FsY3VsYXRlaHAoYjEsIGExcCk7XHJcbiAgICAgICAgY29uc3QgaDJwID0gQ0lFREUyMDAwLl9jYWxjdWxhdGVocChiMiwgYTJwKTtcclxuICAgICAgICBjb25zdCBoX2JhciA9IE1hdGguYWJzKGgxcCAtIGgycCk7XHJcbiAgICAgICAgY29uc3QgZExwID0gTDIgLSBMMTtcclxuICAgICAgICBjb25zdCBkQ3AgPSBDMnAgLSBDMXA7XHJcbiAgICAgICAgY29uc3QgZEhwID0gQ0lFREUyMDAwLl9jYWxjdWxhdGVfZEhwKEMxcEMycCwgaF9iYXIsIGgycCwgaDFwKTtcclxuICAgICAgICBjb25zdCBhaHAgPSBDSUVERTIwMDAuX2NhbGN1bGF0ZV9haHAoQzFwQzJwLCBoX2JhciwgaDFwLCBoMnApO1xyXG4gICAgICAgIGNvbnN0IFQgPSBDSUVERTIwMDAuX2NhbGN1bGF0ZVQoYWhwKTtcclxuICAgICAgICBjb25zdCBhQ3AgPSAoQzFwICsgQzJwKSAvIDIuMDtcclxuICAgICAgICBjb25zdCBhTHBfbWludXNfNTBfc3F1YXJlID0gTWF0aC5wb3coKEwxICsgTDIpIC8gMi4wIC0gNTAuMCwgMi4wKTtcclxuICAgICAgICBjb25zdCBTX0wgPSAxLjAgKyAoLjAxNSAqIGFMcF9taW51c181MF9zcXVhcmUpIC8gTWF0aC5zcXJ0KDIwLjAgKyBhTHBfbWludXNfNTBfc3F1YXJlKTtcclxuICAgICAgICBjb25zdCBTX0MgPSAxLjAgKyAuMDQ1ICogYUNwO1xyXG4gICAgICAgIGNvbnN0IFNfSCA9IDEuMCArIC4wMTUgKiBUICogYUNwO1xyXG4gICAgICAgIGNvbnN0IFJfVCA9IENJRURFMjAwMC5fY2FsY3VsYXRlUlQoYWhwLCBhQ3ApO1xyXG4gICAgICAgIGNvbnN0IGRMcFNMID0gZExwIC8gU19MOyAvLyBTX0wgKiBrTCwgd2hlcmUga0wgaXMgMS4wXHJcbiAgICAgICAgY29uc3QgZENwU0MgPSBkQ3AgLyBTX0M7IC8vIFNfQyAqIGtDLCB3aGVyZSBrQyBpcyAxLjBcclxuICAgICAgICBjb25zdCBkSHBTSCA9IGRIcCAvIFNfSDsgLy8gU19IICoga0gsIHdoZXJlIGtIIGlzIDEuMFxyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhkTHBTTCwgMikgKyBNYXRoLnBvdyhkQ3BTQywgMikgKyBNYXRoLnBvdyhkSHBTSCwgMikgKyBSX1QgKiBkQ3BTQyAqIGRIcFNIO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXZWlnaHQgaW4gZGlzdGFuY2U6IDAuMjVcclxuICogTWF4IERlbHRhRTogMTAwXHJcbiAqIE1heCBEZWx0YUE6IDI1NVxyXG4gKi9cclxuQ0lFREUyMDAwLl9rQSA9IDAuMjUgKiAxMDAgLyAyNTU7XHJcbkNJRURFMjAwMC5fcG93MjV0bzcgPSBNYXRoLnBvdygyNSwgNyk7XHJcbkNJRURFMjAwMC5fZGVnMzYwSW5SYWQgPSBkZWdyZWVzMnJhZGlhbnMoMzYwKTtcclxuQ0lFREUyMDAwLl9kZWcxODBJblJhZCA9IGRlZ3JlZXMycmFkaWFucygxODApO1xyXG5DSUVERTIwMDAuX2RlZzMwSW5SYWQgPSBkZWdyZWVzMnJhZGlhbnMoMzApO1xyXG5DSUVERTIwMDAuX2RlZzZJblJhZCA9IGRlZ3JlZXMycmFkaWFucyg2KTtcclxuQ0lFREUyMDAwLl9kZWc2M0luUmFkID0gZGVncmVlczJyYWRpYW5zKDYzKTtcclxuQ0lFREUyMDAwLl9kZWcyNzVJblJhZCA9IGRlZ3JlZXMycmFkaWFucygyNzUpO1xyXG5DSUVERTIwMDAuX2RlZzI1SW5SYWQgPSBkZWdyZWVzMnJhZGlhbnMoMjUpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaWVkZTIwMDAuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBjbWV0cmljLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IgfSBmcm9tICcuL2Rpc3RhbmNlQ2FsY3VsYXRvcic7XHJcbi8qKlxyXG4gKiBUT0RPOiBOYW1lIGl0OiBodHRwOi8vd3d3LmNvbXB1cGhhc2UuY29tL2NtZXRyaWMuaHRtXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ01ldHJpYyBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcclxuICAgIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcclxuICAgICAgICBjb25zdCBybWVhbiA9IChyMSArIHIyKSAvIDIgKiB0aGlzLl93aGl0ZVBvaW50LnI7XHJcbiAgICAgICAgY29uc3QgciA9IChyMSAtIHIyKSAqIHRoaXMuX3doaXRlUG9pbnQucjtcclxuICAgICAgICBjb25zdCBnID0gKGcxIC0gZzIpICogdGhpcy5fd2hpdGVQb2ludC5nO1xyXG4gICAgICAgIGNvbnN0IGIgPSAoYjEgLSBiMikgKiB0aGlzLl93aGl0ZVBvaW50LmI7XHJcbiAgICAgICAgY29uc3QgZEUgPSAoKCgoNTEyICsgcm1lYW4pICogciAqIHIpID4+IDgpICsgNCAqIGcgKiBnICsgKCgoNzY3IC0gcm1lYW4pICogYiAqIGIpID4+IDgpKTtcclxuICAgICAgICBjb25zdCBkQSA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGRFICsgZEEgKiBkQSk7XHJcbiAgICB9XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7IH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbWV0cmljLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9zZXREZWZhdWx0cygpO1xyXG4gICAgICAgIC8vIHNldCBkZWZhdWx0IG1heGltYWwgY29sb3IgY29tcG9uZW50IGRlbHRhcyAoMjU1IC0gMCA9IDI1NSlcclxuICAgICAgICB0aGlzLnNldFdoaXRlUG9pbnQoMjU1LCAyNTUsIDI1NSwgMjU1KTtcclxuICAgIH1cclxuICAgIHNldFdoaXRlUG9pbnQociwgZywgYiwgYSkge1xyXG4gICAgICAgIHRoaXMuX3doaXRlUG9pbnQgPSB7XHJcbiAgICAgICAgICAgIHI6IChyID4gMCkgPyAyNTUgLyByIDogMCxcclxuICAgICAgICAgICAgZzogKGcgPiAwKSA/IDI1NSAvIGcgOiAwLFxyXG4gICAgICAgICAgICBiOiAoYiA+IDApID8gMjU1IC8gYiA6IDAsXHJcbiAgICAgICAgICAgIGE6IChhID4gMCkgPyAyNTUgLyBhIDogMCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX21heERpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVSYXcociwgZywgYiwgYSwgMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVOb3JtYWxpemVkKGNvbG9yQSwgY29sb3JCKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlUmF3KGNvbG9yQS5yLCBjb2xvckEuZywgY29sb3JBLmIsIGNvbG9yQS5hLCBjb2xvckIuciwgY29sb3JCLmcsIGNvbG9yQi5iLCBjb2xvckIuYSkgLyB0aGlzLl9tYXhEaXN0YW5jZTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0YW5jZUNhbGN1bGF0b3IuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBldWNsaWRlYW4udHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB9IGZyb20gJy4vZGlzdGFuY2VDYWxjdWxhdG9yJztcclxuaW1wb3J0IHsgWSB9IGZyb20gJy4uL2NvbnN0YW50cy9idDcwOSc7XHJcbi8qKlxyXG4gKiBFdWNsaWRlYW4gY29sb3IgZGlzdGFuY2VcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdEV1Y2xpZGVhbiBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcclxuICAgIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcclxuICAgICAgICBjb25zdCBkUiA9IHIyIC0gcjE7XHJcbiAgICAgICAgY29uc3QgZEcgPSBnMiAtIGcxO1xyXG4gICAgICAgIGNvbnN0IGRCID0gYjIgLSBiMTtcclxuICAgICAgICBjb25zdCBkQSA9IGEyIC0gYTE7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLl9rUiAqIGRSICogZFIgKyB0aGlzLl9rRyAqIGRHICogZEcgKyB0aGlzLl9rQiAqIGRCICogZEIgKyB0aGlzLl9rQSAqIGRBICogZEEpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBFdWNsaWRlYW4gZXh0ZW5kcyBBYnN0cmFjdEV1Y2xpZGVhbiB7XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgdGhpcy5fa1IgPSAxO1xyXG4gICAgICAgIHRoaXMuX2tHID0gMTtcclxuICAgICAgICB0aGlzLl9rQiA9IDE7XHJcbiAgICAgICAgdGhpcy5fa0EgPSAxO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdWNsaWRlYW4gY29sb3IgZGlzdGFuY2UgKFJHQlF1YW50IG1vZGlmaWNhdGlvbiB3IEFscGhhKVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV1Y2xpZGVhbkJUNzA5IGV4dGVuZHMgQWJzdHJhY3RFdWNsaWRlYW4ge1xyXG4gICAgX3NldERlZmF1bHRzKCkge1xyXG4gICAgICAgIHRoaXMuX2tSID0gWS5SRUQ7XHJcbiAgICAgICAgdGhpcy5fa0cgPSBZLkdSRUVOO1xyXG4gICAgICAgIHRoaXMuX2tCID0gWS5CTFVFO1xyXG4gICAgICAgIC8vIFRPRE86IHdoYXQgaXMgdGhlIGJlc3QgY29lZmZpY2llbnQgYmVsb3c/XHJcbiAgICAgICAgdGhpcy5fa0EgPSAxO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdWNsaWRlYW4gY29sb3IgZGlzdGFuY2UgKFJHQlF1YW50IG1vZGlmaWNhdGlvbiB3L28gQWxwaGEpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXVjbGlkZWFuQlQ3MDlOb0FscGhhIGV4dGVuZHMgQWJzdHJhY3RFdWNsaWRlYW4ge1xyXG4gICAgX3NldERlZmF1bHRzKCkge1xyXG4gICAgICAgIHRoaXMuX2tSID0gWS5SRUQ7XHJcbiAgICAgICAgdGhpcy5fa0cgPSBZLkdSRUVOO1xyXG4gICAgICAgIHRoaXMuX2tCID0gWS5CTFVFO1xyXG4gICAgICAgIHRoaXMuX2tBID0gMDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldWNsaWRlYW4uanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5leHBvcnQgeyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB9IGZyb20gJy4vZGlzdGFuY2VDYWxjdWxhdG9yJztcclxuZXhwb3J0IHsgQ0lFOTRUZXh0aWxlcywgQ0lFOTRHcmFwaGljQXJ0cyB9IGZyb20gJy4vY2llOTQnO1xyXG5leHBvcnQgeyBDSUVERTIwMDAgfSBmcm9tICcuL2NpZWRlMjAwMCc7XHJcbmV4cG9ydCB7IENNZXRyaWMgfSBmcm9tICcuL2NtZXRyaWMnO1xyXG5leHBvcnQgeyBBYnN0cmFjdEV1Y2xpZGVhbiwgRXVjbGlkZWFuLCBFdWNsaWRlYW5CVDcwOU5vQWxwaGEsIEV1Y2xpZGVhbkJUNzA5IH0gZnJvbSAnLi9ldWNsaWRlYW4nO1xyXG5leHBvcnQgeyBBYnN0cmFjdE1hbmhhdHRhbiwgTWFuaGF0dGFuLCBNYW5oYXR0YW5CVDcwOSwgTWFuaGF0dGFuTm9tbXlkZSB9IGZyb20gJy4vbWFuaGF0dGFuJztcclxuZXhwb3J0IHsgUE5HUXVhbnQgfSBmcm9tICcuL3BuZ1F1YW50JztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBtYW5oYXR0YW5OZXVRdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIH0gZnJvbSAnLi9kaXN0YW5jZUNhbGN1bGF0b3InO1xyXG5pbXBvcnQgeyBZIH0gZnJvbSAnLi4vY29uc3RhbnRzL2J0NzA5JztcclxuLyoqXHJcbiAqIE1hbmhhdHRhbiBkaXN0YW5jZSAoTmV1UXVhbnQgbW9kaWZpY2F0aW9uKSAtIHcvbyBzUkdCIGNvZWZmaWNpZW50c1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFic3RyYWN0TWFuaGF0dGFuIGV4dGVuZHMgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3Ige1xyXG4gICAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xyXG4gICAgICAgIGxldCBkUiA9IHIyIC0gcjE7XHJcbiAgICAgICAgbGV0IGRHID0gZzIgLSBnMTtcclxuICAgICAgICBsZXQgZEIgPSBiMiAtIGIxO1xyXG4gICAgICAgIGxldCBkQSA9IGEyIC0gYTE7XHJcbiAgICAgICAgaWYgKGRSIDwgMClcclxuICAgICAgICAgICAgZFIgPSAwIC0gZFI7XHJcbiAgICAgICAgaWYgKGRHIDwgMClcclxuICAgICAgICAgICAgZEcgPSAwIC0gZEc7XHJcbiAgICAgICAgaWYgKGRCIDwgMClcclxuICAgICAgICAgICAgZEIgPSAwIC0gZEI7XHJcbiAgICAgICAgaWYgKGRBIDwgMClcclxuICAgICAgICAgICAgZEEgPSAwIC0gZEE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tSICogZFIgKyB0aGlzLl9rRyAqIGRHICsgdGhpcy5fa0IgKiBkQiArIHRoaXMuX2tBICogZEE7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIE1hbmhhdHRhbiBleHRlbmRzIEFic3RyYWN0TWFuaGF0dGFuIHtcclxuICAgIF9zZXREZWZhdWx0cygpIHtcclxuICAgICAgICB0aGlzLl9rUiA9IDE7XHJcbiAgICAgICAgdGhpcy5fa0cgPSAxO1xyXG4gICAgICAgIHRoaXMuX2tCID0gMTtcclxuICAgICAgICB0aGlzLl9rQSA9IDE7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hbmhhdHRhbiBkaXN0YW5jZSAoTm9tbXlkZSBtb2RpZmljYXRpb24pXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9pZ29yLWJlemtyb3ZueS9pbWFnZS1xdWFudGl6YXRpb24vaXNzdWVzLzQjaXNzdWVjb21tZW50LTIzNTE1NTMyMFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1hbmhhdHRhbk5vbW15ZGUgZXh0ZW5kcyBBYnN0cmFjdE1hbmhhdHRhbiB7XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgdGhpcy5fa1IgPSAwLjQ5ODQ7XHJcbiAgICAgICAgdGhpcy5fa0cgPSAwLjg2MjU7XHJcbiAgICAgICAgdGhpcy5fa0IgPSAwLjI5Nzk7XHJcbiAgICAgICAgLy8gVE9ETzogd2hhdCBpcyB0aGUgYmVzdCBjb2VmZmljaWVudCBiZWxvdz9cclxuICAgICAgICB0aGlzLl9rQSA9IDE7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hbmhhdHRhbiBkaXN0YW5jZSAoc1JHQiBjb2VmZmljaWVudHMpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWFuaGF0dGFuQlQ3MDkgZXh0ZW5kcyBBYnN0cmFjdE1hbmhhdHRhbiB7XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgdGhpcy5fa1IgPSBZLlJFRDtcclxuICAgICAgICB0aGlzLl9rRyA9IFkuR1JFRU47XHJcbiAgICAgICAgdGhpcy5fa0IgPSBZLkJMVUU7XHJcbiAgICAgICAgLy8gVE9ETzogd2hhdCBpcyB0aGUgYmVzdCBjb2VmZmljaWVudCBiZWxvdz9cclxuICAgICAgICB0aGlzLl9rQSA9IDE7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFuaGF0dGFuLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogcG5nUXVhbnQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB9IGZyb20gJy4vZGlzdGFuY2VDYWxjdWxhdG9yJztcclxuLyoqXHJcbiAqIFRPRE86IGNoZWNrIHF1YWxpdHkgb2YgdGhpcyBkaXN0YW5jZSBlcXVhdGlvblxyXG4gKiBUT0RPOiBhc2sgYXV0aG9yIGZvciB1c2FnZSByaWdodHNcclxuICogdGFrZW4gZnJvbTpcclxuICoge0BsaW5rIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDc1NDUwNi9jb2xvci1zaW1pbGFyaXR5LWRpc3RhbmNlLWluLXJnYmEtY29sb3Itc3BhY2UvODc5Njg2NyM4Nzk2ODY3fVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bvcm5lbC9wbmdxdWFudC9ibG9iL2NjMzliNDc3OTlhN2ZmMmVmMTdiNTI5Zjk0MTVmZjZlNmIyMTNiOGYvbGliL3BhbS5oI0wxNDh9XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUE5HUXVhbnQgZXh0ZW5kcyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB7XHJcbiAgICAvKipcclxuICAgICAqIEF1dGhvcidzIGNvbW1lbnRzXHJcbiAgICAgKiBweF9iLnJnYiA9IHB4LnJnYiArIDAqKDEtcHguYSkgLy8gYmxlbmQgcHggb24gYmxhY2tcclxuICAgICAqIHB4X2IuYSAgID0gcHguYSAgICsgMSooMS1weC5hKVxyXG4gICAgICogcHhfdy5yZ2IgPSBweC5yZ2IgKyAxKigxLXB4LmEpIC8vIGJsZW5kIHB4IG9uIHdoaXRlXHJcbiAgICAgKiBweF93LmEgICA9IHB4LmEgICArIDEqKDEtcHguYSlcclxuICAgICAqXHJcbiAgICAgKiBweF9iLnJnYiA9IHB4LnJnYiAgICAgICAgICAgICAgLy8gZGlmZmVyZW5jZSBzYW1lIGFzIGluIG9wYXF1ZSBSR0JcclxuICAgICAqIHB4X2IuYSAgID0gMVxyXG4gICAgICogcHhfdy5yZ2IgPSBweC5yZ2IgLSBweC5hICAgICAgIC8vIGRpZmZlcmVuY2Ugc2ltcGxpZmllcyB0byBmb3JtdWxhIGJlbG93XHJcbiAgICAgKiBweF93LmEgICA9IDFcclxuICAgICAqXHJcbiAgICAgKiAocHgucmdiIC0gcHguYSkgLSAocHkucmdiIC0gcHkuYSlcclxuICAgICAqIChweC5yZ2IgLSBweS5yZ2IpICsgKHB5LmEgLSBweC5hKVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xyXG4gICAgICAgIGNvbnN0IGFscGhhcyA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JkaWZmZXJlbmNlQ2gocjEgKiB0aGlzLl93aGl0ZVBvaW50LnIsIHIyICogdGhpcy5fd2hpdGVQb2ludC5yLCBhbHBoYXMpICtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3JkaWZmZXJlbmNlQ2goZzEgKiB0aGlzLl93aGl0ZVBvaW50LmcsIGcyICogdGhpcy5fd2hpdGVQb2ludC5nLCBhbHBoYXMpICtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3JkaWZmZXJlbmNlQ2goYjEgKiB0aGlzLl93aGl0ZVBvaW50LmIsIGIyICogdGhpcy5fd2hpdGVQb2ludC5iLCBhbHBoYXMpO1xyXG4gICAgfVxyXG4gICAgX2NvbG9yZGlmZmVyZW5jZUNoKHgsIHksIGFscGhhcykge1xyXG4gICAgICAgIC8vIG1heGltdW0gb2YgY2hhbm5lbCBibGVuZGVkIG9uIHdoaXRlLCBhbmQgYmxlbmRlZCBvbiBibGFja1xyXG4gICAgICAgIC8vIHByZW11bHRpcGxpZWQgYWxwaGEgYW5kIGJhY2tncm91bmRzIDAvMSBzaG9ydGVuIHRoZSBmb3JtdWxhXHJcbiAgICAgICAgY29uc3QgYmxhY2sgPSB4IC0geTtcclxuICAgICAgICBjb25zdCB3aGl0ZSA9IGJsYWNrICsgYWxwaGFzO1xyXG4gICAgICAgIHJldHVybiBibGFjayAqIGJsYWNrICsgd2hpdGUgKiB3aGl0ZTtcclxuICAgIH1cclxuICAgIF9zZXREZWZhdWx0cygpIHsgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBuZ1F1YW50LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0ICogYXMgY29udmVyc2lvbiBmcm9tICcuL2NvbnZlcnNpb24nO1xyXG5pbXBvcnQgKiBhcyBkaXN0YW5jZSBmcm9tICcuL2Rpc3RhbmNlJztcclxuaW1wb3J0ICogYXMgcGFsZXR0ZSBmcm9tICcuL3BhbGV0dGUnO1xyXG5pbXBvcnQgKiBhcyBpbWFnZSBmcm9tICcuL2ltYWdlJztcclxuaW1wb3J0ICogYXMgcXVhbGl0eSBmcm9tICcuL3F1YWxpdHknO1xyXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcclxuZXhwb3J0IHsgYnVpbGRQYWxldHRlLCBidWlsZFBhbGV0dGVTeW5jLCBhcHBseVBhbGV0dGUsIGFwcGx5UGFsZXR0ZVN5bmMsIH0gZnJvbSAnLi9iYXNpY0FQSSc7XHJcbmV4cG9ydCB7IGNvbnN0YW50cywgY29udmVyc2lvbiwgZGlzdGFuY2UsIHBhbGV0dGUsIGltYWdlLCBxdWFsaXR5LCB1dGlscywgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtcS5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGRpdGhlckVycm9yRGlmZnVzaW9uQXJyYXkudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBBYnN0cmFjdEltYWdlUXVhbnRpemVyIH0gZnJvbSAnLi9pbWFnZVF1YW50aXplcic7XHJcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vdXRpbHMvcG9pbnQnO1xyXG5pbXBvcnQgeyBpblJhbmdlMHRvMjU1Um91bmRlZCB9IGZyb20gJy4uL3V0aWxzL2FyaXRobWV0aWMnO1xyXG5pbXBvcnQgeyBQcm9ncmVzc1RyYWNrZXIgfSBmcm9tICcuLi91dGlscy9wcm9ncmVzc1RyYWNrZXInO1xyXG4vLyBUT0RPOiBpcyBpdCB0aGUgYmVzdCBuYW1lIGZvciB0aGlzIGVudW0gXCJrZXJuZWxcIj9cclxuZXhwb3J0IHZhciBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsO1xyXG4oZnVuY3Rpb24gKEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwpIHtcclxuICAgIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtcIkZsb3lkU3RlaW5iZXJnXCJdID0gMF0gPSBcIkZsb3lkU3RlaW5iZXJnXCI7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJGYWxzZUZsb3lkU3RlaW5iZXJnXCJdID0gMV0gPSBcIkZhbHNlRmxveWRTdGVpbmJlcmdcIjtcclxuICAgIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtcIlN0dWNraVwiXSA9IDJdID0gXCJTdHVja2lcIjtcclxuICAgIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtcIkF0a2luc29uXCJdID0gM10gPSBcIkF0a2luc29uXCI7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJKYXJ2aXNcIl0gPSA0XSA9IFwiSmFydmlzXCI7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJCdXJrZXNcIl0gPSA1XSA9IFwiQnVya2VzXCI7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJTaWVycmFcIl0gPSA2XSA9IFwiU2llcnJhXCI7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJUd29TaWVycmFcIl0gPSA3XSA9IFwiVHdvU2llcnJhXCI7XHJcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXCJTaWVycmFMaXRlXCJdID0gOF0gPSBcIlNpZXJyYUxpdGVcIjtcclxufSkoRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbCB8fCAoRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbCA9IHt9KSk7XHJcbi8vIGh0dHA6Ly93d3cudGFubmVyaGVsbGFuZC5jb20vNDY2MC9kaXRoZXJpbmctZWxldmVuLWFsZ29yaXRobXMtc291cmNlLWNvZGUvXHJcbmV4cG9ydCBjbGFzcyBFcnJvckRpZmZ1c2lvbkFycmF5IGV4dGVuZHMgQWJzdHJhY3RJbWFnZVF1YW50aXplciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwga2VybmVsLCBzZXJwZW50aW5lID0gdHJ1ZSwgbWluaW11bUNvbG9yRGlzdGFuY2VUb0RpdGhlciA9IDAsIGNhbGN1bGF0ZUVycm9yTGlrZUdJTVAgPSBmYWxzZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0S2VybmVsKGtlcm5lbCk7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcclxuICAgICAgICB0aGlzLl9taW5Db2xvckRpc3RhbmNlID0gbWluaW11bUNvbG9yRGlzdGFuY2VUb0RpdGhlcjtcclxuICAgICAgICB0aGlzLl9zZXJwZW50aW5lID0gc2VycGVudGluZTtcclxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVFcnJvckxpa2VHSU1QID0gY2FsY3VsYXRlRXJyb3JMaWtlR0lNUDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogYWRhcHRlZCBmcm9tIGh0dHA6Ly9qc2Jpbi5jb20vaVhvZklqaS8yL2VkaXQgYnkgUEFFelxyXG4gICAgICogZml4ZWQgdmVyc2lvbi4gaXQgZG9lc24ndCB1c2UgaW1hZ2UgcGl4ZWxzIGFzIGVycm9yIHN0b3JhZ2UsIGFsc28gaXQgZG9lc24ndCBoYXZlIDAuMyArIDAuMyArIDAuMyArIDAuMyA9IDAgZXJyb3JcclxuICAgICAqIE11dGF0ZXMgcG9pbnRDb250YWluZXJcclxuICAgICAqL1xyXG4gICAgKnF1YW50aXplKHBvaW50Q29udGFpbmVyLCBwYWxldHRlKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFBvaW50ID0gbmV3IFBvaW50KCk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwb2ludENvbnRhaW5lci5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBvaW50Q29udGFpbmVyLmdldEhlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IGVycm9yTGluZXMgPSBbXTtcclxuICAgICAgICBsZXQgZGlyID0gMTtcclxuICAgICAgICBsZXQgbWF4RXJyb3JMaW5lcyA9IDE7XHJcbiAgICAgICAgLy8gaW5pdGlhbCBlcnJvciBsaW5lcyAobnVtYmVyIGlzIHRha2VuIGZyb20gZGl0aGVyaW5nIGtlcm5lbClcclxuICAgICAgICBmb3IgKGNvbnN0IGtlcm5lbCBvZiB0aGlzLl9rZXJuZWwpIHtcclxuICAgICAgICAgICAgY29uc3Qga2VybmVsRXJyb3JMaW5lcyA9IGtlcm5lbFsyXSArIDE7XHJcbiAgICAgICAgICAgIGlmIChtYXhFcnJvckxpbmVzIDwga2VybmVsRXJyb3JMaW5lcylcclxuICAgICAgICAgICAgICAgIG1heEVycm9yTGluZXMgPSBrZXJuZWxFcnJvckxpbmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEVycm9yTGluZXM7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsRXJyb3JMaW5lKGVycm9yTGluZXNbaV0gPSBbXSwgd2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihoZWlnaHQsIDk5KTtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeSh5KSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHdheXMgc2VycGVudGluZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2VycGVudGluZSlcclxuICAgICAgICAgICAgICAgIGRpciA9IGRpciAqIC0xO1xyXG4gICAgICAgICAgICBjb25zdCBsbmkgPSB5ICogd2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IHhTdGFydCA9IGRpciA9PT0gMSA/IDAgOiB3aWR0aCAtIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IHhFbmQgPSBkaXIgPT09IDEgPyB3aWR0aCA6IC0xO1xyXG4gICAgICAgICAgICAvLyBjeWNsaWMgc2hpZnQgd2l0aCBlcmFzaW5nXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxFcnJvckxpbmUoZXJyb3JMaW5lc1swXSwgd2lkdGgpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB3aHkgaXQgaXMgbmVlZGVkIHRvIGNhc3QgdHlwZXMgaGVyZT9cclxuICAgICAgICAgICAgZXJyb3JMaW5lcy5wdXNoKGVycm9yTGluZXMuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTGluZSA9IGVycm9yTGluZXNbMF07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB4U3RhcnQsIGlkeCA9IGxuaSArIHhTdGFydDsgeCAhPT0geEVuZDsgeCArPSBkaXIsIGlkeCArPSBkaXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEltYWdlIHBpeGVsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50QXJyYXlbaWR4XTtcclxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsUG9pbnQgPSBuZXcgVXRpbHMuUG9pbnQoKSxcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JMaW5lW3hdO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQb2ludC5mcm9tKHBvaW50KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZFBvaW50ID0gUG9pbnQuY3JlYXRlQnlSR0JBKGluUmFuZ2UwdG8yNTVSb3VuZGVkKHBvaW50LnIgKyBlcnJvclswXSksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKHBvaW50LmcgKyBlcnJvclsxXSksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKHBvaW50LmIgKyBlcnJvclsyXSksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKHBvaW50LmEgKyBlcnJvclszXSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVkdWNlZCBwaXhlbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFsZXR0ZVBvaW50ID0gcGFsZXR0ZS5nZXROZWFyZXN0Q29sb3IodGhpcy5fZGlzdGFuY2UsIGNvcnJlY3RlZFBvaW50KTtcclxuICAgICAgICAgICAgICAgIHBvaW50LmZyb20ocGFsZXR0ZVBvaW50KTtcclxuICAgICAgICAgICAgICAgIC8vIGRpdGhlcmluZyBzdHJlbmd0aFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21pbkNvbG9yRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlTm9ybWFsaXplZChwb2ludCwgcGFsZXR0ZVBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IHRoaXMuX21pbkNvbG9yRGlzdGFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcG9uZW50IGRpc3RhbmNlXHJcbiAgICAgICAgICAgICAgICBsZXQgZXI7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWc7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWI7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FsY3VsYXRlRXJyb3JMaWtlR0lNUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyID0gY29ycmVjdGVkUG9pbnQuciAtIHBhbGV0dGVQb2ludC5yO1xyXG4gICAgICAgICAgICAgICAgICAgIGVnID0gY29ycmVjdGVkUG9pbnQuZyAtIHBhbGV0dGVQb2ludC5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGViID0gY29ycmVjdGVkUG9pbnQuYiAtIHBhbGV0dGVQb2ludC5iO1xyXG4gICAgICAgICAgICAgICAgICAgIGVhID0gY29ycmVjdGVkUG9pbnQuYSAtIHBhbGV0dGVQb2ludC5hO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXIgPSBvcmlnaW5hbFBvaW50LnIgLSBwYWxldHRlUG9pbnQucjtcclxuICAgICAgICAgICAgICAgICAgICBlZyA9IG9yaWdpbmFsUG9pbnQuZyAtIHBhbGV0dGVQb2ludC5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGViID0gb3JpZ2luYWxQb2ludC5iIC0gcGFsZXR0ZVBvaW50LmI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWEgPSBvcmlnaW5hbFBvaW50LmEgLSBwYWxldHRlUG9pbnQuYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRTdGFydCA9IGRpciA9PT0gMSA/IDAgOiB0aGlzLl9rZXJuZWwubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRFbmQgPSBkaXIgPT09IDEgPyB0aGlzLl9rZXJuZWwubGVuZ3RoIDogLTE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZFN0YXJ0OyBpICE9PSBkRW5kOyBpICs9IGRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gdGhpcy5fa2VybmVsW2ldWzFdICogZGlyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gdGhpcy5fa2VybmVsW2ldWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4MSArIHggPj0gMCAmJiB4MSArIHggPCB3aWR0aCAmJiB5MSArIHkgPj0gMCAmJiB5MSArIHkgPCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuX2tlcm5lbFtpXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGVycm9yTGluZXNbeTFdW3gxICsgeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbMF0gPSBlWzBdICsgZXIgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlWzFdID0gZVsxXSArIGVnICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVsyXSA9IGVbMl0gKyBlYiAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbM10gPSBlWzNdICsgZWEgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgIHBvaW50Q29udGFpbmVyLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogMTAwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfZmlsbEVycm9yTGluZShlcnJvckxpbmUsIHdpZHRoKSB7XHJcbiAgICAgICAgLy8gc2hyaW5rXHJcbiAgICAgICAgaWYgKGVycm9yTGluZS5sZW5ndGggPiB3aWR0aCkge1xyXG4gICAgICAgICAgICBlcnJvckxpbmUubGVuZ3RoID0gd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldXNlIGV4aXN0aW5nIGFycmF5c1xyXG4gICAgICAgIGNvbnN0IGwgPSBlcnJvckxpbmUubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JMaW5lW2ldO1xyXG4gICAgICAgICAgICBlcnJvclswXSA9IGVycm9yWzFdID0gZXJyb3JbMl0gPSBlcnJvclszXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBtaXNzaW5nIGFycmF5c1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBsOyBpIDwgd2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgICBlcnJvckxpbmVbaV0gPSBbMC4wLCAwLjAsIDAuMCwgMC4wXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0S2VybmVsKGtlcm5lbCkge1xyXG4gICAgICAgIHN3aXRjaCAoa2VybmVsKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5GbG95ZFN0ZWluYmVyZzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbNyAvIDE2LCAxLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDE2LCAtMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzUgLyAxNiwgMCwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyAxNiwgMSwgMV0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5GYWxzZUZsb3lkU3RlaW5iZXJnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2VybmVsID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFszIC8gOCwgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzMgLyA4LCAwLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDgsIDEsIDFdLFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuU3R1Y2tpOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2VybmVsID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFs4IC8gNDIsIDEsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gNDIsIDIsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gNDIsIC0yLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbNCAvIDQyLCAtMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzggLyA0MiwgMCwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzQgLyA0MiwgMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyA0MiwgMiwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA0MiwgLTIsIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gNDIsIC0xLCAyXSxcclxuICAgICAgICAgICAgICAgICAgICBbNCAvIDQyLCAwLCAyXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDQyLCAxLCAyXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDQyLCAyLCAyXSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLkF0a2luc29uOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2VybmVsID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gOCwgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA4LCAyLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDgsIC0xLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDgsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gOCwgMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA4LCAwLCAyXSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLkphcnZpczpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbNyAvIDQ4LCAxLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbNSAvIDQ4LCAyLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDQ4LCAtMiwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzUgLyA0OCwgLTEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs3IC8gNDgsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs1IC8gNDgsIDEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFszIC8gNDgsIDIsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gNDgsIC0yLCAyXSxcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDQ4LCAtMSwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzUgLyA0OCwgMCwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzMgLyA0OCwgMSwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA0OCwgMiwgMl0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbC5CdXJrZXM6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgWzggLyAzMiwgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzQgLyAzMiwgMiwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAzMiwgLTIsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gMzIsIC0xLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbOCAvIDMyLCAwLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbNCAvIDMyLCAxLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDMyLCAyLCAxXSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlNpZXJyYTpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbNSAvIDMyLCAxLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDMyLCAyLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDMyLCAtMiwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzQgLyAzMiwgLTEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs1IC8gMzIsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gMzIsIDEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gMzIsIDIsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gMzIsIC0xLCAyXSxcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDMyLCAwLCAyXSxcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDMyLCAxLCAyXSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlR3b1NpZXJyYTpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbNCAvIDE2LCAxLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMyAvIDE2LCAyLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSAvIDE2LCAtMiwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAxNiwgLTEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFszIC8gMTYsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gMTYsIDEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gMTYsIDIsIDFdLFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuU2llcnJhTGl0ZTpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbMiAvIDQsIDEsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gNCwgLTEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gNCwgMCwgMV0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yRGlmZnVzaW9uQXJyYXk6IHVua25vd24ga2VybmVsID0gJyArIGtlcm5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCIsImV4cG9ydCBjbGFzcyBBYnN0cmFjdEltYWdlUXVhbnRpemVyIHtcclxuICAgIHF1YW50aXplU3luYyhwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5xdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnBvaW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUucG9pbnRDb250YWluZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlUXVhbnRpemVyLmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuZXhwb3J0IHsgQWJzdHJhY3RJbWFnZVF1YW50aXplciB9IGZyb20gJy4vaW1hZ2VRdWFudGl6ZXInO1xyXG5leHBvcnQgeyBOZWFyZXN0Q29sb3IgfSBmcm9tICcuL25lYXJlc3RDb2xvcic7XHJcbmV4cG9ydCB7IEVycm9yRGlmZnVzaW9uQXJyYXksIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwgfSBmcm9tICcuL2FycmF5JztcclxuZXhwb3J0IHsgRXJyb3JEaWZmdXNpb25SaWVtZXJzbWEgfSBmcm9tICcuL3JpZW1lcnNtYSc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogbmVhcmVzdENvbG9yLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgQWJzdHJhY3RJbWFnZVF1YW50aXplciB9IGZyb20gJy4vaW1hZ2VRdWFudGl6ZXInO1xyXG5pbXBvcnQgeyBQcm9ncmVzc1RyYWNrZXIgfSBmcm9tICcuLi91dGlscy9wcm9ncmVzc1RyYWNrZXInO1xyXG5leHBvcnQgY2xhc3MgTmVhcmVzdENvbG9yIGV4dGVuZHMgQWJzdHJhY3RJbWFnZVF1YW50aXplciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTXV0YXRlcyBwb2ludENvbnRhaW5lclxyXG4gICAgICovXHJcbiAgICAqcXVhbnRpemUocG9pbnRDb250YWluZXIsIHBhbGV0dGUpIHtcclxuICAgICAgICBjb25zdCBwb2ludEFycmF5ID0gcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihoZWlnaHQsIDk5KTtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeSh5KSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgaWR4ID0geSAqIHdpZHRoOyB4IDwgd2lkdGg7IHgrKywgaWR4KyspIHtcclxuICAgICAgICAgICAgICAgIC8vIEltYWdlIHBpeGVsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50QXJyYXlbaWR4XTtcclxuICAgICAgICAgICAgICAgIC8vIFJlZHVjZWQgcGl4ZWxcclxuICAgICAgICAgICAgICAgIHBvaW50LmZyb20ocGFsZXR0ZS5nZXROZWFyZXN0Q29sb3IodGhpcy5fZGlzdGFuY2UsIHBvaW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICBwb2ludENvbnRhaW5lcixcclxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5lYXJlc3RDb2xvci5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIE1JVCBMaWNlbnNlXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cclxuICogZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcclxuICogcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXHJcbiAqIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTFxyXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXHJcbiAqIElOIFRIRSBTT0ZUV0FSRS5cclxuICpcclxuICogcmllbWVyc21hLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgQWJzdHJhY3RJbWFnZVF1YW50aXplciB9IGZyb20gJy4vaW1hZ2VRdWFudGl6ZXInO1xyXG5pbXBvcnQgeyBoaWxiZXJ0Q3VydmUgfSBmcm9tICcuL3NwYWNlRmlsbGluZ0N1cnZlcy9oaWxiZXJ0Q3VydmUnO1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL3V0aWxzL3BvaW50JztcclxuaW1wb3J0IHsgaW5SYW5nZTB0bzI1NVJvdW5kZWQgfSBmcm9tICcuLi91dGlscy9hcml0aG1ldGljJztcclxuZXhwb3J0IGNsYXNzIEVycm9yRGlmZnVzaW9uUmllbWVyc21hIGV4dGVuZHMgQWJzdHJhY3RJbWFnZVF1YW50aXplciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgZXJyb3JRdWV1ZVNpemUgPSAxNiwgZXJyb3JQcm9wYWdhdGlvbiA9IDEpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XHJcbiAgICAgICAgdGhpcy5fZXJyb3JRdWV1ZVNpemUgPSBlcnJvclF1ZXVlU2l6ZTtcclxuICAgICAgICB0aGlzLl93ZWlnaHRzID0gRXJyb3JEaWZmdXNpb25SaWVtZXJzbWEuX2NyZWF0ZVdlaWdodHMoZXJyb3JQcm9wYWdhdGlvbiwgZXJyb3JRdWV1ZVNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNdXRhdGVzIHBvaW50Q29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgICpxdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50QXJyYXkgPSBwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwb2ludENvbnRhaW5lci5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBvaW50Q29udGFpbmVyLmdldEhlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IGVycm9yUXVldWUgPSBbXTtcclxuICAgICAgICBsZXQgaGVhZCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9lcnJvclF1ZXVlU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVycm9yUXVldWVbaV0gPSB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQqIGhpbGJlcnRDdXJ2ZSh3aWR0aCwgaGVpZ2h0LCAoeCwgeSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwID0gcG9pbnRBcnJheVt4ICsgeSAqIHdpZHRoXTtcclxuICAgICAgICAgICAgbGV0IHIgPSBwLnI7XHJcbiAgICAgICAgICAgIGxldCBnID0gcC5nO1xyXG4gICAgICAgICAgICBsZXQgYiA9IHAuYjtcclxuICAgICAgICAgICAgbGV0IGEgPSBwLmE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JRdWV1ZVNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gdGhpcy5fd2VpZ2h0c1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBlcnJvclF1ZXVlWyhpICsgaGVhZCkgJSB0aGlzLl9lcnJvclF1ZXVlU2l6ZV07XHJcbiAgICAgICAgICAgICAgICByICs9IGUuciAqIHdlaWdodDtcclxuICAgICAgICAgICAgICAgIGcgKz0gZS5nICogd2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgYiArPSBlLmIgKiB3ZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBhICs9IGUuYSAqIHdlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb2ludCA9IFBvaW50LmNyZWF0ZUJ5UkdCQShpblJhbmdlMHRvMjU1Um91bmRlZChyKSwgaW5SYW5nZTB0bzI1NVJvdW5kZWQoZyksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKGIpLCBpblJhbmdlMHRvMjU1Um91bmRlZChhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXplZFBvaW50ID0gcGFsZXR0ZS5nZXROZWFyZXN0Q29sb3IodGhpcy5fZGlzdGFuY2UsIGNvcnJlY3RlZFBvaW50KTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGhlYWQgYW5kIGNhbGN1bGF0ZSB0YWlsXHJcbiAgICAgICAgICAgIGhlYWQgPSAoaGVhZCArIDEpICUgdGhpcy5fZXJyb3JRdWV1ZVNpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSAoaGVhZCArIHRoaXMuX2Vycm9yUXVldWVTaXplIC0gMSkgJSB0aGlzLl9lcnJvclF1ZXVlU2l6ZTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGVycm9yIHdpdGggbmV3IHZhbHVlXHJcbiAgICAgICAgICAgIGVycm9yUXVldWVbdGFpbF0uciA9IHAuciAtIHF1YW50aXplZFBvaW50LnI7XHJcbiAgICAgICAgICAgIGVycm9yUXVldWVbdGFpbF0uZyA9IHAuZyAtIHF1YW50aXplZFBvaW50Lmc7XHJcbiAgICAgICAgICAgIGVycm9yUXVldWVbdGFpbF0uYiA9IHAuYiAtIHF1YW50aXplZFBvaW50LmI7XHJcbiAgICAgICAgICAgIGVycm9yUXVldWVbdGFpbF0uYSA9IHAuYSAtIHF1YW50aXplZFBvaW50LmE7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb2ludFxyXG4gICAgICAgICAgICBwLmZyb20ocXVhbnRpemVkUG9pbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgcG9pbnRDb250YWluZXIsXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfY3JlYXRlV2VpZ2h0cyhlcnJvclByb3BhZ2F0aW9uLCBlcnJvclF1ZXVlU2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSBbXTtcclxuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gTWF0aC5leHAoTWF0aC5sb2coZXJyb3JRdWV1ZVNpemUpIC8gKGVycm9yUXVldWVTaXplIC0gMSkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuZXh0ID0gMTsgaSA8IGVycm9yUXVldWVTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgd2VpZ2h0c1tpXSA9ICgoKG5leHQgKyAwLjUpIHwgMCkgLyBlcnJvclF1ZXVlU2l6ZSkgKiBlcnJvclByb3BhZ2F0aW9uO1xyXG4gICAgICAgICAgICBuZXh0ICo9IG11bHRpcGxpZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3ZWlnaHRzO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpZW1lcnNtYS5qcy5tYXAiLCJpbXBvcnQgeyBQcm9ncmVzc1RyYWNrZXIgfSBmcm9tICcuLi8uLi91dGlscy9wcm9ncmVzc1RyYWNrZXInO1xyXG52YXIgRGlyZWN0aW9uO1xyXG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xyXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xyXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlVQXCJdID0gMV0gPSBcIlVQXCI7XHJcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTEVGVFwiXSA9IDJdID0gXCJMRUZUXCI7XHJcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUklHSFRcIl0gPSAzXSA9IFwiUklHSFRcIjtcclxuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJET1dOXCJdID0gNF0gPSBcIkRPV05cIjtcclxufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xyXG5leHBvcnQgZnVuY3Rpb24qIGhpbGJlcnRDdXJ2ZSh3aWR0aCwgaGVpZ2h0LCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgbWF4Qm91bmQgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIGNvbnN0IGxldmVsID0gTWF0aC5mbG9vcihNYXRoLmxvZyhtYXhCb3VuZCkgLyBNYXRoLmxvZygyKSArIDEpO1xyXG4gICAgY29uc3QgdHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIod2lkdGggKiBoZWlnaHQsIDk5KTtcclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgIGxldmVsLFxyXG4gICAgICAgIGNhbGxiYWNrLFxyXG4gICAgICAgIHRyYWNrZXIsXHJcbiAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgfTtcclxuICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uVVApO1xyXG4gICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLk5PTkUpO1xyXG59XHJcbmZ1bmN0aW9uKiB3YWxrSGlsYmVydChkYXRhLCBkaXJlY3Rpb24pIHtcclxuICAgIGlmIChkYXRhLmxldmVsIDwgMSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICBpZiAoZGF0YS50cmFja2VyLnNob3VsZE5vdGlmeShkYXRhLmluZGV4KSlcclxuICAgICAgICB5aWVsZCB7IHByb2dyZXNzOiBkYXRhLnRyYWNrZXIucHJvZ3Jlc3MgfTtcclxuICAgIGRhdGEubGV2ZWwtLTtcclxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBEaXJlY3Rpb24uTEVGVDpcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5VUCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uTEVGVCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5ET1dOKTtcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5MRUZUKTtcclxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLkxFRlQpO1xyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLkRPV04pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIERpcmVjdGlvbi5SSUdIVDpcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5ET1dOKTtcclxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLkxFRlQpO1xyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLlJJR0hUKTtcclxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLlVQKTtcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uVVApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIERpcmVjdGlvbi5VUDpcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5MRUZUKTtcclxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLkRPV04pO1xyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLlVQKTtcclxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLlJJR0hUKTtcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5VUCk7XHJcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5VUCk7XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uUklHSFQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIERpcmVjdGlvbi5ET1dOOlxyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLlJJR0hUKTtcclxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLlVQKTtcclxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5ET1dOKTtcclxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLkxFRlQpO1xyXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLkRPV04pO1xyXG4gICAgICAgICAgICB2aXNpdChkYXRhLCBEaXJlY3Rpb24uRE9XTik7XHJcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uTEVGVCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgZGF0YS5sZXZlbCsrO1xyXG59XHJcbmZ1bmN0aW9uIHZpc2l0KGRhdGEsIGRpcmVjdGlvbikge1xyXG4gICAgaWYgKGRhdGEueCA+PSAwICYmIGRhdGEueCA8IGRhdGEud2lkdGggJiYgZGF0YS55ID49IDAgJiYgZGF0YS55IDwgZGF0YS5oZWlnaHQpIHtcclxuICAgICAgICBkYXRhLmNhbGxiYWNrKGRhdGEueCwgZGF0YS55KTtcclxuICAgICAgICBkYXRhLmluZGV4Kys7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLkxFRlQ6XHJcbiAgICAgICAgICAgIGRhdGEueC0tO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIERpcmVjdGlvbi5SSUdIVDpcclxuICAgICAgICAgICAgZGF0YS54Kys7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLlVQOlxyXG4gICAgICAgICAgICBkYXRhLnktLTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBEaXJlY3Rpb24uRE9XTjpcclxuICAgICAgICAgICAgZGF0YS55Kys7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpbGJlcnRDdXJ2ZS5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGlxLnRzIC0gSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmV4cG9ydCB7IEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB9IGZyb20gJy4vcGFsZXR0ZVF1YW50aXplcic7XHJcbmV4cG9ydCB7IE5ldVF1YW50IH0gZnJvbSAnLi9uZXVxdWFudC9uZXVxdWFudCc7XHJcbmV4cG9ydCB7IE5ldVF1YW50RmxvYXQgfSBmcm9tICcuL25ldXF1YW50L25ldXF1YW50RmxvYXQnO1xyXG5leHBvcnQgeyBSR0JRdWFudCB9IGZyb20gJy4vcmdicXVhbnQvcmdicXVhbnQnO1xyXG5leHBvcnQgeyBDb2xvckhpc3RvZ3JhbSB9IGZyb20gJy4vcmdicXVhbnQvY29sb3JIaXN0b2dyYW0nO1xyXG5leHBvcnQgeyBXdVF1YW50LCBXdUNvbG9yQ3ViZSB9IGZyb20gJy4vd3Uvd3VRdWFudCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qXHJcbiAqIE5ldVF1YW50IE5ldXJhbC1OZXQgUXVhbnRpemF0aW9uIEFsZ29yaXRobVxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAxOTk0IEFudGhvbnkgRGVra2VyXHJcbiAqXHJcbiAqIE5FVVFVQU5UIE5ldXJhbC1OZXQgcXVhbnRpemF0aW9uIGFsZ29yaXRobSBieSBBbnRob255IERla2tlciwgMTk5NC4gU2VlXHJcbiAqIFwiS29ob25lbiBuZXVyYWwgbmV0d29ya3MgZm9yIG9wdGltYWwgY29sb3VyIHF1YW50aXphdGlvblwiIGluIFwiTmV0d29yazpcclxuICogQ29tcHV0YXRpb24gaW4gTmV1cmFsIFN5c3RlbXNcIiBWb2wuIDUgKDE5OTQpIHBwIDM1MS0zNjcuIGZvciBhIGRpc2N1c3Npb24gb2ZcclxuICogdGhlIGFsZ29yaXRobS5cclxuICpcclxuICogQW55IHBhcnR5IG9idGFpbmluZyBhIGNvcHkgb2YgdGhlc2UgZmlsZXMgZnJvbSB0aGUgYXV0aG9yLCBkaXJlY3RseSBvclxyXG4gKiBpbmRpcmVjdGx5LCBpcyBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgYSBmdWxsIGFuZCB1bnJlc3RyaWN0ZWQgaXJyZXZvY2FibGUsXHJcbiAqIHdvcmxkLXdpZGUsIHBhaWQgdXAsIHJveWFsdHktZnJlZSwgbm9uZXhjbHVzaXZlIHJpZ2h0IGFuZCBsaWNlbnNlIHRvIGRlYWwgaW5cclxuICogdGhpcyBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIGluY2x1ZGluZyB3aXRob3V0XHJcbiAqIGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXHJcbiAqIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB3aG9cclxuICogcmVjZWl2ZSBjb3BpZXMgZnJvbSBhbnkgc3VjaCBwYXJ0eSB0byBkbyBzbywgd2l0aCB0aGUgb25seSByZXF1aXJlbWVudCBiZWluZ1xyXG4gKiB0aGF0IHRoaXMgY29weXJpZ2h0IG5vdGljZSByZW1haW4gaW50YWN0LlxyXG4gKi9cclxuLyoqXHJcbiAqIEBwcmVzZXJ2ZSBUeXBlU2NyaXB0IHBvcnQ6XHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIG5ldXF1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgUGFsZXR0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3BhbGV0dGUnO1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3V0aWxzL3BvaW50JztcclxuaW1wb3J0IHsgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIH0gZnJvbSAnLi4vcGFsZXR0ZVF1YW50aXplcic7XHJcbmltcG9ydCB7IFByb2dyZXNzVHJhY2tlciB9IGZyb20gJy4uLy4uL3V0aWxzJztcclxuLy8gYmlhcyBmb3IgY29sb3VyIHZhbHVlc1xyXG5jb25zdCBuZXR3b3JrQmlhc1NoaWZ0ID0gMztcclxuY2xhc3MgTmV1cm9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IHRoaXMuYSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlcmUgaXMgYSBmaXggaW4gb3JpZ2luYWwgTkVVUVVBTlQgYnkgQW50aG9ueSBEZWtrZXIgKGh0dHA6Ly9tZW1iZXJzLm96ZW1haWwuY29tLmF1L35kZWtrZXIvTkVVUVVBTlQuSFRNTClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByID0gTWF0aC5taW4oMjU1LCAobmV1cm9uLnIgKyAoMSA8PCAobmV0d29ya0JpYXNTaGlmdCAtIDEpKSkgPj4gbmV0d29ya0JpYXNTaGlmdCk7XHJcbiAgICAgKi9cclxuICAgIHRvUG9pbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFBvaW50LmNyZWF0ZUJ5UkdCQSh0aGlzLnIgPj4gbmV0d29ya0JpYXNTaGlmdCwgdGhpcy5nID4+IG5ldHdvcmtCaWFzU2hpZnQsIHRoaXMuYiA+PiBuZXR3b3JrQmlhc1NoaWZ0LCB0aGlzLmEgPj4gbmV0d29ya0JpYXNTaGlmdCk7XHJcbiAgICB9XHJcbiAgICBzdWJ0cmFjdChyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgdGhpcy5yIC09IHIgfCAwO1xyXG4gICAgICAgIHRoaXMuZyAtPSBnIHwgMDtcclxuICAgICAgICB0aGlzLmIgLT0gYiB8IDA7XHJcbiAgICAgICAgdGhpcy5hIC09IGEgfCAwO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBOZXVRdWFudCBleHRlbmRzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzID0gMjU2KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xyXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkgPSBbXTtcclxuICAgICAgICB0aGlzLl9zYW1wbGVGYWN0b3IgPSAxO1xyXG4gICAgICAgIHRoaXMuX25ldHdvcmtTaXplID0gY29sb3JzO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnNldFdoaXRlUG9pbnQoMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0LCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQpO1xyXG4gICAgfVxyXG4gICAgc2FtcGxlKHBvaW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRBcnJheSA9IHRoaXMuX3BvaW50QXJyYXkuY29uY2F0KHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKSk7XHJcbiAgICB9XHJcbiAgICAqcXVhbnRpemUoKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdCgpO1xyXG4gICAgICAgIHlpZWxkKiB0aGlzLl9sZWFybigpO1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgcGFsZXR0ZTogdGhpcy5fYnVpbGRQYWxldHRlKCksXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9pbml0KCkge1xyXG4gICAgICAgIHRoaXMuX2ZyZXEgPSBbXTtcclxuICAgICAgICB0aGlzLl9iaWFzID0gW107XHJcbiAgICAgICAgdGhpcy5fcmFkUG93ZXIgPSBbXTtcclxuICAgICAgICB0aGlzLl9uZXR3b3JrID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9uZXR3b3JrU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtbaV0gPSBuZXcgTmV1cm9uKChpIDw8IChuZXR3b3JrQmlhc1NoaWZ0ICsgOCkpIC8gdGhpcy5fbmV0d29ya1NpemUgfCAwKTtcclxuICAgICAgICAgICAgLy8gMS90aGlzLl9uZXR3b3JrU2l6ZVxyXG4gICAgICAgICAgICB0aGlzLl9mcmVxW2ldID0gTmV1UXVhbnQuX2luaXRpYWxCaWFzIC8gdGhpcy5fbmV0d29ya1NpemUgfCAwO1xyXG4gICAgICAgICAgICB0aGlzLl9iaWFzW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1haW4gTGVhcm5pbmcgTG9vcFxyXG4gICAgICovXHJcbiAgICAqX2xlYXJuKCkge1xyXG4gICAgICAgIGxldCBzYW1wbGVGYWN0b3IgPSB0aGlzLl9zYW1wbGVGYWN0b3I7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzTnVtYmVyID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHBvaW50c051bWJlciA8IE5ldVF1YW50Ll9taW5waWN0dXJlYnl0ZXMpXHJcbiAgICAgICAgICAgIHNhbXBsZUZhY3RvciA9IDE7XHJcbiAgICAgICAgY29uc3QgYWxwaGFkZWMgPSAzMCArIChzYW1wbGVGYWN0b3IgLSAxKSAvIDMgfCAwO1xyXG4gICAgICAgIGNvbnN0IHBvaW50c1RvU2FtcGxlID0gcG9pbnRzTnVtYmVyIC8gc2FtcGxlRmFjdG9yIHwgMDtcclxuICAgICAgICBsZXQgZGVsdGEgPSBwb2ludHNUb1NhbXBsZSAvIE5ldVF1YW50Ll9uQ3ljbGVzIHwgMDtcclxuICAgICAgICBsZXQgYWxwaGEgPSBOZXVRdWFudC5faW5pdEFscGhhO1xyXG4gICAgICAgIGxldCByYWRpdXMgPSAodGhpcy5fbmV0d29ya1NpemUgPj4gMykgKiBOZXVRdWFudC5fcmFkaXVzQmlhcztcclxuICAgICAgICBsZXQgcmFkID0gcmFkaXVzID4+IE5ldVF1YW50Ll9yYWRpdXNCaWFzU2hpZnQ7XHJcbiAgICAgICAgaWYgKHJhZCA8PSAxKVxyXG4gICAgICAgICAgICByYWQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFkOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFkUG93ZXJbaV0gPSBhbHBoYSAqICgoKHJhZCAqIHJhZCAtIGkgKiBpKSAqIE5ldVF1YW50Ll9yYWRCaWFzKSAvIChyYWQgKiByYWQpKSA+Pj4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0ZXA7XHJcbiAgICAgICAgaWYgKHBvaW50c051bWJlciA8IE5ldVF1YW50Ll9taW5waWN0dXJlYnl0ZXMpIHtcclxuICAgICAgICAgICAgc3RlcCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBvaW50c051bWJlciAlIE5ldVF1YW50Ll9wcmltZTEgIT09IDApIHtcclxuICAgICAgICAgICAgc3RlcCA9IE5ldVF1YW50Ll9wcmltZTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwb2ludHNOdW1iZXIgJSBOZXVRdWFudC5fcHJpbWUyKSAhPT0gMCkge1xyXG4gICAgICAgICAgICBzdGVwID0gTmV1UXVhbnQuX3ByaW1lMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHBvaW50c051bWJlciAlIE5ldVF1YW50Ll9wcmltZTMpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudC5fcHJpbWUzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RlcCA9IE5ldVF1YW50Ll9wcmltZTQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKHBvaW50c1RvU2FtcGxlLCA5OSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvaW50SW5kZXggPSAwOyBpIDwgcG9pbnRzVG9TYW1wbGU7KSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeShpKSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX3BvaW50QXJyYXlbcG9pbnRJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwb2ludC5iIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGcgPSBwb2ludC5nIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBwb2ludC5yIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC5hIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ldXJvbkluZGV4ID0gdGhpcy5fY29udGVzdChiLCBnLCByLCBhKTtcclxuICAgICAgICAgICAgdGhpcy5fYWx0ZXJTaW5nbGUoYWxwaGEsIG5ldXJvbkluZGV4LCBiLCBnLCByLCBhKTtcclxuICAgICAgICAgICAgaWYgKHJhZCAhPT0gMClcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsdGVyTmVpZ2hib3VyKHJhZCwgbmV1cm9uSW5kZXgsIGIsIGcsIHIsIGEpO1xyXG4gICAgICAgICAgICAvKiBhbHRlciBuZWlnaGJvdXJzICovXHJcbiAgICAgICAgICAgIHBvaW50SW5kZXggKz0gc3RlcDtcclxuICAgICAgICAgICAgaWYgKHBvaW50SW5kZXggPj0gcG9pbnRzTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgcG9pbnRJbmRleCAtPSBwb2ludHNOdW1iZXI7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgaWYgKGRlbHRhID09PSAwKVxyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAxO1xyXG4gICAgICAgICAgICBpZiAoaSAlIGRlbHRhID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYSAtPSAoYWxwaGEgLyBhbHBoYWRlYykgfCAwO1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzIC09IChyYWRpdXMgLyBOZXVRdWFudC5fcmFkaXVzRGVjcmVhc2UpIHwgMDtcclxuICAgICAgICAgICAgICAgIHJhZCA9IHJhZGl1cyA+PiBOZXVRdWFudC5fcmFkaXVzQmlhc1NoaWZ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhZCA8PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHJhZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJhZDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhZFBvd2VyW2pdID0gYWxwaGEgKiAoKChyYWQgKiByYWQgLSBqICogaikgKiBOZXVRdWFudC5fcmFkQmlhcykgLyAocmFkICogcmFkKSkgPj4+IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYnVpbGRQYWxldHRlKCkge1xyXG4gICAgICAgIGNvbnN0IHBhbGV0dGUgPSBuZXcgUGFsZXR0ZSgpO1xyXG4gICAgICAgIHRoaXMuX25ldHdvcmsuZm9yRWFjaChuZXVyb24gPT4ge1xyXG4gICAgICAgICAgICBwYWxldHRlLmFkZChuZXVyb24udG9Qb2ludCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwYWxldHRlLnNvcnQoKTtcclxuICAgICAgICByZXR1cm4gcGFsZXR0ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTW92ZSBhZGphY2VudCBuZXVyb25zIGJ5IHByZWNvbXB1dGVkIGFscGhhKigxLSgoaS1qKV4yL1tyXV4yKSkgaW4gcmFkcG93ZXJbfGktanxdXHJcbiAgICAgKi9cclxuICAgIF9hbHRlck5laWdoYm91cihyYWQsIGksIGIsIGcsIHIsIGFsKSB7XHJcbiAgICAgICAgbGV0IGxvID0gaSAtIHJhZDtcclxuICAgICAgICBpZiAobG8gPCAtMSlcclxuICAgICAgICAgICAgbG8gPSAtMTtcclxuICAgICAgICBsZXQgaGkgPSBpICsgcmFkO1xyXG4gICAgICAgIGlmIChoaSA+IHRoaXMuX25ldHdvcmtTaXplKVxyXG4gICAgICAgICAgICBoaSA9IHRoaXMuX25ldHdvcmtTaXplO1xyXG4gICAgICAgIGxldCBqID0gaSArIDE7XHJcbiAgICAgICAgbGV0IGsgPSBpIC0gMTtcclxuICAgICAgICBsZXQgbSA9IDE7XHJcbiAgICAgICAgd2hpbGUgKGogPCBoaSB8fCBrID4gbG8pIHtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuX3JhZFBvd2VyW20rK10gLyBOZXVRdWFudC5fYWxwaGFSYWRCaWFzO1xyXG4gICAgICAgICAgICBpZiAoaiA8IGhpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbmV0d29ya1tqKytdO1xyXG4gICAgICAgICAgICAgICAgcC5zdWJ0cmFjdChhICogKHAuciAtIHIpLCBhICogKHAuZyAtIGcpLCBhICogKHAuYiAtIGIpLCBhICogKHAuYSAtIGFsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGsgPiBsbykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuX25ldHdvcmtbay0tXTtcclxuICAgICAgICAgICAgICAgIHAuc3VidHJhY3QoYSAqIChwLnIgLSByKSwgYSAqIChwLmcgLSBnKSwgYSAqIChwLmIgLSBiKSwgYSAqIChwLmEgLSBhbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIG5ldXJvbiBpIHRvd2FyZHMgYmlhc2VkIChiLGcscikgYnkgZmFjdG9yIGFscGhhXHJcbiAgICAgKi9cclxuICAgIF9hbHRlclNpbmdsZShhbHBoYSwgaSwgYiwgZywgciwgYSkge1xyXG4gICAgICAgIGFscGhhIC89IE5ldVF1YW50Ll9pbml0QWxwaGE7XHJcbiAgICAgICAgLyogYWx0ZXIgaGl0IG5ldXJvbiAqL1xyXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9uZXR3b3JrW2ldO1xyXG4gICAgICAgIG4uc3VidHJhY3QoYWxwaGEgKiAobi5yIC0gciksIGFscGhhICogKG4uZyAtIGcpLCBhbHBoYSAqIChuLmIgLSBiKSwgYWxwaGEgKiAobi5hIC0gYSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2ggZm9yIGJpYXNlZCBCR1IgdmFsdWVzXHJcbiAgICAgKiBkZXNjcmlwdGlvbjpcclxuICAgICAqICAgIGZpbmRzIGNsb3Nlc3QgbmV1cm9uIChtaW4gZGlzdCkgYW5kIHVwZGF0ZXMgZnJlcVxyXG4gICAgICogICAgZmluZHMgYmVzdCBuZXVyb24gKG1pbiBkaXN0LWJpYXMpIGFuZCByZXR1cm5zIHBvc2l0aW9uXHJcbiAgICAgKiAgICBmb3IgZnJlcXVlbnRseSBjaG9zZW4gbmV1cm9ucywgZnJlcVtpXSBpcyBoaWdoIGFuZCBiaWFzW2ldIGlzIG5lZ2F0aXZlXHJcbiAgICAgKiAgICBiaWFzW2ldID0gX2dhbW1hKigoMS90aGlzLl9uZXR3b3JrU2l6ZSktZnJlcVtpXSlcclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBkaXN0YW5jZSBlcXVhdGlvbjpcclxuICAgICAqICAgICAgICBkaXN0ID0gYWJzKGRSKSArIGFicyhkRykgKyBhYnMoZEIpXHJcbiAgICAgKi9cclxuICAgIF9jb250ZXN0KGIsIGcsIHIsIGEpIHtcclxuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gKDI1NSAqIDQpIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgbGV0IGJlc3RkID0gfigxIDw8IDMxKTtcclxuICAgICAgICBsZXQgYmVzdGJpYXNkID0gYmVzdGQ7XHJcbiAgICAgICAgbGV0IGJlc3Rwb3MgPSAtMTtcclxuICAgICAgICBsZXQgYmVzdGJpYXNwb3MgPSBiZXN0cG9zO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuID0gdGhpcy5fbmV0d29ya1tpXTtcclxuICAgICAgICAgICAgY29uc3QgZGlzdCA9IHRoaXMuX2Rpc3RhbmNlLmNhbGN1bGF0ZU5vcm1hbGl6ZWQobiwgeyByLCBnLCBiLCBhIH0pICogbXVsdGlwbGllciB8IDA7XHJcbiAgICAgICAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RkID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIGJlc3Rwb3MgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJpYXNkaXN0ID0gZGlzdCAtICgodGhpcy5fYmlhc1tpXSkgPj4gKE5ldVF1YW50Ll9pbml0aWFsQmlhc1NoaWZ0IC0gbmV0d29ya0JpYXNTaGlmdCkpO1xyXG4gICAgICAgICAgICBpZiAoYmlhc2Rpc3QgPCBiZXN0Ymlhc2QpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RiaWFzZCA9IGJpYXNkaXN0O1xyXG4gICAgICAgICAgICAgICAgYmVzdGJpYXNwb3MgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJldGFmcmVxID0gKHRoaXMuX2ZyZXFbaV0gPj4gTmV1UXVhbnQuX2JldGFTaGlmdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZXFbaV0gLT0gYmV0YWZyZXE7XHJcbiAgICAgICAgICAgIHRoaXMuX2JpYXNbaV0gKz0gKGJldGFmcmVxIDw8IE5ldVF1YW50Ll9nYW1tYVNoaWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZnJlcVtiZXN0cG9zXSArPSBOZXVRdWFudC5fYmV0YTtcclxuICAgICAgICB0aGlzLl9iaWFzW2Jlc3Rwb3NdIC09IE5ldVF1YW50Ll9iZXRhR2FtbWE7XHJcbiAgICAgICAgcmV0dXJuIGJlc3RiaWFzcG9zO1xyXG4gICAgfVxyXG59XHJcbi8qXHJcbiBmb3VyIHByaW1lcyBuZWFyIDUwMCAtIGFzc3VtZSBubyBpbWFnZSBoYXMgYSBsZW5ndGggc28gbGFyZ2VcclxuIHRoYXQgaXQgaXMgZGl2aXNpYmxlIGJ5IGFsbCBmb3VyIHByaW1lc1xyXG4gKi9cclxuTmV1UXVhbnQuX3ByaW1lMSA9IDQ5OTtcclxuTmV1UXVhbnQuX3ByaW1lMiA9IDQ5MTtcclxuTmV1UXVhbnQuX3ByaW1lMyA9IDQ4NztcclxuTmV1UXVhbnQuX3ByaW1lNCA9IDUwMztcclxuTmV1UXVhbnQuX21pbnBpY3R1cmVieXRlcyA9IE5ldVF1YW50Ll9wcmltZTQ7XHJcbi8vIG5vLiBvZiBsZWFybmluZyBjeWNsZXNcclxuTmV1UXVhbnQuX25DeWNsZXMgPSAxMDA7XHJcbi8vIGRlZnMgZm9yIGZyZXEgYW5kIGJpYXNcclxuTmV1UXVhbnQuX2luaXRpYWxCaWFzU2hpZnQgPSAxNjtcclxuLy8gYmlhcyBmb3IgZnJhY3Rpb25zXHJcbk5ldVF1YW50Ll9pbml0aWFsQmlhcyA9ICgxIDw8IE5ldVF1YW50Ll9pbml0aWFsQmlhc1NoaWZ0KTtcclxuTmV1UXVhbnQuX2dhbW1hU2hpZnQgPSAxMDtcclxuLy8gZ2FtbWEgPSAxMDI0XHJcbi8vIFRPRE86IHdoeSBnYW1tYSBpcyBuZXZlciB1c2VkP1xyXG4vLyBwcml2YXRlIHN0YXRpYyBfZ2FtbWEgOiBudW1iZXIgICAgID0gKDEgPDwgTmV1UXVhbnQuX2dhbW1hU2hpZnQpO1xyXG5OZXVRdWFudC5fYmV0YVNoaWZ0ID0gMTA7XHJcbk5ldVF1YW50Ll9iZXRhID0gKE5ldVF1YW50Ll9pbml0aWFsQmlhcyA+PiBOZXVRdWFudC5fYmV0YVNoaWZ0KTtcclxuLy8gYmV0YSA9IDEvMTAyNFxyXG5OZXVRdWFudC5fYmV0YUdhbW1hID0gKE5ldVF1YW50Ll9pbml0aWFsQmlhcyA8PCAoTmV1UXVhbnQuX2dhbW1hU2hpZnQgLSBOZXVRdWFudC5fYmV0YVNoaWZ0KSk7XHJcbi8qXHJcbiAqIGZvciAyNTYgY29scywgcmFkaXVzIHN0YXJ0c1xyXG4gKi9cclxuTmV1UXVhbnQuX3JhZGl1c0JpYXNTaGlmdCA9IDY7XHJcbi8vIGF0IDMyLjAgYmlhc2VkIGJ5IDYgYml0c1xyXG5OZXVRdWFudC5fcmFkaXVzQmlhcyA9IDEgPDwgTmV1UXVhbnQuX3JhZGl1c0JpYXNTaGlmdDtcclxuLy8gYW5kIGRlY3JlYXNlcyBieSBhIGZhY3RvciBvZiAxLzMwIGVhY2ggY3ljbGVcclxuTmV1UXVhbnQuX3JhZGl1c0RlY3JlYXNlID0gMzA7XHJcbi8qIGRlZnMgZm9yIGRlY3JlYXNpbmcgYWxwaGEgZmFjdG9yICovXHJcbi8vIGFscGhhIHN0YXJ0cyBhdCAxLjBcclxuTmV1UXVhbnQuX2FscGhhQmlhc1NoaWZ0ID0gMTA7XHJcbi8vIGJpYXNlZCBieSAxMCBiaXRzXHJcbk5ldVF1YW50Ll9pbml0QWxwaGEgPSAoMSA8PCBOZXVRdWFudC5fYWxwaGFCaWFzU2hpZnQpO1xyXG4vKiByYWRCaWFzIGFuZCBhbHBoYVJhZEJpYXMgdXNlZCBmb3IgcmFkcG93ZXIgY2FsY3VsYXRpb24gKi9cclxuTmV1UXVhbnQuX3JhZEJpYXNTaGlmdCA9IDg7XHJcbk5ldVF1YW50Ll9yYWRCaWFzID0gMSA8PCBOZXVRdWFudC5fcmFkQmlhc1NoaWZ0O1xyXG5OZXVRdWFudC5fYWxwaGFSYWRCaWFzU2hpZnQgPSBOZXVRdWFudC5fYWxwaGFCaWFzU2hpZnQgKyBOZXVRdWFudC5fcmFkQmlhc1NoaWZ0O1xyXG5OZXVRdWFudC5fYWxwaGFSYWRCaWFzID0gMSA8PCBOZXVRdWFudC5fYWxwaGFSYWRCaWFzU2hpZnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldXF1YW50LmpzLm1hcCIsIi8qXHJcbiAqIE5ldVF1YW50RmxvYXQgTmV1cmFsLU5ldCBRdWFudGl6YXRpb24gQWxnb3JpdGhtXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDE5OTQgQW50aG9ueSBEZWtrZXJcclxuICpcclxuICogTkVVUVVBTlQgTmV1cmFsLU5ldCBxdWFudGl6YXRpb24gYWxnb3JpdGhtIGJ5IEFudGhvbnkgRGVra2VyLCAxOTk0LiBTZWVcclxuICogXCJLb2hvbmVuIG5ldXJhbCBuZXR3b3JrcyBmb3Igb3B0aW1hbCBjb2xvdXIgcXVhbnRpemF0aW9uXCIgaW4gXCJOZXR3b3JrOlxyXG4gKiBDb21wdXRhdGlvbiBpbiBOZXVyYWwgU3lzdGVtc1wiIFZvbC4gNSAoMTk5NCkgcHAgMzUxLTM2Ny4gZm9yIGEgZGlzY3Vzc2lvbiBvZlxyXG4gKiB0aGUgYWxnb3JpdGhtLlxyXG4gKlxyXG4gKiBBbnkgcGFydHkgb2J0YWluaW5nIGEgY29weSBvZiB0aGVzZSBmaWxlcyBmcm9tIHRoZSBhdXRob3IsIGRpcmVjdGx5IG9yXHJcbiAqIGluZGlyZWN0bHksIGlzIGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCBhIGZ1bGwgYW5kIHVucmVzdHJpY3RlZCBpcnJldm9jYWJsZSxcclxuICogd29ybGQtd2lkZSwgcGFpZCB1cCwgcm95YWx0eS1mcmVlLCBub25leGNsdXNpdmUgcmlnaHQgYW5kIGxpY2Vuc2UgdG8gZGVhbCBpblxyXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgaW5jbHVkaW5nIHdpdGhvdXRcclxuICogbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuICogc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHdob1xyXG4gKiByZWNlaXZlIGNvcGllcyBmcm9tIGFueSBzdWNoIHBhcnR5IHRvIGRvIHNvLCB3aXRoIHRoZSBvbmx5IHJlcXVpcmVtZW50IGJlaW5nXHJcbiAqIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIHJlbWFpbiBpbnRhY3QuXHJcbiAqL1xyXG4vKipcclxuICogQHByZXNlcnZlIFR5cGVTY3JpcHQgcG9ydDpcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogbmV1cXVhbnQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBQYWxldHRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcGFsZXR0ZSc7XHJcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9pbnQnO1xyXG5pbXBvcnQgeyBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXIgfSBmcm9tICcuLi9wYWxldHRlUXVhbnRpemVyJztcclxuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xyXG4vLyBiaWFzIGZvciBjb2xvdXIgdmFsdWVzXHJcbmNvbnN0IG5ldHdvcmtCaWFzU2hpZnQgPSAzO1xyXG5jbGFzcyBOZXVyb25GbG9hdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSB0aGlzLmEgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIGlzIGEgZml4IGluIG9yaWdpbmFsIE5FVVFVQU5UIGJ5IEFudGhvbnkgRGVra2VyIChodHRwOi8vbWVtYmVycy5vemVtYWlsLmNvbS5hdS9+ZGVra2VyL05FVVFVQU5ULkhUTUwpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogciA9IE1hdGgubWluKDI1NSwgKG5ldXJvbi5yICsgKDEgPDwgKG5ldHdvcmtCaWFzU2hpZnQgLSAxKSkpID4+IG5ldHdvcmtCaWFzU2hpZnQpO1xyXG4gICAgICovXHJcbiAgICB0b1BvaW50KCkge1xyXG4gICAgICAgIHJldHVybiBQb2ludC5jcmVhdGVCeVJHQkEodGhpcy5yID4+IG5ldHdvcmtCaWFzU2hpZnQsIHRoaXMuZyA+PiBuZXR3b3JrQmlhc1NoaWZ0LCB0aGlzLmIgPj4gbmV0d29ya0JpYXNTaGlmdCwgdGhpcy5hID4+IG5ldHdvcmtCaWFzU2hpZnQpO1xyXG4gICAgfVxyXG4gICAgc3VidHJhY3QociwgZywgYiwgYSkge1xyXG4gICAgICAgIHRoaXMuciAtPSByO1xyXG4gICAgICAgIHRoaXMuZyAtPSBnO1xyXG4gICAgICAgIHRoaXMuYiAtPSBiO1xyXG4gICAgICAgIHRoaXMuYSAtPSBhO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBOZXVRdWFudEZsb2F0IGV4dGVuZHMgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMgPSAyNTYpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRBcnJheSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3NhbXBsZUZhY3RvciA9IDE7XHJcbiAgICAgICAgdGhpcy5fbmV0d29ya1NpemUgPSBjb2xvcnM7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc2V0V2hpdGVQb2ludCgyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0LCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCk7XHJcbiAgICB9XHJcbiAgICBzYW1wbGUocG9pbnRDb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLl9wb2ludEFycmF5ID0gdGhpcy5fcG9pbnRBcnJheS5jb25jYXQocG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpKTtcclxuICAgIH1cclxuICAgICpxdWFudGl6ZSgpIHtcclxuICAgICAgICB0aGlzLl9pbml0KCk7XHJcbiAgICAgICAgeWllbGQqIHRoaXMuX2xlYXJuKCk7XHJcbiAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICBwYWxldHRlOiB0aGlzLl9idWlsZFBhbGV0dGUoKSxcclxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2luaXQoKSB7XHJcbiAgICAgICAgdGhpcy5fZnJlcSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2JpYXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yYWRQb3dlciA9IFtdO1xyXG4gICAgICAgIHRoaXMuX25ldHdvcmsgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25ldHdvcmtTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fbmV0d29ya1tpXSA9IG5ldyBOZXVyb25GbG9hdCgoaSA8PCAobmV0d29ya0JpYXNTaGlmdCArIDgpKSAvIHRoaXMuX25ldHdvcmtTaXplKTtcclxuICAgICAgICAgICAgLy8gMS90aGlzLl9uZXR3b3JrU2l6ZVxyXG4gICAgICAgICAgICB0aGlzLl9mcmVxW2ldID0gTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXMgLyB0aGlzLl9uZXR3b3JrU2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5fYmlhc1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWluIExlYXJuaW5nIExvb3BcclxuICAgICAqL1xyXG4gICAgKl9sZWFybigpIHtcclxuICAgICAgICBsZXQgc2FtcGxlRmFjdG9yID0gdGhpcy5fc2FtcGxlRmFjdG9yO1xyXG4gICAgICAgIGNvbnN0IHBvaW50c051bWJlciA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGlmIChwb2ludHNOdW1iZXIgPCBOZXVRdWFudEZsb2F0Ll9taW5waWN0dXJlYnl0ZXMpXHJcbiAgICAgICAgICAgIHNhbXBsZUZhY3RvciA9IDE7XHJcbiAgICAgICAgY29uc3QgYWxwaGFkZWMgPSAzMCArIChzYW1wbGVGYWN0b3IgLSAxKSAvIDM7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzVG9TYW1wbGUgPSBwb2ludHNOdW1iZXIgLyBzYW1wbGVGYWN0b3I7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gcG9pbnRzVG9TYW1wbGUgLyBOZXVRdWFudEZsb2F0Ll9uQ3ljbGVzIHwgMDtcclxuICAgICAgICBsZXQgYWxwaGEgPSBOZXVRdWFudEZsb2F0Ll9pbml0QWxwaGE7XHJcbiAgICAgICAgbGV0IHJhZGl1cyA9ICh0aGlzLl9uZXR3b3JrU2l6ZSA+PiAzKSAqIE5ldVF1YW50RmxvYXQuX3JhZGl1c0JpYXM7XHJcbiAgICAgICAgbGV0IHJhZCA9IHJhZGl1cyA+PiBOZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzU2hpZnQ7XHJcbiAgICAgICAgaWYgKHJhZCA8PSAxKVxyXG4gICAgICAgICAgICByYWQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFkOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFkUG93ZXJbaV0gPSBhbHBoYSAqICgoKHJhZCAqIHJhZCAtIGkgKiBpKSAqIE5ldVF1YW50RmxvYXQuX3JhZEJpYXMpIC8gKHJhZCAqIHJhZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3RlcDtcclxuICAgICAgICBpZiAocG9pbnRzTnVtYmVyIDwgTmV1UXVhbnRGbG9hdC5fbWlucGljdHVyZWJ5dGVzKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwb2ludHNOdW1iZXIgJSBOZXVRdWFudEZsb2F0Ll9wcmltZTEgIT09IDApIHtcclxuICAgICAgICAgICAgc3RlcCA9IE5ldVF1YW50RmxvYXQuX3ByaW1lMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHBvaW50c051bWJlciAlIE5ldVF1YW50RmxvYXQuX3ByaW1lMikgIT09IDApIHtcclxuICAgICAgICAgICAgc3RlcCA9IE5ldVF1YW50RmxvYXQuX3ByaW1lMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHBvaW50c051bWJlciAlIE5ldVF1YW50RmxvYXQuX3ByaW1lMykgIT09IDApIHtcclxuICAgICAgICAgICAgc3RlcCA9IE5ldVF1YW50RmxvYXQuX3ByaW1lMztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudEZsb2F0Ll9wcmltZTQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKHBvaW50c1RvU2FtcGxlLCA5OSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvaW50SW5kZXggPSAwOyBpIDwgcG9pbnRzVG9TYW1wbGU7KSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeShpKSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX3BvaW50QXJyYXlbcG9pbnRJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwb2ludC5iIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGcgPSBwb2ludC5nIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBwb2ludC5yIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC5hIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ldXJvbkluZGV4ID0gdGhpcy5fY29udGVzdChiLCBnLCByLCBhKTtcclxuICAgICAgICAgICAgdGhpcy5fYWx0ZXJTaW5nbGUoYWxwaGEsIG5ldXJvbkluZGV4LCBiLCBnLCByLCBhKTtcclxuICAgICAgICAgICAgaWYgKHJhZCAhPT0gMClcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsdGVyTmVpZ2hib3VyKHJhZCwgbmV1cm9uSW5kZXgsIGIsIGcsIHIsIGEpO1xyXG4gICAgICAgICAgICAvKiBhbHRlciBuZWlnaGJvdXJzICovXHJcbiAgICAgICAgICAgIHBvaW50SW5kZXggKz0gc3RlcDtcclxuICAgICAgICAgICAgaWYgKHBvaW50SW5kZXggPj0gcG9pbnRzTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgcG9pbnRJbmRleCAtPSBwb2ludHNOdW1iZXI7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgaWYgKGRlbHRhID09PSAwKVxyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAxO1xyXG4gICAgICAgICAgICBpZiAoaSAlIGRlbHRhID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYSAtPSAoYWxwaGEgLyBhbHBoYWRlYyk7XHJcbiAgICAgICAgICAgICAgICByYWRpdXMgLT0gKHJhZGl1cyAvIE5ldVF1YW50RmxvYXQuX3JhZGl1c0RlY3JlYXNlKTtcclxuICAgICAgICAgICAgICAgIHJhZCA9IHJhZGl1cyA+PiBOZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzU2hpZnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFkIDw9IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmFkID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFkOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmFkUG93ZXJbal0gPSBhbHBoYSAqICgoKHJhZCAqIHJhZCAtIGogKiBqKSAqIE5ldVF1YW50RmxvYXQuX3JhZEJpYXMpIC8gKHJhZCAqIHJhZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2J1aWxkUGFsZXR0ZSgpIHtcclxuICAgICAgICBjb25zdCBwYWxldHRlID0gbmV3IFBhbGV0dGUoKTtcclxuICAgICAgICB0aGlzLl9uZXR3b3JrLmZvckVhY2gobmV1cm9uID0+IHtcclxuICAgICAgICAgICAgcGFsZXR0ZS5hZGQobmV1cm9uLnRvUG9pbnQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGFsZXR0ZS5zb3J0KCk7XHJcbiAgICAgICAgcmV0dXJuIHBhbGV0dGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgYWRqYWNlbnQgbmV1cm9ucyBieSBwcmVjb21wdXRlZCBhbHBoYSooMS0oKGktaileMi9bcl1eMikpIGluIHJhZHBvd2VyW3xpLWp8XVxyXG4gICAgICovXHJcbiAgICBfYWx0ZXJOZWlnaGJvdXIocmFkLCBpLCBiLCBnLCByLCBhbCkge1xyXG4gICAgICAgIGxldCBsbyA9IGkgLSByYWQ7XHJcbiAgICAgICAgaWYgKGxvIDwgLTEpXHJcbiAgICAgICAgICAgIGxvID0gLTE7XHJcbiAgICAgICAgbGV0IGhpID0gaSArIHJhZDtcclxuICAgICAgICBpZiAoaGkgPiB0aGlzLl9uZXR3b3JrU2l6ZSlcclxuICAgICAgICAgICAgaGkgPSB0aGlzLl9uZXR3b3JrU2l6ZTtcclxuICAgICAgICBsZXQgaiA9IGkgKyAxO1xyXG4gICAgICAgIGxldCBrID0gaSAtIDE7XHJcbiAgICAgICAgbGV0IG0gPSAxO1xyXG4gICAgICAgIHdoaWxlIChqIDwgaGkgfHwgayA+IGxvKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLl9yYWRQb3dlclttKytdIC8gTmV1UXVhbnRGbG9hdC5fYWxwaGFSYWRCaWFzO1xyXG4gICAgICAgICAgICBpZiAoaiA8IGhpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbmV0d29ya1tqKytdO1xyXG4gICAgICAgICAgICAgICAgcC5zdWJ0cmFjdChhICogKHAuciAtIHIpLCBhICogKHAuZyAtIGcpLCBhICogKHAuYiAtIGIpLCBhICogKHAuYSAtIGFsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGsgPiBsbykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuX25ldHdvcmtbay0tXTtcclxuICAgICAgICAgICAgICAgIHAuc3VidHJhY3QoYSAqIChwLnIgLSByKSwgYSAqIChwLmcgLSBnKSwgYSAqIChwLmIgLSBiKSwgYSAqIChwLmEgLSBhbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIG5ldXJvbiBpIHRvd2FyZHMgYmlhc2VkIChiLGcscikgYnkgZmFjdG9yIGFscGhhXHJcbiAgICAgKi9cclxuICAgIF9hbHRlclNpbmdsZShhbHBoYSwgaSwgYiwgZywgciwgYSkge1xyXG4gICAgICAgIGFscGhhIC89IE5ldVF1YW50RmxvYXQuX2luaXRBbHBoYTtcclxuICAgICAgICAvKiBhbHRlciBoaXQgbmV1cm9uICovXHJcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XHJcbiAgICAgICAgbi5zdWJ0cmFjdChhbHBoYSAqIChuLnIgLSByKSwgYWxwaGEgKiAobi5nIC0gZyksIGFscGhhICogKG4uYiAtIGIpLCBhbHBoYSAqIChuLmEgLSBhKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaCBmb3IgYmlhc2VkIEJHUiB2YWx1ZXNcclxuICAgICAqIGRlc2NyaXB0aW9uOlxyXG4gICAgICogICAgZmluZHMgY2xvc2VzdCBuZXVyb24gKG1pbiBkaXN0KSBhbmQgdXBkYXRlcyBmcmVxXHJcbiAgICAgKiAgICBmaW5kcyBiZXN0IG5ldXJvbiAobWluIGRpc3QtYmlhcykgYW5kIHJldHVybnMgcG9zaXRpb25cclxuICAgICAqICAgIGZvciBmcmVxdWVudGx5IGNob3NlbiBuZXVyb25zLCBmcmVxW2ldIGlzIGhpZ2ggYW5kIGJpYXNbaV0gaXMgbmVnYXRpdmVcclxuICAgICAqICAgIGJpYXNbaV0gPSBfZ2FtbWEqKCgxL3RoaXMuX25ldHdvcmtTaXplKS1mcmVxW2ldKVxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGRpc3RhbmNlIGVxdWF0aW9uOlxyXG4gICAgICogICAgICAgIGRpc3QgPSBhYnMoZFIpICsgYWJzKGRHKSArIGFicyhkQilcclxuICAgICAqL1xyXG4gICAgX2NvbnRlc3QoYiwgZywgciwgYWwpIHtcclxuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gKDI1NSAqIDQpIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XHJcbiAgICAgICAgbGV0IGJlc3RkID0gfigxIDw8IDMxKTtcclxuICAgICAgICBsZXQgYmVzdGJpYXNkID0gYmVzdGQ7XHJcbiAgICAgICAgbGV0IGJlc3Rwb3MgPSAtMTtcclxuICAgICAgICBsZXQgYmVzdGJpYXNwb3MgPSBiZXN0cG9zO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuID0gdGhpcy5fbmV0d29ya1tpXTtcclxuICAgICAgICAgICAgY29uc3QgZGlzdCA9IHRoaXMuX2Rpc3RhbmNlLmNhbGN1bGF0ZU5vcm1hbGl6ZWQobiwgeyByLCBnLCBiLCBhOiBhbCB9KSAqIG11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RkID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIGJlc3Rwb3MgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJpYXNkaXN0ID0gZGlzdCAtICgodGhpcy5fYmlhc1tpXSkgPj4gKE5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzU2hpZnQgLSBuZXR3b3JrQmlhc1NoaWZ0KSk7XHJcbiAgICAgICAgICAgIGlmIChiaWFzZGlzdCA8IGJlc3RiaWFzZCkge1xyXG4gICAgICAgICAgICAgICAgYmVzdGJpYXNkID0gYmlhc2Rpc3Q7XHJcbiAgICAgICAgICAgICAgICBiZXN0Ymlhc3BvcyA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYmV0YWZyZXEgPSAodGhpcy5fZnJlcVtpXSA+PiBOZXVRdWFudEZsb2F0Ll9iZXRhU2hpZnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmVxW2ldIC09IGJldGFmcmVxO1xyXG4gICAgICAgICAgICB0aGlzLl9iaWFzW2ldICs9IChiZXRhZnJlcSA8PCBOZXVRdWFudEZsb2F0Ll9nYW1tYVNoaWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZnJlcVtiZXN0cG9zXSArPSBOZXVRdWFudEZsb2F0Ll9iZXRhO1xyXG4gICAgICAgIHRoaXMuX2JpYXNbYmVzdHBvc10gLT0gTmV1UXVhbnRGbG9hdC5fYmV0YUdhbW1hO1xyXG4gICAgICAgIHJldHVybiBiZXN0Ymlhc3BvcztcclxuICAgIH1cclxufVxyXG4vKlxyXG4gZm91ciBwcmltZXMgbmVhciA1MDAgLSBhc3N1bWUgbm8gaW1hZ2UgaGFzIGEgbGVuZ3RoIHNvIGxhcmdlXHJcbiB0aGF0IGl0IGlzIGRpdmlzaWJsZSBieSBhbGwgZm91ciBwcmltZXNcclxuICovXHJcbk5ldVF1YW50RmxvYXQuX3ByaW1lMSA9IDQ5OTtcclxuTmV1UXVhbnRGbG9hdC5fcHJpbWUyID0gNDkxO1xyXG5OZXVRdWFudEZsb2F0Ll9wcmltZTMgPSA0ODc7XHJcbk5ldVF1YW50RmxvYXQuX3ByaW1lNCA9IDUwMztcclxuTmV1UXVhbnRGbG9hdC5fbWlucGljdHVyZWJ5dGVzID0gTmV1UXVhbnRGbG9hdC5fcHJpbWU0O1xyXG4vLyBuby4gb2YgbGVhcm5pbmcgY3ljbGVzXHJcbk5ldVF1YW50RmxvYXQuX25DeWNsZXMgPSAxMDA7XHJcbi8vIGRlZnMgZm9yIGZyZXEgYW5kIGJpYXNcclxuTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXNTaGlmdCA9IDE2O1xyXG4vLyBiaWFzIGZvciBmcmFjdGlvbnNcclxuTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXMgPSAoMSA8PCBOZXVRdWFudEZsb2F0Ll9pbml0aWFsQmlhc1NoaWZ0KTtcclxuTmV1UXVhbnRGbG9hdC5fZ2FtbWFTaGlmdCA9IDEwO1xyXG4vLyBnYW1tYSA9IDEwMjRcclxuLy8gVE9ETzogd2h5IGdhbW1hIGlzIG5ldmVyIHVzZWQ/XHJcbi8vIHByaXZhdGUgc3RhdGljIF9nYW1tYSA6IG51bWJlciAgICAgPSAoMSA8PCBOZXVRdWFudEZsb2F0Ll9nYW1tYVNoaWZ0KTtcclxuTmV1UXVhbnRGbG9hdC5fYmV0YVNoaWZ0ID0gMTA7XHJcbk5ldVF1YW50RmxvYXQuX2JldGEgPSAoTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXMgPj4gTmV1UXVhbnRGbG9hdC5fYmV0YVNoaWZ0KTtcclxuLy8gYmV0YSA9IDEvMTAyNFxyXG5OZXVRdWFudEZsb2F0Ll9iZXRhR2FtbWEgPSAoTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXMgPDwgKE5ldVF1YW50RmxvYXQuX2dhbW1hU2hpZnQgLSBOZXVRdWFudEZsb2F0Ll9iZXRhU2hpZnQpKTtcclxuLypcclxuICogZm9yIDI1NiBjb2xzLCByYWRpdXMgc3RhcnRzXHJcbiAqL1xyXG5OZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzU2hpZnQgPSA2O1xyXG4vLyBhdCAzMi4wIGJpYXNlZCBieSA2IGJpdHNcclxuTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhcyA9IDEgPDwgTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhc1NoaWZ0O1xyXG4vLyBhbmQgZGVjcmVhc2VzIGJ5IGEgZmFjdG9yIG9mIDEvMzAgZWFjaCBjeWNsZVxyXG5OZXVRdWFudEZsb2F0Ll9yYWRpdXNEZWNyZWFzZSA9IDMwO1xyXG4vKiBkZWZzIGZvciBkZWNyZWFzaW5nIGFscGhhIGZhY3RvciAqL1xyXG4vLyBhbHBoYSBzdGFydHMgYXQgMS4wXHJcbk5ldVF1YW50RmxvYXQuX2FscGhhQmlhc1NoaWZ0ID0gMTA7XHJcbi8vIGJpYXNlZCBieSAxMCBiaXRzXHJcbk5ldVF1YW50RmxvYXQuX2luaXRBbHBoYSA9ICgxIDw8IE5ldVF1YW50RmxvYXQuX2FscGhhQmlhc1NoaWZ0KTtcclxuLyogcmFkQmlhcyBhbmQgYWxwaGFSYWRCaWFzIHVzZWQgZm9yIHJhZHBvd2VyIGNhbGN1bGF0aW9uICovXHJcbk5ldVF1YW50RmxvYXQuX3JhZEJpYXNTaGlmdCA9IDg7XHJcbk5ldVF1YW50RmxvYXQuX3JhZEJpYXMgPSAxIDw8IE5ldVF1YW50RmxvYXQuX3JhZEJpYXNTaGlmdDtcclxuTmV1UXVhbnRGbG9hdC5fYWxwaGFSYWRCaWFzU2hpZnQgPSBOZXVRdWFudEZsb2F0Ll9hbHBoYUJpYXNTaGlmdCArIE5ldVF1YW50RmxvYXQuX3JhZEJpYXNTaGlmdDtcclxuTmV1UXVhbnRGbG9hdC5fYWxwaGFSYWRCaWFzID0gMSA8PCBOZXVRdWFudEZsb2F0Ll9hbHBoYVJhZEJpYXNTaGlmdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV1cXVhbnRGbG9hdC5qcy5tYXAiLCJleHBvcnQgY2xhc3MgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIHtcclxuICAgIHF1YW50aXplU3luYygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMucXVhbnRpemUoKSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUucGFsZXR0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnBhbGV0dGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbGV0dGVRdWFudGl6ZXIuanMubWFwIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBMZW9uIFNvcm9raW5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogQ29sb3JIaXN0b2dyYW0uanMgLSBhbiBpbWFnZSBxdWFudGl6YXRpb24gbGliXHJcbiAqL1xyXG4vKipcclxuICogQHByZXNlcnZlIFR5cGVTY3JpcHQgcG9ydDpcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogY29sb3JIaXN0b2dyYW0udHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyBIdWVTdGF0aXN0aWNzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaHVlU3RhdGlzdGljcyc7XHJcbmltcG9ydCB7IHN0YWJsZVNvcnQgfSBmcm9tICcuLi8uLi91dGlscy9hcml0aG1ldGljJztcclxuZXhwb3J0IGNsYXNzIENvbG9ySGlzdG9ncmFtIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgY29sb3JzKSB7XHJcbiAgICAgICAgLy8gMSA9IGJ5IGdsb2JhbCBwb3B1bGF0aW9uLCAyID0gc3VicmVnaW9uIHBvcHVsYXRpb24gdGhyZXNob2xkXHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xyXG4gICAgICAgIC8vIGlmID4gMCwgZW5hYmxlcyBodWVzIHN0YXRzIGFuZCBtaW4tY29sb3IgcmV0ZW50aW9uIHBlciBncm91cFxyXG4gICAgICAgIHRoaXMuX21pbkh1ZUNvbHMgPSBjb2xvcnMgPDwgMjsgLy8gb3B0cy5taW5IdWVDb2xzIHx8IDA7XHJcbiAgICAgICAgLy8gIyBvZiBoaWdoZXN0LWZyZXF1ZW5jeSBjb2xvcnMgdG8gc3RhcnQgd2l0aCBmb3IgcGFsZXR0ZSByZWR1Y3Rpb25cclxuICAgICAgICB0aGlzLl9pbml0Q29sb3JzID0gY29sb3JzIDw8IDI7XHJcbiAgICAgICAgLy8gSHVlU3RhdGlzdGljcyBpbnN0YW5jZVxyXG4gICAgICAgIHRoaXMuX2h1ZVN0YXRzID0gbmV3IEh1ZVN0YXRpc3RpY3MoQ29sb3JIaXN0b2dyYW0uX2h1ZUdyb3VwcywgdGhpcy5fbWluSHVlQ29scyk7XHJcbiAgICAgICAgdGhpcy5faGlzdG9ncmFtID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1udWxsLWtleXdvcmRcclxuICAgIH1cclxuICAgIHNhbXBsZShwb2ludENvbnRhaW5lcikge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5fbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yU3RhdHMxRChwb2ludENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3JTdGF0czJEKHBvaW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEltcG9ydGFuY2VTb3J0ZWRDb2xvcnNJRFhJMzIoKSB7XHJcbiAgICAgICAgLy8gVE9ETzogZml4IHR5cGluZyBpc3N1ZSBpbiBzdGFibGVTb3J0IGZ1bmNcclxuICAgICAgICBjb25zdCBzb3J0ZWQgPSBzdGFibGVTb3J0KE9iamVjdC5rZXlzKHRoaXMuX2hpc3RvZ3JhbSksIChhLCBiKSA9PiB0aGlzLl9oaXN0b2dyYW1bYl0gLSB0aGlzLl9oaXN0b2dyYW1bYV0pO1xyXG4gICAgICAgIGlmIChzb3J0ZWQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGlkeGkzMjtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuX21ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsQ29sb3JzTGltaXQgPSBNYXRoLm1pbihzb3J0ZWQubGVuZ3RoLCB0aGlzLl9pbml0Q29sb3JzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBzb3J0ZWRbaW5pdGlhbENvbG9yc0xpbWl0IC0gMV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcmVxID0gdGhpcy5faGlzdG9ncmFtW2xhc3RdO1xyXG4gICAgICAgICAgICAgICAgaWR4aTMyID0gc29ydGVkLnNsaWNlKDAsIGluaXRpYWxDb2xvcnNMaW1pdCk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgYW55IGN1dCBvZmYgY29sb3JzIHdpdGggc2FtZSBmcmVxIGFzIGxhc3RcclxuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBpbml0aWFsQ29sb3JzTGltaXQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBzb3J0ZWQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGxlbiAmJiB0aGlzLl9oaXN0b2dyYW1bc29ydGVkW3Bvc11dID09PSBmcmVxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWR4aTMyLnB1c2goc29ydGVkW3BvcysrXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3QgbWluIGh1ZWdyb3VwIGNvbG9yc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faHVlU3RhdHMuaW5qZWN0SW50b0FycmF5KGlkeGkzMik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgaWR4aTMyID0gc29ydGVkO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZXRoaW5rIGVycm9yc1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbWV0aG9kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGludDMyLWlmeSB2YWx1ZXNcclxuICAgICAgICByZXR1cm4gaWR4aTMyLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gK3Y7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBnbG9iYWwgdG9wLXBvcHVsYXRpb25cclxuICAgIF9jb2xvclN0YXRzMUQocG9pbnRDb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCBoaXN0RyA9IHRoaXMuX2hpc3RvZ3JhbTtcclxuICAgICAgICBjb25zdCBwb2ludEFycmF5ID0gcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50QXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY29sID0gcG9pbnRBcnJheVtpXS51aW50MzI7XHJcbiAgICAgICAgICAgIC8vIGNvbGxlY3QgaHVlIHN0YXRzXHJcbiAgICAgICAgICAgIHRoaXMuX2h1ZVN0YXRzLmNoZWNrKGNvbCk7XHJcbiAgICAgICAgICAgIGlmIChjb2wgaW4gaGlzdEcpIHtcclxuICAgICAgICAgICAgICAgIGhpc3RHW2NvbF0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhpc3RHW2NvbF0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcG9wdWxhdGlvbiB0aHJlc2hvbGQgd2l0aGluIHN1YnJlZ2lvbnNcclxuICAgIC8vIEZJWE1FOiB0aGlzIGNhbiBvdmVyLXJlZHVjZSAoZmV3L25vIGNvbG9ycyBzYW1lPyksIG5lZWQgYSB3YXkgdG8ga2VlcFxyXG4gICAgLy8gaW1wb3J0YW50IGNvbG9ycyB0aGF0IGRvbnQgZXZlciByZWFjaCBsb2NhbCB0aHJlc2hvbGRzIChncmFkaWVudHM/KVxyXG4gICAgX2NvbG9yU3RhdHMyRChwb2ludENvbnRhaW5lcikge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCBwb2ludEFycmF5ID0gcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xyXG4gICAgICAgIGNvbnN0IGJveFcgPSBDb2xvckhpc3RvZ3JhbS5fYm94U2l6ZVswXTtcclxuICAgICAgICBjb25zdCBib3hIID0gQ29sb3JIaXN0b2dyYW0uX2JveFNpemVbMV07XHJcbiAgICAgICAgY29uc3QgYXJlYSA9IGJveFcgKiBib3hIO1xyXG4gICAgICAgIGNvbnN0IGJveGVzID0gdGhpcy5fbWFrZUJveGVzKHdpZHRoLCBoZWlnaHQsIGJveFcsIGJveEgpO1xyXG4gICAgICAgIGNvbnN0IGhpc3RHID0gdGhpcy5faGlzdG9ncmFtO1xyXG4gICAgICAgIGJveGVzLmZvckVhY2goYm94ID0+IHtcclxuICAgICAgICAgICAgbGV0IGVmZmMgPSBNYXRoLnJvdW5kKChib3gudyAqIGJveC5oKSAvIGFyZWEpICogQ29sb3JIaXN0b2dyYW0uX2JveFBpeGVscztcclxuICAgICAgICAgICAgaWYgKGVmZmMgPCAyKVxyXG4gICAgICAgICAgICAgICAgZWZmYyA9IDI7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpc3RMID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGVCb3goYm94LCB3aWR0aCwgKGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHBvaW50QXJyYXlbaV0udWludDMyO1xyXG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBodWUgc3RhdHNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2h1ZVN0YXRzLmNoZWNrKGNvbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sIGluIGhpc3RHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlzdEdbY29sXSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29sIGluIGhpc3RMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsraGlzdExbY29sXSA+PSBlZmZjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RHW2NvbF0gPSBoaXN0TFtjb2xdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpc3RMW2NvbF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBpbmplY3QgbWluIGh1ZWdyb3VwIGNvbG9yc1xyXG4gICAgICAgIHRoaXMuX2h1ZVN0YXRzLmluamVjdEludG9EaWN0aW9uYXJ5KGhpc3RHKTtcclxuICAgIH1cclxuICAgIC8vIGl0ZXJhdGVzIEBiYm94IHdpdGhpbiBhIHBhcmVudCByZWN0IG9mIHdpZHRoIEB3aWQ7IGNhbGxzIEBmbiwgcGFzc2luZyBpbmRleCB3aXRoaW4gcGFyZW50XHJcbiAgICBfaXRlcmF0ZUJveChiYm94LCB3aWQsIGZuKSB7XHJcbiAgICAgICAgY29uc3QgYiA9IGJib3g7XHJcbiAgICAgICAgY29uc3QgaTAgPSBiLnkgKiB3aWQgKyBiLng7XHJcbiAgICAgICAgY29uc3QgaTEgPSAoYi55ICsgYi5oIC0gMSkgKiB3aWQgKyAoYi54ICsgYi53IC0gMSk7XHJcbiAgICAgICAgY29uc3QgaW5jciA9IHdpZCAtIGIudyArIDE7XHJcbiAgICAgICAgbGV0IGNudCA9IDA7XHJcbiAgICAgICAgbGV0IGkgPSBpMDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgaSk7XHJcbiAgICAgICAgICAgIGkgKz0gKCsrY250ICUgYi53ID09PSAwKSA/IGluY3IgOiAxO1xyXG4gICAgICAgIH0gd2hpbGUgKGkgPD0gaTEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgICBwYXJ0aXRpb25zIGEgcmVjdGFuZ2xlIG9mIHdpZHRoIHggaGVpZ2h0IGludG9cclxuICAgICAqICAgIGFycmF5IG9mIGJveGVzIHN0ZXBYIHggc3RlcFkgKG9yIGxlc3MpXHJcbiAgICAgKi9cclxuICAgIF9tYWtlQm94ZXMod2lkdGgsIGhlaWdodCwgc3RlcFgsIHN0ZXBZKSB7XHJcbiAgICAgICAgY29uc3Qgd3JlbSA9IHdpZHRoICUgc3RlcFg7XHJcbiAgICAgICAgY29uc3QgaHJlbSA9IGhlaWdodCAlIHN0ZXBZO1xyXG4gICAgICAgIGNvbnN0IHhlbmQgPSB3aWR0aCAtIHdyZW07XHJcbiAgICAgICAgY29uc3QgeWVuZCA9IGhlaWdodCAtIGhyZW07XHJcbiAgICAgICAgY29uc3QgYm94ZXNBcnJheSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IHN0ZXBZKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHggKz0gc3RlcFgpIHtcclxuICAgICAgICAgICAgICAgIGJveGVzQXJyYXkucHVzaCh7IHgsIHksIHc6ICh4ID09PSB4ZW5kID8gd3JlbSA6IHN0ZXBYKSwgaDogKHkgPT09IHllbmQgPyBocmVtIDogc3RlcFkpIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBib3hlc0FycmF5O1xyXG4gICAgfVxyXG59XHJcbkNvbG9ySGlzdG9ncmFtLl9ib3hTaXplID0gWzY0LCA2NF07XHJcbkNvbG9ySGlzdG9ncmFtLl9ib3hQaXhlbHMgPSAyO1xyXG5Db2xvckhpc3RvZ3JhbS5faHVlR3JvdXBzID0gMTA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9ySGlzdG9ncmFtLmpzLm1hcCIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgTGVvbiBTb3Jva2luXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIFJHQlF1YW50LmpzIC0gYW4gaW1hZ2UgcXVhbnRpemF0aW9uIGxpYlxyXG4gKi9cclxuLyoqXHJcbiAqIEBwcmVzZXJ2ZSBUeXBlU2NyaXB0IHBvcnQ6XHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIHJnYnF1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgUGFsZXR0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3BhbGV0dGUnO1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3V0aWxzL3BvaW50JztcclxuaW1wb3J0IHsgQ29sb3JIaXN0b2dyYW0gfSBmcm9tICcuL2NvbG9ySGlzdG9ncmFtJztcclxuaW1wb3J0IHsgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIH0gZnJvbSAnLi4vcGFsZXR0ZVF1YW50aXplcic7XHJcbmltcG9ydCB7IHN0YWJsZVNvcnQgfSBmcm9tICcuLi8uLi91dGlscy9hcml0aG1ldGljJztcclxuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xyXG5jbGFzcyBSZW1vdmVkQ29sb3Ige1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXgsIGNvbG9yLCBkaXN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgfVxyXG59XHJcbi8vIFRPRE86IG1ha2UgaW5wdXQvb3V0cHV0IGltYWdlIGFuZCBpbnB1dC9vdXRwdXQgcGFsZXR0ZXMgd2l0aCBpbnN0YW5jZXMgb2YgY2xhc3MgUG9pbnQgb25seSFcclxuZXhwb3J0IGNsYXNzIFJHQlF1YW50IGV4dGVuZHMgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMgPSAyNTYsIG1ldGhvZCA9IDIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XHJcbiAgICAgICAgLy8gZGVzaXJlZCBmaW5hbCBwYWxldHRlIHNpemVcclxuICAgICAgICB0aGlzLl9jb2xvcnMgPSBjb2xvcnM7XHJcbiAgICAgICAgLy8gaGlzdG9ncmFtIHRvIGFjY3VtdWxhdGVcclxuICAgICAgICB0aGlzLl9oaXN0b2dyYW0gPSBuZXcgQ29sb3JIaXN0b2dyYW0obWV0aG9kLCBjb2xvcnMpO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxEaXN0YW5jZSA9IDAuMDE7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VJbmNyZW1lbnQgPSAwLjAwNTtcclxuICAgIH1cclxuICAgIC8vIGdhdGhlcnMgaGlzdG9ncmFtIGluZm9cclxuICAgIHNhbXBsZShpbWFnZSkge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIHZhciBwb2ludEFycmF5ID0gaW1hZ2UuZ2V0UG9pbnRBcnJheSgpLCBtYXggPSBbMCwgMCwgMCwgMF0sIG1pbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xyXG4gICAgXHJcbiAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcG9pbnRBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgdmFyIGNvbG9yID0gcG9pbnRBcnJheVtpXTtcclxuICAgICAgICAgZm9yICh2YXIgY29tcG9uZW50SW5kZXggPSAwOyBjb21wb25lbnRJbmRleCA8IDQ7IGNvbXBvbmVudEluZGV4KyspIHtcclxuICAgICAgICAgaWYgKG1heFtjb21wb25lbnRJbmRleF0gPCBjb2xvci5yZ2JhW2NvbXBvbmVudEluZGV4XSkgbWF4W2NvbXBvbmVudEluZGV4XSA9IGNvbG9yLnJnYmFbY29tcG9uZW50SW5kZXhdO1xyXG4gICAgICAgICBpZiAobWluW2NvbXBvbmVudEluZGV4XSA+IGNvbG9yLnJnYmFbY29tcG9uZW50SW5kZXhdKSBtaW5bY29tcG9uZW50SW5kZXhdID0gY29sb3IucmdiYVtjb21wb25lbnRJbmRleF07XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgcmQgPSBtYXhbMF0gLSBtaW5bMF0sIGdkID0gbWF4WzFdIC0gbWluWzFdLCBiZCA9IG1heFsyXSAtIG1pblsyXSwgYWQgPSBtYXhbM10gLSBtaW5bM107XHJcbiAgICAgICAgIHRoaXMuX2Rpc3RhbmNlLnNldFdoaXRlUG9pbnQocmQsIGdkLCBiZCwgYWQpO1xyXG4gICAgXHJcbiAgICAgICAgIHRoaXMuX2luaXRpYWxEaXN0YW5jZSA9IChNYXRoLnNxcnQocmQgKiByZCArIGdkICogZ2QgKyBiZCAqIGJkICsgYWQgKiBhZCkgLyBNYXRoLnNxcnQoMjU1ICogMjU1ICsgMjU1ICogMjU1ICsgMjU1ICogMjU1KSkgKiAwLjAxO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2hpc3RvZ3JhbS5zYW1wbGUoaW1hZ2UpO1xyXG4gICAgfVxyXG4gICAgLy8gcmVkdWNlcyBoaXN0b2dyYW0gdG8gcGFsZXR0ZSwgcmVtYXBzICYgbWVtb2l6ZXMgcmVkdWNlZCBjb2xvcnNcclxuICAgICpxdWFudGl6ZSgpIHtcclxuICAgICAgICBjb25zdCBpZHhpMzIgPSB0aGlzLl9oaXN0b2dyYW0uZ2V0SW1wb3J0YW5jZVNvcnRlZENvbG9yc0lEWEkzMigpO1xyXG4gICAgICAgIGlmIChpZHhpMzIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29sb3JzIGluIGltYWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkKiB0aGlzLl9idWlsZFBhbGV0dGUoaWR4aTMyKTtcclxuICAgIH1cclxuICAgIC8vIHJlZHVjZXMgc2ltaWxhciBjb2xvcnMgZnJvbSBhbiBpbXBvcnRhbmNlLXNvcnRlZCBVaW50MzIgcmdiYSBhcnJheVxyXG4gICAgKl9idWlsZFBhbGV0dGUoaWR4aTMyKSB7XHJcbiAgICAgICAgLy8gcmVkdWNlIGhpc3RvZ3JhbSB0byBjcmVhdGUgaW5pdGlhbCBwYWxldHRlXHJcbiAgICAgICAgLy8gYnVpbGQgZnVsbCByZ2IgcGFsZXR0ZVxyXG4gICAgICAgIGNvbnN0IHBhbGV0dGUgPSBuZXcgUGFsZXR0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBwYWxldHRlLmdldFBvaW50Q29udGFpbmVyKCkuZ2V0UG9pbnRBcnJheSgpO1xyXG4gICAgICAgIGNvbnN0IHVzYWdlQXJyYXkgPSBuZXcgQXJyYXkoaWR4aTMyLmxlbmd0aCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6cHJlZmVyLWFycmF5LWxpdGVyYWxcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkeGkzMi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb2xvckFycmF5LnB1c2goUG9pbnQuY3JlYXRlQnlVaW50MzIoaWR4aTMyW2ldKSk7XHJcbiAgICAgICAgICAgIHVzYWdlQXJyYXlbaV0gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW4gPSBjb2xvckFycmF5Lmxlbmd0aDtcclxuICAgICAgICBjb25zdCBtZW1EaXN0ID0gW107XHJcbiAgICAgICAgbGV0IHBhbExlbiA9IGxlbjtcclxuICAgICAgICBsZXQgdGhvbGQgPSB0aGlzLl9pbml0aWFsRGlzdGFuY2U7XHJcbiAgICAgICAgLy8gcGFsZXR0ZSBhbHJlYWR5IGF0IG9yIGJlbG93IGRlc2lyZWQgbGVuZ3RoXHJcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIocGFsTGVuIC0gdGhpcy5fY29sb3JzLCA5OSk7XHJcbiAgICAgICAgd2hpbGUgKHBhbExlbiA+IHRoaXMuX2NvbG9ycykge1xyXG4gICAgICAgICAgICBtZW1EaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgcGFsZXR0ZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkobGVuIC0gcGFsTGVuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1c2FnZUFycmF5W2ldID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHhpID0gY29sb3JBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgIC8vIGlmICghcHhpKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWdlQXJyYXlbal0gPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB4aiA9IGNvbG9yQXJyYXlbal07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFweGopIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLl9kaXN0YW5jZS5jYWxjdWxhdGVOb3JtYWxpemVkKHB4aSwgcHhqKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IHRob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGluZGV4LHJnYixkaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbURpc3QucHVzaChuZXcgUmVtb3ZlZENvbG9yKGosIHB4aiwgZGlzdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZUFycmF5W2pdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFsTGVuLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHBhbGV0dGUgcmVkdWN0aW9uIHBhc3NcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJwYWxldHRlIGxlbmd0aDogXCIgKyBwYWxMZW4pO1xyXG4gICAgICAgICAgICAvLyBpZiBwYWxldHRlIGlzIHN0aWxsIG11Y2ggbGFyZ2VyIHRoYW4gdGFyZ2V0LCBpbmNyZW1lbnQgYnkgbGFyZ2VyIGluaXREaXN0XHJcbiAgICAgICAgICAgIHRob2xkICs9IChwYWxMZW4gPiB0aGlzLl9jb2xvcnMgKiAzKSA/IHRoaXMuX2luaXRpYWxEaXN0YW5jZSA6IHRoaXMuX2Rpc3RhbmNlSW5jcmVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBwYWxldHRlIGlzIG92ZXItcmVkdWNlZCwgcmUtYWRkIHJlbW92ZWQgY29sb3JzIHdpdGggbGFyZ2VzdCBkaXN0YW5jZXMgZnJvbSBsYXN0IHJvdW5kXHJcbiAgICAgICAgaWYgKHBhbExlbiA8IHRoaXMuX2NvbG9ycykge1xyXG4gICAgICAgICAgICAvLyBzb3J0IGRlc2NlbmRpbmdcclxuICAgICAgICAgICAgc3RhYmxlU29ydChtZW1EaXN0LCBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIuZGlzdGFuY2UgLSBhLmRpc3RhbmNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IGsgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAocGFsTGVuIDwgdGhpcy5fY29sb3JzICYmIGsgPCBtZW1EaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlZENvbG9yID0gbWVtRGlzdFtrXTtcclxuICAgICAgICAgICAgICAgIC8vIHJlLWluamVjdCByZ2IgaW50byBmaW5hbCBwYWxldHRlXHJcbiAgICAgICAgICAgICAgICB1c2FnZUFycmF5W3JlbW92ZWRDb2xvci5pbmRleF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgcGFsTGVuKys7XHJcbiAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbG9ycyA9IGNvbG9yQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGNvbG9ySW5kZXggPSBjb2xvcnMgLSAxOyBjb2xvckluZGV4ID49IDA7IGNvbG9ySW5kZXgtLSkge1xyXG4gICAgICAgICAgICBpZiAodXNhZ2VBcnJheVtjb2xvckluZGV4XSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9ySW5kZXggIT09IGNvbG9ycyAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckFycmF5W2NvbG9ySW5kZXhdID0gY29sb3JBcnJheVtjb2xvcnMgLSAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC0tY29sb3JzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbG9yQXJyYXkubGVuZ3RoID0gY29sb3JzO1xyXG4gICAgICAgIHBhbGV0dGUuc29ydCgpO1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgcGFsZXR0ZSxcclxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJnYnF1YW50LmpzLm1hcCIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuICpcclxuICogd3VRdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmltcG9ydCB7IFBhbGV0dGUgfSBmcm9tICcuLi8uLi91dGlscy9wYWxldHRlJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi91dGlscy9wb2ludCc7XHJcbmltcG9ydCB7IEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB9IGZyb20gJy4uL3BhbGV0dGVRdWFudGl6ZXInO1xyXG5pbXBvcnQgeyBQcm9ncmVzc1RyYWNrZXIgfSBmcm9tICcuLi8uLi91dGlscyc7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5MUQoZGltZW5zaW9uMSkge1xyXG4gICAgY29uc3QgYSA9IFtdO1xyXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1lbnNpb24xOyBrKyspIHtcclxuICAgICAgICBhW2tdID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5NEQoZGltZW5zaW9uMSwgZGltZW5zaW9uMiwgZGltZW5zaW9uMywgZGltZW5zaW9uNCkge1xyXG4gICAgY29uc3QgYSA9IG5ldyBBcnJheShkaW1lbnNpb24xKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uMTsgaSsrKSB7XHJcbiAgICAgICAgYVtpXSA9IG5ldyBBcnJheShkaW1lbnNpb24yKTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbjI7IGorKykge1xyXG4gICAgICAgICAgICBhW2ldW2pdID0gbmV3IEFycmF5KGRpbWVuc2lvbjMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRpbWVuc2lvbjM7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgYVtpXVtqXVtrXSA9IG5ldyBBcnJheShkaW1lbnNpb240KTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgZGltZW5zaW9uNDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYVtpXVtqXVtrXVtsXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheTNEKGRpbWVuc2lvbjEsIGRpbWVuc2lvbjIsIGRpbWVuc2lvbjMpIHtcclxuICAgIGNvbnN0IGEgPSBuZXcgQXJyYXkoZGltZW5zaW9uMSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xyXG4gICAgICAgIGFbaV0gPSBuZXcgQXJyYXkoZGltZW5zaW9uMik7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW1lbnNpb24yOyBqKyspIHtcclxuICAgICAgICAgICAgYVtpXVtqXSA9IG5ldyBBcnJheShkaW1lbnNpb24zKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1lbnNpb24zOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGFbaV1bal1ba10gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuZnVuY3Rpb24gZmlsbEFycmF5M0QoYSwgZGltZW5zaW9uMSwgZGltZW5zaW9uMiwgZGltZW5zaW9uMywgdmFsdWUpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uMTsgaSsrKSB7XHJcbiAgICAgICAgYVtpXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9uMjsgaisrKSB7XHJcbiAgICAgICAgICAgIGFbaV1bal0gPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1lbnNpb24zOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGFbaV1bal1ba10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaWxsQXJyYXkxRChhLCBkaW1lbnNpb24xLCB2YWx1ZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1lbnNpb24xOyBpKyspIHtcclxuICAgICAgICBhW2ldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFd1Q29sb3JDdWJlIHtcclxufVxyXG5leHBvcnQgY2xhc3MgV3VRdWFudCBleHRlbmRzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzID0gMjU2LCBzaWduaWZpY2FudEJpdHNQZXJDaGFubmVsID0gNSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcclxuICAgICAgICB0aGlzLl9zZXRRdWFsaXR5KHNpZ25pZmljYW50Qml0c1BlckNoYW5uZWwpO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemUoY29sb3JzKTtcclxuICAgIH1cclxuICAgIHNhbXBsZShpbWFnZSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50QXJyYXkgPSBpbWFnZS5nZXRQb2ludEFycmF5KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb2ludEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRDb2xvcihwb2ludEFycmF5W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxzID0gdGhpcy5fcGl4ZWxzLmNvbmNhdChwb2ludEFycmF5KTtcclxuICAgIH1cclxuICAgICpxdWFudGl6ZSgpIHtcclxuICAgICAgICB5aWVsZCogdGhpcy5fcHJlcGFyZVBhbGV0dGUoKTtcclxuICAgICAgICBjb25zdCBwYWxldHRlID0gbmV3IFBhbGV0dGUoKTtcclxuICAgICAgICAvLyBnZW5lcmF0ZXMgcGFsZXR0ZVxyXG4gICAgICAgIGZvciAobGV0IHBhbGV0dGVJbmRleCA9IDA7IHBhbGV0dGVJbmRleCA8IHRoaXMuX2NvbG9yczsgcGFsZXR0ZUluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N1bXNbcGFsZXR0ZUluZGV4XSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IHRoaXMuX3N1bXNbcGFsZXR0ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9yZWRzW3BhbGV0dGVJbmRleF0gLyBzdW07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gdGhpcy5fZ3JlZW5zW3BhbGV0dGVJbmRleF0gLyBzdW07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5fYmx1ZXNbcGFsZXR0ZUluZGV4XSAvIHN1bTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLl9hbHBoYXNbcGFsZXR0ZUluZGV4XSAvIHN1bTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gUG9pbnQuY3JlYXRlQnlSR0JBKHIgfCAwLCBnIHwgMCwgYiB8IDAsIGEgfCAwKTtcclxuICAgICAgICAgICAgICAgIHBhbGV0dGUuYWRkKGNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwYWxldHRlLnNvcnQoKTtcclxuICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgIHBhbGV0dGUsXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgICpfcHJlcGFyZVBhbGV0dGUoKSB7XHJcbiAgICAgICAgLy8gcHJlcHJvY2VzcyB0aGUgY29sb3JzXHJcbiAgICAgICAgeWllbGQqIHRoaXMuX2NhbGN1bGF0ZU1vbWVudHMoKTtcclxuICAgICAgICBsZXQgbmV4dCA9IDA7XHJcbiAgICAgICAgY29uc3Qgdm9sdW1lVmFyaWFuY2UgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyk7XHJcbiAgICAgICAgLy8gcHJvY2Vzc2VzIHRoZSBjdWJlc1xyXG4gICAgICAgIGZvciAobGV0IGN1YmVJbmRleCA9IDE7IGN1YmVJbmRleCA8IHRoaXMuX2NvbG9yczsgKytjdWJlSW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gaWYgY3V0IGlzIHBvc3NpYmxlOyBtYWtlIGl0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXQodGhpcy5fY3ViZXNbbmV4dF0sIHRoaXMuX2N1YmVzW2N1YmVJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICB2b2x1bWVWYXJpYW5jZVtuZXh0XSA9IHRoaXMuX2N1YmVzW25leHRdLnZvbHVtZSA+IDEgPyB0aGlzLl9jYWxjdWxhdGVWYXJpYW5jZSh0aGlzLl9jdWJlc1tuZXh0XSkgOiAwLjA7XHJcbiAgICAgICAgICAgICAgICB2b2x1bWVWYXJpYW5jZVtjdWJlSW5kZXhdID0gdGhpcy5fY3ViZXNbY3ViZUluZGV4XS52b2x1bWUgPiAxID8gdGhpcy5fY2FsY3VsYXRlVmFyaWFuY2UodGhpcy5fY3ViZXNbY3ViZUluZGV4XSkgOiAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3V0IHdhcyBub3QgcG9zc2libGUsIHJldmVydCB0aGUgaW5kZXhcclxuICAgICAgICAgICAgICAgIHZvbHVtZVZhcmlhbmNlW25leHRdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgY3ViZUluZGV4LS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV4dCA9IDA7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wID0gdm9sdW1lVmFyaWFuY2VbMF07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPD0gY3ViZUluZGV4OyArK2luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9sdW1lVmFyaWFuY2VbaW5kZXhdID4gdGVtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSB2b2x1bWVWYXJpYW5jZVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0ZW1wIDw9IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3JzID0gY3ViZUluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxvb2t1cFJlZCA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGxvb2t1cEdyZWVuID0gW107XHJcbiAgICAgICAgY29uc3QgbG9va3VwQmx1ZSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGxvb2t1cEFscGhhID0gW107XHJcbiAgICAgICAgLy8gcHJlY2FsY3VsYXRlcyBsb29rdXAgdGFibGVzXHJcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLl9jb2xvcnM7ICsraykge1xyXG4gICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSBXdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX3dlaWdodHMpO1xyXG4gICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbG9va3VwUmVkW2tdID0gKFd1UXVhbnQuX3ZvbHVtZSh0aGlzLl9jdWJlc1trXSwgdGhpcy5fbW9tZW50c1JlZCkgLyB3ZWlnaHQpIHwgMDtcclxuICAgICAgICAgICAgICAgIGxvb2t1cEdyZWVuW2tdID0gKFd1UXVhbnQuX3ZvbHVtZSh0aGlzLl9jdWJlc1trXSwgdGhpcy5fbW9tZW50c0dyZWVuKSAvIHdlaWdodCkgfCAwO1xyXG4gICAgICAgICAgICAgICAgbG9va3VwQmx1ZVtrXSA9IChXdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX21vbWVudHNCbHVlKSAvIHdlaWdodCkgfCAwO1xyXG4gICAgICAgICAgICAgICAgbG9va3VwQWxwaGFba10gPSAoV3VRdWFudC5fdm9sdW1lKHRoaXMuX2N1YmVzW2tdLCB0aGlzLl9tb21lbnRzQWxwaGEpIC8gd2VpZ2h0KSB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb29rdXBSZWRba10gPSAwO1xyXG4gICAgICAgICAgICAgICAgbG9va3VwR3JlZW5ba10gPSAwO1xyXG4gICAgICAgICAgICAgICAgbG9va3VwQmx1ZVtrXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBsb29rdXBBbHBoYVtrXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVkcyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XHJcbiAgICAgICAgdGhpcy5fZ3JlZW5zID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcclxuICAgICAgICB0aGlzLl9ibHVlcyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XHJcbiAgICAgICAgdGhpcy5fYWxwaGFzID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcclxuICAgICAgICB0aGlzLl9zdW1zID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcclxuICAgICAgICAvLyBzY2FucyBhbmQgYWRkcyBjb2xvcnNcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGwgPSB0aGlzLl9waXhlbHMubGVuZ3RoOyBpbmRleCA8IGw7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl9waXhlbHNbaW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IC0xO1xyXG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gbWF0Y2g7XHJcbiAgICAgICAgICAgIGxldCBiZXN0RGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsb29rdXAgPSAwOyBsb29rdXAgPCB0aGlzLl9jb2xvcnM7IGxvb2t1cCsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZFJlZCA9IGxvb2t1cFJlZFtsb29rdXBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRHcmVlbiA9IGxvb2t1cEdyZWVuW2xvb2t1cF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEJsdWUgPSBsb29rdXBCbHVlW2xvb2t1cF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEFscGhhID0gbG9va3VwQWxwaGFbbG9va3VwXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlUmF3KGZvdW5kUmVkLCBmb3VuZEdyZWVuLCBmb3VuZEJsdWUsIGZvdW5kQWxwaGEsIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgYmVzdERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdERpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gbG9va3VwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZHNbYmVzdE1hdGNoXSArPSBjb2xvci5yO1xyXG4gICAgICAgICAgICB0aGlzLl9ncmVlbnNbYmVzdE1hdGNoXSArPSBjb2xvci5nO1xyXG4gICAgICAgICAgICB0aGlzLl9ibHVlc1tiZXN0TWF0Y2hdICs9IGNvbG9yLmI7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhc1tiZXN0TWF0Y2hdICs9IGNvbG9yLmE7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1bXNbYmVzdE1hdGNoXSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hZGRDb2xvcihjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IGJpdHNUb1JlbW92ZSA9IDggLSB0aGlzLl9zaWduaWZpY2FudEJpdHNQZXJDaGFubmVsO1xyXG4gICAgICAgIGNvbnN0IGluZGV4UmVkID0gKGNvbG9yLnIgPj4gYml0c1RvUmVtb3ZlKSArIDE7XHJcbiAgICAgICAgY29uc3QgaW5kZXhHcmVlbiA9IChjb2xvci5nID4+IGJpdHNUb1JlbW92ZSkgKyAxO1xyXG4gICAgICAgIGNvbnN0IGluZGV4Qmx1ZSA9IChjb2xvci5iID4+IGJpdHNUb1JlbW92ZSkgKyAxO1xyXG4gICAgICAgIGNvbnN0IGluZGV4QWxwaGEgPSAoY29sb3IuYSA+PiBiaXRzVG9SZW1vdmUpICsgMTtcclxuICAgICAgICAvLyBpZihjb2xvci5hID4gMTApIHtcclxuICAgICAgICB0aGlzLl93ZWlnaHRzW2luZGV4QWxwaGFdW2luZGV4UmVkXVtpbmRleEdyZWVuXVtpbmRleEJsdWVdKys7XHJcbiAgICAgICAgdGhpcy5fbW9tZW50c1JlZFtpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSBjb2xvci5yO1xyXG4gICAgICAgIHRoaXMuX21vbWVudHNHcmVlbltpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSBjb2xvci5nO1xyXG4gICAgICAgIHRoaXMuX21vbWVudHNCbHVlW2luZGV4QWxwaGFdW2luZGV4UmVkXVtpbmRleEdyZWVuXVtpbmRleEJsdWVdICs9IGNvbG9yLmI7XHJcbiAgICAgICAgdGhpcy5fbW9tZW50c0FscGhhW2luZGV4QWxwaGFdW2luZGV4UmVkXVtpbmRleEdyZWVuXVtpbmRleEJsdWVdICs9IGNvbG9yLmE7XHJcbiAgICAgICAgdGhpcy5fbW9tZW50c1tpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSB0aGlzLl90YWJsZVtjb2xvci5yXSArIHRoaXMuX3RhYmxlW2NvbG9yLmddICsgdGhpcy5fdGFibGVbY29sb3IuYl0gKyB0aGlzLl90YWJsZVtjb2xvci5hXTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBoaXN0b2dyYW0gdG8gYSBzZXJpZXMgb2YgX21vbWVudHMuXHJcbiAgICAgKi9cclxuICAgICpfY2FsY3VsYXRlTW9tZW50cygpIHtcclxuICAgICAgICBjb25zdCBhcmVhID0gW107XHJcbiAgICAgICAgY29uc3QgYXJlYVJlZCA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFyZWFHcmVlbiA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFyZWFCbHVlID0gW107XHJcbiAgICAgICAgY29uc3QgYXJlYUFscGhhID0gW107XHJcbiAgICAgICAgY29uc3QgYXJlYTIgPSBbXTtcclxuICAgICAgICBjb25zdCB4YXJlYSA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XHJcbiAgICAgICAgY29uc3QgeGFyZWFSZWQgPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xyXG4gICAgICAgIGNvbnN0IHhhcmVhR3JlZW4gPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xyXG4gICAgICAgIGNvbnN0IHhhcmVhQmx1ZSA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XHJcbiAgICAgICAgY29uc3QgeGFyZWFBbHBoYSA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XHJcbiAgICAgICAgY29uc3QgeGFyZWEyID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICBsZXQgdHJhY2tlclByb2dyZXNzID0gMDtcclxuICAgICAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcih0aGlzLl9hbHBoYU1heFNpZGVJbmRleCAqIHRoaXMuX21heFNpZGVJbmRleCwgOTkpO1xyXG4gICAgICAgIGZvciAobGV0IGFscGhhSW5kZXggPSAxOyBhbHBoYUluZGV4IDw9IHRoaXMuX2FscGhhTWF4U2lkZUluZGV4OyArK2FscGhhSW5kZXgpIHtcclxuICAgICAgICAgICAgZmlsbEFycmF5M0QoeGFyZWEsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xyXG4gICAgICAgICAgICBmaWxsQXJyYXkzRCh4YXJlYVJlZCwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgIGZpbGxBcnJheTNEKHhhcmVhR3JlZW4sIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xyXG4gICAgICAgICAgICBmaWxsQXJyYXkzRCh4YXJlYUJsdWUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xyXG4gICAgICAgICAgICBmaWxsQXJyYXkzRCh4YXJlYUFscGhhLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgZmlsbEFycmF5M0QoeGFyZWEyLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcmVkSW5kZXggPSAxOyByZWRJbmRleCA8PSB0aGlzLl9tYXhTaWRlSW5kZXg7ICsrcmVkSW5kZXgsICsrdHJhY2tlclByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkodHJhY2tlclByb2dyZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbGxBcnJheTFEKGFyZWEsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgICAgIGZpbGxBcnJheTFEKGFyZWFSZWQsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgICAgIGZpbGxBcnJheTFEKGFyZWFHcmVlbiwgdGhpcy5fc2lkZVNpemUsIDApO1xyXG4gICAgICAgICAgICAgICAgZmlsbEFycmF5MUQoYXJlYUJsdWUsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgICAgIGZpbGxBcnJheTFEKGFyZWFBbHBoYSwgdGhpcy5fc2lkZVNpemUsIDApO1xyXG4gICAgICAgICAgICAgICAgZmlsbEFycmF5MUQoYXJlYTIsIHRoaXMuX3NpZGVTaXplLCAwKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGdyZWVuSW5kZXggPSAxOyBncmVlbkluZGV4IDw9IHRoaXMuX21heFNpZGVJbmRleDsgKytncmVlbkluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lUmVkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZUdyZWVuID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZUJsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lQWxwaGEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lMiA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBibHVlSW5kZXggPSAxOyBibHVlSW5kZXggPD0gdGhpcy5fbWF4U2lkZUluZGV4OyArK2JsdWVJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lICs9IHRoaXMuX3dlaWdodHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVSZWQgKz0gdGhpcy5fbW9tZW50c1JlZFthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUdyZWVuICs9IHRoaXMuX21vbWVudHNHcmVlblthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUJsdWUgKz0gdGhpcy5fbW9tZW50c0JsdWVbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVBbHBoYSArPSB0aGlzLl9tb21lbnRzQWxwaGFbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUyICs9IHRoaXMuX21vbWVudHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWFbYmx1ZUluZGV4XSArPSBsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhUmVkW2JsdWVJbmRleF0gKz0gbGluZVJlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYUdyZWVuW2JsdWVJbmRleF0gKz0gbGluZUdyZWVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhQmx1ZVtibHVlSW5kZXhdICs9IGxpbmVCbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhQWxwaGFbYmx1ZUluZGV4XSArPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEyW2JsdWVJbmRleF0gKz0gbGluZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWFbcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4YXJlYVJlZFtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhUmVkW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWFSZWRbYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGFyZWFHcmVlbltyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhR3JlZW5bcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYUdyZWVuW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhQmx1ZVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhQmx1ZVtyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhQmx1ZVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4YXJlYUFscGhhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWFBbHBoYVtyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhQWxwaGFbYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGFyZWEyW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWEyW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWEyW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlaWdodHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl93ZWlnaHRzW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb21lbnRzUmVkW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c1JlZFthbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYVJlZFtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9tZW50c0dyZWVuW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c0dyZWVuW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhR3JlZW5bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbWVudHNCbHVlW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c0JsdWVbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFCbHVlW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb21lbnRzQWxwaGFbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl9tb21lbnRzQWxwaGFbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFBbHBoYVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9tZW50c1thbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX21vbWVudHNbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWEyW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIHZvbHVtZSBvZiB0aGUgY3ViZSBpbiBhIHNwZWNpZmljIG1vbWVudC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIF92b2x1bWVGbG9hdChjdWJlLCBtb21lbnQpIHtcclxuICAgICAgICByZXR1cm4gKG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxyXG4gICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxyXG4gICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxyXG4gICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dKSAtXHJcbiAgICAgICAgICAgIChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgdm9sdW1lIG9mIHRoZSBjdWJlIGluIGEgc3BlY2lmaWMgbW9tZW50LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgX3ZvbHVtZShjdWJlLCBtb21lbnQpIHtcclxuICAgICAgICByZXR1cm4gV3VRdWFudC5fdm9sdW1lRmxvYXQoY3ViZSwgbW9tZW50KSB8IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNwbGl0cyB0aGUgY3ViZSBpbiBnaXZlbiBwb3NpdGlvbl1bYW5kIGNvbG9yIGRpcmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIF90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgbW9tZW50KSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX2FscGhhOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0pIC1cclxuICAgICAgICAgICAgICAgICAgICAobW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9yZWQ6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9ncmVlbjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1heGltdW1dKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fYmx1ZTpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW3Bvc2l0aW9uXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtwb3NpdGlvbl0gLVxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bcG9zaXRpb25dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSkgLVxyXG4gICAgICAgICAgICAgICAgICAgIChtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW3Bvc2l0aW9uXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bcG9zaXRpb25dIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtwb3NpdGlvbl0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3NzaWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0IHwgMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BsaXRzIHRoZSBjdWJlIGluIGEgZ2l2ZW4gY29sb3IgZGlyZWN0aW9uIGF0IGl0cyBtaW5pbXVtLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIG1vbWVudCkge1xyXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fYWxwaGE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKC1tb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKC1tb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9yZWQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9ncmVlbjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAoLW1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0pIC1cclxuICAgICAgICAgICAgICAgICAgICAoLW1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xyXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX2JsdWU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKC1tb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoeSBoZXJlIGlzIHJldHVybiAwLCBhbmQgaW4gdGhpcy5fdG9wIHRoZXJlIGlzIG5vIGRlZmF1bHQgYXQgYWxsIChub3cgaXQgaXMgdGhyb3cgZXJyb3IpP1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHN0YXRpc3RpY2FsIHZhcmlhbmNlIGZvciBhIGdpdmVuIGN1YmUuXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVWYXJpYW5jZShjdWJlKSB7XHJcbiAgICAgICAgY29uc3Qgdm9sdW1lUmVkID0gV3VRdWFudC5fdm9sdW1lKGN1YmUsIHRoaXMuX21vbWVudHNSZWQpO1xyXG4gICAgICAgIGNvbnN0IHZvbHVtZUdyZWVuID0gV3VRdWFudC5fdm9sdW1lKGN1YmUsIHRoaXMuX21vbWVudHNHcmVlbik7XHJcbiAgICAgICAgY29uc3Qgdm9sdW1lQmx1ZSA9IFd1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzQmx1ZSk7XHJcbiAgICAgICAgY29uc3Qgdm9sdW1lQWxwaGEgPSBXdVF1YW50Ll92b2x1bWUoY3ViZSwgdGhpcy5fbW9tZW50c0FscGhhKTtcclxuICAgICAgICBjb25zdCB2b2x1bWVNb21lbnQgPSBXdVF1YW50Ll92b2x1bWVGbG9hdChjdWJlLCB0aGlzLl9tb21lbnRzKTtcclxuICAgICAgICBjb25zdCB2b2x1bWVXZWlnaHQgPSBXdVF1YW50Ll92b2x1bWUoY3ViZSwgdGhpcy5fd2VpZ2h0cyk7XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB2b2x1bWVSZWQgKiB2b2x1bWVSZWQgKyB2b2x1bWVHcmVlbiAqIHZvbHVtZUdyZWVuICsgdm9sdW1lQmx1ZSAqIHZvbHVtZUJsdWUgKyB2b2x1bWVBbHBoYSAqIHZvbHVtZUFscGhhO1xyXG4gICAgICAgIHJldHVybiB2b2x1bWVNb21lbnQgLSAoZGlzdGFuY2UgLyB2b2x1bWVXZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgb3B0aW1hbCAobWF4aW1hbCkgcG9zaXRpb24gZm9yIHRoZSBjdXQuXHJcbiAgICAgKi9cclxuICAgIF9tYXhpbWl6ZShjdWJlLCBkaXJlY3Rpb24sIGZpcnN0LCBsYXN0LCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJlZCA9IFd1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX21vbWVudHNSZWQpIHwgMDtcclxuICAgICAgICBjb25zdCBib3R0b21HcmVlbiA9IFd1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX21vbWVudHNHcmVlbikgfCAwO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUJsdWUgPSBXdVF1YW50Ll9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCB0aGlzLl9tb21lbnRzQmx1ZSkgfCAwO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUFscGhhID0gV3VRdWFudC5fYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgdGhpcy5fbW9tZW50c0FscGhhKSB8IDA7XHJcbiAgICAgICAgY29uc3QgYm90dG9tV2VpZ2h0ID0gV3VRdWFudC5fYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgdGhpcy5fd2VpZ2h0cykgfCAwO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSAwLjA7XHJcbiAgICAgICAgbGV0IGN1dFBvc2l0aW9uID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb24gPSBmaXJzdDsgcG9zaXRpb24gPCBsYXN0OyArK3Bvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZXMgdGhlIGN1YmUgY3V0IGF0IGEgY2VydGFpbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBsZXQgaGFsZlJlZCA9IGJvdHRvbVJlZCArIFd1UXVhbnQuX3RvcChjdWJlLCBkaXJlY3Rpb24sIHBvc2l0aW9uLCB0aGlzLl9tb21lbnRzUmVkKTtcclxuICAgICAgICAgICAgbGV0IGhhbGZHcmVlbiA9IGJvdHRvbUdyZWVuICsgV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX21vbWVudHNHcmVlbik7XHJcbiAgICAgICAgICAgIGxldCBoYWxmQmx1ZSA9IGJvdHRvbUJsdWUgKyBXdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fbW9tZW50c0JsdWUpO1xyXG4gICAgICAgICAgICBsZXQgaGFsZkFscGhhID0gYm90dG9tQWxwaGEgKyBXdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fbW9tZW50c0FscGhhKTtcclxuICAgICAgICAgICAgbGV0IGhhbGZXZWlnaHQgPSBib3R0b21XZWlnaHQgKyBXdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fd2VpZ2h0cyk7XHJcbiAgICAgICAgICAgIC8vIHRoZSBjdWJlIGNhbm5vdCBiZSBjdXQgYXQgYm90dG9tICh0aGlzIHdvdWxkIGxlYWQgdG8gZW1wdHkgY3ViZSlcclxuICAgICAgICAgICAgaWYgKGhhbGZXZWlnaHQgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBoYWxmRGlzdGFuY2UgPSBoYWxmUmVkICogaGFsZlJlZCArIGhhbGZHcmVlbiAqIGhhbGZHcmVlbiArIGhhbGZCbHVlICogaGFsZkJsdWUgKyBoYWxmQWxwaGEgKiBoYWxmQWxwaGE7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGhhbGZEaXN0YW5jZSAvIGhhbGZXZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBoYWxmUmVkID0gd2hvbGVSZWQgLSBoYWxmUmVkO1xyXG4gICAgICAgICAgICAgICAgaGFsZkdyZWVuID0gd2hvbGVHcmVlbiAtIGhhbGZHcmVlbjtcclxuICAgICAgICAgICAgICAgIGhhbGZCbHVlID0gd2hvbGVCbHVlIC0gaGFsZkJsdWU7XHJcbiAgICAgICAgICAgICAgICBoYWxmQWxwaGEgPSB3aG9sZUFscGhhIC0gaGFsZkFscGhhO1xyXG4gICAgICAgICAgICAgICAgaGFsZldlaWdodCA9IHdob2xlV2VpZ2h0IC0gaGFsZldlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmIChoYWxmV2VpZ2h0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFsZkRpc3RhbmNlID0gaGFsZlJlZCAqIGhhbGZSZWQgKyBoYWxmR3JlZW4gKiBoYWxmR3JlZW4gKyBoYWxmQmx1ZSAqIGhhbGZCbHVlICsgaGFsZkFscGhhICogaGFsZkFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgKz0gaGFsZkRpc3RhbmNlIC8gaGFsZldlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcCA+IHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBtYXg6IHJlc3VsdCwgcG9zaXRpb246IGN1dFBvc2l0aW9uIH07XHJcbiAgICB9XHJcbiAgICAvLyBDdXRzIGEgY3ViZSB3aXRoIGFub3RoZXIgb25lLlxyXG4gICAgX2N1dChmaXJzdCwgc2Vjb25kKSB7XHJcbiAgICAgICAgbGV0IGRpcmVjdGlvbjtcclxuICAgICAgICBjb25zdCB3aG9sZVJlZCA9IFd1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fbW9tZW50c1JlZCk7XHJcbiAgICAgICAgY29uc3Qgd2hvbGVHcmVlbiA9IFd1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fbW9tZW50c0dyZWVuKTtcclxuICAgICAgICBjb25zdCB3aG9sZUJsdWUgPSBXdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNCbHVlKTtcclxuICAgICAgICBjb25zdCB3aG9sZUFscGhhID0gV3VRdWFudC5fdm9sdW1lKGZpcnN0LCB0aGlzLl9tb21lbnRzQWxwaGEpO1xyXG4gICAgICAgIGNvbnN0IHdob2xlV2VpZ2h0ID0gV3VRdWFudC5fdm9sdW1lKGZpcnN0LCB0aGlzLl93ZWlnaHRzKTtcclxuICAgICAgICBjb25zdCByZWQgPSB0aGlzLl9tYXhpbWl6ZShmaXJzdCwgV3VRdWFudC5fcmVkLCBmaXJzdC5yZWRNaW5pbXVtICsgMSwgZmlyc3QucmVkTWF4aW11bSwgd2hvbGVSZWQsIHdob2xlR3JlZW4sIHdob2xlQmx1ZSwgd2hvbGVBbHBoYSwgd2hvbGVXZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IGdyZWVuID0gdGhpcy5fbWF4aW1pemUoZmlyc3QsIFd1UXVhbnQuX2dyZWVuLCBmaXJzdC5ncmVlbk1pbmltdW0gKyAxLCBmaXJzdC5ncmVlbk1heGltdW0sIHdob2xlUmVkLCB3aG9sZUdyZWVuLCB3aG9sZUJsdWUsIHdob2xlQWxwaGEsIHdob2xlV2VpZ2h0KTtcclxuICAgICAgICBjb25zdCBibHVlID0gdGhpcy5fbWF4aW1pemUoZmlyc3QsIFd1UXVhbnQuX2JsdWUsIGZpcnN0LmJsdWVNaW5pbXVtICsgMSwgZmlyc3QuYmx1ZU1heGltdW0sIHdob2xlUmVkLCB3aG9sZUdyZWVuLCB3aG9sZUJsdWUsIHdob2xlQWxwaGEsIHdob2xlV2VpZ2h0KTtcclxuICAgICAgICBjb25zdCBhbHBoYSA9IHRoaXMuX21heGltaXplKGZpcnN0LCBXdVF1YW50Ll9hbHBoYSwgZmlyc3QuYWxwaGFNaW5pbXVtICsgMSwgZmlyc3QuYWxwaGFNYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XHJcbiAgICAgICAgaWYgKGFscGhhLm1heCA+PSByZWQubWF4ICYmIGFscGhhLm1heCA+PSBncmVlbi5tYXggJiYgYWxwaGEubWF4ID49IGJsdWUubWF4KSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IFd1UXVhbnQuX2FscGhhO1xyXG4gICAgICAgICAgICAvLyBjYW5ub3Qgc3BsaXQgZW1wdHkgY3ViZVxyXG4gICAgICAgICAgICBpZiAoYWxwaGEucG9zaXRpb24gPCAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJlZC5tYXggPj0gYWxwaGEubWF4ICYmIHJlZC5tYXggPj0gZ3JlZW4ubWF4ICYmIHJlZC5tYXggPj0gYmx1ZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFd1UXVhbnQuX3JlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChncmVlbi5tYXggPj0gYWxwaGEubWF4ICYmIGdyZWVuLm1heCA+PSByZWQubWF4ICYmIGdyZWVuLm1heCA+PSBibHVlLm1heCkge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gV3VRdWFudC5fZ3JlZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBXdVF1YW50Ll9ibHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlY29uZC5yZWRNYXhpbXVtID0gZmlyc3QucmVkTWF4aW11bTtcclxuICAgICAgICBzZWNvbmQuZ3JlZW5NYXhpbXVtID0gZmlyc3QuZ3JlZW5NYXhpbXVtO1xyXG4gICAgICAgIHNlY29uZC5ibHVlTWF4aW11bSA9IGZpcnN0LmJsdWVNYXhpbXVtO1xyXG4gICAgICAgIHNlY29uZC5hbHBoYU1heGltdW0gPSBmaXJzdC5hbHBoYU1heGltdW07XHJcbiAgICAgICAgLy8gY3V0cyBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uXHJcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9yZWQ6XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQucmVkTWluaW11bSA9IGZpcnN0LnJlZE1heGltdW0gPSByZWQucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQuZ3JlZW5NaW5pbXVtID0gZmlyc3QuZ3JlZW5NaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLmJsdWVNaW5pbXVtID0gZmlyc3QuYmx1ZU1pbmltdW07XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQuYWxwaGFNaW5pbXVtID0gZmlyc3QuYWxwaGFNaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fZ3JlZW46XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQuZ3JlZW5NaW5pbXVtID0gZmlyc3QuZ3JlZW5NYXhpbXVtID0gZ3JlZW4ucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQucmVkTWluaW11bSA9IGZpcnN0LnJlZE1pbmltdW07XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQuYmx1ZU1pbmltdW0gPSBmaXJzdC5ibHVlTWluaW11bTtcclxuICAgICAgICAgICAgICAgIHNlY29uZC5hbHBoYU1pbmltdW0gPSBmaXJzdC5hbHBoYU1pbmltdW07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9ibHVlOlxyXG4gICAgICAgICAgICAgICAgc2Vjb25kLmJsdWVNaW5pbXVtID0gZmlyc3QuYmx1ZU1heGltdW0gPSBibHVlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLnJlZE1pbmltdW0gPSBmaXJzdC5yZWRNaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLmdyZWVuTWluaW11bSA9IGZpcnN0LmdyZWVuTWluaW11bTtcclxuICAgICAgICAgICAgICAgIHNlY29uZC5hbHBoYU1pbmltdW0gPSBmaXJzdC5hbHBoYU1pbmltdW07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9hbHBoYTpcclxuICAgICAgICAgICAgICAgIHNlY29uZC5hbHBoYU1pbmltdW0gPSBmaXJzdC5hbHBoYU1heGltdW0gPSBhbHBoYS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHNlY29uZC5ibHVlTWluaW11bSA9IGZpcnN0LmJsdWVNaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLnJlZE1pbmltdW0gPSBmaXJzdC5yZWRNaW5pbXVtO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kLmdyZWVuTWluaW11bSA9IGZpcnN0LmdyZWVuTWluaW11bTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZXRlcm1pbmVzIHRoZSB2b2x1bWVzIGFmdGVyIGN1dFxyXG4gICAgICAgIGZpcnN0LnZvbHVtZSA9IChmaXJzdC5yZWRNYXhpbXVtIC0gZmlyc3QucmVkTWluaW11bSkgKiAoZmlyc3QuZ3JlZW5NYXhpbXVtIC0gZmlyc3QuZ3JlZW5NaW5pbXVtKSAqIChmaXJzdC5ibHVlTWF4aW11bSAtIGZpcnN0LmJsdWVNaW5pbXVtKSAqIChmaXJzdC5hbHBoYU1heGltdW0gLSBmaXJzdC5hbHBoYU1pbmltdW0pO1xyXG4gICAgICAgIHNlY29uZC52b2x1bWUgPSAoc2Vjb25kLnJlZE1heGltdW0gLSBzZWNvbmQucmVkTWluaW11bSkgKiAoc2Vjb25kLmdyZWVuTWF4aW11bSAtIHNlY29uZC5ncmVlbk1pbmltdW0pICogKHNlY29uZC5ibHVlTWF4aW11bSAtIHNlY29uZC5ibHVlTWluaW11bSkgKiAoc2Vjb25kLmFscGhhTWF4aW11bSAtIHNlY29uZC5hbHBoYU1pbmltdW0pO1xyXG4gICAgICAgIC8vIHRoZSBjdXQgd2FzIHN1Y2Nlc3NmdWxcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKGNvbG9ycykge1xyXG4gICAgICAgIHRoaXMuX2NvbG9ycyA9IGNvbG9ycztcclxuICAgICAgICAvLyBjcmVhdGVzIGFsbCB0aGUgX2N1YmVzXHJcbiAgICAgICAgdGhpcy5fY3ViZXMgPSBbXTtcclxuICAgICAgICAvLyBpbml0aWFsaXplcyBhbGwgdGhlIF9jdWJlc1xyXG4gICAgICAgIGZvciAobGV0IGN1YmVJbmRleCA9IDA7IGN1YmVJbmRleCA8IGNvbG9yczsgY3ViZUluZGV4KyspIHtcclxuICAgICAgICAgICAgdGhpcy5fY3ViZXNbY3ViZUluZGV4XSA9IG5ldyBXdUNvbG9yQ3ViZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNldHMgdGhlIHJlZmVyZW5jZSBtaW5pbXVtc1xyXG4gICAgICAgIHRoaXMuX2N1YmVzWzBdLnJlZE1pbmltdW0gPSAwO1xyXG4gICAgICAgIHRoaXMuX2N1YmVzWzBdLmdyZWVuTWluaW11bSA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0uYmx1ZU1pbmltdW0gPSAwO1xyXG4gICAgICAgIHRoaXMuX2N1YmVzWzBdLmFscGhhTWluaW11bSA9IDA7XHJcbiAgICAgICAgLy8gcmVzZXRzIHRoZSByZWZlcmVuY2UgbWF4aW11bXNcclxuICAgICAgICB0aGlzLl9jdWJlc1swXS5yZWRNYXhpbXVtID0gdGhpcy5fbWF4U2lkZUluZGV4O1xyXG4gICAgICAgIHRoaXMuX2N1YmVzWzBdLmdyZWVuTWF4aW11bSA9IHRoaXMuX21heFNpZGVJbmRleDtcclxuICAgICAgICB0aGlzLl9jdWJlc1swXS5ibHVlTWF4aW11bSA9IHRoaXMuX21heFNpZGVJbmRleDtcclxuICAgICAgICB0aGlzLl9jdWJlc1swXS5hbHBoYU1heGltdW0gPSB0aGlzLl9hbHBoYU1heFNpZGVJbmRleDtcclxuICAgICAgICB0aGlzLl93ZWlnaHRzID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICB0aGlzLl9tb21lbnRzUmVkID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICB0aGlzLl9tb21lbnRzR3JlZW4gPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX21vbWVudHNCbHVlID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcclxuICAgICAgICB0aGlzLl9tb21lbnRzQWxwaGEgPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX21vbWVudHMgPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3RhYmxlID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgdGFibGVJbmRleCA9IDA7IHRhYmxlSW5kZXggPCAyNTY7ICsrdGFibGVJbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLl90YWJsZVt0YWJsZUluZGV4XSA9IHRhYmxlSW5kZXggKiB0YWJsZUluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9waXhlbHMgPSBbXTtcclxuICAgIH1cclxuICAgIF9zZXRRdWFsaXR5KHNpZ25pZmljYW50Qml0c1BlckNoYW5uZWwgPSA1KSB7XHJcbiAgICAgICAgdGhpcy5fc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbCA9IHNpZ25pZmljYW50Qml0c1BlckNoYW5uZWw7XHJcbiAgICAgICAgdGhpcy5fbWF4U2lkZUluZGV4ID0gMSA8PCB0aGlzLl9zaWduaWZpY2FudEJpdHNQZXJDaGFubmVsO1xyXG4gICAgICAgIHRoaXMuX2FscGhhTWF4U2lkZUluZGV4ID0gdGhpcy5fbWF4U2lkZUluZGV4O1xyXG4gICAgICAgIHRoaXMuX3NpZGVTaXplID0gdGhpcy5fbWF4U2lkZUluZGV4ICsgMTtcclxuICAgICAgICB0aGlzLl9hbHBoYVNpZGVTaXplID0gdGhpcy5fYWxwaGFNYXhTaWRlSW5kZXggKyAxO1xyXG4gICAgfVxyXG59XHJcbld1UXVhbnQuX2FscGhhID0gMztcclxuV3VRdWFudC5fcmVkID0gMjtcclxuV3VRdWFudC5fZ3JlZW4gPSAxO1xyXG5XdVF1YW50Ll9ibHVlID0gMDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3VRdWFudC5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGlxLnRzIC0gSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcclxuICovXHJcbmV4cG9ydCB7IHNzaW0gfSBmcm9tICcuL3NzaW0nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBZIH0gZnJvbSAnLi4vY29uc3RhbnRzL2J0NzA5JztcclxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3JoeXMtZS9zdHJ1Y3R1cmFsLXNpbWlsYXJpdHlcclxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdHJ1Y3R1cmFsX3NpbWlsYXJpdHlcclxuY29uc3QgSzEgPSAwLjAxOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5hbWluZy1jb252ZW50aW9uXHJcbmNvbnN0IEsyID0gMC4wMzsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgZnVuY3Rpb24gc3NpbShpbWFnZTEsIGltYWdlMikge1xyXG4gICAgaWYgKGltYWdlMS5nZXRIZWlnaHQoKSAhPT0gaW1hZ2UyLmdldEhlaWdodCgpIHx8IGltYWdlMS5nZXRXaWR0aCgpICE9PSBpbWFnZTIuZ2V0V2lkdGgoKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2VzIGhhdmUgZGlmZmVyZW50IHNpemVzIScpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYml0c1BlckNvbXBvbmVudCA9IDg7XHJcbiAgICBjb25zdCBMID0gKDEgPDwgYml0c1BlckNvbXBvbmVudCkgLSAxOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5hbWluZy1jb252ZW50aW9uXHJcbiAgICBjb25zdCBjMSA9IE1hdGgucG93KChLMSAqIEwpLCAyKTtcclxuICAgIGNvbnN0IGMyID0gTWF0aC5wb3coKEsyICogTCksIDIpO1xyXG4gICAgbGV0IG51bVdpbmRvd3MgPSAwO1xyXG4gICAgbGV0IG1zc2ltID0gMC4wO1xyXG4gICAgLy8gY2FsY3VsYXRlIHNzaW0gZm9yIGVhY2ggd2luZG93XHJcbiAgICBpdGVyYXRlKGltYWdlMSwgaW1hZ2UyLCAobHVtYVZhbHVlczEsIGx1bWFWYWx1ZXMyLCBhdmVyYWdlTHVtYVZhbHVlMSwgYXZlcmFnZUx1bWFWYWx1ZTIpID0+IHtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgdmFyaWFuY2UgYW5kIGNvdmFyaWFuY2VcclxuICAgICAgICBsZXQgc2lneHkgPSAwLjA7XHJcbiAgICAgICAgbGV0IHNpZ3NxeCA9IDAuMDtcclxuICAgICAgICBsZXQgc2lnc3F5ID0gMC4wO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHVtYVZhbHVlczEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2lnc3F4ICs9IE1hdGgucG93KChsdW1hVmFsdWVzMVtpXSAtIGF2ZXJhZ2VMdW1hVmFsdWUxKSwgMik7XHJcbiAgICAgICAgICAgIHNpZ3NxeSArPSBNYXRoLnBvdygobHVtYVZhbHVlczJbaV0gLSBhdmVyYWdlTHVtYVZhbHVlMiksIDIpO1xyXG4gICAgICAgICAgICBzaWd4eSArPSAobHVtYVZhbHVlczFbaV0gLSBhdmVyYWdlTHVtYVZhbHVlMSkgKiAobHVtYVZhbHVlczJbaV0gLSBhdmVyYWdlTHVtYVZhbHVlMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG51bVBpeGVsc0luV2luID0gbHVtYVZhbHVlczEubGVuZ3RoIC0gMTtcclxuICAgICAgICBzaWdzcXggLz0gbnVtUGl4ZWxzSW5XaW47XHJcbiAgICAgICAgc2lnc3F5IC89IG51bVBpeGVsc0luV2luO1xyXG4gICAgICAgIHNpZ3h5IC89IG51bVBpeGVsc0luV2luO1xyXG4gICAgICAgIC8vIHBlcmZvcm0gc3NpbSBjYWxjdWxhdGlvbiBvbiB3aW5kb3dcclxuICAgICAgICBjb25zdCBudW1lcmF0b3IgPSAoMiAqIGF2ZXJhZ2VMdW1hVmFsdWUxICogYXZlcmFnZUx1bWFWYWx1ZTIgKyBjMSkgKiAoMiAqIHNpZ3h5ICsgYzIpO1xyXG4gICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gKE1hdGgucG93KGF2ZXJhZ2VMdW1hVmFsdWUxLCAyKSArIE1hdGgucG93KGF2ZXJhZ2VMdW1hVmFsdWUyLCAyKSArIGMxKSAqIChzaWdzcXggKyBzaWdzcXkgKyBjMik7XHJcbiAgICAgICAgY29uc3Qgc3NpbSA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xyXG4gICAgICAgIG1zc2ltICs9IHNzaW07XHJcbiAgICAgICAgbnVtV2luZG93cysrO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbXNzaW0gLyBudW1XaW5kb3dzO1xyXG59XHJcbmZ1bmN0aW9uIGl0ZXJhdGUoaW1hZ2UxLCBpbWFnZTIsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCB3aW5kb3dTaXplID0gODtcclxuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2UxLmdldFdpZHRoKCk7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZTEuZ2V0SGVpZ2h0KCk7XHJcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSB3aW5kb3dTaXplKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCArPSB3aW5kb3dTaXplKSB7XHJcbiAgICAgICAgICAgIC8vIGF2b2lkIG91dC1vZi13aWR0aC9oZWlnaHRcclxuICAgICAgICAgICAgY29uc3Qgd2luZG93V2lkdGggPSBNYXRoLm1pbih3aW5kb3dTaXplLCB3aWR0aCAtIHgpO1xyXG4gICAgICAgICAgICBjb25zdCB3aW5kb3dIZWlnaHQgPSBNYXRoLm1pbih3aW5kb3dTaXplLCBoZWlnaHQgLSB5KTtcclxuICAgICAgICAgICAgY29uc3QgbHVtYVZhbHVlczEgPSBjYWxjdWxhdGVMdW1hVmFsdWVzRm9yV2luZG93KGltYWdlMSwgeCwgeSwgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGx1bWFWYWx1ZXMyID0gY2FsY3VsYXRlTHVtYVZhbHVlc0ZvcldpbmRvdyhpbWFnZTIsIHgsIHksIHdpbmRvd1dpZHRoLCB3aW5kb3dIZWlnaHQpO1xyXG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlTHVtYTEgPSBjYWxjdWxhdGVBdmVyYWdlTHVtYShsdW1hVmFsdWVzMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VMdW1hMiA9IGNhbGN1bGF0ZUF2ZXJhZ2VMdW1hKGx1bWFWYWx1ZXMyKTtcclxuICAgICAgICAgICAgY2FsbGJhY2sobHVtYVZhbHVlczEsIGx1bWFWYWx1ZXMyLCBhdmVyYWdlTHVtYTEsIGF2ZXJhZ2VMdW1hMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUx1bWFWYWx1ZXNGb3JXaW5kb3coaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGNvbnN0IHBvaW50QXJyYXkgPSBpbWFnZS5nZXRQb2ludEFycmF5KCk7XHJcbiAgICBjb25zdCBsdW1hVmFsdWVzID0gW107XHJcbiAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICBmb3IgKGxldCBqID0geTsgaiA8IHkgKyBoZWlnaHQ7IGorKykge1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGogKiBpbWFnZS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB4OyBpIDwgeCArIHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludEFycmF5W29mZnNldCArIGldO1xyXG4gICAgICAgICAgICBsdW1hVmFsdWVzW2NvdW50ZXJdID0gcG9pbnQuciAqIFkuUkVEICsgcG9pbnQuZyAqIFkuR1JFRU4gKyBwb2ludC5iICogWS5CTFVFO1xyXG4gICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGx1bWFWYWx1ZXM7XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlQXZlcmFnZUx1bWEobHVtYVZhbHVlcykge1xyXG4gICAgbGV0IHN1bUx1bWEgPSAwLjA7XHJcbiAgICBmb3IgKGNvbnN0IGx1bWEgb2YgbHVtYVZhbHVlcykge1xyXG4gICAgICAgIHN1bUx1bWEgKz0gbHVtYTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdW1MdW1hIC8gbHVtYVZhbHVlcy5sZW5ndGg7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3NpbS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gZGVncmVlczJyYWRpYW5zKG4pIHtcclxuICAgIHJldHVybiBuICogKE1hdGguUEkgLyAxODApO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBtYXgzKGEsIGIsIGMpIHtcclxuICAgIGxldCBtID0gYTtcclxuICAgIGlmIChtIDwgYilcclxuICAgICAgICBtID0gYjtcclxuICAgIGlmIChtIDwgYylcclxuICAgICAgICBtID0gYztcclxuICAgIHJldHVybiBtO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBtaW4zKGEsIGIsIGMpIHtcclxuICAgIGxldCBtID0gYTtcclxuICAgIGlmIChtID4gYilcclxuICAgICAgICBtID0gYjtcclxuICAgIGlmIChtID4gYylcclxuICAgICAgICBtID0gYztcclxuICAgIHJldHVybiBtO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRJblJhbmdlKHZhbHVlLCBsb3csIGhpZ2gpIHtcclxuICAgIGlmICh2YWx1ZSA+IGhpZ2gpXHJcbiAgICAgICAgdmFsdWUgPSBoaWdoO1xyXG4gICAgaWYgKHZhbHVlIDwgbG93KVxyXG4gICAgICAgIHZhbHVlID0gbG93O1xyXG4gICAgcmV0dXJuIHZhbHVlIHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaW5SYW5nZTB0bzI1NVJvdW5kZWQobikge1xyXG4gICAgbiA9IE1hdGgucm91bmQobik7XHJcbiAgICBpZiAobiA+IDI1NSlcclxuICAgICAgICBuID0gMjU1O1xyXG4gICAgZWxzZSBpZiAobiA8IDApXHJcbiAgICAgICAgbiA9IDA7XHJcbiAgICByZXR1cm4gbjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaW5SYW5nZTB0bzI1NShuKSB7XHJcbiAgICBpZiAobiA+IDI1NSlcclxuICAgICAgICBuID0gMjU1O1xyXG4gICAgZWxzZSBpZiAobiA8IDApXHJcbiAgICAgICAgbiA9IDA7XHJcbiAgICByZXR1cm4gbjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RhYmxlU29ydChhcnJheVRvU29ydCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJyYXlUb1NvcnRbMF07XHJcbiAgICBsZXQgc29ydGVkO1xyXG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uc3Qgb3JkID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1udWxsLWtleXdvcmRcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5VG9Tb3J0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2YWwgPSBhcnJheVRvU29ydFtpXTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1hbnlcclxuICAgICAgICAgICAgaWYgKG9yZFt2YWxdIHx8IG9yZFt2YWxdID09PSAwKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIG9yZFt2YWxdID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc29ydGVkID0gYXJyYXlUb1NvcnQuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYSwgYikgfHwgb3JkW2FdIC0gb3JkW2JdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgb3JkMiA9IGFycmF5VG9Tb3J0LnNsaWNlKDApO1xyXG4gICAgICAgIHNvcnRlZCA9IGFycmF5VG9Tb3J0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIpIHx8IG9yZDIuaW5kZXhPZihhKSAtIG9yZDIuaW5kZXhPZihiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzb3J0ZWQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJpdGhtZXRpYy5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIGh1ZVN0YXRpc3RpY3MudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgeyByZ2IyaHNsIH0gZnJvbSAnLi4vY29udmVyc2lvbi9yZ2IyaHNsJztcclxuaW1wb3J0IHsgaHVlR3JvdXAgfSBmcm9tICcuL3BhbGV0dGUnO1xyXG5jbGFzcyBIdWVHcm91cCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xzID0gW107XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEh1ZVN0YXRpc3RpY3Mge1xyXG4gICAgY29uc3RydWN0b3IobnVtR3JvdXBzLCBtaW5Db2xzKSB7XHJcbiAgICAgICAgdGhpcy5fbnVtR3JvdXBzID0gbnVtR3JvdXBzO1xyXG4gICAgICAgIHRoaXMuX21pbkNvbHMgPSBtaW5Db2xzO1xyXG4gICAgICAgIHRoaXMuX3N0YXRzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbnVtR3JvdXBzOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdHNbaV0gPSBuZXcgSHVlR3JvdXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JvdXBzRnVsbCA9IDA7XHJcbiAgICB9XHJcbiAgICBjaGVjayhpMzIpIHtcclxuICAgICAgICBpZiAodGhpcy5fZ3JvdXBzRnVsbCA9PT0gdGhpcy5fbnVtR3JvdXBzICsgMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByID0gKGkzMiAmIDB4ZmYpO1xyXG4gICAgICAgIGNvbnN0IGcgPSAoaTMyID4+PiA4KSAmIDB4ZmY7XHJcbiAgICAgICAgY29uc3QgYiA9IChpMzIgPj4+IDE2KSAmIDB4ZmY7XHJcbiAgICAgICAgY29uc3QgaGcgPSAociA9PT0gZyAmJiBnID09PSBiKSA/IDAgOiAxICsgaHVlR3JvdXAocmdiMmhzbChyLCBnLCBiKS5oLCB0aGlzLl9udW1Hcm91cHMpO1xyXG4gICAgICAgIGNvbnN0IGdyID0gdGhpcy5fc3RhdHNbaGddO1xyXG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMuX21pbkNvbHM7XHJcbiAgICAgICAgZ3IubnVtKys7XHJcbiAgICAgICAgaWYgKGdyLm51bSA+IG1pbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnci5udW0gPT09IG1pbikge1xyXG4gICAgICAgICAgICB0aGlzLl9ncm91cHNGdWxsKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnci5udW0gPD0gbWluKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRzW2hnXS5jb2xzLnB1c2goaTMyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbmplY3RJbnRvRGljdGlvbmFyeShoaXN0Rykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuX251bUdyb3VwczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0c1tpXS5udW0gPD0gdGhpcy5fbWluQ29scykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHNbaV0uY29scy5mb3JFYWNoKChjb2wpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhpc3RHW2NvbF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdEdbY29sXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0R1tjb2xdKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbmplY3RJbnRvQXJyYXkoaGlzdEcpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLl9udW1Hcm91cHM7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdHNbaV0ubnVtIDw9IHRoaXMuX21pbkNvbHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRzW2ldLmNvbHMuZm9yRWFjaCgoY29sKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpc3RHLmluZGV4T2YoY29sKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdEcucHVzaChjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh1ZVN0YXRpc3RpY3MuanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XHJcbiAqL1xyXG5pbXBvcnQgKiBhcyBhcml0aG1ldGljIGZyb20gJy4vYXJpdGhtZXRpYyc7XHJcbmltcG9ydCB7IEh1ZVN0YXRpc3RpY3MgfSBmcm9tICcuL2h1ZVN0YXRpc3RpY3MnO1xyXG5pbXBvcnQgeyBQYWxldHRlIH0gZnJvbSAnLi9wYWxldHRlJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50JztcclxuaW1wb3J0IHsgUG9pbnRDb250YWluZXIgfSBmcm9tICcuL3BvaW50Q29udGFpbmVyJztcclxuaW1wb3J0IHsgUHJvZ3Jlc3NUcmFja2VyIH0gZnJvbSAnLi9wcm9ncmVzc1RyYWNrZXInO1xyXG5leHBvcnQgeyBQb2ludCwgUG9pbnRDb250YWluZXIsIFBhbGV0dGUsIEh1ZVN0YXRpc3RpY3MsIFByb2dyZXNzVHJhY2tlciwgYXJpdGhtZXRpYywgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXHJcbiAqIEBwcmVzZXJ2ZVxyXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxyXG4gKlxyXG4gKiBwYWxldHRlLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgUG9pbnRDb250YWluZXIgfSBmcm9tICcuL3BvaW50Q29udGFpbmVyJztcclxuaW1wb3J0IHsgcmdiMmhzbCB9IGZyb20gJy4uL2NvbnZlcnNpb24vcmdiMmhzbCc7XHJcbi8vIFRPRE86IG1ha2UgcGFsZXR0ZUFycmF5IHZpYSBwb2ludENvbnRhaW5lciwgc28sIGV4cG9ydCB3aWxsIGJlIGF2YWlsYWJsZSB2aWEgcG9pbnRDb250YWluZXIuZXhwb3J0WFhYXHJcbmNvbnN0IGh1ZUdyb3VwcyA9IDEwO1xyXG5leHBvcnQgZnVuY3Rpb24gaHVlR3JvdXAoaHVlLCBzZWdtZW50c051bWJlcikge1xyXG4gICAgY29uc3QgbWF4SHVlID0gMzYwO1xyXG4gICAgY29uc3Qgc2VnID0gbWF4SHVlIC8gc2VnbWVudHNOdW1iZXI7XHJcbiAgICBjb25zdCBoYWxmID0gc2VnIC8gMjtcclxuICAgIGZvciAobGV0IGkgPSAxLCBtaWQgPSBzZWcgLSBoYWxmOyBpIDwgc2VnbWVudHNOdW1iZXI7IGkrKywgbWlkICs9IHNlZykge1xyXG4gICAgICAgIGlmIChodWUgPj0gbWlkICYmIGh1ZSA8IG1pZCArIHNlZylcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5leHBvcnQgY2xhc3MgUGFsZXR0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9wb2ludEFycmF5ID0gW107XHJcbiAgICAgICAgdGhpcy5faTMyaWR4ID0ge307XHJcbiAgICAgICAgdGhpcy5fcG9pbnRDb250YWluZXIgPSBuZXcgUG9pbnRDb250YWluZXIoKTtcclxuICAgICAgICB0aGlzLl9wb2ludENvbnRhaW5lci5zZXRIZWlnaHQoMSk7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRBcnJheSA9IHRoaXMuX3BvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcclxuICAgIH1cclxuICAgIGFkZChjb2xvcikge1xyXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkucHVzaChjb2xvcik7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRDb250YWluZXIuc2V0V2lkdGgodGhpcy5fcG9pbnRBcnJheS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgaGFzKGNvbG9yKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yLnVpbnQzMiA9PT0gdGhpcy5fcG9pbnRBcnJheVtpXS51aW50MzIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gVE9UUlk6IHVzZSBIVVNMIC0gaHR0cDovL2Jvcm9uaW5lLmNvbS9odXNsLyBodHRwOi8vd3d3Lmh1c2wtY29sb3JzLm9yZy8gaHR0cHM6Ly9naXRodWIuY29tL2h1c2wtY29sb3JzL2h1c2xcclxuICAgIGdldE5lYXJlc3RDb2xvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRBcnJheVt0aGlzLl9nZXROZWFyZXN0SW5kZXgoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9yKSB8IDBdO1xyXG4gICAgfVxyXG4gICAgZ2V0UG9pbnRDb250YWluZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50Q29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgLy8gVE9UUlk6IHVzZSBIVVNMIC0gaHR0cDovL2Jvcm9uaW5lLmNvbS9odXNsL1xyXG4gICAgLypcclxuICAgICBwdWJsaWMgbmVhcmVzdEluZGV4QnlVaW50MzIoaTMyKSB7XHJcbiAgICAgdmFyIGlkeCA6IG51bWJlciA9IHRoaXMuX25lYXJlc3RQb2ludEZyb21DYWNoZShcIlwiICsgaTMyKTtcclxuICAgICBpZiAoaWR4ID49IDApIHJldHVybiBpZHg7XHJcbiAgXHJcbiAgICAgdmFyIG1pbiA9IDEwMDAsXHJcbiAgICAgcmdiID0gW1xyXG4gICAgIChpMzIgJiAweGZmKSxcclxuICAgICAoaTMyID4+PiA4KSAmIDB4ZmYsXHJcbiAgICAgKGkzMiA+Pj4gMTYpICYgMHhmZixcclxuICAgICAoaTMyID4+PiAyNCkgJiAweGZmXHJcbiAgICAgXSxcclxuICAgICBsZW4gPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aDtcclxuICBcclxuICAgICBpZHggPSAwO1xyXG4gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICB2YXIgZGlzdCA9IFV0aWxzLmRpc3RFdWNsaWRlYW4ocmdiLCB0aGlzLl9wb2ludEFycmF5W2ldLnJnYmEpO1xyXG4gIFxyXG4gICAgIGlmIChkaXN0IDwgbWluKSB7XHJcbiAgICAgbWluID0gZGlzdDtcclxuICAgICBpZHggPSBpO1xyXG4gICAgIH1cclxuICAgICB9XHJcbiAgXHJcbiAgICAgdGhpcy5faTMyaWR4W2kzMl0gPSBpZHg7XHJcbiAgICAgcmV0dXJuIGlkeDtcclxuICAgICB9XHJcbiAgICAgKi9cclxuICAgIF9uZWFyZXN0UG9pbnRGcm9tQ2FjaGUoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9pMzJpZHhba2V5XSA9PT0gJ251bWJlcicgPyB0aGlzLl9pMzJpZHhba2V5XSA6IC0xO1xyXG4gICAgfVxyXG4gICAgX2dldE5lYXJlc3RJbmRleChjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgcG9pbnQpIHtcclxuICAgICAgICBsZXQgaWR4ID0gdGhpcy5fbmVhcmVzdFBvaW50RnJvbUNhY2hlKCcnICsgcG9pbnQudWludDMyKTtcclxuICAgICAgICBpZiAoaWR4ID49IDApXHJcbiAgICAgICAgICAgIHJldHVybiBpZHg7XHJcbiAgICAgICAgbGV0IG1pbmltYWxEaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgaWR4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9wb2ludEFycmF5W2ldO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLmNhbGN1bGF0ZVJhdyhwb2ludC5yLCBwb2ludC5nLCBwb2ludC5iLCBwb2ludC5hLCBwLnIsIHAuZywgcC5iLCBwLmEpO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5pbWFsRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIG1pbmltYWxEaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWR4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pMzJpZHhbcG9pbnQudWludDMyXSA9IGlkeDtcclxuICAgICAgICByZXR1cm4gaWR4O1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICBwdWJsaWMgcmVkdWNlKGhpc3RvZ3JhbSA6IENvbG9ySGlzdG9ncmFtLCBjb2xvcnMgOiBudW1iZXIpIHtcclxuICAgICBpZiAodGhpcy5fcG9pbnRBcnJheS5sZW5ndGggPiBjb2xvcnMpIHtcclxuICAgICB2YXIgaWR4aTMyID0gaGlzdG9ncmFtLmdldEltcG9ydGFuY2VTb3J0ZWRDb2xvcnNJRFhJMzIoKTtcclxuICBcclxuICAgICAvLyBxdWFudGl6ZSBoaXN0b2dyYW0gdG8gZXhpc3RpbmcgcGFsZXR0ZVxyXG4gICAgIHZhciBrZWVwID0gW10sIHVuaXF1ZUNvbG9ycyA9IDAsIGlkeCwgcHJ1bmVkID0gZmFsc2U7XHJcbiAgXHJcbiAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkeGkzMi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgIC8vIHBhbGV0dGUgbGVuZ3RoIHJlYWNoZWQsIHVuc2V0IGFsbCByZW1haW5pbmcgY29sb3JzIChzcGFyc2UgcGFsZXR0ZSlcclxuICAgICBpZiAodW5pcXVlQ29sb3JzID49IGNvbG9ycykge1xyXG4gICAgIHRoaXMucHJ1bmVQYWwoa2VlcCk7XHJcbiAgICAgcHJ1bmVkID0gdHJ1ZTtcclxuICAgICBicmVhaztcclxuICAgICB9IGVsc2Uge1xyXG4gICAgIGlkeCA9IHRoaXMubmVhcmVzdEluZGV4QnlVaW50MzIoaWR4aTMyW2ldKTtcclxuICAgICBpZiAoa2VlcC5pbmRleE9mKGlkeCkgPCAwKSB7XHJcbiAgICAga2VlcC5wdXNoKGlkeCk7XHJcbiAgICAgdW5pcXVlQ29sb3JzKys7XHJcbiAgICAgfVxyXG4gICAgIH1cclxuICAgICB9XHJcbiAgXHJcbiAgICAgaWYgKCFwcnVuZWQpIHtcclxuICAgICB0aGlzLnBydW5lUGFsKGtlZXApO1xyXG4gICAgIH1cclxuICAgICB9XHJcbiAgICAgfVxyXG4gIFxyXG4gICAgIC8vIFRPRE86IGNoZWNrIHVzYWdlLCBub3QgdGVzdGVkIVxyXG4gICAgIHB1YmxpYyBwcnVuZVBhbChrZWVwIDogbnVtYmVyW10pIHtcclxuICAgICB2YXIgY29sb3JzID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7XHJcbiAgICAgZm9yICh2YXIgY29sb3JJbmRleCA9IGNvbG9ycyAtIDE7IGNvbG9ySW5kZXggPj0gMDsgY29sb3JJbmRleC0tKSB7XHJcbiAgICAgaWYgKGtlZXAuaW5kZXhPZihjb2xvckluZGV4KSA8IDApIHtcclxuICBcclxuICAgICBpZihjb2xvckluZGV4ICsgMSA8IGNvbG9ycykge1xyXG4gICAgIHRoaXMuX3BvaW50QXJyYXlbIGNvbG9ySW5kZXggXSA9IHRoaXMuX3BvaW50QXJyYXkgWyBjb2xvcnMgLSAxIF07XHJcbiAgICAgfVxyXG4gICAgIC0tY29sb3JzO1xyXG4gICAgIC8vdGhpcy5fcG9pbnRBcnJheVtjb2xvckluZGV4XSA9IG51bGw7XHJcbiAgICAgfVxyXG4gICAgIH1cclxuICAgICBjb25zb2xlLmxvZyhcImNvbG9ycyBwcnVuZWQ6IFwiICsgKHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoIC0gY29sb3JzKSk7XHJcbiAgICAgdGhpcy5fcG9pbnRBcnJheS5sZW5ndGggPSBjb2xvcnM7XHJcbiAgICAgdGhpcy5faTMyaWR4ID0ge307XHJcbiAgICAgfVxyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBncm91cCB2ZXJ5IGxvdyBsdW0gYW5kIHZlcnkgaGlnaCBsdW0gY29sb3JzXHJcbiAgICAvLyBUT0RPOiBwYXNzIGN1c3RvbSBzb3J0IG9yZGVyXHJcbiAgICAvLyBUT0RPOiBzb3J0IGNyaXRlcmlhIGZ1bmN0aW9uIHNob3VsZCBiZSBwbGFjZWQgdG8gSHVlU3RhdHMgY2xhc3NcclxuICAgIHNvcnQoKSB7XHJcbiAgICAgICAgdGhpcy5faTMyaWR4ID0ge307XHJcbiAgICAgICAgdGhpcy5fcG9pbnRBcnJheS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhzbEEgPSByZ2IyaHNsKGEuciwgYS5nLCBhLmIpO1xyXG4gICAgICAgICAgICBjb25zdCBoc2xCID0gcmdiMmhzbChiLnIsIGIuZywgYi5iKTtcclxuICAgICAgICAgICAgLy8gc29ydCBhbGwgZ3JheXMgKyB3aGl0ZXMgdG9nZXRoZXJcclxuICAgICAgICAgICAgY29uc3QgaHVlQSA9IChhLnIgPT09IGEuZyAmJiBhLmcgPT09IGEuYikgPyAwIDogMSArIGh1ZUdyb3VwKGhzbEEuaCwgaHVlR3JvdXBzKTtcclxuICAgICAgICAgICAgY29uc3QgaHVlQiA9IChiLnIgPT09IGIuZyAmJiBiLmcgPT09IGIuYikgPyAwIDogMSArIGh1ZUdyb3VwKGhzbEIuaCwgaHVlR3JvdXBzKTtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgIHZhciBodWVBID0gKGEuciA9PT0gYS5nICYmIGEuZyA9PT0gYS5iKSA/IDAgOiAxICsgVXRpbHMuaHVlR3JvdXAoaHNsQS5oLCBodWVHcm91cHMpO1xyXG4gICAgICAgICAgICAgdmFyIGh1ZUIgPSAoYi5yID09PSBiLmcgJiYgYi5nID09PSBiLmIpID8gMCA6IDEgKyBVdGlscy5odWVHcm91cChoc2xCLmgsIGh1ZUdyb3Vwcyk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCBodWVEaWZmID0gaHVlQiAtIGh1ZUE7XHJcbiAgICAgICAgICAgIGlmIChodWVEaWZmKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1odWVEaWZmO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgdmFyIGx1bURpZmYgPSBVdGlscy5sdW1Hcm91cCgraHNsQi5sLnRvRml4ZWQoMikpIC0gVXRpbHMubHVtR3JvdXAoK2hzbEEubC50b0ZpeGVkKDIpKTtcclxuICAgICAgICAgICAgIGlmIChsdW1EaWZmKSByZXR1cm4gLWx1bURpZmY7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCBsQSA9IGEuZ2V0THVtaW5vc2l0eSh0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgbEIgPSBiLmdldEx1bWlub3NpdHkodHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChsQiAtIGxBICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxCIC0gbEE7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhdERpZmYgPSAoKGhzbEIucyAqIDEwMCkgfCAwKSAtICgoaHNsQS5zICogMTAwKSB8IDApO1xyXG4gICAgICAgICAgICBpZiAoc2F0RGlmZilcclxuICAgICAgICAgICAgICAgIHJldHVybiAtc2F0RGlmZjtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFsZXR0ZS5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIHBvaW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgWSB9IGZyb20gJy4uL2NvbnN0YW50cy9idDcwOSc7XHJcbi8qKlxyXG4gKiB2OCBvcHRpbWl6ZWQgY2xhc3NcclxuICogMSkgXCJjb25zdHJ1Y3RvclwiIHNob3VsZCBoYXZlIGluaXRpYWxpemF0aW9uIHdpdGggd29yc3QgdHlwZXNcclxuICogMikgXCJzZXRcIiBzaG91bGQgaGF2ZSB8MCAvID4+PiAwXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9pbnQge1xyXG4gICAgLy8gTGFiIDogeyBMIDogbnVtYmVyOyBhIDogbnVtYmVyOyBiIDogbnVtYmVyIH07XHJcbiAgICBzdGF0aWMgY3JlYXRlQnlRdWFkcnVwbGV0KHF1YWRydXBsZXQpIHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCgpO1xyXG4gICAgICAgIHBvaW50LnIgPSBxdWFkcnVwbGV0WzBdIHwgMDtcclxuICAgICAgICBwb2ludC5nID0gcXVhZHJ1cGxldFsxXSB8IDA7XHJcbiAgICAgICAgcG9pbnQuYiA9IHF1YWRydXBsZXRbMl0gfCAwO1xyXG4gICAgICAgIHBvaW50LmEgPSBxdWFkcnVwbGV0WzNdIHwgMDtcclxuICAgICAgICBwb2ludC5fbG9hZFVJTlQzMigpO1xyXG4gICAgICAgIHBvaW50Ll9sb2FkUXVhZHJ1cGxldCgpO1xyXG4gICAgICAgIC8vIHBvaW50Ll9sb2FkTGFiKCk7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUJ5UkdCQShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KCk7XHJcbiAgICAgICAgcG9pbnQuciA9IHJlZCB8IDA7XHJcbiAgICAgICAgcG9pbnQuZyA9IGdyZWVuIHwgMDtcclxuICAgICAgICBwb2ludC5iID0gYmx1ZSB8IDA7XHJcbiAgICAgICAgcG9pbnQuYSA9IGFscGhhIHwgMDtcclxuICAgICAgICBwb2ludC5fbG9hZFVJTlQzMigpO1xyXG4gICAgICAgIHBvaW50Ll9sb2FkUXVhZHJ1cGxldCgpO1xyXG4gICAgICAgIC8vIHBvaW50Ll9sb2FkTGFiKCk7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUJ5VWludDMyKHVpbnQzMikge1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KCk7XHJcbiAgICAgICAgcG9pbnQudWludDMyID0gdWludDMyID4+PiAwO1xyXG4gICAgICAgIHBvaW50Ll9sb2FkUkdCQSgpO1xyXG4gICAgICAgIHBvaW50Ll9sb2FkUXVhZHJ1cGxldCgpO1xyXG4gICAgICAgIC8vIHBvaW50Ll9sb2FkTGFiKCk7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy51aW50MzIgPSAtMSA+Pj4gMDtcclxuICAgICAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSB0aGlzLmEgPSAwO1xyXG4gICAgICAgIHRoaXMucmdiYSA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgICB0aGlzLnJnYmFbMF0gPSAwO1xyXG4gICAgICAgIHRoaXMucmdiYVsxXSA9IDA7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzJdID0gMDtcclxuICAgICAgICB0aGlzLnJnYmFbM10gPSAwO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIHRoaXMuTGFiID0ge1xyXG4gICAgICAgICBMIDogMC4wLFxyXG4gICAgICAgICBhIDogMC4wLFxyXG4gICAgICAgICBiIDogMC4wXHJcbiAgICAgICAgIH07XHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcbiAgICBmcm9tKHBvaW50KSB7XHJcbiAgICAgICAgdGhpcy5yID0gcG9pbnQucjtcclxuICAgICAgICB0aGlzLmcgPSBwb2ludC5nO1xyXG4gICAgICAgIHRoaXMuYiA9IHBvaW50LmI7XHJcbiAgICAgICAgdGhpcy5hID0gcG9pbnQuYTtcclxuICAgICAgICB0aGlzLnVpbnQzMiA9IHBvaW50LnVpbnQzMjtcclxuICAgICAgICB0aGlzLnJnYmFbMF0gPSBwb2ludC5yO1xyXG4gICAgICAgIHRoaXMucmdiYVsxXSA9IHBvaW50Lmc7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzJdID0gcG9pbnQuYjtcclxuICAgICAgICB0aGlzLnJnYmFbM10gPSBwb2ludC5hO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIHRoaXMuTGFiLkwgPSBwb2ludC5MYWIuTDtcclxuICAgICAgICAgdGhpcy5MYWIuYSA9IHBvaW50LkxhYi5hO1xyXG4gICAgICAgICB0aGlzLkxhYi5iID0gcG9pbnQuTGFiLmI7XHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICogVE9ETzpcclxuICAgICBMdW1pbmFuY2UgZnJvbSBSR0I6XHJcbiAgXHJcbiAgICAgTHVtaW5hbmNlIChzdGFuZGFyZCBmb3IgY2VydGFpbiBjb2xvdXIgc3BhY2VzKTogKDAuMjEyNipSICsgMC43MTUyKkcgKyAwLjA3MjIqQikgWzFdXHJcbiAgICAgTHVtaW5hbmNlIChwZXJjZWl2ZWQgb3B0aW9uIDEpOiAoMC4yOTkqUiArIDAuNTg3KkcgKyAwLjExNCpCKSBbMl1cclxuICAgICBMdW1pbmFuY2UgKHBlcmNlaXZlZCBvcHRpb24gMiwgc2xvd2VyIHRvIGNhbGN1bGF0ZSk6ICBzcXJ0KCAwLjI0MSpSXjIgKyAwLjY5MSpHXjIgKyAwLjA2OCpCXjIgKSA/IHNxcnQoIDAuMjk5KlJeMiArIDAuNTg3KkdeMiArIDAuMTE0KkJeMiApICh0aGFua3MgdG8gQE1hdHRoZXdIZXJic3QpIFtodHRwOi8vYWxpZW5yeWRlcmZsZXguY29tL2hzcC5odG1sXVxyXG4gICAgICovXHJcbiAgICBnZXRMdW1pbm9zaXR5KHVzZUFscGhhQ2hhbm5lbCkge1xyXG4gICAgICAgIGxldCByID0gdGhpcy5yO1xyXG4gICAgICAgIGxldCBnID0gdGhpcy5nO1xyXG4gICAgICAgIGxldCBiID0gdGhpcy5iO1xyXG4gICAgICAgIGlmICh1c2VBbHBoYUNoYW5uZWwpIHtcclxuICAgICAgICAgICAgciA9IE1hdGgubWluKDI1NSwgMjU1IC0gdGhpcy5hICsgdGhpcy5hICogciAvIDI1NSk7XHJcbiAgICAgICAgICAgIGcgPSBNYXRoLm1pbigyNTUsIDI1NSAtIHRoaXMuYSArIHRoaXMuYSAqIGcgLyAyNTUpO1xyXG4gICAgICAgICAgICBiID0gTWF0aC5taW4oMjU1LCAyNTUgLSB0aGlzLmEgKyB0aGlzLmEgKiBiIC8gMjU1KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdmFyIGx1bWEgPSB0aGlzLnIgKiBQb2ludC5fUkVEX0NPRUZGSUNJRU5UICsgdGhpcy5nICogUG9pbnQuX0dSRUVOX0NPRUZGSUNJRU5UICsgdGhpcy5iICogUG9pbnQuX0JMVUVfQ09FRkZJQ0lFTlQ7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgaWYodXNlQWxwaGFDaGFubmVsKSB7XHJcbiAgICAgICAgIGx1bWEgPSAobHVtYSAqICgyNTUgLSB0aGlzLmEpKSAvIDI1NTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJldHVybiByICogWS5SRUQgKyBnICogWS5HUkVFTiArIGIgKiBZLkJMVUU7XHJcbiAgICB9XHJcbiAgICBfbG9hZFVJTlQzMigpIHtcclxuICAgICAgICB0aGlzLnVpbnQzMiA9ICh0aGlzLmEgPDwgMjQgfCB0aGlzLmIgPDwgMTYgfCB0aGlzLmcgPDwgOCB8IHRoaXMucikgPj4+IDA7XHJcbiAgICB9XHJcbiAgICBfbG9hZFJHQkEoKSB7XHJcbiAgICAgICAgdGhpcy5yID0gdGhpcy51aW50MzIgJiAweGZmO1xyXG4gICAgICAgIHRoaXMuZyA9ICh0aGlzLnVpbnQzMiA+Pj4gOCkgJiAweGZmO1xyXG4gICAgICAgIHRoaXMuYiA9ICh0aGlzLnVpbnQzMiA+Pj4gMTYpICYgMHhmZjtcclxuICAgICAgICB0aGlzLmEgPSAodGhpcy51aW50MzIgPj4+IDI0KSAmIDB4ZmY7XHJcbiAgICB9XHJcbiAgICBfbG9hZFF1YWRydXBsZXQoKSB7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzBdID0gdGhpcy5yO1xyXG4gICAgICAgIHRoaXMucmdiYVsxXSA9IHRoaXMuZztcclxuICAgICAgICB0aGlzLnJnYmFbMl0gPSB0aGlzLmI7XHJcbiAgICAgICAgdGhpcy5yZ2JhWzNdID0gdGhpcy5hO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIHZhciB4eXogPSByZ2IyeHl6KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xyXG4gICAgICAgICB2YXIgbGFiID0geHl6MmxhYih4eXoueCwgeHl6LnksIHh5ei56KTtcclxuICAgICAgICAgdGhpcy5sYWIubCA9IGxhYi5sO1xyXG4gICAgICAgICB0aGlzLmxhYi5hID0gbGFiLmE7XHJcbiAgICAgICAgIHRoaXMubGFiLmIgPSBsYWIuYjtcclxuICAgICAgICAgKi9cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2ludC5qcy5tYXAiLCIvKipcclxuICogQHByZXNlcnZlXHJcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXHJcbiAqXHJcbiAqIHBvaW50Q29udGFpbmVyLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxyXG4gKi9cclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50JztcclxuLyoqXHJcbiAqIHY4IG9wdGltaXphdGlvbnMgZG9uZS5cclxuICogZnJvbVhYWCBtZXRob2RzIGFyZSBzdGF0aWMgdG8gbW92ZSBvdXQgcG9seW1vcnBoaWMgY29kZSBmcm9tIGNsYXNzIGluc3RhbmNlIGl0c2VsZi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQb2ludENvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLl9wb2ludEFycmF5ID0gW107XHJcbiAgICB9XHJcbiAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIHNldFdpZHRoKHdpZHRoKSB7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgIH1cclxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBnZXRQb2ludEFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludEFycmF5O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgUG9pbnRDb250YWluZXIoKTtcclxuICAgICAgICBjbG9uZS5fd2lkdGggPSB0aGlzLl93aWR0aDtcclxuICAgICAgICBjbG9uZS5faGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgY2xvbmUuX3BvaW50QXJyYXlbaV0gPSBQb2ludC5jcmVhdGVCeVVpbnQzMih0aGlzLl9wb2ludEFycmF5W2ldLnVpbnQzMiB8IDApOyAvLyBcInwgMFwiIGlzIGFkZGVkIGZvciB2OCBvcHRpbWl6YXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG4gICAgdG9VaW50MzJBcnJheSgpIHtcclxuICAgICAgICBjb25zdCBsID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkobCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdWludDMyQXJyYXlbaV0gPSB0aGlzLl9wb2ludEFycmF5W2ldLnVpbnQzMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVpbnQzMkFycmF5O1xyXG4gICAgfVxyXG4gICAgdG9VaW50OEFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLnRvVWludDMyQXJyYXkoKS5idWZmZXIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21IVE1MSW1hZ2VFbGVtZW50KGltZykge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1nLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodDtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gUG9pbnRDb250YWluZXIuZnJvbUhUTUxDYW52YXNFbGVtZW50KGNhbnZhcyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUhUTUxDYW52YXNFbGVtZW50KGNhbnZhcykge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICAgICAgY29uc3QgaW1nRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21JbWFnZURhdGEoaW1nRGF0YSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUltYWdlRGF0YShpbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlRGF0YS53aWR0aDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tVWludDhBcnJheShpbWFnZURhdGEuZGF0YSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVVpbnQ4QXJyYXkodWludDhBcnJheSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHVpbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzpcclxuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBVaW50OEFycmF5XSc6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh1aW50OEFycmF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkodWludDhBcnJheS5idWZmZXIpO1xyXG4gICAgICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tVWludDMyQXJyYXkodWludDMyQXJyYXksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21VaW50MzJBcnJheSh1aW50MzJBcnJheSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBQb2ludENvbnRhaW5lcigpO1xyXG4gICAgICAgIGNvbnRhaW5lci5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjb250YWluZXIuX2hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHVpbnQzMkFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBjb250YWluZXIuX3BvaW50QXJyYXlbaV0gPSBQb2ludC5jcmVhdGVCeVVpbnQzMih1aW50MzJBcnJheVtpXSB8IDApOyAvLyBcInwgMFwiIGlzIGFkZGVkIGZvciB2OCBvcHRpbWl6YXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCAvIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcclxuICAgICAgICByZXR1cm4gUG9pbnRDb250YWluZXIuZnJvbVVpbnQzMkFycmF5KHVpbnQzMkFycmF5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2ludENvbnRhaW5lci5qcy5tYXAiLCJleHBvcnQgY2xhc3MgUHJvZ3Jlc3NUcmFja2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlUmFuZ2UsIHByb2dyZXNzUmFuZ2UpIHtcclxuICAgICAgICB0aGlzLl9yYW5nZSA9IHZhbHVlUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NSYW5nZSA9IHByb2dyZXNzUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5fc3RlcCA9IE1hdGgubWF4KDEsIHRoaXMuX3JhbmdlIC8gKFByb2dyZXNzVHJhY2tlci5zdGVwcyArIDEpIHwgMCk7XHJcbiAgICAgICAgdGhpcy5fbGFzdCA9IC10aGlzLl9zdGVwO1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xyXG4gICAgfVxyXG4gICAgc2hvdWxkTm90aWZ5KGN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoY3VycmVudCAtIHRoaXMuX2xhc3QgPj0gdGhpcy5fc3RlcCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gY3VycmVudDtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IE1hdGgubWluKHRoaXMuX3Byb2dyZXNzUmFuZ2UgKiB0aGlzLl9sYXN0IC8gdGhpcy5fcmFuZ2UsIHRoaXMuX3Byb2dyZXNzUmFuZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblByb2dyZXNzVHJhY2tlci5zdGVwcyA9IDEwMDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvZ3Jlc3NUcmFja2VyLmpzLm1hcCIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNJRSA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEzLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9vbWdnaWZcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuLy9cbi8vIG9tZ2dpZiBpcyBhIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBHSUYgODlhIGVuY29kZXIgYW5kIGRlY29kZXIsXG4vLyBpbmNsdWRpbmcgYW5pbWF0aW9uIGFuZCBjb21wcmVzc2lvbi4gIEl0IGRvZXMgbm90IHJlbHkgb24gYW55IHNwZWNpZmljXG4vLyB1bmRlcmx5aW5nIHN5c3RlbSwgc28gc2hvdWxkIHJ1biBpbiB0aGUgYnJvd3NlciwgTm9kZSwgb3IgUGxhc2suXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBHaWZXcml0ZXIoYnVmLCB3aWR0aCwgaGVpZ2h0LCBnb3B0cykge1xuICB2YXIgcCA9IDA7XG5cbiAgdmFyIGdvcHRzID0gZ29wdHMgPT09IHVuZGVmaW5lZCA/IHsgfSA6IGdvcHRzO1xuICB2YXIgbG9vcF9jb3VudCA9IGdvcHRzLmxvb3AgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5sb29wO1xuICB2YXIgZ2xvYmFsX3BhbGV0dGUgPSBnb3B0cy5wYWxldHRlID09PSB1bmRlZmluZWQgPyBudWxsIDogZ29wdHMucGFsZXR0ZTtcblxuICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCB8fCB3aWR0aCA+IDY1NTM1IHx8IGhlaWdodCA+IDY1NTM1KVxuICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKTtcblxuICBmdW5jdGlvbiBjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzKHBhbGV0dGUpIHtcbiAgICB2YXIgbnVtX2NvbG9ycyA9IHBhbGV0dGUubGVuZ3RoO1xuICAgIGlmIChudW1fY29sb3JzIDwgMiB8fCBudW1fY29sb3JzID4gMjU2IHx8ICBudW1fY29sb3JzICYgKG51bV9jb2xvcnMtMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgY29kZS9jb2xvciBsZW5ndGgsIG11c3QgYmUgcG93ZXIgb2YgMiBhbmQgMiAuLiAyNTYuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtX2NvbG9ycztcbiAgfVxuXG4gIC8vIC0gSGVhZGVyLlxuICBidWZbcCsrXSA9IDB4NDc7IGJ1ZltwKytdID0gMHg0OTsgYnVmW3ArK10gPSAweDQ2OyAgLy8gR0lGXG4gIGJ1ZltwKytdID0gMHgzODsgYnVmW3ArK10gPSAweDM5OyBidWZbcCsrXSA9IDB4NjE7ICAvLyA4OWFcblxuICAvLyBIYW5kbGluZyBvZiBHbG9iYWwgQ29sb3IgVGFibGUgKHBhbGV0dGUpIGFuZCBiYWNrZ3JvdW5kIGluZGV4LlxuICB2YXIgZ3BfbnVtX2NvbG9yc19wb3cyID0gMDtcbiAgdmFyIGJhY2tncm91bmQgPSAwO1xuICBpZiAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwpIHtcbiAgICB2YXIgZ3BfbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMoZ2xvYmFsX3BhbGV0dGUpO1xuICAgIHdoaWxlIChncF9udW1fY29sb3JzID4+PSAxKSArK2dwX251bV9jb2xvcnNfcG93MjtcbiAgICBncF9udW1fY29sb3JzID0gMSA8PCBncF9udW1fY29sb3JzX3BvdzI7XG4gICAgLS1ncF9udW1fY29sb3JzX3BvdzI7XG4gICAgaWYgKGdvcHRzLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmFja2dyb3VuZCA9IGdvcHRzLmJhY2tncm91bmQ7XG4gICAgICBpZiAoYmFja2dyb3VuZCA+PSBncF9udW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZ3JvdW5kIGluZGV4IG91dCBvZiByYW5nZS5cIik7XG4gICAgICAvLyBUaGUgR0lGIHNwZWMgc3RhdGVzIHRoYXQgYSBiYWNrZ3JvdW5kIGluZGV4IG9mIDAgc2hvdWxkIGJlIGlnbm9yZWQsIHNvXG4gICAgICAvLyB0aGlzIGlzIHByb2JhYmx5IGEgbWlzdGFrZSBhbmQgeW91IHJlYWxseSB3YW50IHRvIHNldCBpdCB0byBhbm90aGVyXG4gICAgICAvLyBzbG90IGluIHRoZSBwYWxldHRlLiAgQnV0IGFjdHVhbGx5IGluIHRoZSBlbmQgbW9zdCBicm93c2VycywgZXRjIGVuZFxuICAgICAgLy8gdXAgaWdub3JpbmcgdGhpcyBhbG1vc3QgY29tcGxldGVseSAoaW5jbHVkaW5nIGZvciBkaXNwb3NlIGJhY2tncm91bmQpLlxuICAgICAgaWYgKGJhY2tncm91bmQgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggZXhwbGljaXRseSBwYXNzZWQgYXMgMC5cIik7XG4gICAgfVxuICB9XG5cbiAgLy8gLSBMb2dpY2FsIFNjcmVlbiBEZXNjcmlwdG9yLlxuICAvLyBOT1RFKGRlYW5tKTogdy9oIGFwcGFyZW50bHkgaWdub3JlZCBieSBpbXBsZW1lbnRhdGlvbnMsIGJ1dCBzZXQgYW55d2F5LlxuICBidWZbcCsrXSA9IHdpZHRoICYgMHhmZjsgYnVmW3ArK10gPSB3aWR0aCA+PiA4ICYgMHhmZjtcbiAgYnVmW3ArK10gPSBoZWlnaHQgJiAweGZmOyBidWZbcCsrXSA9IGhlaWdodCA+PiA4ICYgMHhmZjtcbiAgLy8gTk9URTogSW5kaWNhdGVzIDAtYnBwIG9yaWdpbmFsIGNvbG9yIHJlc29sdXRpb24gKHVudXNlZD8pLlxuICBidWZbcCsrXSA9IChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCA/IDB4ODAgOiAwKSB8ICAvLyBHbG9iYWwgQ29sb3IgVGFibGUgRmxhZy5cbiAgICAgICAgICAgICBncF9udW1fY29sb3JzX3BvdzI7ICAvLyBOT1RFOiBObyBzb3J0IGZsYWcgKHVudXNlZD8pLlxuICBidWZbcCsrXSA9IGJhY2tncm91bmQ7ICAvLyBCYWNrZ3JvdW5kIENvbG9yIEluZGV4LlxuICBidWZbcCsrXSA9IDA7ICAvLyBQaXhlbCBhc3BlY3QgcmF0aW8gKHVudXNlZD8pLlxuXG4gIC8vIC0gR2xvYmFsIENvbG9yIFRhYmxlXG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGdsb2JhbF9wYWxldHRlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHZhciByZ2IgPSBnbG9iYWxfcGFsZXR0ZVtpXTtcbiAgICAgIGJ1ZltwKytdID0gcmdiID4+IDE2ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgJiAweGZmO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsb29wX2NvdW50ICE9PSBudWxsKSB7ICAvLyBOZXRzY2FwZSBibG9jayBmb3IgbG9vcGluZy5cbiAgICBpZiAobG9vcF9jb3VudCA8IDAgfHwgbG9vcF9jb3VudCA+IDY1NTM1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9vcCBjb3VudCBpbnZhbGlkLlwiKVxuICAgIC8vIEV4dGVuc2lvbiBjb2RlLCBsYWJlbCwgYW5kIGxlbmd0aC5cbiAgICBidWZbcCsrXSA9IDB4MjE7IGJ1ZltwKytdID0gMHhmZjsgYnVmW3ArK10gPSAweDBiO1xuICAgIC8vIE5FVFNDQVBFMi4wXG4gICAgYnVmW3ArK10gPSAweDRlOyBidWZbcCsrXSA9IDB4NDU7IGJ1ZltwKytdID0gMHg1NDsgYnVmW3ArK10gPSAweDUzO1xuICAgIGJ1ZltwKytdID0gMHg0MzsgYnVmW3ArK10gPSAweDQxOyBidWZbcCsrXSA9IDB4NTA7IGJ1ZltwKytdID0gMHg0NTtcbiAgICBidWZbcCsrXSA9IDB4MzI7IGJ1ZltwKytdID0gMHgyZTsgYnVmW3ArK10gPSAweDMwO1xuICAgIC8vIFN1Yi1ibG9ja1xuICAgIGJ1ZltwKytdID0gMHgwMzsgYnVmW3ArK10gPSAweDAxO1xuICAgIGJ1ZltwKytdID0gbG9vcF9jb3VudCAmIDB4ZmY7IGJ1ZltwKytdID0gbG9vcF9jb3VudCA+PiA4ICYgMHhmZjtcbiAgICBidWZbcCsrXSA9IDB4MDA7ICAvLyBUZXJtaW5hdG9yLlxuICB9XG5cblxuICB2YXIgZW5kZWQgPSBmYWxzZTtcblxuICB0aGlzLmFkZEZyYW1lID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgaW5kZXhlZF9waXhlbHMsIG9wdHMpIHtcbiAgICBpZiAoZW5kZWQgPT09IHRydWUpIHsgLS1wOyBlbmRlZCA9IGZhbHNlOyB9ICAvLyBVbi1lbmQuXG5cbiAgICBvcHRzID0gb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogb3B0cztcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBCb3VuZHMgY2hlY2sgeCwgeS4gIERvIHRoZXkgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHZpcnR1YWxcbiAgICAvLyBjYW52YXMgd2lkdGgvaGVpZ2h0LCBJIGltYWdpbmU/XG4gICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPiA2NTUzNSB8fCB5ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4L3kgaW52YWxpZC5cIilcblxuICAgIGlmICh3IDw9IDAgfHwgaCA8PSAwIHx8IHcgPiA2NTUzNSB8fCBoID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aC9IZWlnaHQgaW52YWxpZC5cIilcblxuICAgIGlmIChpbmRleGVkX3BpeGVscy5sZW5ndGggPCB3ICogaClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBlbm91Z2ggcGl4ZWxzIGZvciB0aGUgZnJhbWUgc2l6ZS5cIik7XG5cbiAgICB2YXIgdXNpbmdfbG9jYWxfcGFsZXR0ZSA9IHRydWU7XG4gICAgdmFyIHBhbGV0dGUgPSBvcHRzLnBhbGV0dGU7XG4gICAgaWYgKHBhbGV0dGUgPT09IHVuZGVmaW5lZCB8fCBwYWxldHRlID09PSBudWxsKSB7XG4gICAgICB1c2luZ19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICBwYWxldHRlID0gZ2xvYmFsX3BhbGV0dGU7XG4gICAgfVxuXG4gICAgaWYgKHBhbGV0dGUgPT09IHVuZGVmaW5lZCB8fCBwYWxldHRlID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdXBwbHkgZWl0aGVyIGEgbG9jYWwgb3IgZ2xvYmFsIHBhbGV0dGUuXCIpO1xuXG4gICAgdmFyIG51bV9jb2xvcnMgPSBjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzKHBhbGV0dGUpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbWluX2NvZGVfc2l6ZSAocG93ZXIgb2YgMiksIGRlc3Ryb3lpbmcgbnVtX2NvbG9ycy5cbiAgICB2YXIgbWluX2NvZGVfc2l6ZSA9IDA7XG4gICAgd2hpbGUgKG51bV9jb2xvcnMgPj49IDEpICsrbWluX2NvZGVfc2l6ZTtcbiAgICBudW1fY29sb3JzID0gMSA8PCBtaW5fY29kZV9zaXplOyAgLy8gTm93IHdlIGNhbiBlYXNpbHkgZ2V0IGl0IGJhY2suXG5cbiAgICB2YXIgZGVsYXkgPSBvcHRzLmRlbGF5ID09PSB1bmRlZmluZWQgPyAwIDogb3B0cy5kZWxheTtcblxuICAgIC8vIEZyb20gdGhlIHNwZWM6XG4gICAgLy8gICAgIDAgLSAgIE5vIGRpc3Bvc2FsIHNwZWNpZmllZC4gVGhlIGRlY29kZXIgaXNcbiAgICAvLyAgICAgICAgICAgbm90IHJlcXVpcmVkIHRvIHRha2UgYW55IGFjdGlvbi5cbiAgICAvLyAgICAgMSAtICAgRG8gbm90IGRpc3Bvc2UuIFRoZSBncmFwaGljIGlzIHRvIGJlIGxlZnRcbiAgICAvLyAgICAgICAgICAgaW4gcGxhY2UuXG4gICAgLy8gICAgIDIgLSAgIFJlc3RvcmUgdG8gYmFja2dyb3VuZCBjb2xvci4gVGhlIGFyZWEgdXNlZCBieSB0aGVcbiAgICAvLyAgICAgICAgICAgZ3JhcGhpYyBtdXN0IGJlIHJlc3RvcmVkIHRvIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgIC8vICAgICAzIC0gICBSZXN0b3JlIHRvIHByZXZpb3VzLiBUaGUgZGVjb2RlciBpcyByZXF1aXJlZCB0b1xuICAgIC8vICAgICAgICAgICByZXN0b3JlIHRoZSBhcmVhIG92ZXJ3cml0dGVuIGJ5IHRoZSBncmFwaGljIHdpdGhcbiAgICAvLyAgICAgICAgICAgd2hhdCB3YXMgdGhlcmUgcHJpb3IgdG8gcmVuZGVyaW5nIHRoZSBncmFwaGljLlxuICAgIC8vICA0LTcgLSAgICBUbyBiZSBkZWZpbmVkLlxuICAgIC8vIE5PVEUoZGVhbm0pOiBEaXNwb3NlIGJhY2tncm91bmQgZG9lc24ndCByZWFsbHkgd29yaywgYXBwYXJlbnRseSBtb3N0XG4gICAgLy8gYnJvd3NlcnMgaWdub3JlIHRoZSBiYWNrZ3JvdW5kIHBhbGV0dGUgaW5kZXggYW5kIGNsZWFyIHRvIHRyYW5zcGFyZW5jeS5cbiAgICB2YXIgZGlzcG9zYWwgPSBvcHRzLmRpc3Bvc2FsID09PSB1bmRlZmluZWQgPyAwIDogb3B0cy5kaXNwb3NhbDtcbiAgICBpZiAoZGlzcG9zYWwgPCAwIHx8IGRpc3Bvc2FsID4gMykgIC8vIDQtNyBpcyByZXNlcnZlZC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc3Bvc2FsIG91dCBvZiByYW5nZS5cIik7XG5cbiAgICB2YXIgdXNlX3RyYW5zcGFyZW5jeSA9IGZhbHNlO1xuICAgIHZhciB0cmFuc3BhcmVudF9pbmRleCA9IDA7XG4gICAgaWYgKG9wdHMudHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnRyYW5zcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB1c2VfdHJhbnNwYXJlbmN5ID0gdHJ1ZTtcbiAgICAgIHRyYW5zcGFyZW50X2luZGV4ID0gb3B0cy50cmFuc3BhcmVudDtcbiAgICAgIGlmICh0cmFuc3BhcmVudF9pbmRleCA8IDAgfHwgdHJhbnNwYXJlbnRfaW5kZXggPj0gbnVtX2NvbG9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXCIpO1xuICAgIH1cblxuICAgIGlmIChkaXNwb3NhbCAhPT0gMCB8fCB1c2VfdHJhbnNwYXJlbmN5IHx8IGRlbGF5ICE9PSAwKSB7XG4gICAgICAvLyAtIEdyYXBoaWNzIENvbnRyb2wgRXh0ZW5zaW9uXG4gICAgICBidWZbcCsrXSA9IDB4MjE7IGJ1ZltwKytdID0gMHhmOTsgIC8vIEV4dGVuc2lvbiAvIExhYmVsLlxuICAgICAgYnVmW3ArK10gPSA0OyAgLy8gQnl0ZSBzaXplLlxuXG4gICAgICBidWZbcCsrXSA9IGRpc3Bvc2FsIDw8IDIgfCAodXNlX3RyYW5zcGFyZW5jeSA9PT0gdHJ1ZSA/IDEgOiAwKTtcbiAgICAgIGJ1ZltwKytdID0gZGVsYXkgJiAweGZmOyBidWZbcCsrXSA9IGRlbGF5ID4+IDggJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSB0cmFuc3BhcmVudF9pbmRleDsgIC8vIFRyYW5zcGFyZW50IGNvbG9yIGluZGV4LlxuICAgICAgYnVmW3ArK10gPSAwOyAgLy8gQmxvY2sgVGVybWluYXRvci5cbiAgICB9XG5cbiAgICAvLyAtIEltYWdlIERlc2NyaXB0b3JcbiAgICBidWZbcCsrXSA9IDB4MmM7ICAvLyBJbWFnZSBTZXBlcmF0b3IuXG4gICAgYnVmW3ArK10gPSB4ICYgMHhmZjsgYnVmW3ArK10gPSB4ID4+IDggJiAweGZmOyAgLy8gTGVmdC5cbiAgICBidWZbcCsrXSA9IHkgJiAweGZmOyBidWZbcCsrXSA9IHkgPj4gOCAmIDB4ZmY7ICAvLyBUb3AuXG4gICAgYnVmW3ArK10gPSB3ICYgMHhmZjsgYnVmW3ArK10gPSB3ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gaCAmIDB4ZmY7IGJ1ZltwKytdID0gaCA+PiA4ICYgMHhmZjtcbiAgICAvLyBOT1RFOiBObyBzb3J0IGZsYWcgKHVudXNlZD8pLlxuICAgIC8vIFRPRE8oZGVhbm0pOiBTdXBwb3J0IGludGVybGFjZS5cbiAgICBidWZbcCsrXSA9IHVzaW5nX2xvY2FsX3BhbGV0dGUgPT09IHRydWUgPyAoMHg4MCB8IChtaW5fY29kZV9zaXplLTEpKSA6IDA7XG5cbiAgICAvLyAtIExvY2FsIENvbG9yIFRhYmxlXG4gICAgaWYgKHVzaW5nX2xvY2FsX3BhbGV0dGUgPT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHBhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIgcmdiID0gcGFsZXR0ZVtpXTtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiA4ICYgMHhmZjtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgJiAweGZmO1xuICAgICAgfVxuICAgIH1cblxuICAgIHAgPSBHaWZXcml0ZXJPdXRwdXRMWldDb2RlU3RyZWFtKFxuICAgICAgICAgICAgYnVmLCBwLCBtaW5fY29kZV9zaXplIDwgMiA/IDIgOiBtaW5fY29kZV9zaXplLCBpbmRleGVkX3BpeGVscyk7XG5cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB0aGlzLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChlbmRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGJ1ZltwKytdID0gMHgzYjsgIC8vIFRyYWlsZXIuXG4gICAgICBlbmRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBidWY7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyID0gZnVuY3Rpb24odikgeyBidWYgPSB2OyB9O1xuICB0aGlzLmdldE91dHB1dEJ1ZmZlclBvc2l0aW9uID0gZnVuY3Rpb24oKSB7IHJldHVybiBwOyB9O1xuICB0aGlzLnNldE91dHB1dEJ1ZmZlclBvc2l0aW9uID0gZnVuY3Rpb24odikgeyBwID0gdjsgfTtcbn1cblxuLy8gTWFpbiBjb21wcmVzc2lvbiByb3V0aW5lLCBwYWxldHRlIGluZGV4ZXMgLT4gTFpXIGNvZGUgc3RyZWFtLlxuLy8gfGluZGV4X3N0cmVhbXwgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbnRyeS5cbmZ1bmN0aW9uIEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oYnVmLCBwLCBtaW5fY29kZV9zaXplLCBpbmRleF9zdHJlYW0pIHtcbiAgYnVmW3ArK10gPSBtaW5fY29kZV9zaXplO1xuICB2YXIgY3VyX3N1YmJsb2NrID0gcCsrOyAgLy8gUG9pbnRpbmcgYXQgdGhlIGxlbmd0aCBmaWVsZC5cblxuICB2YXIgY2xlYXJfY29kZSA9IDEgPDwgbWluX2NvZGVfc2l6ZTtcbiAgdmFyIGNvZGVfbWFzayA9IGNsZWFyX2NvZGUgLSAxO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICAvLyBXZSBoYXZlIGF0IG1vc3QgMTItYml0IGNvZGVzLCBzbyB3ZSBzaG91bGQgaGF2ZSB0byBob2xkIGEgbWF4IG9mIDE5XG4gIC8vIGJpdHMgaGVyZSAoYW5kIHRoZW4gd2Ugd291bGQgd3JpdGUgb3V0KS5cbiAgdmFyIGN1ciA9IDA7XG5cbiAgZnVuY3Rpb24gZW1pdF9ieXRlc190b19idWZmZXIoYml0X2Jsb2NrX3NpemUpIHtcbiAgICB3aGlsZSAoY3VyX3NoaWZ0ID49IGJpdF9ibG9ja19zaXplKSB7XG4gICAgICBidWZbcCsrXSA9IGN1ciAmIDB4ZmY7XG4gICAgICBjdXIgPj49IDg7IGN1cl9zaGlmdCAtPSA4O1xuICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgYnVmW2N1cl9zdWJibG9ja10gPSAyNTU7XG4gICAgICAgIGN1cl9zdWJibG9jayA9IHArKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0X2NvZGUoYykge1xuICAgIGN1ciB8PSBjIDw8IGN1cl9zaGlmdDtcbiAgICBjdXJfc2hpZnQgKz0gY3VyX2NvZGVfc2l6ZTtcbiAgICBlbWl0X2J5dGVzX3RvX2J1ZmZlcig4KTtcbiAgfVxuXG4gIC8vIEkgYW0gbm90IGFuIGV4cGVydCBvbiB0aGUgdG9waWMsIGFuZCBJIGRvbid0IHdhbnQgdG8gd3JpdGUgYSB0aGVzaXMuXG4gIC8vIEhvd2V2ZXIsIGl0IGlzIGdvb2QgdG8gb3V0bGluZSBoZXJlIHRoZSBiYXNpYyBhbGdvcml0aG0gYW5kIHRoZSBmZXcgZGF0YVxuICAvLyBzdHJ1Y3R1cmVzIGFuZCBvcHRpbWl6YXRpb25zIGhlcmUgdGhhdCBtYWtlIHRoaXMgaW1wbGVtZW50YXRpb24gZmFzdC5cbiAgLy8gVGhlIGJhc2ljIGlkZWEgYmVoaW5kIExaVyBpcyB0byBidWlsZCBhIHRhYmxlIG9mIHByZXZpb3VzbHkgc2VlbiBydW5zXG4gIC8vIGFkZHJlc3NlZCBieSBhIHNob3J0IGlkIChoZXJlaW4gY2FsbGVkIG91dHB1dCBjb2RlKS4gIEFsbCBkYXRhIGlzXG4gIC8vIHJlZmVyZW5jZWQgYnkgYSBjb2RlLCB3aGljaCByZXByZXNlbnRzIG9uZSBvciBtb3JlIHZhbHVlcyBmcm9tIHRoZVxuICAvLyBvcmlnaW5hbCBpbnB1dCBzdHJlYW0uICBBbGwgaW5wdXQgYnl0ZXMgY2FuIGJlIHJlZmVyZW5jZWQgYXMgdGhlIHNhbWVcbiAgLy8gdmFsdWUgYXMgYW4gb3V0cHV0IGNvZGUuICBTbyBpZiB5b3UgZGlkbid0IHdhbnQgYW55IGNvbXByZXNzaW9uLCB5b3VcbiAgLy8gY291bGQgbW9yZSBvciBsZXNzIGp1c3Qgb3V0cHV0IHRoZSBvcmlnaW5hbCBieXRlcyBhcyBjb2RlcyAodGhlcmUgYXJlXG4gIC8vIHNvbWUgZGV0YWlscyB0byB0aGlzLCBidXQgaXQgaXMgdGhlIGlkZWEpLiAgSW4gb3JkZXIgdG8gYWNoaWV2ZVxuICAvLyBjb21wcmVzc2lvbiwgdmFsdWVzIGdyZWF0ZXIgdGhlbiB0aGUgaW5wdXQgcmFuZ2UgKGNvZGVzIGNhbiBiZSB1cCB0b1xuICAvLyAxMi1iaXQgd2hpbGUgaW5wdXQgb25seSA4LWJpdCkgcmVwcmVzZW50IGEgc2VxdWVuY2Ugb2YgcHJldmlvdXNseSBzZWVuXG4gIC8vIGlucHV0cy4gIFRoZSBkZWNvbXByZXNzb3IgaXMgYWJsZSB0byBidWlsZCB0aGUgc2FtZSBtYXBwaW5nIHdoaWxlXG4gIC8vIGRlY29kaW5nLCBzbyB0aGVyZSBpcyBhbHdheXMgYSBzaGFyZWQgY29tbW9uIGtub3dsZWRnZSBiZXR3ZWVuIHRoZVxuICAvLyBlbmNvZGluZyBhbmQgZGVjb2Rlciwgd2hpY2ggaXMgYWxzbyBpbXBvcnRhbnQgZm9yIFwidGltaW5nXCIgYXNwZWN0cyBsaWtlXG4gIC8vIGhvdyB0byBoYW5kbGUgdmFyaWFibGUgYml0IHdpZHRoIGNvZGUgZW5jb2RpbmcuXG4gIC8vXG4gIC8vIE9uZSBvYnZpb3VzIGJ1dCB2ZXJ5IGltcG9ydGFudCBjb25zZXF1ZW5jZSBvZiB0aGUgdGFibGUgc3lzdGVtIGlzIHRoZXJlXG4gIC8vIGlzIGFsd2F5cyBhIHVuaXF1ZSBpZCAoYXQgbW9zdCAxMi1iaXRzKSB0byBtYXAgdGhlIHJ1bnMuICAnQScgbWlnaHQgYmVcbiAgLy8gNCwgdGhlbiAnQUEnIG1pZ2h0IGJlIDEwLCAnQUFBJyAxMSwgJ0FBQUEnIDEyLCBldGMuICBUaGlzIHJlbGF0aW9uc2hpcFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgYW4gZWZmZWNpZW50IGxvb2t1cCBzdHJhdGVneSBmb3IgdGhlIGNvZGUgbWFwcGluZy4gIFdlXG4gIC8vIG5lZWQgdG8ga25vdyBpZiBhIHJ1biBoYXMgYmVlbiBzZWVuIGJlZm9yZSwgYW5kIGJlIGFibGUgdG8gbWFwIHRoYXQgcnVuXG4gIC8vIHRvIHRoZSBvdXRwdXQgY29kZS4gIFNpbmNlIHdlIHN0YXJ0IHdpdGgga25vd24gdW5pcXVlIGlkcyAoaW5wdXQgYnl0ZXMpLFxuICAvLyBhbmQgdGhlbiBmcm9tIHRob3NlIGJ1aWxkIG1vcmUgdW5pcXVlIGlkcyAodGFibGUgZW50cmllcyksIHdlIGNhblxuICAvLyBjb250aW51ZSB0aGlzIGNoYWluIChhbG1vc3QgbGlrZSBhIGxpbmtlZCBsaXN0KSB0byBhbHdheXMgaGF2ZSBzbWFsbFxuICAvLyBpbnRlZ2VyIHZhbHVlcyB0aGF0IHJlcHJlc2VudCB0aGUgY3VycmVudCBieXRlIGNoYWlucyBpbiB0aGUgZW5jb2Rlci5cbiAgLy8gVGhpcyBtZWFucyBpbnN0ZWFkIG9mIHRyYWNraW5nIHRoZSBpbnB1dCBieXRlcyAoQUFBQUJDRCkgdG8ga25vdyBvdXJcbiAgLy8gY3VycmVudCBzdGF0ZSwgd2UgY2FuIHRyYWNrIHRoZSB0YWJsZSBlbnRyeSBmb3IgQUFBQUJDIChpdCBpcyBndWFyYW50ZWVkXG4gIC8vIHRvIGV4aXN0IGJ5IHRoZSBuYXR1cmUgb2YgdGhlIGFsZ29yaXRobSkgYW5kIHRoZSBuZXh0IGNoYXJhY3RlciBELlxuICAvLyBUaGVyZWZvciB0aGUgdHVwbGUgb2YgKHRhYmxlX2VudHJ5LCBieXRlKSBpcyBndWFyYW50ZWVkIHRvIGFsc28gYmVcbiAgLy8gdW5pcXVlLiAgVGhpcyBhbGxvd3MgdXMgdG8gY3JlYXRlIGEgc2ltcGxlIGxvb2t1cCBrZXkgZm9yIG1hcHBpbmcgaW5wdXRcbiAgLy8gc2VxdWVuY2VzIHRvIGNvZGVzICh0YWJsZSBpbmRpY2VzKSB3aXRob3V0IGhhdmluZyB0byBzdG9yZSBvciBzZWFyY2hcbiAgLy8gYW55IG9mIHRoZSBjb2RlIHNlcXVlbmNlcy4gIFNvIGlmICdBQUFBJyBoYXMgYSB0YWJsZSBlbnRyeSBvZiAxMiwgdGhlXG4gIC8vIHR1cGxlIG9mICgnQUFBQScsIEspIGZvciBhbnkgaW5wdXQgYnl0ZSBLIHdpbGwgYmUgdW5pcXVlLCBhbmQgY2FuIGJlIG91clxuICAvLyBrZXkuICBUaGlzIGxlYWRzIHRvIGEgaW50ZWdlciB2YWx1ZSBhdCBtb3N0IDIwLWJpdHMsIHdoaWNoIGNhbiBhbHdheXNcbiAgLy8gZml0IGluIGFuIFNNSSB2YWx1ZSBhbmQgYmUgdXNlZCBhcyBhIGZhc3Qgc3BhcnNlIGFycmF5IC8gb2JqZWN0IGtleS5cblxuICAvLyBPdXRwdXQgY29kZSBmb3IgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIGluZGV4IGJ1ZmZlci5cbiAgdmFyIGliX2NvZGUgPSBpbmRleF9zdHJlYW1bMF0gJiBjb2RlX21hc2s7ICAvLyBMb2FkIGZpcnN0IGlucHV0IGluZGV4LlxuICB2YXIgY29kZV90YWJsZSA9IHsgfTsgIC8vIEtleSdkIG9uIG91ciAyMC1iaXQgXCJ0dXBsZVwiLlxuXG4gIGVtaXRfY29kZShjbGVhcl9jb2RlKTsgIC8vIFNwZWMgc2F5cyBmaXJzdCBjb2RlIHNob3VsZCBiZSBhIGNsZWFyIGNvZGUuXG5cbiAgLy8gRmlyc3QgaW5kZXggYWxyZWFkeSBsb2FkZWQsIHByb2Nlc3MgdGhlIHJlc3Qgb2YgdGhlIHN0cmVhbS5cbiAgZm9yICh2YXIgaSA9IDEsIGlsID0gaW5kZXhfc3RyZWFtLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICB2YXIgayA9IGluZGV4X3N0cmVhbVtpXSAmIGNvZGVfbWFzaztcbiAgICB2YXIgY3VyX2tleSA9IGliX2NvZGUgPDwgOCB8IGs7ICAvLyAocHJldiwgaykgdW5pcXVlIHR1cGxlLlxuICAgIHZhciBjdXJfY29kZSA9IGNvZGVfdGFibGVbY3VyX2tleV07ICAvLyBidWZmZXIgKyBrLlxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgY29kZSB0YWJsZSBlbnRyeS5cbiAgICBpZiAoY3VyX2NvZGUgPT09IHVuZGVmaW5lZCkgeyAgLy8gV2UgZG9uJ3QgaGF2ZSBidWZmZXIgKyBrLlxuICAgICAgLy8gRW1pdCBpbmRleCBidWZmZXIgKHdpdGhvdXQgaykuXG4gICAgICAvLyBUaGlzIGlzIGFuIGlubGluZSB2ZXJzaW9uIG9mIGVtaXRfY29kZSwgYmVjYXVzZSB0aGlzIGlzIHRoZSBjb3JlXG4gICAgICAvLyB3cml0aW5nIHJvdXRpbmUgb2YgdGhlIGNvbXByZXNzb3IgKGFuZCBWOCBjYW5ub3QgaW5saW5lIGVtaXRfY29kZVxuICAgICAgLy8gYmVjYXVzZSBpdCBpcyBhIGNsb3N1cmUgaGVyZSBpbiBhIGRpZmZlcmVudCBjb250ZXh0KS4gIEFkZGl0aW9uYWxseVxuICAgICAgLy8gd2UgY2FuIGNhbGwgZW1pdF9ieXRlX3RvX2J1ZmZlciBsZXNzIG9mdGVuLCBiZWNhdXNlIHdlIGNhbiBoYXZlXG4gICAgICAvLyAzMC1iaXRzIChmcm9tIG91ciAzMS1iaXQgc2lnbmVkIFNNSSksIGFuZCB3ZSBrbm93IG91ciBjb2RlcyB3aWxsIG9ubHlcbiAgICAgIC8vIGJlIDEyLWJpdHMsIHNvIGNhbiBzYWZlbHkgaGF2ZSAxOC1iaXRzIHRoZXJlIHdpdGhvdXQgb3ZlcmZsb3cuXG4gICAgICAvLyBlbWl0X2NvZGUoaWJfY29kZSk7XG4gICAgICBjdXIgfD0gaWJfY29kZSA8PCBjdXJfc2hpZnQ7XG4gICAgICBjdXJfc2hpZnQgKz0gY3VyX2NvZGVfc2l6ZTtcbiAgICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gOCkge1xuICAgICAgICBidWZbcCsrXSA9IGN1ciAmIDB4ZmY7XG4gICAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICAgIGlmIChwID09PSBjdXJfc3ViYmxvY2sgKyAyNTYpIHsgIC8vIEZpbmlzaGVkIGEgc3ViYmxvY2suXG4gICAgICAgICAgYnVmW2N1cl9zdWJibG9ja10gPSAyNTU7XG4gICAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0X2NvZGUgPT09IDQwOTYpIHsgIC8vIFRhYmxlIGZ1bGwsIG5lZWQgYSBjbGVhci5cbiAgICAgICAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpO1xuICAgICAgICBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG4gICAgICAgIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTtcbiAgICAgICAgY29kZV90YWJsZSA9IHsgfTtcbiAgICAgIH0gZWxzZSB7ICAvLyBUYWJsZSBub3QgZnVsbCwgaW5zZXJ0IGEgbmV3IGVudHJ5LlxuICAgICAgICAvLyBJbmNyZWFzZSBvdXIgdmFyaWFibGUgYml0IGNvZGUgc2l6ZXMgaWYgbmVjZXNzYXJ5LiAgVGhpcyBpcyBhIGJpdFxuICAgICAgICAvLyB0cmlja3kgYXMgaXQgaXMgYmFzZWQgb24gXCJ0aW1pbmdcIiBiZXR3ZWVuIHRoZSBlbmNvZGluZyBhbmRcbiAgICAgICAgLy8gZGVjb2Rlci4gIEZyb20gdGhlIGVuY29kZXJzIHBlcnNwZWN0aXZlIHRoaXMgc2hvdWxkIGhhcHBlbiBhZnRlclxuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGVtaXR0ZWQgdGhlIGluZGV4IGJ1ZmZlciBhbmQgYXJlIGFib3V0IHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgLy8gZmlyc3QgdGFibGUgZW50cnkgdGhhdCB3b3VsZCBvdmVyZmxvdyBvdXIgY3VycmVudCBjb2RlIGJpdCBzaXplLlxuICAgICAgICBpZiAobmV4dF9jb2RlID49ICgxIDw8IGN1cl9jb2RlX3NpemUpKSArK2N1cl9jb2RlX3NpemU7XG4gICAgICAgIGNvZGVfdGFibGVbY3VyX2tleV0gPSBuZXh0X2NvZGUrKzsgIC8vIEluc2VydCBpbnRvIGNvZGUgdGFibGUuXG4gICAgICB9XG5cbiAgICAgIGliX2NvZGUgPSBrOyAgLy8gSW5kZXggYnVmZmVyIHRvIHNpbmdsZSBpbnB1dCBrLlxuICAgIH0gZWxzZSB7XG4gICAgICBpYl9jb2RlID0gY3VyX2NvZGU7ICAvLyBJbmRleCBidWZmZXIgdG8gc2VxdWVuY2UgaW4gY29kZSB0YWJsZS5cbiAgICB9XG4gIH1cblxuICBlbWl0X2NvZGUoaWJfY29kZSk7ICAvLyBUaGVyZSB3aWxsIHN0aWxsIGJlIHNvbWV0aGluZyBpbiB0aGUgaW5kZXggYnVmZmVyLlxuICBlbWl0X2NvZGUoZW9pX2NvZGUpOyAgLy8gRW5kIE9mIEluZm9ybWF0aW9uLlxuXG4gIC8vIEZsdXNoIC8gZmluYWxpemUgdGhlIHN1Yi1ibG9ja3Mgc3RyZWFtIHRvIHRoZSBidWZmZXIuXG4gIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDEpO1xuXG4gIC8vIEZpbmlzaCB0aGUgc3ViLWJsb2Nrcywgd3JpdGluZyBvdXQgYW55IHVuZmluaXNoZWQgbGVuZ3RocyBhbmRcbiAgLy8gdGVybWluYXRpbmcgd2l0aCBhIHN1Yi1ibG9jayBvZiBsZW5ndGggMC4gIElmIHdlIGhhdmUgYWxyZWFkeSBzdGFydGVkXG4gIC8vIGJ1dCBub3QgeWV0IHVzZWQgYSBzdWItYmxvY2sgaXQgY2FuIGp1c3QgYmVjb21lIHRoZSB0ZXJtaW5hdG9yLlxuICBpZiAoY3VyX3N1YmJsb2NrICsgMSA9PT0gcCkgeyAgLy8gU3RhcnRlZCBidXQgdW51c2VkLlxuICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMDtcbiAgfSBlbHNlIHsgIC8vIFN0YXJ0ZWQgYW5kIHVzZWQsIHdyaXRlIGxlbmd0aCBhbmQgYWRkaXRpb25hbCB0ZXJtaW5hdG9yIGJsb2NrLlxuICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gcCAtIGN1cl9zdWJibG9jayAtIDE7XG4gICAgYnVmW3ArK10gPSAwO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBHaWZSZWFkZXIoYnVmKSB7XG4gIHZhciBwID0gMDtcblxuICAvLyAtIEhlYWRlciAoR0lGODdhIG9yIEdJRjg5YSkuXG4gIGlmIChidWZbcCsrXSAhPT0gMHg0NyB8fCAgICAgICAgICAgIGJ1ZltwKytdICE9PSAweDQ5IHx8IGJ1ZltwKytdICE9PSAweDQ2IHx8XG4gICAgICBidWZbcCsrXSAhPT0gMHgzOCB8fCAoYnVmW3ArK10rMSAmIDB4ZmQpICE9PSAweDM4IHx8IGJ1ZltwKytdICE9PSAweDYxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHSUYgODdhLzg5YSBoZWFkZXIuXCIpO1xuICB9XG5cbiAgLy8gLSBMb2dpY2FsIFNjcmVlbiBEZXNjcmlwdG9yLlxuICB2YXIgd2lkdGggPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gIHZhciBoZWlnaHQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gIHZhciBwZjAgPSBidWZbcCsrXTsgIC8vIDxQYWNrZWQgRmllbGRzPi5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX2ZsYWcgPSBwZjAgPj4gNztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzX3BvdzIgPSBwZjAgJiAweDc7XG4gIHZhciBudW1fZ2xvYmFsX2NvbG9ycyA9IDEgPDwgKG51bV9nbG9iYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgdmFyIGJhY2tncm91bmQgPSBidWZbcCsrXTtcbiAgYnVmW3ArK107ICAvLyBQaXhlbCBhc3BlY3QgcmF0aW8gKHVudXNlZD8pLlxuXG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9vZmZzZXQgPSBudWxsO1xuICB2YXIgZ2xvYmFsX3BhbGV0dGVfc2l6ZSAgID0gbnVsbDtcblxuICBpZiAoZ2xvYmFsX3BhbGV0dGVfZmxhZykge1xuICAgIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IHA7XG4gICAgZ2xvYmFsX3BhbGV0dGVfc2l6ZSA9IG51bV9nbG9iYWxfY29sb3JzO1xuICAgIHAgKz0gbnVtX2dsb2JhbF9jb2xvcnMgKiAzOyAgLy8gU2VlayBwYXN0IHBhbGV0dGUuXG4gIH1cblxuICB2YXIgbm9fZW9mID0gdHJ1ZTtcblxuICB2YXIgZnJhbWVzID0gWyBdO1xuXG4gIHZhciBkZWxheSA9IDA7XG4gIHZhciB0cmFuc3BhcmVudF9pbmRleCA9IG51bGw7XG4gIHZhciBkaXNwb3NhbCA9IDA7ICAvLyAwIC0gTm8gZGlzcG9zYWwgc3BlY2lmaWVkLlxuICB2YXIgbG9vcF9jb3VudCA9IG51bGw7XG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICB3aGlsZSAobm9fZW9mICYmIHAgPCBidWYubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChidWZbcCsrXSkge1xuICAgICAgY2FzZSAweDIxOiAgLy8gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb24gQmxvY2tcbiAgICAgICAgc3dpdGNoIChidWZbcCsrXSkge1xuICAgICAgICAgIGNhc2UgMHhmZjogIC8vIEFwcGxpY2F0aW9uIHNwZWNpZmljIGJsb2NrXG4gICAgICAgICAgICAvLyBUcnkgaWYgaXQncyBhIE5ldHNjYXBlIGJsb2NrICh3aXRoIGFuaW1hdGlvbiBsb29wIGNvdW50ZXIpLlxuICAgICAgICAgICAgaWYgKGJ1ZltwICAgXSAhPT0gMHgwYiB8fCAgLy8gMjEgRkYgYWxyZWFkeSByZWFkLCBjaGVjayBibG9jayBzaXplLlxuICAgICAgICAgICAgICAgIC8vIE5FVFNDQVBFMi4wXG4gICAgICAgICAgICAgICAgYnVmW3ArMSBdID09IDB4NGUgJiYgYnVmW3ArMiBdID09IDB4NDUgJiYgYnVmW3ArMyBdID09IDB4NTQgJiZcbiAgICAgICAgICAgICAgICBidWZbcCs0IF0gPT0gMHg1MyAmJiBidWZbcCs1IF0gPT0gMHg0MyAmJiBidWZbcCs2IF0gPT0gMHg0MSAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzcgXSA9PSAweDUwICYmIGJ1ZltwKzggXSA9PSAweDQ1ICYmIGJ1ZltwKzkgXSA9PSAweDMyICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArMTBdID09IDB4MmUgJiYgYnVmW3ArMTFdID09IDB4MzAgJiZcbiAgICAgICAgICAgICAgICAvLyBTdWItYmxvY2tcbiAgICAgICAgICAgICAgICBidWZbcCsxMl0gPT0gMHgwMyAmJiBidWZbcCsxM10gPT0gMHgwMSAmJiBidWZbcCsxNl0gPT0gMCkge1xuICAgICAgICAgICAgICBwICs9IDE0O1xuICAgICAgICAgICAgICBsb29wX2NvdW50ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICB9IGVsc2UgeyAgLy8gV2UgZG9uJ3Qga25vdyB3aGF0IGl0IGlzLCBqdXN0IHRyeSB0byBnZXQgcGFzdCBpdC5cbiAgICAgICAgICAgICAgcCArPSAxMjtcbiAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrX3NpemUgPSBidWZbcCsrXTtcbiAgICAgICAgICAgICAgICAvLyBCYWQgYmxvY2sgc2l6ZSAoZXg6IHVuZGVmaW5lZCBmcm9tIGFuIG91dCBvZiBib3VuZHMgcmVhZCkuXG4gICAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gMCBzaXplIGlzIHRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgICBwICs9IGJsb2NrX3NpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweGY5OiAgLy8gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgICAgICAgIGlmIChidWZbcCsrXSAhPT0gMHg0IHx8IGJ1ZltwKzRdICE9PSAwKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyYXBoaWNzIGV4dGVuc2lvbiBibG9jay5cIik7XG4gICAgICAgICAgICB2YXIgcGYxID0gYnVmW3ArK107XG4gICAgICAgICAgICBkZWxheSA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgICAgIHRyYW5zcGFyZW50X2luZGV4ID0gYnVmW3ArK107XG4gICAgICAgICAgICBpZiAoKHBmMSAmIDEpID09PSAwKSB0cmFuc3BhcmVudF9pbmRleCA9IG51bGw7XG4gICAgICAgICAgICBkaXNwb3NhbCA9IHBmMSA+PiAyICYgMHg3O1xuICAgICAgICAgICAgcCsrOyAgLy8gU2tpcCB0ZXJtaW5hdG9yLlxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4ZmU6ICAvLyBDb21tZW50IEV4dGVuc2lvbi5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7ICAvLyBTZWVrIHRocm91Z2ggc3ViYmxvY2tzLlxuICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAvLyBCYWQgYmxvY2sgc2l6ZSAoZXg6IHVuZGVmaW5lZCBmcm9tIGFuIG91dCBvZiBib3VuZHMgcmVhZCkuXG4gICAgICAgICAgICAgIGlmICghKGJsb2NrX3NpemUgPj0gMCkpIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhidWYuc2xpY2UocCwgcCtibG9ja19zaXplKS50b1N0cmluZygnYXNjaWknKSk7XG4gICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlVua25vd24gZ3JhcGhpYyBjb250cm9sIGxhYmVsOiAweFwiICsgYnVmW3AtMV0udG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDJjOiAgLy8gSW1hZ2UgRGVzY3JpcHRvci5cbiAgICAgICAgdmFyIHggPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgdyA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIGggPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciBwZjIgPSBidWZbcCsrXTtcbiAgICAgICAgdmFyIGxvY2FsX3BhbGV0dGVfZmxhZyA9IHBmMiA+PiA3O1xuICAgICAgICB2YXIgaW50ZXJsYWNlX2ZsYWcgPSBwZjIgPj4gNiAmIDE7XG4gICAgICAgIHZhciBudW1fbG9jYWxfY29sb3JzX3BvdzIgPSBwZjIgJiAweDc7XG4gICAgICAgIHZhciBudW1fbG9jYWxfY29sb3JzID0gMSA8PCAobnVtX2xvY2FsX2NvbG9yc19wb3cyICsgMSk7XG4gICAgICAgIHZhciBwYWxldHRlX29mZnNldCA9IGdsb2JhbF9wYWxldHRlX29mZnNldDtcbiAgICAgICAgdmFyIHBhbGV0dGVfc2l6ZSA9IGdsb2JhbF9wYWxldHRlX3NpemU7XG4gICAgICAgIHZhciBoYXNfbG9jYWxfcGFsZXR0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAobG9jYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICAgICAgICBwYWxldHRlX29mZnNldCA9IHA7ICAvLyBPdmVycmlkZSB3aXRoIGxvY2FsIHBhbGV0dGUuXG4gICAgICAgICAgcGFsZXR0ZV9zaXplID0gbnVtX2xvY2FsX2NvbG9ycztcbiAgICAgICAgICBwICs9IG51bV9sb2NhbF9jb2xvcnMgKiAzOyAgLy8gU2VlayBwYXN0IHBhbGV0dGUuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YV9vZmZzZXQgPSBwO1xuXG4gICAgICAgIHArKzsgIC8vIGNvZGVzaXplXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGJsb2NrX3NpemUgPSBidWZbcCsrXTtcbiAgICAgICAgICAvLyBCYWQgYmxvY2sgc2l6ZSAoZXg6IHVuZGVmaW5lZCBmcm9tIGFuIG91dCBvZiBib3VuZHMgcmVhZCkuXG4gICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgaWYgKGJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gMCBzaXplIGlzIHRlcm1pbmF0b3JcbiAgICAgICAgICBwICs9IGJsb2NrX3NpemU7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZXMucHVzaCh7eDogeCwgeTogeSwgd2lkdGg6IHcsIGhlaWdodDogaCxcbiAgICAgICAgICAgICAgICAgICAgIGhhc19sb2NhbF9wYWxldHRlOiBoYXNfbG9jYWxfcGFsZXR0ZSxcbiAgICAgICAgICAgICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0OiBwYWxldHRlX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgIHBhbGV0dGVfc2l6ZTogcGFsZXR0ZV9zaXplLFxuICAgICAgICAgICAgICAgICAgICAgZGF0YV9vZmZzZXQ6IGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgZGF0YV9sZW5ndGg6IHAgLSBkYXRhX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50X2luZGV4OiB0cmFuc3BhcmVudF9pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgIGludGVybGFjZWQ6ICEhaW50ZXJsYWNlX2ZsYWcsXG4gICAgICAgICAgICAgICAgICAgICBkZWxheTogZGVsYXksXG4gICAgICAgICAgICAgICAgICAgICBkaXNwb3NhbDogZGlzcG9zYWx9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgzYjogIC8vIFRyYWlsZXIgTWFya2VyIChlbmQgb2YgZmlsZSkuXG4gICAgICAgIG5vX2VvZiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBnaWYgYmxvY2s6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLm51bUZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmcmFtZXMubGVuZ3RoO1xuICB9O1xuXG4gIHRoaXMubG9vcENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxvb3BfY291bnQ7XG4gIH07XG5cbiAgdGhpcy5mcmFtZUluZm8gPSBmdW5jdGlvbihmcmFtZV9udW0pIHtcbiAgICBpZiAoZnJhbWVfbnVtIDwgMCB8fCBmcmFtZV9udW0gPj0gZnJhbWVzLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYW1lIGluZGV4IG91dCBvZiByYW5nZS5cIik7XG4gICAgcmV0dXJuIGZyYW1lc1tmcmFtZV9udW1dO1xuICB9XG5cbiAgdGhpcy5kZWNvZGVBbmRCbGl0RnJhbWVCR1JBID0gZnVuY3Rpb24oZnJhbWVfbnVtLCBwaXhlbHMpIHtcbiAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lSW5mbyhmcmFtZV9udW0pO1xuICAgIHZhciBudW1fcGl4ZWxzID0gZnJhbWUud2lkdGggKiBmcmFtZS5oZWlnaHQ7XG4gICAgdmFyIGluZGV4X3N0cmVhbSA9IG5ldyBVaW50OEFycmF5KG51bV9waXhlbHMpOyAgLy8gQXQgbW9zdCA4LWJpdCBpbmRpY2VzLlxuICAgIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKFxuICAgICAgICBidWYsIGZyYW1lLmRhdGFfb2Zmc2V0LCBpbmRleF9zdHJlYW0sIG51bV9waXhlbHMpO1xuICAgIHZhciBwYWxldHRlX29mZnNldCA9IGZyYW1lLnBhbGV0dGVfb2Zmc2V0O1xuXG4gICAgLy8gTk9URShkZWFubSk6IEl0IHNlZW1zIHRvIGJlIG11Y2ggZmFzdGVyIHRvIGNvbXBhcmUgaW5kZXggdG8gMjU2IHRoYW5cbiAgICAvLyB0byA9PT0gbnVsbC4gIE5vdCBzdXJlIHdoeSwgYnV0IENvbXBhcmVTdHViX0VRX1NUUklDVCBzaG93cyB1cCBoaWdoIGluXG4gICAgLy8gdGhlIHByb2ZpbGUsIG5vdCBzdXJlIGlmIGl0J3MgcmVsYXRlZCB0byB1c2luZyBhIFVpbnQ4QXJyYXkuXG4gICAgdmFyIHRyYW5zID0gZnJhbWUudHJhbnNwYXJlbnRfaW5kZXg7XG4gICAgaWYgKHRyYW5zID09PSBudWxsKSB0cmFucyA9IDI1NjtcblxuICAgIC8vIFdlIGFyZSBwb3NzaWJseSBqdXN0IGJsaXR0aW5nIHRvIGEgcG9ydGlvbiBvZiB0aGUgZW50aXJlIGZyYW1lLlxuICAgIC8vIFRoYXQgaXMgYSBzdWJyZWN0IHdpdGhpbiB0aGUgZnJhbWVyZWN0LCBzbyB0aGUgYWRkaXRpb25hbCBwaXhlbHNcbiAgICAvLyBtdXN0IGJlIHNraXBwZWQgb3ZlciBhZnRlciB3ZSBmaW5pc2hlZCBhIHNjYW5saW5lLlxuICAgIHZhciBmcmFtZXdpZHRoICA9IGZyYW1lLndpZHRoO1xuICAgIHZhciBmcmFtZXN0cmlkZSA9IHdpZHRoIC0gZnJhbWV3aWR0aDtcbiAgICB2YXIgeGxlZnQgICAgICAgPSBmcmFtZXdpZHRoOyAgLy8gTnVtYmVyIG9mIHN1YnJlY3QgcGl4ZWxzIGxlZnQgaW4gc2NhbmxpbmUuXG5cbiAgICAvLyBPdXRwdXQgaW5kaWNpZXMgb2YgdGhlIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgY29ybmVycyBvZiB0aGUgc3VicmVjdC5cbiAgICB2YXIgb3BiZWcgPSAoKGZyYW1lLnkgKiB3aWR0aCkgKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wZW5kID0gKChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAqIHdpZHRoICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcCAgICA9IG9wYmVnO1xuXG4gICAgdmFyIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQ7XG5cbiAgICAvLyBVc2Ugc2NhbnN0cmlkZSB0byBza2lwIHBhc3QgdGhlIHJvd3Mgd2hlbiBpbnRlcmxhY2luZy4gIFRoaXMgaXMgc2tpcHBpbmdcbiAgICAvLyA3IHJvd3MgZm9yIHRoZSBmaXJzdCB0d28gcGFzc2VzLCB0aGVuIDMgdGhlbiAxLlxuICAgIGlmIChmcmFtZS5pbnRlcmxhY2VkID09PSB0cnVlKSB7XG4gICAgICBzY2Fuc3RyaWRlICs9IHdpZHRoICogNCAqIDc7ICAvLyBQYXNzIDEuXG4gICAgfVxuXG4gICAgdmFyIGludGVybGFjZXNraXAgPSA4OyAgLy8gVHJhY2tpbmcgdGhlIHJvdyBpbnRlcnZhbCBpbiB0aGUgY3VycmVudCBwYXNzLlxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5kZXhfc3RyZWFtLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGV4X3N0cmVhbVtpXTtcblxuICAgICAgaWYgKHhsZWZ0ID09PSAwKSB7ICAvLyBCZWdpbm5pbmcgb2YgbmV3IHNjYW4gbGluZVxuICAgICAgICBvcCArPSBzY2Fuc3RyaWRlO1xuICAgICAgICB4bGVmdCA9IGZyYW1ld2lkdGg7XG4gICAgICAgIGlmIChvcCA+PSBvcGVuZCkgeyAvLyBDYXRjaCB0aGUgd3JhcCB0byBzd2l0Y2ggcGFzc2VzIHdoZW4gaW50ZXJsYWNpbmcuXG4gICAgICAgICAgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNCArIHdpZHRoICogNCAqIChpbnRlcmxhY2Vza2lwLTEpO1xuICAgICAgICAgIC8vIGludGVybGFjZXNraXAgLyAyICogNCBpcyBpbnRlcmxhY2Vza2lwIDw8IDEuXG4gICAgICAgICAgb3AgPSBvcGJlZyArIChmcmFtZXdpZHRoICsgZnJhbWVzdHJpZGUpICogKGludGVybGFjZXNraXAgPDwgMSk7XG4gICAgICAgICAgaW50ZXJsYWNlc2tpcCA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IHRyYW5zKSB7XG4gICAgICAgIG9wICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgciA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogM107XG4gICAgICAgIHZhciBnID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzICsgMV07XG4gICAgICAgIHZhciBiID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzICsgMl07XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IGI7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IGc7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IHI7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIC0teGxlZnQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIEkgd2lsbCBnbyB0byBjb3B5IGFuZCBwYXN0ZSBoZWxsIG9uZSBkYXkuLi5cbiAgdGhpcy5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBID0gZnVuY3Rpb24oZnJhbWVfbnVtLCBwaXhlbHMpIHtcbiAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lSW5mbyhmcmFtZV9udW0pO1xuICAgIHZhciBudW1fcGl4ZWxzID0gZnJhbWUud2lkdGggKiBmcmFtZS5oZWlnaHQ7XG4gICAgdmFyIGluZGV4X3N0cmVhbSA9IG5ldyBVaW50OEFycmF5KG51bV9waXhlbHMpOyAgLy8gQXQgbW9zdCA4LWJpdCBpbmRpY2VzLlxuICAgIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKFxuICAgICAgICBidWYsIGZyYW1lLmRhdGFfb2Zmc2V0LCBpbmRleF9zdHJlYW0sIG51bV9waXhlbHMpO1xuICAgIHZhciBwYWxldHRlX29mZnNldCA9IGZyYW1lLnBhbGV0dGVfb2Zmc2V0O1xuXG4gICAgLy8gTk9URShkZWFubSk6IEl0IHNlZW1zIHRvIGJlIG11Y2ggZmFzdGVyIHRvIGNvbXBhcmUgaW5kZXggdG8gMjU2IHRoYW5cbiAgICAvLyB0byA9PT0gbnVsbC4gIE5vdCBzdXJlIHdoeSwgYnV0IENvbXBhcmVTdHViX0VRX1NUUklDVCBzaG93cyB1cCBoaWdoIGluXG4gICAgLy8gdGhlIHByb2ZpbGUsIG5vdCBzdXJlIGlmIGl0J3MgcmVsYXRlZCB0byB1c2luZyBhIFVpbnQ4QXJyYXkuXG4gICAgdmFyIHRyYW5zID0gZnJhbWUudHJhbnNwYXJlbnRfaW5kZXg7XG4gICAgaWYgKHRyYW5zID09PSBudWxsKSB0cmFucyA9IDI1NjtcblxuICAgIC8vIFdlIGFyZSBwb3NzaWJseSBqdXN0IGJsaXR0aW5nIHRvIGEgcG9ydGlvbiBvZiB0aGUgZW50aXJlIGZyYW1lLlxuICAgIC8vIFRoYXQgaXMgYSBzdWJyZWN0IHdpdGhpbiB0aGUgZnJhbWVyZWN0LCBzbyB0aGUgYWRkaXRpb25hbCBwaXhlbHNcbiAgICAvLyBtdXN0IGJlIHNraXBwZWQgb3ZlciBhZnRlciB3ZSBmaW5pc2hlZCBhIHNjYW5saW5lLlxuICAgIHZhciBmcmFtZXdpZHRoICA9IGZyYW1lLndpZHRoO1xuICAgIHZhciBmcmFtZXN0cmlkZSA9IHdpZHRoIC0gZnJhbWV3aWR0aDtcbiAgICB2YXIgeGxlZnQgICAgICAgPSBmcmFtZXdpZHRoOyAgLy8gTnVtYmVyIG9mIHN1YnJlY3QgcGl4ZWxzIGxlZnQgaW4gc2NhbmxpbmUuXG5cbiAgICAvLyBPdXRwdXQgaW5kaWNpZXMgb2YgdGhlIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgY29ybmVycyBvZiB0aGUgc3VicmVjdC5cbiAgICB2YXIgb3BiZWcgPSAoKGZyYW1lLnkgKiB3aWR0aCkgKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wZW5kID0gKChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAqIHdpZHRoICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcCAgICA9IG9wYmVnO1xuXG4gICAgdmFyIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQ7XG5cbiAgICAvLyBVc2Ugc2NhbnN0cmlkZSB0byBza2lwIHBhc3QgdGhlIHJvd3Mgd2hlbiBpbnRlcmxhY2luZy4gIFRoaXMgaXMgc2tpcHBpbmdcbiAgICAvLyA3IHJvd3MgZm9yIHRoZSBmaXJzdCB0d28gcGFzc2VzLCB0aGVuIDMgdGhlbiAxLlxuICAgIGlmIChmcmFtZS5pbnRlcmxhY2VkID09PSB0cnVlKSB7XG4gICAgICBzY2Fuc3RyaWRlICs9IHdpZHRoICogNCAqIDc7ICAvLyBQYXNzIDEuXG4gICAgfVxuXG4gICAgdmFyIGludGVybGFjZXNraXAgPSA4OyAgLy8gVHJhY2tpbmcgdGhlIHJvdyBpbnRlcnZhbCBpbiB0aGUgY3VycmVudCBwYXNzLlxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5kZXhfc3RyZWFtLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGV4X3N0cmVhbVtpXTtcblxuICAgICAgaWYgKHhsZWZ0ID09PSAwKSB7ICAvLyBCZWdpbm5pbmcgb2YgbmV3IHNjYW4gbGluZVxuICAgICAgICBvcCArPSBzY2Fuc3RyaWRlO1xuICAgICAgICB4bGVmdCA9IGZyYW1ld2lkdGg7XG4gICAgICAgIGlmIChvcCA+PSBvcGVuZCkgeyAvLyBDYXRjaCB0aGUgd3JhcCB0byBzd2l0Y2ggcGFzc2VzIHdoZW4gaW50ZXJsYWNpbmcuXG4gICAgICAgICAgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNCArIHdpZHRoICogNCAqIChpbnRlcmxhY2Vza2lwLTEpO1xuICAgICAgICAgIC8vIGludGVybGFjZXNraXAgLyAyICogNCBpcyBpbnRlcmxhY2Vza2lwIDw8IDEuXG4gICAgICAgICAgb3AgPSBvcGJlZyArIChmcmFtZXdpZHRoICsgZnJhbWVzdHJpZGUpICogKGludGVybGFjZXNraXAgPDwgMSk7XG4gICAgICAgICAgaW50ZXJsYWNlc2tpcCA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IHRyYW5zKSB7XG4gICAgICAgIG9wICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgciA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogM107XG4gICAgICAgIHZhciBnID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzICsgMV07XG4gICAgICAgIHZhciBiID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzICsgMl07XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IHI7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IGc7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IGI7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIC0teGxlZnQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbShjb2RlX3N0cmVhbSwgcCwgb3V0cHV0LCBvdXRwdXRfbGVuZ3RoKSB7XG4gIHZhciBtaW5fY29kZV9zaXplID0gY29kZV9zdHJlYW1bcCsrXTtcblxuICB2YXIgY2xlYXJfY29kZSA9IDEgPDwgbWluX2NvZGVfc2l6ZTtcbiAgdmFyIGVvaV9jb2RlID0gY2xlYXJfY29kZSArIDE7XG4gIHZhciBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG5cbiAgdmFyIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTsgIC8vIE51bWJlciBvZiBiaXRzIHBlciBjb2RlLlxuICAvLyBOT1RFOiBUaGlzIHNoYXJlcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBlbmNvZGVyLCBidXQgaGFzIGEgZGlmZmVyZW50XG4gIC8vIG1lYW5pbmcgaGVyZS4gIEhlcmUgdGhpcyBtYXNrcyBlYWNoIGNvZGUgY29taW5nIGZyb20gdGhlIGNvZGUgc3RyZWFtLlxuICB2YXIgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuICB2YXIgY3VyX3NoaWZ0ID0gMDtcbiAgdmFyIGN1ciA9IDA7XG5cbiAgdmFyIG9wID0gMDsgIC8vIE91dHB1dCBwb2ludGVyLlxuXG4gIHZhciBzdWJibG9ja19zaXplID0gY29kZV9zdHJlYW1bcCsrXTtcblxuICAvLyBUT0RPKGRlYW5tKTogV291bGQgdXNpbmcgYSBUeXBlZEFycmF5IGJlIGFueSBmYXN0ZXI/ICBBdCBsZWFzdCBpdCB3b3VsZFxuICAvLyBzb2x2ZSB0aGUgZmFzdCBtb2RlIC8gYmFja2luZyBzdG9yZSB1bmNlcnRhaW50eS5cbiAgLy8gdmFyIGNvZGVfdGFibGUgPSBBcnJheSg0MDk2KTtcbiAgdmFyIGNvZGVfdGFibGUgPSBuZXcgSW50MzJBcnJheSg0MDk2KTsgIC8vIENhbiBiZSBzaWduZWQsIHdlIG9ubHkgdXNlIDIwIGJpdHMuXG5cbiAgdmFyIHByZXZfY29kZSA9IG51bGw7ICAvLyBUcmFjayBjb2RlLTEuXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBSZWFkIHVwIHRvIHR3byBieXRlcywgbWFraW5nIHN1cmUgd2UgYWx3YXlzIDEyLWJpdHMgZm9yIG1heCBzaXplZCBjb2RlLlxuICAgIHdoaWxlIChjdXJfc2hpZnQgPCAxNikge1xuICAgICAgaWYgKHN1YmJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gTm8gbW9yZSBkYXRhIHRvIGJlIHJlYWQuXG5cbiAgICAgIGN1ciB8PSBjb2RlX3N0cmVhbVtwKytdIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSA4O1xuXG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMSkgeyAgLy8gTmV2ZXIgbGV0IGl0IGdldCB0byAwIHRvIGhvbGQgbG9naWMgYWJvdmUuXG4gICAgICAgIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdOyAgLy8gTmV4dCBzdWJibG9jay5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC0tc3ViYmxvY2tfc2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPKGRlYW5tKTogV2Ugc2hvdWxkIG5ldmVyIHJlYWxseSBnZXQgaGVyZSwgd2Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWRcbiAgICAvLyBhbmQgRU9JLlxuICAgIGlmIChjdXJfc2hpZnQgPCBjdXJfY29kZV9zaXplKVxuICAgICAgYnJlYWs7XG5cbiAgICB2YXIgY29kZSA9IGN1ciAmIGNvZGVfbWFzaztcbiAgICBjdXIgPj49IGN1cl9jb2RlX3NpemU7XG4gICAgY3VyX3NoaWZ0IC09IGN1cl9jb2RlX3NpemU7XG5cbiAgICAvLyBUT0RPKGRlYW5tKTogTWF5YmUgc2hvdWxkIGNoZWNrIHRoYXQgdGhlIGZpcnN0IGNvZGUgd2FzIGEgY2xlYXIgY29kZSxcbiAgICAvLyBhdCBsZWFzdCB0aGlzIGlzIHdoYXQgeW91J3JlIHN1cHBvc2VkIHRvIGRvLiAgQnV0IGFjdHVhbGx5IG91ciBlbmNvZGVyXG4gICAgLy8gbm93IGRvZXNuJ3QgZW1pdCBhIGNsZWFyIGNvZGUgZmlyc3QgYW55d2F5LlxuICAgIGlmIChjb2RlID09PSBjbGVhcl9jb2RlKSB7XG4gICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBoYXZlIHRvIGNsZWFyIHRoZSB0YWJsZS4gIFRoaXMgY291bGQgYmUgYSBnb29kIGlkZWFcbiAgICAgIC8vIGZvciBncmVhdGVyIGVycm9yIGNoZWNraW5nLCBidXQgd2UgZG9uJ3QgcmVhbGx5IGRvIGFueSBhbnl3YXkuICBXZVxuICAgICAgLy8gd2lsbCBqdXN0IHRyYWNrIGl0IHdpdGggbmV4dF9jb2RlIGFuZCBvdmVyd3JpdGUgb2xkIGVudHJpZXMuXG5cbiAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTtcbiAgICAgIGNvZGVfbWFzayA9ICgxIDw8IGN1cl9jb2RlX3NpemUpIC0gMTtcblxuICAgICAgLy8gRG9uJ3QgdXBkYXRlIHByZXZfY29kZSA/XG4gICAgICBwcmV2X2NvZGUgPSBudWxsO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBlb2lfY29kZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBhIHNpbWlsYXIgc2l0dWF0aW9uIGFzIHRoZSBkZWNvZGVyLCB3aGVyZSB3ZSB3YW50IHRvIHN0b3JlXG4gICAgLy8gdmFyaWFibGUgbGVuZ3RoIGVudHJpZXMgKGNvZGUgdGFibGUgZW50cmllcyksIGJ1dCB3ZSB3YW50IHRvIGRvIGluIGFcbiAgICAvLyBmYXN0ZXIgbWFubmVyIHRoYW4gYW4gYXJyYXkgb2YgYXJyYXlzLiAgVGhlIGNvZGUgYmVsb3cgc3RvcmVzIHNvcnQgb2YgYVxuICAgIC8vIGxpbmtlZCBsaXN0IHdpdGhpbiB0aGUgY29kZSB0YWJsZSwgYW5kIHRoZW4gXCJjaGFzZXNcIiB0aHJvdWdoIGl0IHRvXG4gICAgLy8gY29uc3RydWN0IHRoZSBkaWN0aW9uYXJ5IGVudHJpZXMuICBXaGVuIGEgbmV3IGVudHJ5IGlzIGNyZWF0ZWQsIGp1c3QgdGhlXG4gICAgLy8gbGFzdCBieXRlIGlzIHN0b3JlZCwgYW5kIHRoZSByZXN0IChwcmVmaXgpIG9mIHRoZSBlbnRyeSBpcyBvbmx5XG4gICAgLy8gcmVmZXJlbmNlZCBieSBpdHMgdGFibGUgZW50cnkuICBUaGVuIHRoZSBjb2RlIGNoYXNlcyB0aHJvdWdoIHRoZVxuICAgIC8vIHByZWZpeGVzIHVudGlsIGl0IHJlYWNoZXMgYSBzaW5nbGUgYnl0ZSBjb2RlLiAgV2UgaGF2ZSB0byBjaGFzZSB0d2ljZSxcbiAgICAvLyBmaXJzdCB0byBjb21wdXRlIHRoZSBsZW5ndGgsIGFuZCB0aGVuIHRvIGFjdHVhbGx5IGNvcHkgdGhlIGRhdGEgdG8gdGhlXG4gICAgLy8gb3V0cHV0IChiYWNrd2FyZHMsIHNpbmNlIHdlIGtub3cgdGhlIGxlbmd0aCkuICBUaGUgYWx0ZXJuYXRpdmUgd291bGQgYmVcbiAgICAvLyBzdG9yaW5nIHNvbWV0aGluZyBpbiBhbiBpbnRlcm1lZGlhdGUgc3RhY2ssIGJ1dCB0aGF0IGRvZXNuJ3QgbWFrZSBhbnlcbiAgICAvLyBtb3JlIHNlbnNlLiAgSSBpbXBsZW1lbnRlZCBhbiBhcHByb2FjaCB3aGVyZSBpdCBhbHNvIHN0b3JlZCB0aGUgbGVuZ3RoXG4gICAgLy8gaW4gdGhlIGNvZGUgdGFibGUsIGFsdGhvdWdoIGl0J3MgYSBiaXQgdHJpY2t5IGJlY2F1c2UgeW91IHJ1biBvdXQgb2ZcbiAgICAvLyBiaXRzICgxMiArIDEyICsgOCksIGJ1dCBJIGRpZG4ndCBtZWFzdXJlIG11Y2ggaW1wcm92ZW1lbnRzICh0aGUgdGFibGVcbiAgICAvLyBlbnRyaWVzIGFyZSBnZW5lcmFsbHkgbm90IHRoZSBsb25nKS4gIEV2ZW4gd2hlbiBJIGNyZWF0ZWQgYmVuY2htYXJrcyBmb3JcbiAgICAvLyB2ZXJ5IGxvbmcgdGFibGUgZW50cmllcyB0aGUgY29tcGxleGl0eSBkaWQgbm90IHNlZW0gd29ydGggaXQuXG4gICAgLy8gVGhlIGNvZGUgdGFibGUgc3RvcmVzIHRoZSBwcmVmaXggZW50cnkgaW4gMTIgYml0cyBhbmQgdGhlbiB0aGUgc3VmZml4XG4gICAgLy8gYnl0ZSBpbiA4IGJpdHMsIHNvIGVhY2ggZW50cnkgaXMgMjAgYml0cy5cblxuICAgIHZhciBjaGFzZV9jb2RlID0gY29kZSA8IG5leHRfY29kZSA/IGNvZGUgOiBwcmV2X2NvZGU7XG5cbiAgICAvLyBDaGFzZSB3aGF0IHdlIHdpbGwgb3V0cHV0LCBlaXRoZXIge0NPREV9IG9yIHtDT0RFLTF9LlxuICAgIHZhciBjaGFzZV9sZW5ndGggPSAwO1xuICAgIHZhciBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlID4gY2xlYXJfY29kZSkge1xuICAgICAgY2hhc2UgPSBjb2RlX3RhYmxlW2NoYXNlXSA+PiA4O1xuICAgICAgKytjaGFzZV9sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIGsgPSBjaGFzZTtcblxuICAgIHZhciBvcF9lbmQgPSBvcCArIGNoYXNlX2xlbmd0aCArIChjaGFzZV9jb2RlICE9PSBjb2RlID8gMSA6IDApO1xuICAgIGlmIChvcF9lbmQgPiBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmcsIGdpZiBzdHJlYW0gbG9uZ2VyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFscmVhZHkgaGF2ZSB0aGUgZmlyc3QgYnl0ZSBmcm9tIHRoZSBjaGFzZSwgbWlnaHQgYXMgd2VsbCB3cml0ZSBpdCBmYXN0LlxuICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBvcCArPSBjaGFzZV9sZW5ndGg7XG4gICAgdmFyIGIgPSBvcDsgIC8vIFRyYWNrIHBvaW50ZXIsIHdyaXRpbmcgYmFja3dhcmRzLlxuXG4gICAgaWYgKGNoYXNlX2NvZGUgIT09IGNvZGUpICAvLyBUaGUgY2FzZSBvZiBlbWl0dGluZyB7Q09ERS0xfSArIGsuXG4gICAgICBvdXRwdXRbb3ArK10gPSBrO1xuXG4gICAgY2hhc2UgPSBjaGFzZV9jb2RlO1xuICAgIHdoaWxlIChjaGFzZV9sZW5ndGgtLSkge1xuICAgICAgY2hhc2UgPSBjb2RlX3RhYmxlW2NoYXNlXTtcbiAgICAgIG91dHB1dFstLWJdID0gY2hhc2UgJiAweGZmOyAgLy8gV3JpdGUgYmFja3dhcmRzLlxuICAgICAgY2hhc2UgPj49IDg7ICAvLyBQdWxsIGRvd24gdG8gdGhlIHByZWZpeCBjb2RlLlxuICAgIH1cblxuICAgIGlmIChwcmV2X2NvZGUgIT09IG51bGwgJiYgbmV4dF9jb2RlIDwgNDA5Nikge1xuICAgICAgY29kZV90YWJsZVtuZXh0X2NvZGUrK10gPSBwcmV2X2NvZGUgPDwgOCB8IGs7XG4gICAgICAvLyBUT0RPKGRlYW5tKTogRmlndXJlIG91dCB0aGlzIGNsZWFyaW5nIHZzIGNvZGUgZ3Jvd3RoIGxvZ2ljIGJldHRlci4gIElcbiAgICAgIC8vIGhhdmUgYW4gZmVlbGluZyB0aGF0IGl0IHNob3VsZCBqdXN0IGhhcHBlbiBzb21ld2hlcmUgZWxzZSwgZm9yIG5vdyBpdFxuICAgICAgLy8gaXMgYXdrd2FyZCBiZXR3ZWVuIHdoZW4gd2UgZ3JvdyBwYXN0IHRoZSBtYXggYW5kIHRoZW4gaGl0IGEgY2xlYXIgY29kZS5cbiAgICAgIC8vIEZvciBub3cganVzdCBjaGVjayBpZiB3ZSBoaXQgdGhlIG1heCAxMi1iaXRzICh0aGVuIGEgY2xlYXIgY29kZSBzaG91bGRcbiAgICAgIC8vIGZvbGxvdywgYWxzbyBvZiBjb3Vyc2UgZW5jb2RlZCBpbiAxMi1iaXRzKS5cbiAgICAgIGlmIChuZXh0X2NvZGUgPj0gY29kZV9tYXNrKzEgJiYgY3VyX2NvZGVfc2l6ZSA8IDEyKSB7XG4gICAgICAgICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV9tYXNrID0gY29kZV9tYXNrIDw8IDEgfCAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZfY29kZSA9IGNvZGU7XG4gIH1cblxuICBpZiAob3AgIT09IG91dHB1dF9sZW5ndGgpIHtcbiAgICBjb25zb2xlLmxvZyhcIldhcm5pbmcsIGdpZiBzdHJlYW0gc2hvcnRlciB0aGFuIGV4cGVjdGVkLlwiKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIENvbW1vbkpTLlxudHJ5IHsgZXhwb3J0cy5HaWZXcml0ZXIgPSBHaWZXcml0ZXI7IGV4cG9ydHMuR2lmUmVhZGVyID0gR2lmUmVhZGVyIH0gY2F0Y2goZSkge31cbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8qIHNvY2tqcy1jbGllbnQgdjEuNC4wIHwgaHR0cDovL3NvY2tqcy5vcmcgfCBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuU29ja0pTID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9tYWluXCI6MTQsXCIuL3RyYW5zcG9ydC1saXN0XCI6MTZ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudHRhcmdldCcpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vbih0eXBlLCBnKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgZm9yICh2YXIgYWkgPSAxOyBhaSA8IGw7IGFpKyspIHtcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0se1wiLi9ldmVudHRhcmdldFwiOjUsXCJpbmhlcml0c1wiOjU3fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG59XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgdGhpcy50aW1lU3RhbXAgPSArbmV3IERhdGUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcbkV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxuICogICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICB9XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgLy8gIzRcbiAgaWYgKGFyci5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgYXJyID0gYXJyLmNvbmNhdChbbGlzdGVuZXJdKTtcbiAgfVxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIGlmICghYXJyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpZHggPSBhcnIuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgLy8gc2V0LlxuICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2VFdmVudChkYXRhKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWVzc2FnZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gIDtcblxuZnVuY3Rpb24gRmFjYWRlSlModHJhbnNwb3J0KSB7XG4gIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgdHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xufVxuXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdjJywgSlNPTjMuc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xuXG59LHtcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCJqc29uM1wiOjU4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxuICAsIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aWZyYW1lLWJvb3RzdHJhcCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbihhdCkge1xuICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBoYXJkLWNvZGVkIGZvciB0aGUgaW5mbyBpZnJhbWVcbiAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGR5bmFtaWNcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgdmFyIHBhcmVudE9yaWdpbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIHZhciBmYWNhZGU7XG4gICAgaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkID0gbG9jLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnRPcmlnaW4gPSBlLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHBbMV07XG4gICAgICAgIHZhciB0cmFuc1VybCA9IHBbMl07XG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcbiAgICAgICAgZGVidWcodmVyc2lvbiwgdHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCk7XG4gICAgICAgIC8vIGNoYW5nZSB0aGlzIHRvIHNlbXZlciBsb2dpY1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIHZlcnNpb24gKyAnXCIsIHRoZSBpZnJhbWU6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxuICAgICAgICAgICAgIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoYmFzZVVybCwgbG9jLmhyZWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBuZXcgRmFjYWRlSlMobmV3IHRyYW5zcG9ydE1hcFt0cmFuc3BvcnRdKHRyYW5zVXJsLCBiYXNlVXJsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGZhY2FkZS5fc2VuZChpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBpZiAoZmFjYWRlKSB7XG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgIC8vIFN0YXJ0XG4gICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3MnKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2ZhY2FkZVwiOjcsXCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWFqYXgnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0FqYXgodXJsLCBBamF4T2JqZWN0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHQwID0gK25ldyBEYXRlKCk7XG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIHZhciBpbmZvLCBydHQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBydHQgPSAoK25ldyBEYXRlKCkpIC0gdDA7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluZm8gPSBKU09OMy5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0VXRpbHMuaXNPYmplY3QoaW5mbykpIHtcbiAgICAgICAgaW5mbyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9BamF4LCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvQWpheC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy54by5jbG9zZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXJJZnJhbWUodHJhbnNVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XG4gIHRoaXMuaXIub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgc2VsZi5pciA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXJJZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcblxuSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pcikge1xuICAgIHRoaXMuaXIuY2xvc2UoKTtcbiAgICB0aGlzLmlyID0gbnVsbDtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXJJZnJhbWU7XG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi90cmFuc3BvcnQvaWZyYW1lXCI6MjIsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxuICAsIFhIUkNvcnMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXG4gICwgSW5mb0lmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXIoYmFzZVVybCwgdXJsSW5mbykge1xuICBkZWJ1ZyhiYXNlVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZG9YaHIoYmFzZVVybCwgdXJsSW5mbyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgaWdub3JpbmcgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgYW5kIHRoZSB3aGl0ZWxpc3RcblxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xuICAvLyBkZXRlcm1pbmUgbWV0aG9kIG9mIENPUlMgc3VwcG9ydCAoaWYgbmVlZGVkKVxuICBpZiAodXJsSW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcbiAgfVxuICBpZiAoWEhSQ29ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xuICB9XG4gIGlmIChYRFIuZW5hYmxlZCAmJiB1cmxJbmZvLnNhbWVTY2hlbWUpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcbiAgfVxuICBpZiAoSW5mb0lmcmFtZS5lbmFibGVkKCkpIHtcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcbiAgfVxuICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSRmFrZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsSW5mbykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pbmZvJylcbiAgICA7XG4gIGRlYnVnKCdkb1hocicsIHVybCk7XG5cbiAgdGhpcy54byA9IEluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIoYmFzZVVybCwgdXJsLCB1cmxJbmZvKTtcblxuICB0aGlzLnRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgfSwgSW5mb1JlY2VpdmVyLnRpbWVvdXQpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gIH0pO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgdGhpcy50aW1lb3V0UmVmID0gbnVsbDtcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICB9XG4gIHRoaXMueG8gPSBudWxsO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi9pbmZvLWlmcmFtZVwiOjExLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjM0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjozNixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uIHx8IHtcbiAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCdcbiwgcHJvdG9jb2w6ICdodHRwOidcbiwgaG9zdDogJ2xvY2FsaG9zdCdcbiwgcG9ydDogODBcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xuLCBoYXNoOiAnJ1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gIHRoaXMuX3RyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG4gIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgMDtcblxuICB2YXIgc2Vzc2lvbklkID0gb3B0aW9ucy5zZXNzaW9uSWQgfHwgODtcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhzZXNzaW9uSWQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gTWF0aC5tYXgodGhpcy5fdGltZW91dCwgKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwKTtcbiAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICBkZWJ1ZygndXNpbmcgdGltZW91dCcsIHRpbWVvdXRNcyk7XG5cbiAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl90cmFuc3BvcnRPcHRpb25zW1RyYW5zcG9ydC50cmFuc3BvcnROYW1lXTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQgJiYgdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuT1BFTjtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XG4gICAgZGVidWcoJ2Nvbm5lY3RlZCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxuICAgIC8vIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fY2xvc2UoMTAwNiwgJ1NlcnZlciBsb3N0IHNlc3Npb24nKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uLCB3YXNDbGVhbiwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgdmFyIGZvcmNlRmFpbCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLl9pcikge1xuICAgIGZvcmNlRmFpbCA9IHRydWU7XG4gICAgdGhpcy5faXIuY2xvc2UoKTtcbiAgICB0aGlzLl9pciA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFNvY2tKUyBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCcpO1xuICB9XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NJTkc7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NFRDtcblxuICAgIGlmIChmb3JjZUZhaWwpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpO1xuICAgIH1cblxuICAgIHZhciBlID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJyk7XG4gICAgZS53YXNDbGVhbiA9IHdhc0NsZWFuIHx8IGZhbHNlO1xuICAgIGUuY29kZSA9IGNvZGUgfHwgMTAwMDtcbiAgICBlLnJlYXNvbiA9IHJlYXNvbjtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB0aGlzLm9ubWVzc2FnZSA9IHRoaXMub25jbG9zZSA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgZGVidWcoJ2Rpc2Nvbm5lY3RlZCcpO1xuICB9LmJpbmQodGhpcyksIDApO1xufTtcblxuLy8gU2VlOiBodHRwOi8vd3d3LmVyZy5hYmRuLmFjLnVrL35nZXJyaXQvZGNjcC9ub3Rlcy9jY2lkMi9ydG9fZXN0aW1hdG9yL1xuLy8gYW5kIFJGQyAyOTg4LlxuU29ja0pTLnByb3RvdHlwZS5jb3VudFJUTyA9IGZ1bmN0aW9uKHJ0dCkge1xuICAvLyBJbiBhIGxvY2FsIGVudmlyb25tZW50LCB3aGVuIHVzaW5nIElFOC85IGFuZCB0aGUgYGpzb25wLXBvbGxpbmdgXG4gIC8vIHRyYW5zcG9ydCB0aGUgdGltZSBuZWVkZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiAodGhlIHRpbWUgdGhhdCBwYXNzXG4gIC8vIGZyb20gdGhlIG9wZW5pbmcgb2YgdGhlIHRyYW5zcG9ydCB0byB0aGUgY2FsbCBvZiBgX2Rpc3BhdGNoT3BlbmApIGlzXG4gIC8vIGFyb3VuZCAyMDBtc2VjICh0aGUgbG93ZXIgYm91bmQgdXNlZCBpbiB0aGUgYXJ0aWNsZSBhYm92ZSkgYW5kIHRoaXNcbiAgLy8gY2F1c2VzIHNwdXJpb3VzIHRpbWVvdXRzLiBGb3IgdGhpcyByZWFzb24gd2UgY2FsY3VsYXRlIGEgdmFsdWUgc2xpZ2h0bHlcbiAgLy8gbGFyZ2VyIHRoYW4gdGhhdCB1c2VkIGluIHRoZSBhcnRpY2xlLlxuICBpZiAocnR0ID4gMTAwKSB7XG4gICAgcmV0dXJuIDQgKiBydHQ7IC8vIHJ0byA+IDQwMG1zZWNcbiAgfVxuICByZXR1cm4gMzAwICsgcnR0OyAvLyAzMDBtc2VjIDwgcnRvIDw9IDQwMG1zZWNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB0cmFuc3BvcnRzID0gdHJhbnNwb3J0KGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXF1aXJlKCcuL2lmcmFtZS1ib290c3RyYXAnKShTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXR1cm4gU29ja0pTO1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9ldmVudC9jbG9zZVwiOjIsXCIuL2V2ZW50L2V2ZW50XCI6NCxcIi4vZXZlbnQvZXZlbnR0YXJnZXRcIjo1LFwiLi9ldmVudC90cmFucy1tZXNzYWdlXCI6NixcIi4vaWZyYW1lLWJvb3RzdHJhcFwiOjgsXCIuL2luZm8tcmVjZWl2ZXJcIjoxMixcIi4vbG9jYXRpb25cIjoxMyxcIi4vc2hpbXNcIjoxNSxcIi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi91dGlscy9lc2NhcGVcIjo0NSxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvbG9nXCI6NDgsXCIuL3V0aWxzL29iamVjdFwiOjQ5LFwiLi91dGlscy9yYW5kb21cIjo1MCxcIi4vdXRpbHMvdHJhbnNwb3J0XCI6NTEsXCIuL3V0aWxzL3VybFwiOjUyLFwiLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTgsXCJ1cmwtcGFyc2VcIjo2MX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlICovXG4vKiBqc2NzOiBkaXNhYmxlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIHB1bGxlZCBzcGVjaWZpYyBzaGltcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgRVMzICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KCkpO1xuXG4vLyBEZWZpbmUgY29uZmlndXJhYmxlLCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbi8vIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG52YXIgZGVmaW5lUHJvcGVydHk7XG5pZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgIH0pO1xuICAgIH07XG59IGVsc2Uge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9iamVjdFtuYW1lXSA9IG1ldGhvZDtcbiAgICB9O1xufVxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXAsIGZvcmNlQXNzaWduKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgaWYgKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgbmFtZSkpIHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHRvT2JqZWN0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIG8gKyAnIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0KG8pO1xufTtcblxuLy9cbi8vIFV0aWxcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDkuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS40XG4vLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXG5cbmZ1bmN0aW9uIHRvSW50ZWdlcihudW0pIHtcbiAgICB2YXIgbiA9ICtudW07XG4gICAgaWYgKG4gIT09IG4pIHsgLy8gaXNOYU5cbiAgICAgICAgbiA9IDA7XG4gICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIFRvVWludDMyKHgpIHtcbiAgICByZXR1cm4geCA+Pj4gMDtcbn1cblxuLy9cbi8vIEZ1bmN0aW9uXG4vLyA9PT09PT09PVxuLy9cblxuLy8gRVMtNSAxNS4zLjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcblxuZnVuY3Rpb24gRW1wdHkoKSB7fVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXG4gICAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgIC8vICAgc3BlY2lmaWVkIGluIDE1LjMuNS4xLlxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBYWFggQnVpbGQgYSBkeW5hbWljIGZ1bmN0aW9uIHdpdGggZGVzaXJlZCBhbW91bnQgb2YgYXJndW1lbnRzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgLy8gZm9yIGV4LikgYWxsIHVzZSBvZiBldmFsIG9yIEZ1bmN0aW9uIGNvc3RydWN0b3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgIHZhciBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxuICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcbiAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcbiAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgLy8gW1tTY29wZV1dIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxufSk7XG5cbi8vXG4vLyBBcnJheVxuLy8gPT09PT1cbi8vXG5cbi8vIEVTNSAxNS40LjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbmRlZmluZVByb3BlcnRpZXMoQXJyYXksIHsgaXNBcnJheTogaXNBcnJheSB9KTtcblxuXG52YXIgYm94ZWRTdHJpbmcgPSBPYmplY3QoJ2EnKTtcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxudmFyIHByb3Blcmx5Qm94ZXNDb250ZXh0ID0gZnVuY3Rpb24gcHJvcGVybHlCb3hlZChtZXRob2QpIHtcbiAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICB2YXIgcHJvcGVybHlCb3hlc1N0cmljdCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnKSB7IHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTsgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZXRob2QuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgIH0sICd4Jyk7XG4gICAgfVxuICAgIHJldHVybiAhIW1ldGhvZCAmJiBwcm9wZXJseUJveGVzTm9uU3RyaWN0ICYmIHByb3Blcmx5Qm94ZXNTdHJpY3Q7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmdW4gLyosIHRoaXNwKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBvYmplY3QsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIFRPRE8gbWVzc2FnZVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBjYWxsLCBwYXNzaW5nIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LCBwcm9wZXJ0eSB2YWx1ZSwgcHJvcGVydHkga2V5LCB0aGlzQXJnIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHRcbiAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5mb3JFYWNoKSk7XG5cbi8vIEVTNSAxNS40LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mICYmIFswLCAxXS5pbmRleE9mKDEsIDIpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovICkge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IHRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzb3VnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufSwgaGFzRmlyZWZveDJJbmRleE9mQnVnKTtcblxuLy9cbi8vIFN0cmluZ1xuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgMTUuNS40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcblxuLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbi8vIGRvIG5vdCBwZXJmb3JtIHRoZSBzcGxpdCBjb3JyZWN0bHkgdW5kZXIgb2JzY3VyZSBjb25kaXRpb25zLlxuLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4vLyAgICAnYWInLnNwbGl0KC8oPzphYikqLykgc2hvdWxkIGJlIFtcIlwiLCBcIlwiXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4vLyAgICAgICBbdW5kZWZpbmVkLCBcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgLi4uXVxuLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxudmFyIHN0cmluZ19zcGxpdCA9IFN0cmluZ1Byb3RvdHlwZS5zcGxpdDtcbmlmIChcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9PSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPT0gNCB8fFxuICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPT0gNCB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbikge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdm9pZCAwOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuXG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLmV4dGVuZGVkICAgPyAneCcgOiAnJykgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSAgICAgPyAneScgOiAnJyksIC8vIEZpcmVmb3ggMytcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgIHN0cmluZyArPSAnJzsgLy8gVHlwZS1jb252ZXJ0XG4gICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yLnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdm9pZCAwID9cbiAgICAgICAgICAgICAgICAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAgICBUb1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KCcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfSgpKTtcblxuLy8gW2J1Z2ZpeCwgY2hyb21lXVxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbi8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuLy8gdGhlbiB0aGUgb3V0cHV0IGFycmF5IGlzIHRydW5jYXRlZCBzbyB0aGF0IGl0IGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBsaW1pdFxuLy8gZWxlbWVudHMuXG4vLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG59IGVsc2UgaWYgKCcwJy5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbn1cblxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbi8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbnZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0IDwgMCA/ICgoc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0KSA8IDAgPyAwIDogc3RhcnQpIDogc3RhcnQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIC8vIHN0cmVhbWluZyB0cmFuc3BvcnRzXG4gIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3dlYnNvY2tldCcpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpKVxuXG4gIC8vIHBvbGxpbmcgdHJhbnNwb3J0c1xuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nJylcbl07XG5cbn0se1wiLi90cmFuc3BvcnQvZXZlbnRzb3VyY2VcIjoyMCxcIi4vdHJhbnNwb3J0L2h0bWxmaWxlXCI6MjEsXCIuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nXCI6MjMsXCIuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXBcIjoyNixcIi4vdHJhbnNwb3J0L3dlYnNvY2tldFwiOjM4LFwiLi90cmFuc3BvcnQveGRyLXBvbGxpbmdcIjozOSxcIi4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmdcIjo0MCxcIi4vdHJhbnNwb3J0L3hoci1wb2xsaW5nXCI6NDEsXCIuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nXCI6NDJ9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBYSFIgPSBnbG9iYWwuWE1MSHR0cFJlcXVlc3RcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJyb3dzZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIEFic3RyYWN0WEhST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhBYnN0cmFjdFhIUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIHRoaXMueGhyID0gbmV3IFhIUigpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG5cbiAgaWYgKCF0aGlzLnhocikge1xuICAgIGRlYnVnKCdubyB4aHInKTtcbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICdubyB4aHIgc3VwcG9ydCcpO1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzZXZlcmFsIGJyb3dzZXJzIGNhY2hlIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxuICAvLyB0YWIgZ2V0cyBjbG9zZWQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzUyODBcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCBjbGVhbnVwJyk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgdGhpcy54aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMudGltZW91dCAmJiAndGltZW91dCcgaW4gdGhpcy54aHIpIHtcbiAgICAgIHRoaXMueGhyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVidWcoJ3hociB0aW1lb3V0Jyk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ2V4Y2VwdGlvbicsIGUpO1xuICAgIC8vIElFIHJhaXNlcyBhbiBleGNlcHRpb24gb24gd3JvbmcgcG9ydC5cbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoKCFvcHRzIHx8ICFvcHRzLm5vQ3JlZGVudGlhbHMpICYmIEFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUykge1xuICAgIGRlYnVnKCd3aXRoQ3JlZGVudGlhbHMnKTtcbiAgICAvLyBNb3ppbGxhIGRvY3Mgc2F5cyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9YTUxIdHRwUmVxdWVzdCA6XG4gICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG5cbiAgICB0aGlzLnhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICB9XG4gIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICB2YXIgeCA9IHNlbGYueGhyO1xuICAgICAgdmFyIHRleHQsIHN0YXR1cztcbiAgICAgIGRlYnVnKCdyZWFkeVN0YXRlJywgeC5yZWFkeVN0YXRlKTtcbiAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUgZG9lcyByZXR1cm4gcmVhZHlzdGF0ZSA9PSAzIGZvciA0MDQgYW5zd2Vycy5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwICYmIHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWcoJ2NodW5rJyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdjaHVuaycsIHN0YXR1cywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRSByZXR1cm5zIHRoaXMgZm9yIGEgYmFkIHBvcnRcbiAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM4Mzc3MCh2PXZzLjg1KS5hc3B4XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMDA1IHx8IHN0YXR1cyA9PT0gMTIwMjkpIHtcbiAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgc2VsZi54aHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgLy8gSUUgbmVlZHMgdGhpcyBmaWVsZCB0byBiZSBhIGZ1bmN0aW9uXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge307XG4gIGlmICh0aGlzLnhoci5vbnRpbWVvdXQpIHtcbiAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGhyID0gbnVsbDtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIVhIUjtcbi8vIG92ZXJyaWRlIFhNTEh0dHBSZXF1ZXN0IGZvciBJRTYvN1xuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoIUFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgJiYgKGF4byBpbiBnbG9iYWwpKSB7XG4gIGRlYnVnKCdvdmVycmlkaW5nIHhtbGh0dHByZXF1ZXN0Jyk7XG4gIFhIUiA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtheG9dKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhbmV3IFhIUigpO1xufVxuXG52YXIgY29ycyA9IGZhbHNlO1xudHJ5IHtcbiAgY29ycyA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYSFIoKTtcbn0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxufVxuXG5BYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMgPSBjb3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIERyaXZlciA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbmlmIChEcml2ZXIpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBXZWJTb2NrZXRCcm93c2VyRHJpdmVyKHVybCkge1xuXHRcdHJldHVybiBuZXcgRHJpdmVyKHVybCk7XG5cdH07XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9ldmVudHNvdXJjZScsIEV2ZW50U291cmNlUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFFdmVudFNvdXJjZURyaXZlcjtcbn07XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnZXZlbnRzb3VyY2UnO1xuRXZlbnRTb3VyY2VUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9ldmVudHNvdXJjZVwiOjI5LFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSHRtbGZpbGVSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvaHRtbGZpbGUnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgO1xuXG5mdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgWEhSTG9jYWxPYmplY3QpO1xufVxuXG5pbmhlcml0cyhIdG1sRmlsZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuSHRtbEZpbGVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgcmV0dXJuIEh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW47XG59O1xuXG5IdG1sRmlsZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2h0bWxmaWxlJztcbkh0bWxGaWxlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxGaWxlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvaHRtbGZpbGVcIjozMCxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JrIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZnJvbSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXG4vLyBjcm9zcyBkb21haW4gaWZyYW1lIHVzaW5nIHBvc3RNZXNzYWdlKCkuIEluIElFIGl0IHdhcyBpbXBsZW1lbnRlZFxuLy8gZnJvbSBJRSA4KywgYnV0IG9mIGNvdXJzZSwgSUUgZ290IHNvbWUgZGV0YWlscyB3cm9uZzpcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4vLyAgICBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvaWZyYW1lJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gIGlmICghSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5vcmlnaW4gPSB1cmxVdGlscy5nZXRPcmlnaW4oYmFzZVVybCk7XG4gIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMud2luZG93SWQgPSByYW5kb20uc3RyaW5nKDgpO1xuXG4gIHZhciBpZnJhbWVVcmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaWZyYW1lLmh0bWwnKSArICcjJyArIHRoaXMud2luZG93SWQ7XG4gIGRlYnVnKHRyYW5zcG9ydCwgdHJhbnNVcmwsIGlmcmFtZVVybCk7XG5cbiAgdGhpcy5pZnJhbWVPYmogPSBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWUoaWZyYW1lVXJsLCBmdW5jdGlvbihyKSB7XG4gICAgZGVidWcoJ2VyciBjYWxsYmFjaycpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcblxuICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG59XG5cbmluaGVyaXRzKElmcmFtZVRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgZXZlbnRVdGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLl9tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XG4gICAgZGVidWcoJ25vdCBzYW1lIG9yaWdpbicsIGUub3JpZ2luLCB0aGlzLm9yaWdpbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSB0aGlzLndpbmRvd0lkKSB7XG4gICAgZGVidWcoJ21pc21hdGNoZWQgd2luZG93IGlkJywgaWZyYW1lTWVzc2FnZS53aW5kb3dJZCwgdGhpcy53aW5kb3dJZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgY2FzZSAncyc6XG4gICAgdGhpcy5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XG4gICAgdGhpcy5wb3N0TWVzc2FnZSgncycsIEpTT04zLnN0cmluZ2lmeShbXG4gICAgICB2ZXJzaW9uXG4gICAgLCB0aGlzLnRyYW5zcG9ydFxuICAgICwgdGhpcy50cmFuc1VybFxuICAgICwgdGhpcy5iYXNlVXJsXG4gICAgXSkpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0JzpcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjJzpcbiAgICB2YXIgY2RhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGNkYXRhID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgY2RhdGFbMF0sIGNkYXRhWzFdKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gIGRlYnVnKCdwb3N0TWVzc2FnZScsIHR5cGUsIGRhdGEpO1xuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04zLnN0cmluZ2lmeSh7XG4gICAgd2luZG93SWQ6IHRoaXMud2luZG93SWRcbiAgLCB0eXBlOiB0eXBlXG4gICwgZGF0YTogZGF0YSB8fCAnJ1xuICB9KSwgdGhpcy5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZSc7XG5JZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi91dGlscy91cmxcIjo1MixcIi4uL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4vLyBkb21haW4gaGFjayAtIEpTT05QLiBUaGlzIHRyYW5zcG9ydCBpcyBxdWl0ZSBpbmVmZmljaWVudCAtIG9uZVxuLy8gbWVzc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXG4gICwgSnNvbnBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvanNvbnAnKVxuICAsIGpzb25wU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXIvanNvbnAnKVxuICA7XG5cbmZ1bmN0aW9uIEpzb25QVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcbn1cblxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xuSnNvblBUcmFuc3BvcnQucm91bmRUcmlwcyA9IDE7XG5Kc29uUFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvblBUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vbGliL3NlbmRlci1yZWNlaXZlclwiOjI4LFwiLi9yZWNlaXZlci9qc29ucFwiOjMxLFwiLi9zZW5kZXIvanNvbnBcIjozMyxcImluaGVyaXRzXCI6NTd9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9zZW5kZXItcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YWpheC1iYXNlZCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcbiAgICB2YXIgb3B0ID0ge307XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ307XG4gICAgfVxuICAgIHZhciBhamF4VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh1cmwsICcveGhyX3NlbmQnKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XG4gICAgeG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwICYmIHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICB4by5jbG9zZSgpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIEFqYXhCYXNlZFRyYW5zcG9ydCh0cmFuc1VybCwgdXJsU3VmZml4LCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCB1cmxTdWZmaXgsIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCksIFJlY2VpdmVyLCBBamF4T2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoQWpheEJhc2VkVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQWpheEJhc2VkVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL3NlbmRlci1yZWNlaXZlclwiOjI4LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpidWZmZXJlZC1zZW5kZXInKTtcbn1cblxuZnVuY3Rpb24gQnVmZmVyZWRTZW5kZXIodXJsLCBzZW5kZXIpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgdGhpcy51cmwgPSB1cmw7XG59XG5cbmluaGVyaXRzKEJ1ZmZlcmVkU2VuZGVyLCBFdmVudEVtaXR0ZXIpO1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5zZW5kQnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gIGlmICghdGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFNjaGVkdWxlKCk7XG4gIH1cbn07XG5cbi8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcbi8vIG5ldyBtZXNzYWdlIGlzIGJlaW5nIHNlbmQuIElmIHRoZSBzZW5kaW5nIGNvbm5lY3Rpb24gd2FzIHN0YXJ0ZWRcbi8vIGJlZm9yZSByZWNlaXZpbmcgb25lLCBpdCBpcyBwb3NzaWJsZSB0byBzYXR1cmF0ZSB0aGUgbmV0d29yayBhbmRcbi8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcbi8vIHNlbmRpbmcgbWVzc2FnZXMgYnkgc29tZSBzbWFsbCB0aW1lLCBpbiBvcmRlciB0byBsZXQgcmVjZWl2aW5nXG4vLyBjb25uZWN0aW9uIGJlIHN0YXJ0ZWQgYmVmb3JlaGFuZC4gVGhpcyBpcyBvbmx5IGEgaGFsZm1lYXN1cmUgYW5kXG4vLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXG4vLyBzdGFibGUgb24gc2xvdyBuZXR3b3Jrcy5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGVXYWl0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGVXYWl0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRyZWY7XG4gIHRoaXMuc2VuZFN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnc2VuZFN0b3AnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gIH07XG4gIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgc2VsZi5zZW5kU2NoZWR1bGUoKTtcbiAgfSwgMjUpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlJywgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHBheWxvYWQgPSAnWycgKyB0aGlzLnNlbmRCdWZmZXIuam9pbignLCcpICsgJ10nO1xuICAgIHRoaXMuc2VuZFN0b3AgPSB0aGlzLnNlbmRlcih0aGlzLnVybCwgcGF5bG9hZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGVyci5jb2RlIHx8IDEwMDYsICdTZW5kaW5nIGVycm9yOiAnICsgZXJyKTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZW5kU2NoZWR1bGVXYWl0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIH1cbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAodGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFN0b3AoKTtcbiAgICB0aGlzLnNlbmRTdG9wID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJlZFNlbmRlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2lmcmFtZScpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cbiAgZnVuY3Rpb24gSWZyYW1lV3JhcFRyYW5zcG9ydCh0cmFuc1VybCwgYmFzZVVybCkge1xuICAgIElmcmFtZVRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0cmFuc1VybCwgYmFzZVVybCk7XG4gIH1cblxuICBpbmhlcml0cyhJZnJhbWVXcmFwVHJhbnNwb3J0LCBJZnJhbWVUcmFuc3BvcnQpO1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKHVybCwgaW5mbykge1xuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlmcmFtZUluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoe30sIGluZm8pO1xuICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XG4gICAgcmV0dXJuIHRyYW5zcG9ydC5lbmFibGVkKGlmcmFtZUluZm8pICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG4gIH07XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS0nICsgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZmFjYWRlVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIHJldHVybiBJZnJhbWVXcmFwVHJhbnNwb3J0O1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuLi9pZnJhbWVcIjoyMixcImluaGVyaXRzXCI6NTd9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpwb2xsaW5nJyk7XG59XG5cbmZ1bmN0aW9uIFBvbGxpbmcoUmVjZWl2ZXIsIHJlY2VpdmVVcmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcocmVjZWl2ZVVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLlJlY2VpdmVyID0gUmVjZWl2ZXI7XG4gIHRoaXMucmVjZWl2ZVVybCA9IHJlY2VpdmVVcmw7XG4gIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XG4gIHRoaXMuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbn1cblxuaW5oZXJpdHMoUG9sbGluZywgRXZlbnRFbWl0dGVyKTtcblxuUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY2hlZHVsZVJlY2VpdmVyJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBvbGwgPSB0aGlzLnBvbGwgPSBuZXcgdGhpcy5SZWNlaXZlcih0aGlzLnJlY2VpdmVVcmwsIHRoaXMuQWpheE9iamVjdCk7XG5cbiAgcG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcblxuICBwb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ2Nsb3NlJywgY29kZSwgcmVhc29uLCBzZWxmLnBvbGxJc0Nsb3NpbmcpO1xuICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xuXG4gICAgaWYgKCFzZWxmLnBvbGxJc0Nsb3NpbmcpIHtcbiAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xuICAgICAgICBzZWxmLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xuICAgICAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5wb2xsSXNDbG9zaW5nID0gdHJ1ZTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEJ1ZmZlcmVkU2VuZGVyID0gcmVxdWlyZSgnLi9idWZmZXJlZC1zZW5kZXInKVxuICAsIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIFNlbmRlclJlY2VpdmVyKHRyYW5zVXJsLCB1cmxTdWZmaXgsIHNlbmRlckZ1bmMsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIHZhciBwb2xsVXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgdXJsU3VmZml4KTtcbiAgZGVidWcocG9sbFVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgQnVmZmVyZWRTZW5kZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgc2VuZGVyRnVuYyk7XG5cbiAgdGhpcy5wb2xsID0gbmV3IFBvbGxpbmcoUmVjZWl2ZXIsIHBvbGxVcmwsIEFqYXhPYmplY3QpO1xuICB0aGlzLnBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygncG9sbCBtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcbiAgdGhpcy5wb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ3BvbGwgY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYucG9sbCA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoU2VuZGVyUmVjZWl2ZXIsIEJ1ZmZlcmVkU2VuZGVyKTtcblxuU2VuZGVyUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIEJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICAgIHRoaXMucG9sbCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vYnVmZmVyZWQtc2VuZGVyXCI6MjUsXCIuL3BvbGxpbmdcIjoyNyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6ZXZlbnRzb3VyY2UnKTtcbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZXMgPSB0aGlzLmVzID0gbmV3IEV2ZW50U291cmNlRHJpdmVyKHVybCk7XG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGVjb2RlVVJJKGUuZGF0YSkpO1xuICB9O1xuICBlcy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvcicsIGVzLnJlYWR5U3RhdGUsIGUpO1xuICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cbiAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgIHZhciByZWFzb24gPSAoZXMucmVhZHlTdGF0ZSAhPT0gMiA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UocmVhc29uKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIHZhciBlcyA9IHRoaXMuZXM7XG4gIGlmIChlcykge1xuICAgIGVzLm9ubWVzc2FnZSA9IGVzLm9uZXJyb3IgPSBudWxsO1xuICAgIGVzLmNsb3NlKCk7XG4gICAgdGhpcy5lcyA9IG51bGw7XG4gIH1cbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIFNhZmFyaSBhbmQgY2hyb21lIDwgMTUgY3Jhc2ggaWYgd2UgY2xvc2Ugd2luZG93IGJlZm9yZVxuICAvLyB3YWl0aW5nIGZvciBFUyBjbGVhbnVwLiBTZWU6XG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0sIDIwMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpodG1sZmlsZScpO1xufVxuXG5mdW5jdGlvbiBIdG1sZmlsZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZnJhbWVVdGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGRlY29kZVVSSUNvbXBvbmVudChpZnJhbWVVdGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGRlYnVnKCd1c2luZyBodG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkKTtcbiAgdmFyIGNvbnN0cnVjdEZ1bmMgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA/XG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0YXJ0Jyk7XG4gICAgICBzZWxmLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICB9XG4gICwgbWVzc2FnZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgIH1cbiAgLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdG9wJyk7XG4gICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICBzZWxmLl9jbG9zZSgnbmV0d29yaycpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5pZnJhbWVPYmogPSBjb25zdHJ1Y3RGdW5jKHVybCwgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKCdwZXJtYW5lbnQnKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gZmFsc2U7XG5cbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKGF4byBpbiBnbG9iYWwpIHtcbiAgdHJ5IHtcbiAgICBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9ICEhbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG59XG5cbkh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkIHx8IGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbGZpbGVSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6anNvbnAnKTtcbn1cblxuZnVuY3Rpb24gSnNvbnBSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcblxuICAvLyBGYWxsYmFjayBtb3N0bHkgZm9yIEtvbnF1ZXJvciAtIHN0dXBpZCB0aW1lciwgMzUgc2Vjb25kcyBzaGFsbCBiZSBwbGVudHkuXG4gIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5ICh0aW1lb3V0KScpKTtcbiAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmIChnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0pIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdKU09OUCB1c2VyIGFib3J0ZWQgcmVhZCcpO1xuICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICB0aGlzLl9hYm9ydChlcnIpO1xuICB9XG59O1xuXG5Kc29ucFJlY2VpdmVyLnRpbWVvdXQgPSAzNTAwMDtcbkpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0ID0gMTAwMDtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICBkZWJ1ZygnX2NhbGxiYWNrJywgZGF0YSk7XG4gIHRoaXMuX2NsZWFudXAoKTtcblxuICBpZiAodGhpcy5hYm9ydGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ25ldHdvcmsnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKGVycikge1xuICBkZWJ1ZygnX2Fib3J0JywgZXJyKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIGVyci5jb2RlLCBlcnIubWVzc2FnZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgaWYgKHRoaXMuc2NyaXB0Mikge1xuICAgIHRoaXMuc2NyaXB0Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0Mik7XG4gICAgdGhpcy5zY3JpcHQyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgeW91IGNhbid0IHJlYWxseSBhYm9ydCBzY3JpcHQgbG9hZGluZyBvZlxuICAgIC8vIHRoZSBzY3JpcHQuXG4gICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPVxuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NyaXB0RXJyb3InKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5lcnJvclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lcnJvclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYubG9hZGVkT2theSkge1xuICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpJykpO1xuICAgIH1cbiAgfSwgSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uKHVybCkge1xuICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXG5cbiAgc2NyaXB0LmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICBzY3JpcHQub25lcnJvciA9IHRoaXMuX3NjcmlwdEVycm9yLmJpbmQodGhpcyk7XG4gIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZCknKSk7XG4gIH07XG5cbiAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb25yZWFkeXN0YXRlY2hhbmdlIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxuICAvLyBVc2UgbG9hZGVkT2theSB0byBkZXRlcm1pbmUgaWYgYWN0dWFsbHkgZXJyb3JlZFxuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIHNjcmlwdC5yZWFkeVN0YXRlKTtcbiAgICBpZiAoL2xvYWRlZHxjbG9zZWQvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5odG1sRm9yICYmIHNjcmlwdC5vbmNsaWNrKSB7XG4gICAgICAgIHNlbGYubG9hZGVkT2theSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW4gSUUsIGFjdHVhbGx5IGV4ZWN1dGUgdGhlIHNjcmlwdC5cbiAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbnJlYWR5c3RhdGVjaGFuZ2UpJykpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gSUU6IGV2ZW50L2h0bWxGb3Ivb25jbGljayB0cmljay5cbiAgLy8gT25lIGNhbid0IHJlbHkgb24gcHJvcGVyIG9yZGVyIGZvciBvbnJlYWR5c3RhdGVjaGFuZ2UuIEluIG9yZGVyIHRvXG4gIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcbiAgLy8gc2NyaXB0IGNvZGUgd2lsbCBiZSBpbnN0YWxsZWQgYXMgJ29uY2xpY2snIGhhbmRsZXIgZm9yIHRoZVxuICAvLyBzY3JpcHQgb2JqZWN0LiBMYXRlciwgb25yZWFkeXN0YXRlY2hhbmdlLCBtYW51YWxseSBleGVjdXRlIHRoaXNcbiAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcbiAgLy8gc2V0LiBGb3IgcmVmZXJlbmNlIHNlZTpcbiAgLy8gICBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcbiAgLy8gICBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvRHluYW1pY19TY3JpcHRfRXhlY3V0aW9uX09yZGVyXG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jID09PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAvLyBBY2NvcmRpbmcgdG8gbW96aWxsYSBkb2NzLCBpbiByZWNlbnQgYnJvd3NlcnMgc2NyaXB0LmFzeW5jIGRlZmF1bHRzXG4gICAgLy8gdG8gJ3RydWUnLCBzbyB3ZSBtYXkgdXNlIGl0IHRvIGRldGVjdCBhIGdvb2QgYnJvd3NlcjpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9IVE1ML0VsZW1lbnQvc2NyaXB0XG4gICAgaWYgKCFicm93c2VyLmlzT3BlcmEoKSkge1xuICAgICAgLy8gTmFpdmVseSBhc3N1bWUgd2UncmUgaW4gSUVcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xuICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9wZXJhLCBzZWNvbmQgc3luYyBzY3JpcHQgaGFja1xuICAgICAgc2NyaXB0MiA9IHRoaXMuc2NyaXB0MiA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiICsgc2NyaXB0LmlkICsgXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcbiAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoZWFkID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgaWYgKHNjcmlwdDIpIHtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQyLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25wUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOnhocicpO1xufVxuXG5mdW5jdGlvbiBYaHJSZWNlaXZlcih1cmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmJ1ZmZlclBvc2l0aW9uID0gMDtcblxuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xuICB0aGlzLnhvLm9uKCdjaHVuaycsIHRoaXMuX2NodW5rSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLl9jaHVua0hhbmRsZXIoc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLnhvID0gbnVsbDtcbiAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcbiAgICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhoclJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICBkZWJ1ZygnX2NodW5rSGFuZGxlcicsIHN0YXR1cyk7XG4gIGlmIChzdGF0dXMgIT09IDIwMCB8fCAhdGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGlkeCA9IC0xOyA7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xuICAgIHZhciBidWYgPSB0ZXh0LnNsaWNlKHRoaXMuYnVmZmVyUG9zaXRpb24pO1xuICAgIGlkeCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcbiAgICBpZiAobXNnKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIH1cbiAgfVxufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAodGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ3VzZXInKTtcbiAgICB0aGlzLnhvID0gbnVsbDtcbiAgfVxuICB0aGlzLl9jbGVhbnVwKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjpqc29ucCcpO1xufVxuXG52YXIgZm9ybSwgYXJlYTtcblxuZnVuY3Rpb24gY3JlYXRlSWZyYW1lKGlkKSB7XG4gIGRlYnVnKCdjcmVhdGVJZnJhbWUnLCBpZCk7XG4gIHRyeSB7XG4gICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgcmV0dXJuIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8aWZyYW1lIG5hbWU9XCInICsgaWQgKyAnXCI+Jyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5uYW1lID0gaWQ7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtKCkge1xuICBkZWJ1ZygnY3JlYXRlRm9ybScpO1xuICBmb3JtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICBmb3JtLmFjY2VwdENoYXJzZXQgPSAnVVRGLTgnO1xuXG4gIGFyZWEgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgYXJlYS5uYW1lID0gJ2QnO1xuICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuXG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgZGVidWcodXJsLCBwYXlsb2FkKTtcbiAgaWYgKCFmb3JtKSB7XG4gICAgY3JlYXRlRm9ybSgpO1xuICB9XG4gIHZhciBpZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIGZvcm0udGFyZ2V0ID0gaWQ7XG4gIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xuXG4gIHZhciBpZnJhbWUgPSBjcmVhdGVJZnJhbWUoaWQpO1xuICBpZnJhbWUuaWQgPSBpZDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICB0cnkge1xuICAgIGFyZWEudmFsdWUgPSBwYXlsb2FkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gc2VyaW91c2x5IGJyb2tlbiBicm93c2VycyBnZXQgaGVyZVxuICB9XG4gIGZvcm0uc3VibWl0KCk7XG5cbiAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uKGVycikge1xuICAgIGRlYnVnKCdjb21wbGV0ZWQnLCBpZCwgZXJyKTtcbiAgICBpZiAoIWlmcmFtZS5vbmVycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgIC8vIE9wZXJhIG1pbmkgZG9lc24ndCBsaWtlIGlmIHdlIEdDIGlmcmFtZVxuICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFuaW5nIHVwJywgaWQpO1xuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgfSwgNTAwKTtcbiAgICBhcmVhLnZhbHVlID0gJyc7XG4gICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBpZiB0aGUgaWZyYW1lIHN1Y2NlZWRlZCBvclxuICAgIC8vIGZhaWxlZCB0byBzdWJtaXQgb3VyIGZvcm0uXG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcbiAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGlkLCBpZnJhbWUucmVhZHlTdGF0ZSwgZSk7XG4gICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnYWJvcnRlZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTV9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjp4ZHInKTtcbn1cblxuLy8gUmVmZXJlbmNlczpcbi8vICAgaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzLzEwMC1saW5lLWFqYXgtd3JhcHBlclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxuXG5mdW5jdGlvbiBYRFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKCdfc3RhcnQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGRyID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpO1xuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnRpbWVvdXQnKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICB9O1xuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2xvYWQnKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH07XG4gIHRoaXMueGRyID0geGRyO1xuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIC8vIEZhaWxzIHdpdGggQWNjZXNzRGVuaWVkIGlmIHBvcnQgbnVtYmVyIGlzIGJvZ3VzXG4gICAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy54ZHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICB9XG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHRoaXMuX2Vycm9yKCk7XG4gIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcbiAgaWYgKCF0aGlzLnhkcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBldmVudFV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgdGhpcy54ZHIub250aW1lb3V0ID0gdGhpcy54ZHIub25lcnJvciA9IHRoaXMueGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLnhkci5vbmxvYWQgPSBudWxsO1xuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbi8vIElFIDgvOSBpZiB0aGUgcmVxdWVzdCB0YXJnZXQgdXNlcyB0aGUgc2FtZSBzY2hlbWUgLSAjNzlcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhEUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSQ29yc09iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG59XG5cbmluaGVyaXRzKFhIUkNvcnNPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkNvcnNPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkICYmIFhockRyaXZlci5zdXBwb3J0c0NPUlM7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSQ29yc09iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gIDtcblxuZnVuY3Rpb24gWEhSRmFrZSgvKiBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyAqLykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCAne30nKTtcbiAgfSwgWEhSRmFrZS50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoWEhSRmFrZSwgRXZlbnRFbWl0dGVyKTtcblxuWEhSRmFrZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudG8pO1xufTtcblxuWEhSRmFrZS50aW1lb3V0ID0gMjAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJGYWtlO1xuXG59LHtcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSTG9jYWxPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQgLyosIG9wdHMgKi8pIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIHtcbiAgICBub0NyZWRlbnRpYWxzOiB0cnVlXG4gIH0pO1xufVxuXG5pbmhlcml0cyhYSFJMb2NhbE9iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSTG9jYWxPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvY2FsT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIFdlYnNvY2tldERyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVyL3dlYnNvY2tldCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp3ZWJzb2NrZXQnKTtcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KHRyYW5zVXJsLCBpZ25vcmUsIG9wdGlvbnMpIHtcbiAgaWYgKCFXZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2NvbnN0cnVjdG9yJywgdHJhbnNVcmwpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsICcvd2Vic29ja2V0Jyk7XG4gIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICB1cmwgPSAnd3NzJyArIHVybC5zbGljZSg1KTtcbiAgfSBlbHNlIHtcbiAgICB1cmwgPSAnd3MnICsgdXJsLnNsaWNlKDQpO1xuICB9XG4gIHRoaXMudXJsID0gdXJsO1xuXG4gIHRoaXMud3MgPSBuZXcgV2Vic29ja2V0RHJpdmVyKHRoaXMudXJsLCBbXSwgb3B0aW9ucyk7XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlIGV2ZW50JywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICB9O1xuICAvLyBGaXJlZm94IGhhcyBhbiBpbnRlcmVzdGluZyBidWcuIElmIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgLy8gY3JlYXRlZCBhZnRlciBvbnVubG9hZCwgaXQgc3RheXMgYWxpdmUgZXZlbiB3aGVuIHVzZXJcbiAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgLy8gbGV0J3Mgbm90IG9wZW4gdGhlIHdzIGNvbm5lY3Rpb24gYXQgYWxsLiBTZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NranMvc29ja2pzLWNsaWVudC9pc3N1ZXMvMjhcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQnKTtcbiAgICBzZWxmLndzLmNsb3NlKCk7XG4gIH0pO1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Nsb3NlIGV2ZW50JywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvciBldmVudCcsIGUpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xufVxuXG5pbmhlcml0cyhXZWJTb2NrZXRUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIG1zZyA9ICdbJyArIGRhdGEgKyAnXSc7XG4gIGRlYnVnKCdzZW5kJywgbXNnKTtcbiAgdGhpcy53cy5zZW5kKG1zZyk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh3cykge1xuICAgIHdzLmNsb3NlKCk7XG4gIH1cbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIGlmICh3cykge1xuICAgIHdzLm9ubWVzc2FnZSA9IHdzLm9uY2xvc2UgPSB3cy5vbmVycm9yID0gbnVsbDtcbiAgfVxuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMud3MgPSBudWxsO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2VuYWJsZWQnKTtcbiAgcmV0dXJuICEhV2Vic29ja2V0RHJpdmVyO1xufTtcbldlYlNvY2tldFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXG4vLyBub3QgdmVyeSBzdGFibGUgb3ZlciBTU0wuIE1vc3QgbGlrZWx5IGEgd3MgY29ubmVjdGlvbiByZXF1aXJlcyBhXG4vLyBzZXBhcmF0ZSBTU0wgY29ubmVjdGlvbiwgaW4gd2hpY2ggY2FzZSAyIHJvdW5kIHRyaXBzIGFyZSBhblxuLy8gYWJzb2x1dGUgbWludW11bS5cbldlYlNvY2tldFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2RyaXZlci93ZWJzb2NrZXRcIjoxOSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG5mdW5jdGlvbiBYZHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCIuL3hkci1zdHJlYW1pbmdcIjo0MCxcImluaGVyaXRzXCI6NTd9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbi8vIEFjY29yZGluZyB0bzpcbi8vICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxNTA3L2RldGVjdC1icm93c2VyLXN1cHBvcnQtZm9yLWNyb3NzLWRvbWFpbi14bWxodHRwcmVxdWVzdHNcbi8vICAgaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG5cbmZ1bmN0aW9uIFhkclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5jb29raWVfbmVlZGVkIHx8IGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gWERST2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lU2NoZW1lO1xufTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXN0cmVhbWluZyc7XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCJpbmhlcml0c1wiOjU3fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gIDtcblxuZnVuY3Rpb24gWGhyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG5YaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKVxuICA7XG5cbmZ1bmN0aW9uIFhoclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXG4gIC8vIEJ1dCBpdCBtaWdodCBiZSBhYmxlIHRvICM5MlxuICBpZiAoYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG4vLyBPbmx5IHJlcXVpcmUgYm9keSB3aGVuIHVzZWQgaW4gYSBicm93c2VyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09wZXJhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL29wZXJhL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuLCBpc0tvbnF1ZXJvcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9rb25xdWVyb3IvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8vICMxODcgd3JhcCBkb2N1bWVudC5kb21haW4gaW4gdHJ5L2NhdGNoIGJlY2F1c2Ugb2YgV1A4IGZyb20gZmlsZTovLy9cbiwgaGFzRG9tYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm9uLWJyb3dzZXIgY2xpZW50IGFsd2F5cyBoYXMgYSBkb21haW5cbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudC5kb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKTtcblxuLy8gU29tZSBleHRyYSBjaGFyYWN0ZXJzIHRoYXQgQ2hyb21lIGdldHMgd3JvbmcsIGFuZCBzdWJzdGl0dXRlcyB3aXRoXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgZXh0cmFFc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZ1xuICAsIGV4dHJhTG9va3VwO1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbExvb2t1cCA9IGZ1bmN0aW9uKGVzY2FwYWJsZSkge1xuICB2YXIgaTtcbiAgdmFyIHVucm9sbGVkID0ge307XG4gIHZhciBjID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gIH1cbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICB1bnJvbGxlZFsgYSBdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT04zLnN0cmluZ2lmeShzdHJpbmcpO1xuXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgIGV4dHJhRXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKCFleHRyYUVzY2FwYWJsZS50ZXN0KHF1b3RlZCkpIHtcbiAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFleHRyYUxvb2t1cCkge1xuICAgICAgZXh0cmFMb29rdXAgPSB1bnJvbGxMb29rdXAoZXh0cmFFc2NhcGFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBxdW90ZWQucmVwbGFjZShleHRyYUVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGV4dHJhTG9va3VwW2FdO1xuICAgIH0pO1xuICB9XG59O1xuXG59LHtcImpzb24zXCI6NTh9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuL3JhbmRvbScpO1xuXG52YXIgb25VbmxvYWQgPSB7fVxuICAsIGFmdGVyVW5sb2FkID0gZmFsc2VcbiAgICAvLyBkZXRlY3QgZ29vZ2xlIGNocm9tZSBwYWNrYWdlZCBhcHBzIGJlY2F1c2UgdGhleSBkb24ndCBhbGxvdyB0aGUgJ3VubG9hZCcgZXZlbnRcbiAgLCBpc0Nocm9tZVBhY2thZ2VkQXBwID0gZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmFwcCAmJiBnbG9iYWwuY2hyb21lLmFwcC5ydW50aW1lXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGF0dGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAvLyBJRSBxdWlya3MuXG4gICAgICAvLyBBY2NvcmRpbmcgdG86IGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcbiAgICAgIC8vIHRoZSBtZXNzYWdlIGdldHMgZGVsaXZlcmVkIG9ubHkgdG8gJ2RvY3VtZW50Jywgbm90ICd3aW5kb3cnLlxuICAgICAgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgLy8gSSBnZXQgJ3dpbmRvdycgZm9yIGllOC5cbiAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCBkZXRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5kZXRhY2hFdmVudCkge1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgZ2xvYmFsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIHVubG9hZEFkZDogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBpZiAoaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHJhbmRvbS5zdHJpbmcoOCk7XG4gICAgb25VbmxvYWRbcmVmXSA9IGxpc3RlbmVyO1xuICAgIGlmIChhZnRlclVubG9hZCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MsIDApO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xuICB9XG5cbiwgdW5sb2FkRGVsOiBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAocmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cblxuLCB0cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciByZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIG9uVW5sb2FkW3JlZl0oKTtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHVubG9hZFRyaWdnZXJlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWZ0ZXJVbmxvYWQgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzKCk7XG59O1xuXG4vLyAndW5sb2FkJyBhbG9uZSBpcyBub3QgcmVsaWFibGUgaW4gb3BlcmEgd2l0aGluIGFuIGlmcmFtZSwgYnV0IHdlXG4vLyBjYW4ndCB1c2UgYGJlZm9yZXVubG9hZGAgYXMgSUUgZmlyZXMgaXQgb24gamF2YXNjcmlwdDogbGlua3MuXG5pZiAoIWlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgbW9kdWxlLmV4cG9ydHMuYXR0YWNoRXZlbnQoJ3VubG9hZCcsIHVubG9hZFRyaWdnZXJlZCk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vcmFuZG9tXCI6NTB9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOmlmcmFtZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV1ByZWZpeDogJ19qcCdcbiwgY3VycmVudFdpbmRvd0lkOiBudWxsXG5cbiwgcG9sbHV0ZUdsb2JhbE5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEobW9kdWxlLmV4cG9ydHMuV1ByZWZpeCBpbiBnbG9iYWwpKSB7XG4gICAgICBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSB7fTtcbiAgICB9XG4gIH1cblxuLCBwb3N0TWVzc2FnZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIGlmIChnbG9iYWwucGFyZW50ICE9PSBnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5wYXJlbnQucG9zdE1lc3NhZ2UoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICAgICAgd2luZG93SWQ6IG1vZHVsZS5leHBvcnRzLmN1cnJlbnRXaW5kb3dJZFxuICAgICAgLCB0eXBlOiB0eXBlXG4gICAgICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgICAgIH0pLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4sIGNyZWF0ZUlmcmFtZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3VuYXR0YWNoJyk7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAvLyBFeHBsb3JlciBoYWQgcHJvYmxlbXMgd2l0aCB0aGF0LlxuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgbWFrZXMgY2hyb21lIGZpcmUgb25iZWZvcmV1bmxvYWQgZXZlbnRcbiAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgIC8vIG9udW5sb2FkLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgZXJyKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICBkZWJ1ZygncG9zdCcsIG1zZywgb3JpZ2luKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ29ubG9hZCcpO1xuICAgICAgLy8gYG9ubG9hZGAgaXMgdHJpZ2dlcmVkIGJlZm9yZSBzY3JpcHRzIG9uIHRoZSBpZnJhbWUgYXJlXG4gICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uZXJyb3IoJ29ubG9hZCB0aW1lb3V0Jyk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9O1xuICAgIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxuXG4vKiBlc2xpbnQgbm8tdW5kZWY6IFwib2ZmXCIsIG5ldy1jYXA6IFwib2ZmXCIgKi9cbiwgY3JlYXRlSHRtbGZpbGU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuICAgIHZhciBkb2MgPSBuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgaWZyYW1lO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgQ29sbGVjdEdhcmJhZ2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCByKTtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKHIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBnbG9iYWwuZG9jdW1lbnQuZG9tYWluICsgJ1wiOycgK1xuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgZG9jLnBhcmVudFdpbmRvd1ttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSBmYWxzZTtcbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gIC8vIGh1Z2UgZGVsYXksIG9yIG5vdCBhdCBhbGwuXG4gIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSAodHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdvYmplY3QnKSAmJiAoIWJyb3dzZXIuaXNLb25xdWVyb3IoKSk7XG59XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vYnJvd3NlclwiOjQ0LFwiLi9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2dPYmplY3QgPSB7fTtcblsnbG9nJywgJ2RlYnVnJywgJ3dhcm4nXS5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICB2YXIgbGV2ZWxFeGlzdHM7XG5cbiAgdHJ5IHtcbiAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XG4gIH0gY2F0Y2goZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuXG4gIGxvZ09iamVjdFtsZXZlbF0gPSBsZXZlbEV4aXN0cyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xuICB9IDogKGxldmVsID09PSAnbG9nJyA/IGZ1bmN0aW9uICgpIHt9IDogbG9nT2JqZWN0LmxvZyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2dPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9XG5cbiwgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMuaXNPYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xuXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBjcnlwdG86dHJ1ZSAqL1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vLyBUaGlzIHN0cmluZyBoYXMgbGVuZ3RoIDMyLCBhIHBvd2VyIG9mIDIsIHNvIHRoZSBtb2R1bHVzIGRvZXNuJ3QgaW50cm9kdWNlIGFcbi8vIGJpYXMuXG52YXIgX3JhbmRvbVN0cmluZ0NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Jztcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmc6IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBtYXggPSBfcmFuZG9tU3RyaW5nQ2hhcnMubGVuZ3RoO1xuICAgIHZhciBieXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGgpO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXQucHVzaChfcmFuZG9tU3RyaW5nQ2hhcnMuc3Vic3RyKGJ5dGVzW2ldICUgbWF4LCAxKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG4gIH1cblxuLCBudW1iZXI6IGZ1bmN0aW9uKG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xuICB9XG5cbiwgbnVtYmVyU3RyaW5nOiBmdW5jdGlvbihtYXgpIHtcbiAgICB2YXIgdCA9ICgnJyArIChtYXggLSAxKSkubGVuZ3RoO1xuICAgIHZhciBwID0gbmV3IEFycmF5KHQgKyAxKS5qb2luKCcwJyk7XG4gICAgcmV0dXJuIChwICsgdGhpcy5udW1iZXIobWF4KSkuc2xpY2UoLXQpO1xuICB9XG59O1xuXG59LHtcImNyeXB0b1wiOjQzfV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp0cmFuc3BvcnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHJldHVybiB7XG4gICAgZmlsdGVyVG9FbmFibGVkOiBmdW5jdGlvbih0cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKSB7XG4gICAgICB2YXIgdHJhbnNwb3J0cyA9IHtcbiAgICAgICAgbWFpbjogW11cbiAgICAgICwgZmFjYWRlOiBbXVxuICAgICAgfTtcbiAgICAgIGlmICghdHJhbnNwb3J0c1doaXRlbGlzdCkge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW107XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc3BvcnRzV2hpdGVsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW3RyYW5zcG9ydHNXaGl0ZWxpc3RdO1xuICAgICAgfVxuXG4gICAgICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgaWYgKCF0cmFucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy50cmFuc3BvcnROYW1lID09PSAnd2Vic29ja2V0JyAmJiBpbmZvLndlYnNvY2tldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQgZnJvbSBzZXJ2ZXInLCAnd2Vic29ja2V0Jyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zcG9ydHNXaGl0ZWxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0LmluZGV4T2YodHJhbnMudHJhbnNwb3J0TmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgZGVidWcoJ25vdCBpbiB3aGl0ZWxpc3QnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMuZW5hYmxlZChpbmZvKSkge1xuICAgICAgICAgIGRlYnVnKCdlbmFibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgdHJhbnNwb3J0cy5tYWluLnB1c2godHJhbnMpO1xuICAgICAgICAgIGlmICh0cmFucy5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydHMuZmFjYWRlLnB1c2godHJhbnMuZmFjYWRlVHJhbnNwb3J0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gICAgfVxuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTV9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJyk7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dXJsJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRPcmlnaW46IGZ1bmN0aW9uKHVybCkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAocC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBvcnQgPSBwLnBvcnQ7XG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gKHAucHJvdG9jb2wgPT09ICdodHRwczonKSA/ICc0NDMnIDogJzgwJztcbiAgICB9XG5cbiAgICByZXR1cm4gcC5wcm90b2NvbCArICcvLycgKyBwLmhvc3RuYW1lICsgJzonICsgcG9ydDtcbiAgfVxuXG4sIGlzT3JpZ2luRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5nZXRPcmlnaW4oYSkgPT09IHRoaXMuZ2V0T3JpZ2luKGIpO1xuICAgIGRlYnVnKCdzYW1lJywgYSwgYiwgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiwgaXNTY2hlbWVFcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiAoYS5zcGxpdCgnOicpWzBdID09PSBiLnNwbGl0KCc6JylbMF0pO1xuICB9XG5cbiwgYWRkUGF0aDogZnVuY3Rpb24gKHVybCwgcGF0aCkge1xuICAgIHZhciBxcyA9IHVybC5zcGxpdCgnPycpO1xuICAgIHJldHVybiBxc1swXSArIHBhdGggKyAocXNbMV0gPyAnPycgKyBxc1sxXSA6ICcnKTtcbiAgfVxuXG4sIGFkZFF1ZXJ5OiBmdW5jdGlvbiAodXJsLCBxKSB7XG4gICAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICgnPycgKyBxKSA6ICgnJicgKyBxKSk7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwidXJsLXBhcnNlXCI6NjF9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9ICcxLjQuMCc7XG5cbn0se31dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwtP1xcZD9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cblxufSx7fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWycjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJywgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLCAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJywgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLCAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JywgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLCAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJywgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ107XG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblxuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXG5cbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSB8fCAvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHwgLy8gSXMgZmlyZWZveCA+PSB2MzE/XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8IC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLyk7XG59XG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgKyBhcmdzWzBdICsgKHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICsgJysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTsgLy8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblxuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5kZXgrKztcblxuICAgIGlmIChtYXRjaCA9PT0gJyVjJykge1xuICAgICAgLy8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgX2NvbnNvbGU7XG5cbiAgLy8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICh0eXBlb2YgY29uc29sZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNvbnNvbGUpKSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS5sb2cgJiYgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcblxuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9IC8vIFN3YWxsb3dcbiAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblxuXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICAvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG4gICAgLy8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG52YXIgZm9ybWF0dGVycyA9IG1vZHVsZS5leHBvcnRzLmZvcm1hdHRlcnM7XG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcbiAgfVxufTtcblxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9jb21tb25cIjo1Nn1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgY3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcbiAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG4gIH0pO1xuICAvKipcbiAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG4gIC8qKlxuICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gIC8qKlxuICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAgKlxuICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG4gIC8qKlxuICAqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG4gICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbiAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcbiAgLyoqXG4gICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICogQHJldHVybiB7RnVuY3Rpb259XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcbiAgICB2YXIgcHJldlRpbWU7XG5cbiAgICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXNhYmxlZD9cbiAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gZGVidWc7IC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cbiAgICAgIHZhciBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgYXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgICB9IC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cblxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpOyAvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cbiAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pOyAvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXG4gICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG4gICAgICB2YXIgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcbiAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgZGVidWcuZXh0ZW5kID0gZXh0ZW5kOyAvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICAvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG4gICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblxuICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuICAgIHJldHVybiBkZWJ1ZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuICAgIHJldHVybiBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG4gICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG4gICAgICBpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgKlxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogQ29lcmNlIGB2YWxgLlxuICAqXG4gICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICogQHJldHVybiB7TWl4ZWR9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cblxuICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcbiAgcmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuXG5cbn0se1wibXNcIjo1NH1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgaWYgKGtleSBpbiByZXN1bHQpIGNvbnRpbnVlO1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW107XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcblxufSx7fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG5cbn0se31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFNcXHNdKikvaVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgbG9jYXRpb24gPSBnbG9iYWwgJiYgZ2xvYmFsLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jYXRpb24gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBwYXJzZXIgUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycpO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKCFleHRyYWN0ZWQuc2xhc2hlcykgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wicXVlcnlzdHJpbmdpZnlcIjo1OSxcInJlcXVpcmVzLXBvcnRcIjo2MH1dfSx7fSxbMV0pKDEpXG59KTtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2NranMuanMubWFwXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUNsaWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNsaWVudCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG5lZWRzIGltcGxlbWVudGF0aW9uJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDbGllbnQ7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGVcbiAgbm8tdW51c2VkLXZhcnNcbiovXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgU29ja0pTID0gcmVxdWlyZSgnc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcycpO1xuXG52YXIgQmFzZUNsaWVudCA9IHJlcXVpcmUoJy4vQmFzZUNsaWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VDbGllbnQpIHtcbiAgX2luaGVyaXRzKFNvY2tKU0NsaWVudCwgX0Jhc2VDbGllbnQpO1xuXG4gIGZ1bmN0aW9uIFNvY2tKU0NsaWVudCh1cmwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU29ja0pTQ2xpZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNvY2tKU0NsaWVudCkuY2FsbCh0aGlzKSk7XG4gICAgX3RoaXMuc29jayA9IG5ldyBTb2NrSlModXJsKTtcblxuICAgIF90aGlzLnNvY2sub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsvLyBUT0RPOiB1c2UgbG9nZ2VyIHRvIGxvZyB0aGUgZXJyb3IgZXZlbnQgb25jZSBjbGllbnQgYW5kIGNsaWVudC1zcmNcbiAgICAgIC8vIGFyZSByZW9yZ2FuaXplZCB0byBoYXZlIHRoZSBzYW1lIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNvY2tKU0NsaWVudCwgW3tcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbihmKSB7XG4gICAgICB0aGlzLnNvY2sub25vcGVuID0gZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbmNsb3NlID0gZjtcbiAgICB9IC8vIGNhbGwgZiB3aXRoIHRoZSBtZXNzYWdlIHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcblxuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGYoZS5kYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUoJy4vU29ja0pTQ2xpZW50Jyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvY2tKU0NsaWVudDtcbn0oQmFzZUNsaWVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpLFxuICAgIGxvZyA9IF9yZXF1aXJlLmxvZyxcbiAgICBzZXRMb2dMZXZlbCA9IF9yZXF1aXJlLnNldExvZ0xldmVsO1xuXG52YXIgc2VuZE1lc3NhZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3NlbmRNZXNzYWdlJyk7XG5cbnZhciByZWxvYWRBcHAgPSByZXF1aXJlKCcuL3V0aWxzL3JlbG9hZEFwcCcpO1xuXG52YXIgY3JlYXRlU29ja2V0VXJsID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTb2NrZXRVcmwnKTtcblxudmFyIHN0YXR1cyA9IHtcbiAgaXNVbmxvYWRpbmc6IGZhbHNlLFxuICBjdXJyZW50SGFzaDogJydcbn07XG52YXIgb3B0aW9ucyA9IHtcbiAgaG90OiBmYWxzZSxcbiAgaG90UmVsb2FkOiB0cnVlLFxuICBsaXZlUmVsb2FkOiBmYWxzZSxcbiAgaW5pdGlhbDogdHJ1ZSxcbiAgdXNlV2FybmluZ092ZXJsYXk6IGZhbHNlLFxuICB1c2VFcnJvck92ZXJsYXk6IGZhbHNlLFxuICB1c2VQcm9ncmVzczogZmFsc2Vcbn07XG52YXIgc29ja2V0VXJsID0gY3JlYXRlU29ja2V0VXJsKF9fcmVzb3VyY2VRdWVyeSk7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgc3RhdHVzLmlzVW5sb2FkaW5nID0gdHJ1ZTtcbn0pO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHFzID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICBvcHRpb25zLmhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cblxudmFyIG9uU29ja2V0TWVzc2FnZSA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC4nKTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7IC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnSW52YWxpZCcpO1xuICB9LFxuICBoYXNoOiBmdW5jdGlvbiBoYXNoKF9oYXNoKSB7XG4gICAgc3RhdHVzLmN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ1N0aWxsT2snKTtcbiAgfSxcbiAgJ2xvZy1sZXZlbCc6IGZ1bmN0aW9uIGxvZ0xldmVsKGxldmVsKSB7XG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XG5cbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG5cbiAgICBzZXRMb2dMZXZlbChsZXZlbCk7XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlLmVycm9ycztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhfcHJvZ3Jlc3MpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy51c2VQcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgICB9XG4gIH0sXG4gICdwcm9ncmVzcy11cGRhdGUnOiBmdW5jdGlvbiBwcm9ncmVzc1VwZGF0ZShkYXRhKSB7XG4gICAgaWYgKG9wdGlvbnMudXNlUHJvZ3Jlc3MpIHtcbiAgICAgIGxvZy5pbmZvKFwiW1dEU10gXCIuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnUHJvZ3Jlc3MnLCBkYXRhKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKCdPaycpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQ29udGVudCBiYXNlIGNoYW5nZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBEaXNjb25uZWN0ZWQhJyk7XG4gICAgc2VuZE1lc3NhZ2UoJ0Nsb3NlJyk7XG4gIH1cbn07XG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1lc3NhZ2UpOyIsIid1c2Ugc3RyaWN0JzsgLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5cbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdodG1sLWVudGl0aWVzJyksXG4gICAgQWxsSHRtbEVudGl0aWVzID0gX3JlcXVpcmUuQWxsSHRtbEVudGl0aWVzO1xuXG52YXIgZW50aXRpZXMgPSBuZXcgQWxsSHRtbEVudGl0aWVzKCk7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogWyd0cmFuc3BhcmVudCcsICd0cmFuc3BhcmVudCddLFxuICBibGFjazogJzE4MTgxOCcsXG4gIHJlZDogJ0UzNjA0OScsXG4gIGdyZWVuOiAnQjNDQjc0JyxcbiAgeWVsbG93OiAnRkZEMDgwJyxcbiAgYmx1ZTogJzdDQUZDMicsXG4gIG1hZ2VudGE6ICc3RkFDQ0EnLFxuICBjeWFuOiAnQzNDMkVGJyxcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcbiAgZGFya2dyZXk6ICc2RDc4OTEnXG59O1xudmFyIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xudmFyIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG5hbnNpSFRNTC5zZXRDb2xvcnMoY29sb3JzKTtcblxuZnVuY3Rpb24gY3JlYXRlT3ZlcmxheUlmcmFtZShvbklmcmFtZUxvYWQpIHtcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICBpZnJhbWUuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5JztcbiAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGlmcmFtZS5zdHlsZS5sZWZ0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLnRvcCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5yaWdodCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5ib3R0b20gPSAwO1xuICBpZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBpZnJhbWUuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgaWZyYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgaWZyYW1lLnN0eWxlLnpJbmRleCA9IDk5OTk5OTk5OTk7XG4gIGlmcmFtZS5vbmxvYWQgPSBvbklmcmFtZUxvYWQ7XG4gIHJldHVybiBpZnJhbWU7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJsYXlEaXZUbyhpZnJhbWUpIHtcbiAgdmFyIGRpdiA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXktZGl2JztcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgZGl2LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgZGl2LnN0eWxlLmxlZnQgPSAwO1xuICBkaXYuc3R5bGUudG9wID0gMDtcbiAgZGl2LnN0eWxlLnJpZ2h0ID0gMDtcbiAgZGl2LnN0eWxlLmJvdHRvbSA9IDA7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC44NSknO1xuICBkaXYuc3R5bGUuY29sb3IgPSAnI0U4RThFOCc7XG4gIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gJ01lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlJztcbiAgZGl2LnN0eWxlLmZvbnRTaXplID0gJ2xhcmdlJztcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMnJlbSc7XG4gIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gJzEuMic7XG4gIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICBpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn1cblxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhvbk92ZXJsYXlEaXZSZWFkeSkge1xuICBpZiAob3ZlcmxheURpdikge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgb25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuXG5cbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gb25PdmVybGF5RGl2UmVhZHk7XG5cbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcbiAgICAvLyBXZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0ZSBpZnJhbWUgYW5kLCB3aGVuIGl0IGlzIHJlYWR5LCBhIGRpdiBpbnNpZGUgaXQuXG5cblxuICBvdmVybGF5SWZyYW1lID0gY3JlYXRlT3ZlcmxheUlmcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgb3ZlcmxheURpdiA9IGFkZE92ZXJsYXlEaXZUbyhvdmVybGF5SWZyYW1lKTsgLy8gTm93IHdlIGNhbiB0YWxrIVxuXG4gICAgbGFzdE9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICB9KTsgLy8gWmFsZ28gYWxlcnQ6IG9uSWZyYW1lTG9hZCgpIHdpbGwgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5XG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cbiAgLy8gV2UgZGVsYXkgYWRkaW5nIGl0IHNvIGBvdmVybGF5SWZyYW1lYCBpcyBzZXQgd2hlbiBgb25JZnJhbWVMb2FkYCBmaXJlcy5cblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXlJZnJhbWUpO1xufSAvLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuXG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBpZiAoIW92ZXJsYXlEaXYpIHtcbiAgICAvLyBJdCBpcyBub3QgdGhlcmUgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIHJldHVybjtcbiAgfSAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG5cblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG92ZXJsYXlJZnJhbWUpO1xuICBvdmVybGF5RGl2ID0gbnVsbDtcbiAgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG59IC8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuXG5cbmZ1bmN0aW9uIHNob3dNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMoZnVuY3Rpb24gKGRpdikge1xuICAgIC8vIE1ha2UgaXQgbG9vayBzaW1pbGFyIHRvIG91ciB0ZXJtaW5hbC5cbiAgICBkaXYuaW5uZXJIVE1MID0gXCI8c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNcIi5jb25jYXQoY29sb3JzLnJlZCwgXCJcXFwiPkZhaWxlZCB0byBjb21waWxlLjwvc3Bhbj48YnI+PGJyPlwiKS5jb25jYXQoYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1lc3NhZ2VzWzBdKSkpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNsZWFyOiBjbGVhcixcbiAgc2hvd01lc3NhZ2U6IHNob3dNZXNzYWdlXG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZVxuICBjYW1lbGNhc2VcbiovXG4vLyB0aGlzIFNvY2tKU0NsaWVudCBpcyBoZXJlIGFzIGEgZGVmYXVsdCBmYWxsYmFjaywgaW4gY2FzZSBpbmxpbmUgbW9kZVxuLy8gaXMgb2ZmIG9yIHRoZSBjbGllbnQgaXMgbm90IGluamVjdGVkLiBUaGlzIHdpbGwgYmUgc3dpdGNoZWQgdG9cbi8vIFdlYnNvY2tldENsaWVudCB3aGVuIGl0IGJlY29tZXMgdGhlIGRlZmF1bHRcbi8vIGltcG9ydGFudDogdGhlIHBhdGggdG8gU29ja0pTQ2xpZW50IGhlcmUgaXMgbWFkZSB0byB3b3JrIGluIHRoZSAnY2xpZW50J1xuLy8gZGlyZWN0b3J5LCBidXQgaXMgdXBkYXRlZCB2aWEgdGhlIHdlYnBhY2sgY29tcGlsYXRpb24gd2hlbiBjb21waWxlZCBmcm9tXG4vLyB0aGUgJ2NsaWVudC1zcmMnIGRpcmVjdG9yeVxuXG52YXIgQ2xpZW50ID0gdHlwZW9mIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5yZXF1aXJlKCcuL2NsaWVudHMvU29ja0pTQ2xpZW50Jyk7XG52YXIgcmV0cmllcyA9IDA7XG52YXIgY2xpZW50ID0gbnVsbDtcblxudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycykge1xuICBjbGllbnQgPSBuZXcgQ2xpZW50KHVybCk7XG4gIGNsaWVudC5vbk9wZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHJpZXMgPSAwO1xuICB9KTtcbiAgY2xpZW50Lm9uQ2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXRyaWVzID09PSAwKSB7XG4gICAgICBoYW5kbGVycy5jbG9zZSgpO1xuICAgIH0gLy8gVHJ5IHRvIHJlY29ubmVjdC5cblxuXG4gICAgY2xpZW50ID0gbnVsbDsgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuXG4gICAgaWYgKHJldHJpZXMgPD0gMTApIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcbiAgICAgIHZhciByZXRyeUluTXMgPSAxMDAwICogTWF0aC5wb3coMiwgcmV0cmllcykgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9KTtcbiAgY2xpZW50Lm9uTWVzc2FnZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBtc2cgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgaWYgKGhhbmRsZXJzW21zZy50eXBlXSkge1xuICAgICAgaGFuZGxlcnNbbXNnLnR5cGVdKG1zZy5kYXRhKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb2NrZXQ7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIHNlbGYgKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG52YXIgZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSA9IHJlcXVpcmUoJy4vZ2V0Q3VycmVudFNjcmlwdFNvdXJjZScpO1xuXG5mdW5jdGlvbiBjcmVhdGVTb2NrZXRVcmwocmVzb3VyY2VRdWVyeSkge1xuICB2YXIgdXJsUGFydHM7XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiByZXNvdXJjZVF1ZXJ5ICE9PSAnJykge1xuICAgIC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cbiAgICB1cmxQYXJ0cyA9IHVybC5wYXJzZShyZXNvdXJjZVF1ZXJ5LnN1YnN0cigxKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cbiAgICB2YXIgc2NyaXB0SG9zdCA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTtcblxuICAgIGlmIChzY3JpcHRIb3N0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAgIHNjcmlwdEhvc3QgPSBzY3JpcHRIb3N0LnJlcGxhY2UoL1xcL1teXFwvXSskLywgJycpO1xuICAgIH1cblxuICAgIHVybFBhcnRzID0gdXJsLnBhcnNlKHNjcmlwdEhvc3QgfHwgJy8nLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoIXVybFBhcnRzLnBvcnQgfHwgdXJsUGFydHMucG9ydCA9PT0gJzAnKSB7XG4gICAgdXJsUGFydHMucG9ydCA9IHNlbGYubG9jYXRpb24ucG9ydDtcbiAgfVxuXG4gIHZhciBfdXJsUGFydHMgPSB1cmxQYXJ0cyxcbiAgICAgIGF1dGggPSBfdXJsUGFydHMuYXV0aCxcbiAgICAgIHBhdGggPSBfdXJsUGFydHMucGF0aDtcbiAgdmFyIF91cmxQYXJ0czIgPSB1cmxQYXJ0cyxcbiAgICAgIGhvc3RuYW1lID0gX3VybFBhcnRzMi5ob3N0bmFtZSxcbiAgICAgIHByb3RvY29sID0gX3VybFBhcnRzMi5wcm90b2NvbDsgLy8gY2hlY2sgaXB2NCBhbmQgaXB2NiBgYWxsIGhvc3RuYW1lYFxuICAvLyB3aHkgZG8gd2UgbmVlZCB0aGlzIGNoZWNrP1xuICAvLyBob3N0bmFtZSBuL2EgZm9yIGZpbGUgcHJvdG9jb2wgKGV4YW1wbGUsIHdoZW4gdXNpbmcgZWxlY3Ryb24sIGlvbmljKVxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9wdWxsLzM4NFxuXG4gIHZhciBpc0FueUhvc3RuYW1lID0gKGhvc3RuYW1lID09PSAnMC4wLjAuMCcgfHwgaG9zdG5hbWUgPT09ICc6OicpICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgISF+c2VsZi5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJyk7XG5cbiAgaWYgKGlzQW55SG9zdG5hbWUpIHtcbiAgICBob3N0bmFtZSA9IHNlbGYubG9jYXRpb24uaG9zdG5hbWU7XG4gIH0gLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xuICAvLyBhIHByb3RvY29sIHdvdWxkIHJlc3VsdCBpbiBhbiBpbnZhbGlkIFVSTC5cbiAgLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XG4gIC8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxuXG5cbiAgaWYgKGhvc3RuYW1lICYmIChzZWxmLmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCB1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSkge1xuICAgIHByb3RvY29sID0gc2VsZi5sb2NhdGlvbi5wcm90b2NvbDtcbiAgfSAvLyBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgc29jayB1cmwgaWYgdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cblxuICB2YXIgc29ja0hvc3QgPSBob3N0bmFtZTtcbiAgdmFyIHNvY2tQYXRoID0gJy9zb2NranMtbm9kZSc7XG4gIHZhciBzb2NrUG9ydCA9IHVybFBhcnRzLnBvcnQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcblxuICB2YXIgc2hvdWxkUGFyc2VQYXRoID0gcGF0aCAhPT0gbnVsbCAmJiBwYXRoICE9PSB1bmRlZmluZWQgJiYgcGF0aCAhPT0gJy8nO1xuXG4gIGlmIChzaG91bGRQYXJzZVBhdGgpIHtcbiAgICB2YXIgcGFyc2VkUXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZShwYXRoKTsgLy8gYWxsIG9mIHRoZXNlIHNvY2sgdXJsIHBhcmFtcyBhcmUgb3B0aW9uYWxseSBwYXNzZWQgaW4gdGhyb3VnaFxuICAgIC8vIHJlc291cmNlUXVlcnksIHNvIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IGlmXG4gICAgLy8gdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cbiAgICBzb2NrSG9zdCA9IHBhcnNlZFF1ZXJ5LnNvY2tIb3N0IHx8IHNvY2tIb3N0O1xuICAgIHNvY2tQYXRoID0gcGFyc2VkUXVlcnkuc29ja1BhdGggfHwgc29ja1BhdGg7XG4gICAgc29ja1BvcnQgPSBwYXJzZWRRdWVyeS5zb2NrUG9ydCB8fCBzb2NrUG9ydDtcbiAgfVxuXG4gIHJldHVybiB1cmwuZm9ybWF0KHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgYXV0aDogYXV0aCxcbiAgICBob3N0bmFtZTogc29ja0hvc3QsXG4gICAgcG9ydDogc29ja1BvcnQsXG4gICAgLy8gSWYgc29ja1BhdGggaXMgcHJvdmlkZWQgaXQnbGwgYmUgcGFzc2VkIGluIHZpYSB0aGUgcmVzb3VyY2VRdWVyeSBhcyBhXG4gICAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgICAvLyBjbGllbnQgdG8gb3BlbiB0aGUgc29ja2V0IHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgIHBhdGhuYW1lOiBzb2NrUGF0aFxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTb2NrZXRVcmw7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG5cblxuICB2YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5zY3JpcHRzIHx8IFtdO1xuICB2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzW3NjcmlwdEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdbV0RTXSBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgc2NyaXB0IHNvdXJjZS4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykuZ2V0TG9nZ2VyKCd3ZWJwYWNrLWRldi1zZXJ2ZXInKTtcblxudmFyIElORk8gPSAnaW5mbyc7XG52YXIgV0FSTiA9ICd3YXJuJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgREVCVUcgPSAnZGVidWcnO1xudmFyIFRSQUNFID0gJ3RyYWNlJztcbnZhciBTSUxFTlQgPSAnc2lsZW50JzsgLy8gZGVwcmVjYXRlZFxuLy8gVE9ETzogcmVtb3ZlIHRoZXNlIGF0IG1ham9yIHJlbGVhc2VkXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8xODI1XG5cbnZhciBXQVJOSU5HID0gJ3dhcm5pbmcnO1xudmFyIE5PTkUgPSAnbm9uZSc7IC8vIFNldCB0aGUgZGVmYXVsdCBsb2cgbGV2ZWxcblxubG9nLnNldERlZmF1bHRMZXZlbChJTkZPKTtcblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgSU5GTzpcbiAgICBjYXNlIFdBUk46XG4gICAgY2FzZSBFUlJPUjpcbiAgICBjYXNlIERFQlVHOlxuICAgIGNhc2UgVFJBQ0U6XG4gICAgICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gZGVwcmVjYXRlZFxuXG4gICAgY2FzZSBXQVJOSU5HOlxuICAgICAgLy8gbG9nbGV2ZWwncyB3YXJuaW5nIG5hbWUgaXMgZGlmZmVyZW50IGZyb20gd2VicGFjaydzXG4gICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgTk9ORTpcbiAgICBjYXNlIFNJTEVOVDpcbiAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBsb2cuZXJyb3IoXCJbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsICdcIi5jb25jYXQobGV2ZWwsIFwiJ1wiKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZzogbG9nLFxuICBzZXRMb2dMZXZlbDogc2V0TG9nTGV2ZWxcbn07IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9sb2cnKSxcbiAgICBsb2cgPSBfcmVxdWlyZS5sb2c7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcChfcmVmLCBfcmVmMikge1xuICB2YXIgaG90UmVsb2FkID0gX3JlZi5ob3RSZWxvYWQsXG4gICAgICBob3QgPSBfcmVmLmhvdCxcbiAgICAgIGxpdmVSZWxvYWQgPSBfcmVmLmxpdmVSZWxvYWQ7XG4gIHZhciBpc1VubG9hZGluZyA9IF9yZWYyLmlzVW5sb2FkaW5nLFxuICAgICAgY3VycmVudEhhc2ggPSBfcmVmMi5jdXJyZW50SGFzaDtcblxuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChob3QpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTtcblxuICAgIHZhciBob3RFbWl0dGVyID0gcmVxdWlyZSgnd2VicGFjay9ob3QvZW1pdHRlcicpO1xuXG4gICAgaG90RW1pdHRlci5lbWl0KCd3ZWJwYWNrSG90VXBkYXRlJywgY3VycmVudEhhc2gpO1xuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoXCJ3ZWJwYWNrSG90VXBkYXRlXCIuY29uY2F0KGN1cnJlbnRIYXNoKSwgJyonKTtcbiAgICB9XG4gIH0gLy8gYWxsb3cgcmVmcmVzaGluZyB0aGUgcGFnZSBvbmx5IGlmIGxpdmVSZWxvYWQgaXNuJ3QgZGlzYWJsZWRcbiAgZWxzZSBpZiAobGl2ZVJlbG9hZCkge1xuICAgICAgdmFyIHJvb3RXaW5kb3cgPSBzZWxmOyAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcblxuICAgICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdhYm91dDonKSB7XG4gICAgICAgICAgLy8gcmVsb2FkIGltbWVkaWF0ZWx5IGlmIHByb3RvY29sIGlzIHZhbGlkXG4gICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdFdpbmRvdyA9IHJvb3RXaW5kb3cucGFyZW50O1xuXG4gICAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgICAvLyBpZiBwYXJlbnQgZXF1YWxzIGN1cnJlbnQgd2luZG93IHdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3Qgd2hpY2ggd291bGQgY29udGludWUgZm9yZXZlciwgc28gdHJpZ2dlciBhIHJlbG9hZCBhbnl3YXlzXG4gICAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWxvYWRBcHA7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG4vLyBTZW5kIG1lc3NhZ2VzIHRvIHRoZSBvdXRzaWRlLCBzbyBwbHVnaW5zIGNhbiBjb25zdW1lIGl0LlxuXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJyB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIndlYnBhY2tcIi5jb25jYXQodHlwZSksXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgJyonKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbmRNc2c7IiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsInZhciBtYXAgPSB7XG5cdFwiLi9sb2dcIjogXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9sb2cuanNcIlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3Qgc3luYyBeXFxcXC5cXFxcL2xvZyRcIjsiLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5cbmZ1bmN0aW9uIGR1bW15KCkge31cblxuZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsKSB7XG5cdHZhciBzaG91bGRMb2cgPVxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCIpO1xuXHRyZXR1cm4gc2hvdWxkTG9nO1xufVxuXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xuXHRyZXR1cm4gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRcdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRsb2dGbihtc2cpO1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0aWYgKGxldmVsID09PSBcImluZm9cIikge1xuXHRcdFx0Y29uc29sZS5sb2cobXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ0dyb3VwKGdyb3VwQ29sbGFwc2VkKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XG5cbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0bG9nTGV2ZWwgPSBsZXZlbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZvcm1hdEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdHZhciBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG5cdHZhciBzdGFjayA9IGVyci5zdGFjaztcblx0aWYgKCFzdGFjaykge1xuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPCAwKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0YWNrO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMzQzOTEzL2hvdy10by1jcmVhdGUtYS13ZWItd29ya2VyLWZyb20tYS1zdHJpbmdcblxudmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBibG9iO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBCbG9iQnVpbGRlciA9IERlcHJlY2F0ZWQsIGJ1dCB3aWRlbHkgaW1wbGVtZW50ZWRcbiAgICAgICAgdmFyIEJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG5cbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuXG4gICAgICAgIGJsb2IuYXBwZW5kKGNvbnRlbnQpO1xuXG4gICAgICAgIGJsb2IgPSBibG9iLmdldEJsb2IoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVGhlIHByb3Bvc2VkIEFQSVxuICAgICAgICBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoJ2RhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lubGluZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgV29ya2VyKHVybCk7XG4gIH1cbn07IiwiaW1wb3J0IHsgR2lmV3JpdGVyIH0gZnJvbSAnb21nZ2lmJ1xuaW1wb3J0IHsgYXBwbHlQYWxldHRlU3luYywgYnVpbGRQYWxldHRlU3luYywgdXRpbHMgfSBmcm9tICdpbWFnZS1xJ1xuaW1wb3J0IEdpZldvcmtlciBmcm9tICcuL0FuaW1hdGVkX0dJRi53b3JrZXInXG4vLyBBIGxpYnJhcnkvdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBHSUYgZmlsZXNcbi8vIFVzZXMgRGVhbiBNY05hbWVlJ3Mgb21nZ2lmIGxpYnJhcnlcbi8vIGFuZCBpbWFnZS1xJ3MgUkdCUXVhbnQgcXVhbnRpemVyXG4vL1xuLy8gQGF1dGhvciBzb2xlIC8gaHR0cDovL3NvbGVkYWRwZW5hZGVzLmNvbVxuLy8gVXBkYXRlZCBieSBBZHJpYW4gRGUgTGlzbGUgdG8gc3VwcG9ydCB0cmFuc3BhcmVuY3kgJiBzbGlnaHQgbW9kZXJuaXphdGlvblxuY29uc3QgQW5pbWF0ZWRfR0lGID0gZnVuY3Rpb24gQW5pbWF0ZWRfR0lGKGdsb2JhbE9wdGlvbnMpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnMgfHwge31cblxuICBsZXQgZ2xvYmFsV2lkdGggPSBnbG9iYWxPcHRpb25zLndpZHRoIHx8IDE2MFxuICBsZXQgZ2xvYmFsSGVpZ2h0ID0gZ2xvYmFsT3B0aW9ucy5oZWlnaHQgfHwgMTIwXG4gIGNvbnN0IGdsb2JhbERpdGhlcmluZyA9IGdsb2JhbE9wdGlvbnMuZGl0aGVyaW5nIHx8IHVuZGVmaW5lZFxuICBjb25zdCBnbG9iYWxQYWxldHRlID0gZ2xvYmFsT3B0aW9ucy5wYWxldHRlIHx8IG51bGxcbiAgY29uc3QgZ2xvYmFsRGlzcG9zYWwgPSBnbG9iYWxPcHRpb25zLmRpc3Bvc2FsIHx8IDBcbiAgY29uc3QgZ2xvYmFsVHJhbnNwYXJlbmN5Q3V0T2ZmID0gZ2xvYmFsT3B0aW9ucy50cmFuc3BhcmVuY3lDdXRPZmYgfHwgMC43IC8vIHVzZWQgZm9yIG5vcm1hbGl6aW5nIHBpeGVscyB0byBiZSBmdWxsIHRyYW5zcGFyZW50IG9yIG9wYXF1ZVxuICBsZXQgY2FudmFzID0gbnVsbCxcbiAgICBjdHggPSBudWxsLFxuICAgIHJlcGVhdCA9IDAsXG4gICAgZGVsYXkgPSAyNTBcbiAgY29uc3QgZnJhbWVzID0gW11cbiAgbGV0IG51bVJlbmRlcmVkRnJhbWVzID0gMFxuICBsZXQgb25SZW5kZXJDb21wbGV0ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fVxuICBsZXQgb25SZW5kZXJQcm9ncmVzc0NhbGxiYWNrID0gZnVuY3Rpb24oKSB7fVxuICBsZXQgd29ya2VycyA9IFtdLFxuICAgIGF2YWlsYWJsZVdvcmtlcnMgPSBbXSxcbiAgICBudW1Xb3JrZXJzXG4gIGxldCBnZW5lcmF0aW5nR0lGID0gZmFsc2VcblxuICAvLyBXZSdsbCB0cnkgdG8gYmUgYSBsaXR0bGUgbGVuaWVudCB3aXRoIHRoZSBwYWxldHRlIHNvIGFzIHRvIG1ha2UgdGhlIGxpYnJhcnkgZWFzeSB0byB1c2VcbiAgLy8gVGhlIG9ubHkgdGhpbmcgd2UgY2FuJ3QgY29wZSB3aXRoIGlzIGhhdmluZyBhIG5vbi1hcnJheSBzbyB3ZSdsbCBiYWlsIG9uIHRoYXQgb25lLlxuICBpZiAoZ2xvYmFsUGFsZXR0ZSkge1xuICAgIGlmICghKGdsb2JhbFBhbGV0dGUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRocm93ICgnUGFsZXR0ZSBNVVNUIGJlIGFuIGFycmF5IGJ1dCBpdCBpczogJywgZ2xvYmFsUGFsZXR0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm93IHRoZXJlIGFyZSBvdGhlciB0d28gY29uc3RyYWludHMgdGhhdCB3ZSB3aWxsIHdhcm4gYWJvdXRcbiAgICAgIC8vIGFuZCBzaWxlbnRseSBmaXggdGhlbS4uLiBzb21laG93OlxuXG4gICAgICAvLyBhKSBNdXN0IGNvbnRhaW4gYmV0d2VlbiAyIGFuZCAyNTYgY29sb3Vyc1xuICAgICAgaWYgKGdsb2JhbFBhbGV0dGUubGVuZ3RoIDwgMiB8fCBnbG9iYWxQYWxldHRlLmxlbmd0aCA+IDI1Nikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdQYWxldHRlIG11c3QgaG9sZCBvbmx5IGJldHdlZW4gMiBhbmQgMjU2IGNvbG91cnMnKVxuXG4gICAgICAgIHdoaWxlIChnbG9iYWxQYWxldHRlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICBnbG9iYWxQYWxldHRlLnB1c2goMHgwMDAwMDApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2xvYmFsUGFsZXR0ZS5sZW5ndGggPiAyNTYpIHtcbiAgICAgICAgICBnbG9iYWxQYWxldHRlID0gZ2xvYmFsUGFsZXR0ZS5zbGljZSgwLCAyNTYpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYikgTXVzdCBiZSBwb3dlciBvZiAyXG4gICAgICBpZiAoIXBvd2VyT2ZUd28oZ2xvYmFsUGFsZXR0ZS5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BhbGV0dGUgbXVzdCBoYXZlIGEgcG93ZXIgb2YgdHdvIG51bWJlciBvZiBjb2xvdXJzJylcblxuICAgICAgICB3aGlsZSAoIXBvd2VyT2ZUd28oZ2xvYmFsUGFsZXR0ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgZ2xvYmFsUGFsZXR0ZS5zcGxpY2UoZ2xvYmFsUGFsZXR0ZS5sZW5ndGggLSAxLCAxKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnMgfHwge31cbiAgbnVtV29ya2VycyA9IGdsb2JhbE9wdGlvbnMubnVtV29ya2VycyB8fCAyXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyBpKyspIHtcbiAgICBjb25zdCB3ID0gbmV3IEdpZldvcmtlcigpXG4gICAgd29ya2Vycy5wdXNoKHcpXG4gICAgYXZhaWxhYmxlV29ya2Vycy5wdXNoKHcpXG4gIH1cblxuICAvLyAtLS1cblxuICAvLyBSZXR1cm4gYSB3b3JrZXIgZm9yIHByb2Nlc3NpbmcgYSBmcmFtZVxuICBmdW5jdGlvbiBnZXRXb3JrZXIoKSB7XG4gICAgaWYgKGF2YWlsYWJsZVdvcmtlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyAnTm8gd29ya2VycyBsZWZ0ISdcbiAgICB9XG5cbiAgICByZXR1cm4gYXZhaWxhYmxlV29ya2Vycy5wb3AoKVxuICB9XG5cbiAgLy8gUmVzdG9yZSBhIHdvcmtlciB0byB0aGUgcG9vbFxuICBmdW5jdGlvbiBmcmVlV29ya2VyKHdvcmtlcikge1xuICAgIGF2YWlsYWJsZVdvcmtlcnMucHVzaCh3b3JrZXIpXG4gIH1cblxuICAvLyBGYXN0ZXIvY2xvc3VyaXplZCBidWZmZXJUb1N0cmluZyBmdW5jdGlvblxuICAvLyAoY2FjaGluZyB0aGUgU3RyaW5nLmZyb21DaGFyQ29kZSB2YWx1ZXMpXG4gIGNvbnN0IGJ1ZmZlclRvU3RyaW5nID0gKGZ1bmN0aW9uKCkge1xuICAgIGxldCBieXRlTWFwID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBieXRlTWFwW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGNvbnN0IG51bWJlclZhbHVlcyA9IGJ1ZmZlci5sZW5ndGhcbiAgICAgIGxldCBzdHIgPSAnJ1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlclZhbHVlczsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBieXRlTWFwW2J1ZmZlcltpXV1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0clxuICAgIH1cbiAgfSkoKVxuXG4gIGZ1bmN0aW9uIHN0YXJ0UmVuZGVyaW5nKGNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICBvblJlbmRlckNvbXBsZXRlQ2FsbGJhY2sgPSBjb21wbGV0ZUNhbGxiYWNrXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdvcmtlcnMgJiYgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvY2Vzc0ZyYW1lKGkpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lKHBvc2l0aW9uKSB7XG4gICAgbGV0IGZyYW1lXG4gICAgbGV0IHdvcmtlclxuXG4gICAgZnJhbWUgPSBmcmFtZXNbcG9zaXRpb25dXG5cbiAgICBpZiAoZnJhbWUuYmVpbmdQcm9jZXNzZWQgfHwgZnJhbWUuZG9uZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRnJhbWUgYWxyZWFkeSBiZWluZyBwcm9jZXNzZWQgb3IgZG9uZSEnLCBmcmFtZS5wb3NpdGlvbilcbiAgICAgIG9uRnJhbWVGaW5pc2hlZCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmcmFtZS5iZWluZ1Byb2Nlc3NlZCA9IHRydWVcblxuICAgIHdvcmtlciA9IGdldFdvcmtlcigpXG5cbiAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBldi5kYXRhXG5cbiAgICAgIC8vIERlbGV0ZSBvcmlnaW5hbCBkYXRhLCBhbmQgZnJlZSBtZW1vcnlcbiAgICAgIGRlbGV0ZSBmcmFtZS5kYXRhXG5cbiAgICAgIC8vIFRPRE8gZ3Jyci4uLiBIQUNLIGZvciBvYmplY3QgLT4gQXJyYXlcbiAgICAgIGZyYW1lLnBpeGVscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEucGl4ZWxzKVxuICAgICAgZnJhbWUucGFsZXR0ZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEucGFsZXR0ZSlcbiAgICAgIGZyYW1lLnRyYW5zcGFyZW5jeUluZGV4ID0gZGF0YS50cmFuc3BhcmVuY3lJbmRleFxuICAgICAgZnJhbWUuZG9uZSA9IHRydWVcbiAgICAgIGZyYW1lLmJlaW5nUHJvY2Vzc2VkID0gZmFsc2VcblxuICAgICAgZnJlZVdvcmtlcih3b3JrZXIpXG5cbiAgICAgIG9uRnJhbWVGaW5pc2hlZCgpXG4gICAgfVxuXG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKGZyYW1lKVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc05leHRGcmFtZSgpIHtcbiAgICBsZXQgcG9zaXRpb24gPSAtMVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tpXVxuICAgICAgaWYgKCFmcmFtZS5kb25lICYmICFmcmFtZS5iZWluZ1Byb2Nlc3NlZCkge1xuICAgICAgICBwb3NpdGlvbiA9IGlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgcHJvY2Vzc0ZyYW1lKHBvc2l0aW9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRnJhbWVGaW5pc2hlZCgpIHtcbiAgICAvLyB+fn4gdGFza0ZpbmlzaGVkXG5cbiAgICAvLyBUaGUgR0lGIGlzIG5vdCB3cml0dGVuIHVudGlsIHdlJ3JlIGRvbmUgd2l0aCBhbGwgdGhlIGZyYW1lc1xuICAgIC8vIGJlY2F1c2UgdGhleSBtaWdodCBub3QgYmUgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIG9yZGVyXG4gICAgY29uc3QgYWxsRG9uZSA9IGZyYW1lcy5ldmVyeShmdW5jdGlvbihmcmFtZSkge1xuICAgICAgcmV0dXJuICFmcmFtZS5iZWluZ1Byb2Nlc3NlZCAmJiBmcmFtZS5kb25lXG4gICAgfSlcblxuICAgIG51bVJlbmRlcmVkRnJhbWVzKytcbiAgICBvblJlbmRlclByb2dyZXNzQ2FsbGJhY2soKG51bVJlbmRlcmVkRnJhbWVzICogMC43NSkgLyBmcmFtZXMubGVuZ3RoKVxuXG4gICAgaWYgKGFsbERvbmUpIHtcbiAgICAgIGlmICghZ2VuZXJhdGluZ0dJRikge1xuICAgICAgICBnZW5lcmF0ZUdJRihmcmFtZXMsIG9uUmVuZGVyQ29tcGxldGVDYWxsYmFjaylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChwcm9jZXNzTmV4dEZyYW1lLCAxKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRha2VzIHRoZSBhbHJlYWR5IHByb2Nlc3NlZCBkYXRhIGluIGZyYW1lcyBhbmQgZmVlZHMgaXQgdG8gYSBuZXdcbiAgLy8gR2lmV3JpdGVyIGluc3RhbmNlIGluIG9yZGVyIHRvIGdldCB0aGUgYmluYXJ5IEdJRiBmaWxlXG4gIGZ1bmN0aW9uIGdlbmVyYXRlR0lGKGZyYW1lcywgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBXZWlyZDogdXNpbmcgYSBzaW1wbGUgSlMgYXJyYXkgaW5zdGVhZCBvZiBhIHR5cGVkIGFycmF5LFxuICAgIC8vIHRoZSBmaWxlcyBhcmUgV0FZIHNtYWxsZXIgb19vLiBQYXRjaGVzL2V4cGxhbmF0aW9ucyB3ZWxjb21lIVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdIC8vIG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogZnJhbWVzLmxlbmd0aCAqIDUpO1xuICAgIGNvbnN0IGdpZk9wdGlvbnMgPSB7IGxvb3A6IHJlcGVhdCB9XG5cbiAgICAvLyBVc2luZyBnbG9iYWwgcGFsZXR0ZSBidXQgb25seSBpZiB3ZSdyZSBhbHNvIHVzaW5nIGRpdGhlcmluZ1xuICAgIGlmIChnbG9iYWxEaXRoZXJpbmcgIT09IG51bGwgJiYgZ2xvYmFsUGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgICAgZ2lmT3B0aW9ucy5wYWxldHRlID0gZ2xvYmFsUGFsZXR0ZVxuICAgIH1cblxuICAgIGNvbnN0IGdpZldyaXRlciA9IG5ldyBHaWZXcml0ZXIoXG4gICAgICBidWZmZXIsXG4gICAgICBnbG9iYWxXaWR0aCxcbiAgICAgIGdsb2JhbEhlaWdodCxcbiAgICAgIGdpZk9wdGlvbnNcbiAgICApXG5cbiAgICBnZW5lcmF0aW5nR0lGID0gdHJ1ZVxuXG4gICAgZnJhbWVzLmZvckVhY2goZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgIGxldCBmcmFtZVBhbGV0dGUgPSBnbG9iYWxQYWxldHRlID8gZ2xvYmFsUGFsZXR0ZSA6IGZyYW1lLnBhbGV0dGVcblxuICAgICAgb25SZW5kZXJQcm9ncmVzc0NhbGxiYWNrKFxuICAgICAgICAwLjc1ICsgKDAuMjUgKiBmcmFtZS5wb3NpdGlvbiAqIDEuMCkgLyBmcmFtZXMubGVuZ3RoXG4gICAgICApXG5cbiAgICAgIHdoaWxlICghcG93ZXJPZlR3byhmcmFtZVBhbGV0dGUubGVuZ3RoKSAmJiBmcmFtZVBhbGV0dGUubGVuZ3RoIDwgMjU2KSB7XG4gICAgICAgIGZyYW1lUGFsZXR0ZS5wdXNoKDB4MDAwMDAwKVxuICAgICAgfVxuXG4gICAgICBnaWZXcml0ZXIuYWRkRnJhbWUoMCwgMCwgZ2xvYmFsV2lkdGgsIGdsb2JhbEhlaWdodCwgZnJhbWUucGl4ZWxzLCB7XG4gICAgICAgIHBhbGV0dGU6IGZyYW1lUGFsZXR0ZSxcbiAgICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgICB0cmFuc3BhcmVudDogZnJhbWUudHJhbnNwYXJlbmN5SW5kZXgsXG4gICAgICAgIGRpc3Bvc2FsOiBmcmFtZS5kaXNwb3NhbCxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGdpZldyaXRlci5lbmQoKVxuICAgIG9uUmVuZGVyUHJvZ3Jlc3NDYWxsYmFjaygxLjApXG5cbiAgICBmcmFtZXMgPSBbXVxuICAgIGdlbmVyYXRpbmdHSUYgPSBmYWxzZVxuXG4gICAgY2FsbGJhY2soYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gcG93ZXJPZlR3byh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gMCAmJiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDBcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICBnbG9iYWxXaWR0aCA9IHdcbiAgICBnbG9iYWxIZWlnaHQgPSBoXG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSB3XG4gICAgY2FudmFzLmhlaWdodCA9IGhcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICB9XG5cbiAgLy8gSW50ZXJuYWxseSwgR0lGIHVzZXMgdGVudGhzIG9mIHNlY29uZHMgdG8gc3RvcmUgdGhlIGRlbGF5XG4gIHRoaXMuc2V0RGVsYXkgPSBmdW5jdGlvbihzZWNvbmRzKSB7XG4gICAgZGVsYXkgPSBzZWNvbmRzICogMC4xXG4gIH1cblxuICAvLyBGcm9tIEdJRjogMCA9IGxvb3AgZm9yZXZlciwgbnVsbCA9IG5vdCBsb29waW5nLCBuID4gMCA9IGxvb3AgbiB0aW1lcyBhbmQgc3RvcFxuICB0aGlzLnNldFJlcGVhdCA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXBlYXQgPSByXG4gIH1cblxuICB0aGlzLmFkZEZyYW1lID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGN0eCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRTaXplKGdsb2JhbFdpZHRoLCBnbG9iYWxIZWlnaHQpXG4gICAgfVxuICAgIC8vIGNsZWFyIHRoZSBjYW52YXMgYmVjYXVzZSBkcmF3aW5nIG92ZXIgb3RoZXIgZnJhbWVzIGJyZWFrcyB0cmFuc3BhcmVuY3lcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGdsb2JhbFdpZHRoLCBnbG9iYWxIZWlnaHQpXG4gICAgY3R4LmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLCBnbG9iYWxXaWR0aCwgZ2xvYmFsSGVpZ2h0KVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgZ2xvYmFsV2lkdGgsIGdsb2JhbEhlaWdodClcblxuICAgIHRoaXMuYWRkRnJhbWVJbWFnZURhdGEoaW1hZ2VEYXRhLCBvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5hZGRGcmFtZUltYWdlRGF0YSA9IGZ1bmN0aW9uKGltYWdlRGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaW1hZ2VEYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShpbWFnZURhdGEuZGF0YSlcblxuICAgIGZyYW1lcy5wdXNoKHtcbiAgICAgIGRhdGE6IGltYWdlRGF0YUFycmF5LFxuICAgICAgd2lkdGg6IGltYWdlRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodDogaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIHBhbGV0dGU6IG9wdGlvbnMucGFsZXR0ZSB8fCBnbG9iYWxQYWxldHRlLFxuICAgICAgZGl0aGVyaW5nOiBvcHRpb25zLmRpdGhlcmluZyB8fCBnbG9iYWxEaXRoZXJpbmcsXG4gICAgICBkaXNwb3NhbDogb3B0aW9ucy5kaXNwb3NhbCB8fCBnbG9iYWxEaXNwb3NhbCxcbiAgICAgIHRyYW5zcGFyZW5jeUN1dE9mZjpcbiAgICAgICAgb3B0aW9ucy50cmFuc3BhcmVuY3lDdXRPZmYgfHwgZ2xvYmFsVHJhbnNwYXJlbmN5Q3V0T2ZmLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBiZWluZ1Byb2Nlc3NlZDogZmFsc2UsXG4gICAgICBwb3NpdGlvbjogZnJhbWVzLmxlbmd0aCxcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5vblJlbmRlclByb2dyZXNzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBvblJlbmRlclByb2dyZXNzQ2FsbGJhY2sgPSBjYWxsYmFja1xuICB9XG5cbiAgdGhpcy5pc1JlbmRlcmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZW5lcmF0aW5nR0lGXG4gIH1cblxuICB0aGlzLmdldEJhc2U2NEdJRiA9IGZ1bmN0aW9uKGNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBvblJlbmRlckNvbXBsZXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICBjb25zdCBzdHIgPSBidWZmZXJUb1N0cmluZyhidWZmZXIpXG4gICAgICBjb25zdCBnaWYgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LCcgKyBidG9hKHN0cilcbiAgICAgIGNvbXBsZXRlQ2FsbGJhY2soZ2lmKVxuICAgIH1cblxuICAgIHN0YXJ0UmVuZGVyaW5nKG9uUmVuZGVyQ29tcGxldGUpXG4gIH1cblxuICB0aGlzLmdldEJsb2JHSUYgPSBmdW5jdGlvbihjb21wbGV0ZUNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb25SZW5kZXJDb21wbGV0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2FycmF5XSwgeyB0eXBlOiAnaW1hZ2UvZ2lmJyB9KVxuICAgICAgY29tcGxldGVDYWxsYmFjayhibG9iKVxuICAgIH1cblxuICAgIHN0YXJ0UmVuZGVyaW5nKG9uUmVuZGVyQ29tcGxldGUpXG4gIH1cblxuICAvLyBPbmNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgb2JqZWN0IGJlY29tZXMgdW51c2FibGVcbiAgLy8gYW5kIHlvdSdsbCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEV4cGxpY2l0bHkgYXNrIHdlYiB3b3JrZXJzIHRvIGRpZSBzbyB0aGV5IGFyZSBleHBsaWNpdGx5IEdDJ2VkXG4gICAgd29ya2Vycy5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgIHcudGVybWluYXRlKClcbiAgICB9KVxuICB9XG59XG5cbndpbmRvdy5BbmltYXRlZF9HSUYgPSBBbmltYXRlZF9HSUZcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGVkX0dJRlxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJlcXVpcmUoXCIhIS9tbnQvYy9Vc2Vycy9BZHJpYW4vUHJvamVjdHMvQW5pbWF0ZWRfR0lGL25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3Qvd29ya2Vycy9JbmxpbmVXb3JrZXIuanNcIikoXCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0XFx0fVxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGk6IG1vZHVsZUlkLFxcbi8qKioqKiovIFxcdFxcdFxcdGw6IGZhbHNlLFxcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9XFxuLyoqKioqKi8gXFx0XFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdFxcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sID0gdHJ1ZTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG4vKioqKioqL1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xcbi8qKioqKiovIFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcXG4vKioqKioqLyBcXHRcXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcXG4vKioqKioqLyBcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcXG4vKioqKioqLyBcXHRcXHR9XFxuLyoqKioqKi8gXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcXG4vKioqKioqLyBcXHRcXHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xcbi8qKioqKiovIFxcdFxcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcXG4vKioqKioqLyBcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBucztcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcXG4vKioqKioqLyBcXHRcXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cXG4vKioqKioqLyBcXHRcXHRcXHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxcbi8qKioqKiovIFxcdFxcdFxcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBnZXR0ZXI7XFxuLyoqKioqKi8gXFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuLyoqKioqKi9cXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xcbi8qKioqKiovIFxcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFxcXCIuL3NyYy9BbmltYXRlZF9HSUYud29ya2VyLmpzXFxcIik7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovICh7XFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vc2V0LWltbWVkaWF0ZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zZXQtaW1tZWRpYXRlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qc1xcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbW9kdWxlcy9fY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXFxcIikuc2V0SW1tZWRpYXRlO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XFxuICByZXR1cm4gaXQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcXG4gIHJldHVybiBpdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG52YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjInIH07XFxuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hLWZ1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanNcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XFxuICBhRnVuY3Rpb24oZm4pO1xcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xcbiAgc3dpdGNoIChsZW5ndGgpIHtcXG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcXG4gICAgfTtcXG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcXG4gICAgfTtcXG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcXG4gICAgfTtcXG4gIH1cXG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcXG4gIH07XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxcbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXFxcIikoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcXFwiKS5kb2N1bWVudDtcXG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXFxcIik7XFxudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcXFwiKTtcXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hpZGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1xcXCIpO1xcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3JlZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXFxcIik7XFxudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2N0eCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanNcXFwiKTtcXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XFxuXFxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XFxuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcXG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XFxuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcXG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XFxuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcXG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XFxuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XFxuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcXG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcXG4gICAgLy8gZXhwb3J0XFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcXG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xcbiAgfVxcbn07XFxuZ2xvYmFsLmNvcmUgPSBjb3JlO1xcbi8vIHR5cGUgYml0bWFwXFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXFxuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xcbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xcbiAgdHJ5IHtcXG4gICAgcmV0dXJuICEhZXhlYygpO1xcbiAgfSBjYXRjaCAoZSkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcXG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcXG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XFxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1kcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcXFwiKTtcXG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Byb3BlcnR5LWRlc2MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcXFwiKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XFxufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIG9iamVjdFtrZXldID0gdmFsdWU7XFxuICByZXR1cm4gb2JqZWN0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1xcXCIpLmRvY3VtZW50O1xcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xcXCIpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1xcXCIpKGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZG9tLWNyZWF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXFxcIikoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XFxuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XFxuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XFxuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XFxuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXFxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcXG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XFxuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hbi1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faWU4LWRvbS1kZWZpbmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcXFwiKTtcXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1wcmltaXRpdmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXFxcIik7XFxudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xcblxcbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Rlc2NyaXB0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXFxcIikgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcXG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XFxuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cXG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XFxuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcXG4gIHJldHVybiBPO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xcbiAgcmV0dXJuIHtcXG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcXG4gICAgdmFsdWU6IHZhbHVlXFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXFxcIik7XFxudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oaWRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcXFwiKTtcXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1xcXCIpO1xcbnZhciBTUkMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL191aWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXFxcIikoJ3NyYycpO1xcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XFxuXFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXFxcIikuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcXG59O1xcblxcbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XFxuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XFxuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XFxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XFxuICAgIE9ba2V5XSA9IHZhbDtcXG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcXG4gICAgZGVsZXRlIE9ba2V5XTtcXG4gICAgaGlkZShPLCBrZXksIHZhbCk7XFxuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xcbiAgICBPW2tleV0gPSB2YWw7XFxuICB9IGVsc2Uge1xcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcXG4gIH1cXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2N0eCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanNcXFwiKTtcXG52YXIgaW52b2tlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faW52b2tlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qc1xcXCIpO1xcbnZhciBodG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faHRtbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzXFxcIik7XFxudmFyIGNlbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2RvbS1jcmVhdGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xcXCIpO1xcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXFxcIik7XFxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcXG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XFxudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcXG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XFxudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xcbnZhciBjb3VudGVyID0gMDtcXG52YXIgcXVldWUgPSB7fTtcXG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XFxudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgaWQgPSArdGhpcztcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcXG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xcbiAgICBkZWxldGUgcXVldWVbaWRdO1xcbiAgICBmbigpO1xcbiAgfVxcbn07XFxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuICBydW4uY2FsbChldmVudC5kYXRhKTtcXG59O1xcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcXG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xcbiAgICB2YXIgYXJncyA9IFtdO1xcbiAgICB2YXIgaSA9IDE7XFxuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcXG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XFxuICAgIH07XFxuICAgIGRlZmVyKGNvdW50ZXIpO1xcbiAgICByZXR1cm4gY291bnRlcjtcXG4gIH07XFxuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xcbiAgICBkZWxldGUgcXVldWVbaWRdO1xcbiAgfTtcXG4gIC8vIE5vZGUuanMgMC44LVxcbiAgaWYgKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanNcXFwiKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcXG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XFxuICAgIH07XFxuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XFxuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XFxuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XFxuICAgIH07XFxuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XFxuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcXG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XFxuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XFxuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXFxuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcXG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcXG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcXG4gICAgfTtcXG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xcbiAgLy8gSUU4LVxcbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XFxuICAgICAgICBydW4uY2FsbChpZCk7XFxuICAgICAgfTtcXG4gICAgfTtcXG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXFxuICB9IGVsc2Uge1xcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcXG4gICAgfTtcXG4gIH1cXG59XFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBzZXQ6IHNldFRhc2ssXFxuICBjbGVhcjogY2xlYXJUYXNrXFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcXFwiKTtcXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcXG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XFxuICB2YXIgZm4sIHZhbDtcXG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XFxuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XFxuICB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVxcXCIpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG52YXIgaWQgPSAwO1xcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcXFwiKTtcXG52YXIgJHRhc2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190YXNrICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanNcXFwiKTtcXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xcbiAgc2V0SW1tZWRpYXRlOiAkdGFzay5zZXQsXFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9iYXNpY0FQSS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vYmFzaWNBUEkuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogYnVpbGRQYWxldHRlU3luYywgYnVpbGRQYWxldHRlLCBhcHBseVBhbGV0dGVTeW5jLCBhcHBseVBhbGV0dGUgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJidWlsZFBhbGV0dGVTeW5jXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBidWlsZFBhbGV0dGVTeW5jOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJidWlsZFBhbGV0dGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1aWxkUGFsZXR0ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXBwbHlQYWxldHRlU3luY1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXBwbHlQYWxldHRlU3luYzsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXBwbHlQYWxldHRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhcHBseVBhbGV0dGU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX2ZuX3NldF9pbW1lZGlhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvZm4vc2V0LWltbWVkaWF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zZXQtaW1tZWRpYXRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfZm5fc2V0X2ltbWVkaWF0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfZm5fc2V0X2ltbWVkaWF0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Rpc3RhbmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Rpc3RhbmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbWFnZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGFsZXR0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYWxldHRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvaW5kZXguanNcXFwiKTtcXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBoZWxwZXIudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuZnVuY3Rpb24gYnVpbGRQYWxldHRlU3luYyhpbWFnZXMsIHsgY29sb3JEaXN0YW5jZUZvcm11bGEsIHBhbGV0dGVRdWFudGl6YXRpb24sIGNvbG9ycyB9ID0ge30pIHtcXHJcXG4gICAgY29uc3QgZGlzdGFuY2VDYWxjdWxhdG9yID0gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEpO1xcclxcbiAgICBjb25zdCBwYWxldHRlUXVhbnRpemVyID0gcGFsZXR0ZVF1YW50aXphdGlvblRvUGFsZXR0ZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIHBhbGV0dGVRdWFudGl6YXRpb24sIGNvbG9ycyk7XFxyXFxuICAgIGltYWdlcy5mb3JFYWNoKGltYWdlID0+IHBhbGV0dGVRdWFudGl6ZXIuc2FtcGxlKGltYWdlKSk7XFxyXFxuICAgIHJldHVybiBwYWxldHRlUXVhbnRpemVyLnF1YW50aXplU3luYygpO1xcclxcbn1cXHJcXG5hc3luYyBmdW5jdGlvbiBidWlsZFBhbGV0dGUoaW1hZ2VzLCB7IGNvbG9yRGlzdGFuY2VGb3JtdWxhLCBwYWxldHRlUXVhbnRpemF0aW9uLCBjb2xvcnMsIG9uUHJvZ3Jlc3MgfSA9IHt9KSB7XFxyXFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxyXFxuICAgICAgICBjb25zdCBkaXN0YW5jZUNhbGN1bGF0b3IgPSBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSk7XFxyXFxuICAgICAgICBjb25zdCBwYWxldHRlUXVhbnRpemVyID0gcGFsZXR0ZVF1YW50aXphdGlvblRvUGFsZXR0ZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIHBhbGV0dGVRdWFudGl6YXRpb24sIGNvbG9ycyk7XFxyXFxuICAgICAgICBpbWFnZXMuZm9yRWFjaChpbWFnZSA9PiBwYWxldHRlUXVhbnRpemVyLnNhbXBsZShpbWFnZSkpO1xcclxcbiAgICAgICAgbGV0IHBhbGV0dGU7XFxyXFxuICAgICAgICBsZXQgdGltZXJJZDtcXHJcXG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gcGFsZXR0ZVF1YW50aXplci5xdWFudGl6ZSgpO1xcclxcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcXHJcXG4gICAgICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYWxldHRlKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUucGFsZXR0ZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWxldHRlID0gcmVzdWx0LnZhbHVlLnBhbGV0dGU7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAob25Qcm9ncmVzcylcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzKHJlc3VsdC52YWx1ZS5wcm9ncmVzcyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aW1lcklkID0gY29yZV9qc19mbl9zZXRfaW1tZWRpYXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18obmV4dCk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9O1xcclxcbiAgICAgICAgdGltZXJJZCA9IGNvcmVfanNfZm5fc2V0X2ltbWVkaWF0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKG5leHQpO1xcclxcbiAgICB9KTtcXHJcXG59XFxyXFxuZnVuY3Rpb24gYXBwbHlQYWxldHRlU3luYyhpbWFnZSwgcGFsZXR0ZSwgeyBjb2xvckRpc3RhbmNlRm9ybXVsYSwgaW1hZ2VRdWFudGl6YXRpb24gfSA9IHt9KSB7XFxyXFxuICAgIGNvbnN0IGRpc3RhbmNlQ2FsY3VsYXRvciA9IGNvbG9yRGlzdGFuY2VGb3JtdWxhVG9Db2xvckRpc3RhbmNlKGNvbG9yRGlzdGFuY2VGb3JtdWxhKTtcXHJcXG4gICAgY29uc3QgaW1hZ2VRdWFudGl6ZXIgPSBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbik7XFxyXFxuICAgIHJldHVybiBpbWFnZVF1YW50aXplci5xdWFudGl6ZVN5bmMoaW1hZ2UsIHBhbGV0dGUpO1xcclxcbn1cXHJcXG5hc3luYyBmdW5jdGlvbiBhcHBseVBhbGV0dGUoaW1hZ2UsIHBhbGV0dGUsIHsgY29sb3JEaXN0YW5jZUZvcm11bGEsIGltYWdlUXVhbnRpemF0aW9uLCBvblByb2dyZXNzIH0gPSB7fSkge1xcclxcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcclxcbiAgICAgICAgY29uc3QgZGlzdGFuY2VDYWxjdWxhdG9yID0gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEpO1xcclxcbiAgICAgICAgY29uc3QgaW1hZ2VRdWFudGl6ZXIgPSBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbik7XFxyXFxuICAgICAgICBsZXQgb3V0UG9pbnRDb250YWluZXI7XFxyXFxuICAgICAgICBsZXQgdGltZXJJZDtcXHJcXG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gaW1hZ2VRdWFudGl6ZXIucXVhbnRpemUoaW1hZ2UsIHBhbGV0dGUpO1xcclxcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcXHJcXG4gICAgICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRQb2ludENvbnRhaW5lcik7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlLnBvaW50Q29udGFpbmVyKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFBvaW50Q29udGFpbmVyID0gcmVzdWx0LnZhbHVlLnBvaW50Q29udGFpbmVyO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhyZXN1bHQudmFsdWUucHJvZ3Jlc3MpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGltZXJJZCA9IGNvcmVfanNfZm5fc2V0X2ltbWVkaWF0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKG5leHQpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xcclxcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XFxyXFxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgICAgIHRpbWVySWQgPSBjb3JlX2pzX2ZuX3NldF9pbW1lZGlhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyhuZXh0KTtcXHJcXG4gICAgfSk7XFxyXFxufVxcclxcbmZ1bmN0aW9uIGNvbG9yRGlzdGFuY2VGb3JtdWxhVG9Db2xvckRpc3RhbmNlKGNvbG9yRGlzdGFuY2VGb3JtdWxhID0gJ2V1Y2xpZGVhbi1idDcwOScpIHtcXHJcXG4gICAgc3dpdGNoIChjb2xvckRpc3RhbmNlRm9ybXVsYSkge1xcclxcbiAgICAgICAgY2FzZSAnY2llOTQtZ3JhcGhpYy1hcnRzJzogcmV0dXJuIG5ldyBfZGlzdGFuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiQ0lFOTRHcmFwaGljQXJ0c1xcXCJdKCk7XFxyXFxuICAgICAgICBjYXNlICdjaWU5NC10ZXh0aWxlcyc6IHJldHVybiBuZXcgX2Rpc3RhbmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkNJRTk0VGV4dGlsZXNcXFwiXSgpO1xcclxcbiAgICAgICAgY2FzZSAnY2llZGUyMDAwJzogcmV0dXJuIG5ldyBfZGlzdGFuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiQ0lFREUyMDAwXFxcIl0oKTtcXHJcXG4gICAgICAgIGNhc2UgJ2NvbG9yLW1ldHJpYyc6IHJldHVybiBuZXcgX2Rpc3RhbmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkNNZXRyaWNcXFwiXSgpO1xcclxcbiAgICAgICAgY2FzZSAnZXVjbGlkZWFuJzogcmV0dXJuIG5ldyBfZGlzdGFuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiRXVjbGlkZWFuXFxcIl0oKTtcXHJcXG4gICAgICAgIGNhc2UgJ2V1Y2xpZGVhbi1idDcwOSc6IHJldHVybiBuZXcgX2Rpc3RhbmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkV1Y2xpZGVhbkJUNzA5XFxcIl0oKTtcXHJcXG4gICAgICAgIGNhc2UgJ2V1Y2xpZGVhbi1idDcwOS1ub2FscGhhJzogcmV0dXJuIG5ldyBfZGlzdGFuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiRXVjbGlkZWFuQlQ3MDlOb0FscGhhXFxcIl0oKTtcXHJcXG4gICAgICAgIGNhc2UgJ21hbmhhdHRhbic6IHJldHVybiBuZXcgX2Rpc3RhbmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1hbmhhdHRhblxcXCJdKCk7XFxyXFxuICAgICAgICBjYXNlICdtYW5oYXR0YW4tYnQ3MDknOiByZXR1cm4gbmV3IF9kaXN0YW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJNYW5oYXR0YW5CVDcwOVxcXCJdKCk7XFxyXFxuICAgICAgICBjYXNlICdtYW5oYXR0YW4tbm9tbXlkZSc6IHJldHVybiBuZXcgX2Rpc3RhbmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1hbmhhdHRhbk5vbW15ZGVcXFwiXSgpO1xcclxcbiAgICAgICAgY2FzZSAncG5ncXVhbnQnOiByZXR1cm4gbmV3IF9kaXN0YW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJQTkdRdWFudFxcXCJdKCk7XFxyXFxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29sb3JEaXN0YW5jZUZvcm11bGEgJHtjb2xvckRpc3RhbmNlRm9ybXVsYX1gKTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5mdW5jdGlvbiBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbiA9ICdmbG95ZC1zdGVpbmJlcmcnKSB7XFxyXFxuICAgIHN3aXRjaCAoaW1hZ2VRdWFudGl6YXRpb24pIHtcXHJcXG4gICAgICAgIGNhc2UgJ25lYXJlc3QnOiByZXR1cm4gbmV3IF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJOZWFyZXN0Q29sb3JcXFwiXShkaXN0YW5jZUNhbGN1bGF0b3IpO1xcclxcbiAgICAgICAgY2FzZSAncmllbWVyc21hJzogcmV0dXJuIG5ldyBfaW1hZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiRXJyb3JEaWZmdXNpb25SaWVtZXJzbWFcXFwiXShkaXN0YW5jZUNhbGN1bGF0b3IpO1xcclxcbiAgICAgICAgY2FzZSAnZmxveWQtc3RlaW5iZXJnJzogcmV0dXJuIG5ldyBfaW1hZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiRXJyb3JEaWZmdXNpb25BcnJheVxcXCJdKGRpc3RhbmNlQ2FsY3VsYXRvciwgX2ltYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxcXFwiXS5GbG95ZFN0ZWluYmVyZyk7XFxyXFxuICAgICAgICBjYXNlICdmYWxzZS1mbG95ZC1zdGVpbmJlcmcnOiByZXR1cm4gbmV3IF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJFcnJvckRpZmZ1c2lvbkFycmF5XFxcIl0oZGlzdGFuY2VDYWxjdWxhdG9yLCBfaW1hZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFxcXCJdLkZhbHNlRmxveWRTdGVpbmJlcmcpO1xcclxcbiAgICAgICAgY2FzZSAnc3R1Y2tpJzogcmV0dXJuIG5ldyBfaW1hZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiRXJyb3JEaWZmdXNpb25BcnJheVxcXCJdKGRpc3RhbmNlQ2FsY3VsYXRvciwgX2ltYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxcXFwiXS5TdHVja2kpO1xcclxcbiAgICAgICAgY2FzZSAnYXRraW5zb24nOiByZXR1cm4gbmV3IF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJFcnJvckRpZmZ1c2lvbkFycmF5XFxcIl0oZGlzdGFuY2VDYWxjdWxhdG9yLCBfaW1hZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFxcXCJdLkF0a2luc29uKTtcXHJcXG4gICAgICAgIGNhc2UgJ2phcnZpcyc6IHJldHVybiBuZXcgX2ltYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkVycm9yRGlmZnVzaW9uQXJyYXlcXFwiXShkaXN0YW5jZUNhbGN1bGF0b3IsIF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsXFxcIl0uSmFydmlzKTtcXHJcXG4gICAgICAgIGNhc2UgJ2J1cmtlcyc6IHJldHVybiBuZXcgX2ltYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkVycm9yRGlmZnVzaW9uQXJyYXlcXFwiXShkaXN0YW5jZUNhbGN1bGF0b3IsIF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsXFxcIl0uQnVya2VzKTtcXHJcXG4gICAgICAgIGNhc2UgJ3NpZXJyYSc6IHJldHVybiBuZXcgX2ltYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkVycm9yRGlmZnVzaW9uQXJyYXlcXFwiXShkaXN0YW5jZUNhbGN1bGF0b3IsIF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsXFxcIl0uU2llcnJhKTtcXHJcXG4gICAgICAgIGNhc2UgJ3R3by1zaWVycmEnOiByZXR1cm4gbmV3IF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJFcnJvckRpZmZ1c2lvbkFycmF5XFxcIl0oZGlzdGFuY2VDYWxjdWxhdG9yLCBfaW1hZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFxcXCJdLlR3b1NpZXJyYSk7XFxyXFxuICAgICAgICBjYXNlICdzaWVycmEtbGl0ZSc6IHJldHVybiBuZXcgX2ltYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkVycm9yRGlmZnVzaW9uQXJyYXlcXFwiXShkaXN0YW5jZUNhbGN1bGF0b3IsIF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsXFxcIl0uU2llcnJhTGl0ZSk7XFxyXFxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaW1hZ2VRdWFudGl6YXRpb24gJHtpbWFnZVF1YW50aXphdGlvbn1gKTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5mdW5jdGlvbiBwYWxldHRlUXVhbnRpemF0aW9uVG9QYWxldHRlUXVhbnRpemVyKGRpc3RhbmNlQ2FsY3VsYXRvciwgcGFsZXR0ZVF1YW50aXphdGlvbiA9ICd3dXF1YW50JywgY29sb3JzID0gMjU2KSB7XFxyXFxuICAgIHN3aXRjaCAocGFsZXR0ZVF1YW50aXphdGlvbikge1xcclxcbiAgICAgICAgY2FzZSAnbmV1cXVhbnQnOiByZXR1cm4gbmV3IF9wYWxldHRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIk5ldVF1YW50XFxcIl0oZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xcclxcbiAgICAgICAgY2FzZSAncmdicXVhbnQnOiByZXR1cm4gbmV3IF9wYWxldHRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIlJHQlF1YW50XFxcIl0oZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xcclxcbiAgICAgICAgY2FzZSAnd3VxdWFudCc6IHJldHVybiBuZXcgX3BhbGV0dGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiV3VRdWFudFxcXCJdKGRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzKTtcXHJcXG4gICAgICAgIGNhc2UgJ25ldXF1YW50LWZsb2F0JzogcmV0dXJuIG5ldyBfcGFsZXR0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJOZXVRdWFudEZsb2F0XFxcIl0oZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xcclxcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhbGV0dGVRdWFudGl6YXRpb24gJHtwYWxldHRlUXVhbnRpemF0aW9ufWApO1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2ljQVBJLmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9idDcwOS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9idDcwOS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogWSwgeCwgeSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIllcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFk7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInhcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHg7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInlcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHk7IH0pO1xcbi8qKlxcclxcbiAqIEBwcmVzZXJ2ZVxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIGNvbnN0YW50cy50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG4vKipcXHJcXG4gKiBzUkdCIChiYXNlZCBvbiBJVFUtUiBSZWNvbW1lbmRhdGlvbiBCVC43MDkpXFxyXFxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TUkdCXFxyXFxuICovXFxyXFxudmFyIFk7XFxyXFxuKGZ1bmN0aW9uIChZKSB7XFxyXFxuICAgIFlbWVtcXFwiUkVEXFxcIl0gPSAwLjIxMjZdID0gXFxcIlJFRFxcXCI7XFxyXFxuICAgIFlbWVtcXFwiR1JFRU5cXFwiXSA9IDAuNzE1Ml0gPSBcXFwiR1JFRU5cXFwiO1xcclxcbiAgICBZW1lbXFxcIkJMVUVcXFwiXSA9IDAuMDcyMl0gPSBcXFwiQkxVRVxcXCI7XFxyXFxuICAgIFlbWVtcXFwiV0hJVEVcXFwiXSA9IDFdID0gXFxcIldISVRFXFxcIjtcXHJcXG59KShZIHx8IChZID0ge30pKTtcXHJcXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bmFtaW5nLWNvbnZlbnRpb25cXHJcXG52YXIgeDtcXHJcXG4oZnVuY3Rpb24gKHgpIHtcXHJcXG4gICAgeFt4W1xcXCJSRURcXFwiXSA9IDAuNjRdID0gXFxcIlJFRFxcXCI7XFxyXFxuICAgIHhbeFtcXFwiR1JFRU5cXFwiXSA9IDAuM10gPSBcXFwiR1JFRU5cXFwiO1xcclxcbiAgICB4W3hbXFxcIkJMVUVcXFwiXSA9IDAuMTVdID0gXFxcIkJMVUVcXFwiO1xcclxcbiAgICB4W3hbXFxcIldISVRFXFxcIl0gPSAwLjMxMjddID0gXFxcIldISVRFXFxcIjtcXHJcXG59KSh4IHx8ICh4ID0ge30pKTtcXHJcXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bmFtaW5nLWNvbnZlbnRpb25cXHJcXG52YXIgeTtcXHJcXG4oZnVuY3Rpb24gKHkpIHtcXHJcXG4gICAgeVt5W1xcXCJSRURcXFwiXSA9IDAuMzNdID0gXFxcIlJFRFxcXCI7XFxyXFxuICAgIHlbeVtcXFwiR1JFRU5cXFwiXSA9IDAuNl0gPSBcXFwiR1JFRU5cXFwiO1xcclxcbiAgICB5W3lbXFxcIkJMVUVcXFwiXSA9IDAuMDZdID0gXFxcIkJMVUVcXFwiO1xcclxcbiAgICB5W3lbXFxcIldISVRFXFxcIl0gPSAwLjMyOV0gPSBcXFwiV0hJVEVcXFwiO1xcclxcbn0pKHkgfHwgKHkgPSB7fSkpO1xcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ0NzA5LmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9pbmRleC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9pbmRleC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogYnQ3MDkgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2J0NzA5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2J0NzA5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9idDcwOS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKG1vZHVsZSBvYmplY3QpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYnQ3MDlcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fOyB9KTtcXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBjb25zdGFudHMudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9pbmRleC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL2luZGV4LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmdiMnh5eiwgcmdiMmhzbCwgcmdiMmxhYiwgbGFiMnh5eiwgbGFiMnJnYiwgeHl6MmxhYiwgeHl6MnJnYiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmdiMnh5el9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZ2IyeHl6ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMnh5ei5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmdiMnh5elxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3JnYjJ4eXpfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmdiMnh5elxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JnYjJoc2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmdiMmhzbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3JnYjJoc2wuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJnYjJoc2xcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9yZ2IyaHNsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInJnYjJoc2xcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZ2IybGFiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JnYjJsYWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9yZ2IybGFiLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZ2IybGFiXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcmdiMmxhYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJyZ2IybGFiXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGFiMnh5el9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sYWIyeHl6ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vbGFiMnh5ei5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibGFiMnh5elxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2xhYjJ4eXpfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwibGFiMnh5elxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xhYjJyZ2JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGFiMnJnYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL2xhYjJyZ2IuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImxhYjJyZ2JcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9sYWIycmdiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImxhYjJyZ2JcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF94eXoybGFiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3h5ejJsYWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi94eXoybGFiLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ4eXoybGFiXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfeHl6MmxhYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJ4eXoybGFiXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfeHl6MnJnYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi94eXoycmdiICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24veHl6MnJnYi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwieHl6MnJnYlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3h5ejJyZ2JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwieHl6MnJnYlxcXCJdOyB9KTtcXG5cXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9sYWIycmdiLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9sYWIycmdiLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBsYWIycmdiICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibGFiMnJnYlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbGFiMnJnYjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sYWIyeHl6X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xhYjJ4eXogKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9sYWIyeHl6LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF94eXoycmdiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3h5ejJyZ2IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi94eXoycmdiLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogbGFiMnJnYi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG5cXHJcXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bmFtaW5nLWNvbnZlbnRpb25cXHJcXG5mdW5jdGlvbiBsYWIycmdiKEwsIGEsIGIpIHtcXHJcXG4gICAgY29uc3QgeHl6ID0gT2JqZWN0KF9sYWIyeHl6X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImxhYjJ4eXpcXFwiXSkoTCwgYSwgYik7XFxyXFxuICAgIHJldHVybiBPYmplY3QoX3h5ejJyZ2JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwieHl6MnJnYlxcXCJdKSh4eXoueCwgeHl6LnksIHh5ei56KTtcXHJcXG59XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFiMnJnYi5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL2xhYjJ4eXouanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL2xhYjJ4eXouanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGxhYjJ4eXogKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJsYWIyeHl6XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsYWIyeHl6OyB9KTtcXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBsYWIyeHl6LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcbmNvbnN0IHJlZlggPSAwLjk1MDQ3OyAvLyByZWZfWCA9ICA5NS4wNDcgICBPYnNlcnZlcj0gMsKwLCBJbGx1bWluYW50ID0gRDY1XFxyXFxuY29uc3QgcmVmWSA9IDEuMDAwMDA7IC8vIHJlZl9ZID0gMTAwLjAwMFxcclxcbmNvbnN0IHJlZlogPSAxLjA4ODgzOyAvLyByZWZfWiA9IDEwOC44ODNcXHJcXG5mdW5jdGlvbiBwaXZvdChuKSB7XFxyXFxuICAgIHJldHVybiBuID4gMC4yMDY4OTMwMzQgPyBNYXRoLnBvdyhuLCAzKSA6IChuIC0gMTYgLyAxMTYpIC8gNy43ODc7XFxyXFxufVxcclxcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuYW1pbmctY29udmVudGlvblxcclxcbmZ1bmN0aW9uIGxhYjJ4eXooTCwgYSwgYikge1xcclxcbiAgICBjb25zdCB5ID0gKEwgKyAxNikgLyAxMTY7XFxyXFxuICAgIGNvbnN0IHggPSBhIC8gNTAwICsgeTtcXHJcXG4gICAgY29uc3QgeiA9IHkgLSBiIC8gMjAwO1xcclxcbiAgICByZXR1cm4ge1xcclxcbiAgICAgICAgeDogcmVmWCAqIHBpdm90KHgpLFxcclxcbiAgICAgICAgeTogcmVmWSAqIHBpdm90KHkpLFxcclxcbiAgICAgICAgejogcmVmWiAqIHBpdm90KHopLFxcclxcbiAgICB9O1xcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYWIyeHl6LmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMmhzbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMmhzbC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmdiMmhzbCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJnYjJoc2xcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJnYjJoc2w7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYXJpdGhtZXRpYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9hcml0aG1ldGljLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogcmdiMmhzbC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBDYWxjdWxhdGUgSFNMIGZyb20gUkdCXFxyXFxuICogSHVlIGlzIGluIGRlZ3JlZXMgWzAuLjM2MF1cXHJcXG4gKiBMaWdodG5lc3M6IFswLi4xXVxcclxcbiAqIFNhdHVyYXRpb246IFswLi4xXVxcclxcbiAqIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMDYwOTE0MDQwNDM2L2h0dHA6Ly9sb2NhbC53YXNwLnV3YS5lZHUuYXUvfnBib3Vya2UvY29sb3VyL2hzbC9cXHJcXG4gKi9cXHJcXG5mdW5jdGlvbiByZ2IyaHNsKHIsIGcsIGIpIHtcXHJcXG4gICAgY29uc3QgbWluID0gT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm1pbjNcXFwiXSkociwgZywgYik7XFxyXFxuICAgIGNvbnN0IG1heCA9IE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJtYXgzXFxcIl0pKHIsIGcsIGIpO1xcclxcbiAgICBjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcXHJcXG4gICAgY29uc3QgbCA9IChtaW4gKyBtYXgpIC8gNTEwO1xcclxcbiAgICBsZXQgcyA9IDA7XFxyXFxuICAgIGlmIChsID4gMCAmJiBsIDwgMSlcXHJcXG4gICAgICAgIHMgPSBkZWx0YSAvIChsIDwgMC41ID8gKG1heCArIG1pbikgOiAoNTEwIC0gbWF4IC0gbWluKSk7XFxyXFxuICAgIGxldCBoID0gMDtcXHJcXG4gICAgaWYgKGRlbHRhID4gMCkge1xcclxcbiAgICAgICAgaWYgKG1heCA9PT0gcikge1xcclxcbiAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBlbHNlIGlmIChtYXggPT09IGcpIHtcXHJcXG4gICAgICAgICAgICBoID0gKDIgKyAoYiAtIHIpIC8gZGVsdGEpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgaCA9ICg0ICsgKHIgLSBnKSAvIGRlbHRhKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGggKj0gNjA7XFxyXFxuICAgICAgICBpZiAoaCA8IDApXFxyXFxuICAgICAgICAgICAgaCArPSAzNjA7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIHsgaCwgcywgbCB9O1xcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZ2IyaHNsLmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMmxhYi5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMmxhYi5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmdiMmxhYiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJnYjJsYWJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJnYjJsYWI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmdiMnh5el9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZ2IyeHl6ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMnh5ei5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfeHl6MmxhYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi94eXoybGFiICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24veHl6MmxhYi5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEBwcmVzZXJ2ZVxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIHJnYjJsYWIudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuZnVuY3Rpb24gcmdiMmxhYihyLCBnLCBiKSB7XFxyXFxuICAgIGNvbnN0IHh5eiA9IE9iamVjdChfcmdiMnh5el9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyZ2IyeHl6XFxcIl0pKHIsIGcsIGIpO1xcclxcbiAgICByZXR1cm4gT2JqZWN0KF94eXoybGFiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInh5ejJsYWJcXFwiXSkoeHl6LngsIHh5ei55LCB4eXoueik7XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJnYjJsYWIuanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9yZ2IyeHl6LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi9yZ2IyeHl6LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiByZ2IyeHl6ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmdiMnh5elxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmdiMnh5ejsgfSk7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogcmdiMnh5ei50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5mdW5jdGlvbiBjb3JyZWN0R2FtbWEobikge1xcclxcbiAgICByZXR1cm4gbiA+IDAuMDQwNDUgPyBNYXRoLnBvdygobiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogbiAvIDEyLjkyO1xcclxcbn1cXHJcXG5mdW5jdGlvbiByZ2IyeHl6KHIsIGcsIGIpIHtcXHJcXG4gICAgLy8gZ2FtbWEgY29ycmVjdGlvbiwgc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NSR0IjVGhlX3JldmVyc2VfdHJhbnNmb3JtYXRpb25cXHJcXG4gICAgciA9IGNvcnJlY3RHYW1tYShyIC8gMjU1KTtcXHJcXG4gICAgZyA9IGNvcnJlY3RHYW1tYShnIC8gMjU1KTtcXHJcXG4gICAgYiA9IGNvcnJlY3RHYW1tYShiIC8gMjU1KTtcXHJcXG4gICAgLy8gT2JzZXJ2ZXIuID0gMsKwLCBJbGx1bWluYW50ID0gRDY1XFxyXFxuICAgIHJldHVybiB7XFxyXFxuICAgICAgICB4OiByICogMC40MTI0ICsgZyAqIDAuMzU3NiArIGIgKiAwLjE4MDUsXFxyXFxuICAgICAgICB5OiByICogMC4yMTI2ICsgZyAqIDAuNzE1MiArIGIgKiAwLjA3MjIsXFxyXFxuICAgICAgICB6OiByICogMC4wMTkzICsgZyAqIDAuMTE5MiArIGIgKiAwLjk1MDUsXFxyXFxuICAgIH07XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJnYjJ4eXouanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi94eXoybGFiLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29udmVyc2lvbi94eXoybGFiLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiB4eXoybGFiICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwieHl6MmxhYlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4geHl6MmxhYjsgfSk7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogeHl6MmxhYi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5jb25zdCByZWZYID0gMC45NTA0NzsgLy8gcmVmX1ggPSAgOTUuMDQ3ICAgT2JzZXJ2ZXI9IDLCsCwgSWxsdW1pbmFudD0gRDY1XFxyXFxuY29uc3QgcmVmWSA9IDEuMDAwMDA7IC8vIHJlZl9ZID0gMTAwLjAwMFxcclxcbmNvbnN0IHJlZlogPSAxLjA4ODgzOyAvLyByZWZfWiA9IDEwOC44ODNcXHJcXG5mdW5jdGlvbiBwaXZvdChuKSB7XFxyXFxuICAgIHJldHVybiBuID4gMC4wMDg4NTYgPyBNYXRoLnBvdyhuLCAxIC8gMykgOiAoNy43ODcgKiBuICsgMTYgLyAxMTYpO1xcclxcbn1cXHJcXG5mdW5jdGlvbiB4eXoybGFiKHgsIHksIHopIHtcXHJcXG4gICAgeCA9IHBpdm90KHggLyByZWZYKTtcXHJcXG4gICAgeSA9IHBpdm90KHkgLyByZWZZKTtcXHJcXG4gICAgeiA9IHBpdm90KHogLyByZWZaKTtcXHJcXG4gICAgaWYgKCgxMTYgKiB5KSAtIDE2IDwgMClcXHJcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigneHh4Jyk7XFxyXFxuICAgIHJldHVybiB7XFxyXFxuICAgICAgICBMOiBNYXRoLm1heCgwLCAoMTE2ICogeSkgLSAxNiksXFxyXFxuICAgICAgICBhOiA1MDAgKiAoeCAtIHkpLFxcclxcbiAgICAgICAgYjogMjAwICogKHkgLSB6KSxcXHJcXG4gICAgfTtcXHJcXG59XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eHl6MmxhYi5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3h5ejJyZ2IuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3h5ejJyZ2IuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHh5ejJyZ2IgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ4eXoycmdiXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB4eXoycmdiOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2FyaXRobWV0aWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvYXJpdGhtZXRpYy5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEBwcmVzZXJ2ZVxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIHh5ejJyZ2IudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuLy8gZ2FtbWEgY29ycmVjdGlvbiwgc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NSR0IjVGhlX3JldmVyc2VfdHJhbnNmb3JtYXRpb25cXHJcXG5mdW5jdGlvbiBjb3JyZWN0R2FtbWEobikge1xcclxcbiAgICByZXR1cm4gbiA+IDAuMDAzMTMwOCA/IDEuMDU1ICogTWF0aC5wb3cobiwgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogbjtcXHJcXG59XFxyXFxuZnVuY3Rpb24geHl6MnJnYih4LCB5LCB6KSB7XFxyXFxuICAgIC8vIE9ic2VydmVyLiA9IDLCsCwgSWxsdW1pbmFudCA9IEQ2NVxcclxcbiAgICBjb25zdCByID0gY29ycmVjdEdhbW1hKHggKiAzLjI0MDYgKyB5ICogLTEuNTM3MiArIHogKiAtMC40OTg2KTtcXHJcXG4gICAgY29uc3QgZyA9IGNvcnJlY3RHYW1tYSh4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1KTtcXHJcXG4gICAgY29uc3QgYiA9IGNvcnJlY3RHYW1tYSh4ICogMC4wNTU3ICsgeSAqIC0wLjIwNDAgKyB6ICogMS4wNTcwKTtcXHJcXG4gICAgcmV0dXJuIHtcXHJcXG4gICAgICAgIHI6IE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJpblJhbmdlMHRvMjU1Um91bmRlZFxcXCJdKShyICogMjU1KSxcXHJcXG4gICAgICAgIGc6IE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJpblJhbmdlMHRvMjU1Um91bmRlZFxcXCJdKShnICogMjU1KSxcXHJcXG4gICAgICAgIGI6IE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJpblJhbmdlMHRvMjU1Um91bmRlZFxcXCJdKShiICogMjU1KSxcXHJcXG4gICAgfTtcXHJcXG59XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eHl6MnJnYi5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9jaWU5NC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvY2llOTQuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWJzdHJhY3RDSUU5NCwgQ0lFOTRUZXh0aWxlcywgQ0lFOTRHcmFwaGljQXJ0cyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFic3RyYWN0Q0lFOTRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFic3RyYWN0Q0lFOTQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkNJRTk0VGV4dGlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENJRTk0VGV4dGlsZXM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkNJRTk0R3JhcGhpY0FydHNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENJRTk0R3JhcGhpY0FydHM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzdGFuY2VDYWxjdWxhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Rpc3RhbmNlQ2FsY3VsYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9kaXN0YW5jZUNhbGN1bGF0b3IuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnZlcnNpb25fcmdiMmxhYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29udmVyc2lvbi9yZ2IybGFiICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMmxhYi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYXJpdGhtZXRpYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9hcml0aG1ldGljLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogY2llOTQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLyoqXFxyXFxuICogQ0lFOTQgbWV0aG9kIG9mIGRlbHRhLWVcXHJcXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbG9yX2RpZmZlcmVuY2UjQ0lFOTRcXHJcXG4gKi9cXHJcXG5jbGFzcyBBYnN0cmFjdENJRTk0IGV4dGVuZHMgX2Rpc3RhbmNlQ2FsY3VsYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvclxcXCJdIHtcXHJcXG4gICAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xcclxcbiAgICAgICAgY29uc3QgbGFiMSA9IE9iamVjdChfY29udmVyc2lvbl9yZ2IybGFiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInJnYjJsYWJcXFwiXSkoT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImluUmFuZ2UwdG8yNTVcXFwiXSkocjEgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaW5SYW5nZTB0bzI1NVxcXCJdKShnMSAqIHRoaXMuX3doaXRlUG9pbnQuZyksIE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJpblJhbmdlMHRvMjU1XFxcIl0pKGIxICogdGhpcy5fd2hpdGVQb2ludC5iKSk7XFxyXFxuICAgICAgICBjb25zdCBsYWIyID0gT2JqZWN0KF9jb252ZXJzaW9uX3JnYjJsYWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicmdiMmxhYlxcXCJdKShPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaW5SYW5nZTB0bzI1NVxcXCJdKShyMiAqIHRoaXMuX3doaXRlUG9pbnQuciksIE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJpblJhbmdlMHRvMjU1XFxcIl0pKGcyICogdGhpcy5fd2hpdGVQb2ludC5nKSwgT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImluUmFuZ2UwdG8yNTVcXFwiXSkoYjIgKiB0aGlzLl93aGl0ZVBvaW50LmIpKTtcXHJcXG4gICAgICAgIGNvbnN0IGRMID0gbGFiMS5MIC0gbGFiMi5MO1xcclxcbiAgICAgICAgY29uc3QgZEEgPSBsYWIxLmEgLSBsYWIyLmE7XFxyXFxuICAgICAgICBjb25zdCBkQiA9IGxhYjEuYiAtIGxhYjIuYjtcXHJcXG4gICAgICAgIGNvbnN0IGMxID0gTWF0aC5zcXJ0KGxhYjEuYSAqIGxhYjEuYSArIGxhYjEuYiAqIGxhYjEuYik7XFxyXFxuICAgICAgICBjb25zdCBjMiA9IE1hdGguc3FydChsYWIyLmEgKiBsYWIyLmEgKyBsYWIyLmIgKiBsYWIyLmIpO1xcclxcbiAgICAgICAgY29uc3QgZEMgPSBjMSAtIGMyO1xcclxcbiAgICAgICAgbGV0IGRlbHRhSCA9IGRBICogZEEgKyBkQiAqIGRCIC0gZEMgKiBkQztcXHJcXG4gICAgICAgIGRlbHRhSCA9IGRlbHRhSCA8IDAgPyAwIDogTWF0aC5zcXJ0KGRlbHRhSCk7XFxyXFxuICAgICAgICBjb25zdCBkQWxwaGEgPSAoYTIgLSBhMSkgKiB0aGlzLl93aGl0ZVBvaW50LmEgKiB0aGlzLl9rQTtcXHJcXG4gICAgICAgIC8vIFRPRE86IGFkZCBhbHBoYSBjaGFubmVsIHN1cHBvcnRcXHJcXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZEwgLyB0aGlzLl9LbCwgMikgK1xcclxcbiAgICAgICAgICAgIE1hdGgucG93KGRDIC8gKDEuMCArIHRoaXMuX0sxICogYzEpLCAyKSArXFxyXFxuICAgICAgICAgICAgTWF0aC5wb3coZGVsdGFIIC8gKDEuMCArIHRoaXMuX0syICogYzEpLCAyKSArXFxyXFxuICAgICAgICAgICAgTWF0aC5wb3coZEFscGhhLCAyKSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuY2xhc3MgQ0lFOTRUZXh0aWxlcyBleHRlbmRzIEFic3RyYWN0Q0lFOTQge1xcclxcbiAgICBfc2V0RGVmYXVsdHMoKSB7XFxyXFxuICAgICAgICB0aGlzLl9LbCA9IDIuMDtcXHJcXG4gICAgICAgIHRoaXMuX0sxID0gMC4wNDg7XFxyXFxuICAgICAgICB0aGlzLl9LMiA9IDAuMDE0O1xcclxcbiAgICAgICAgdGhpcy5fa0EgPSAwLjI1ICogNTAgLyAyNTU7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuY2xhc3MgQ0lFOTRHcmFwaGljQXJ0cyBleHRlbmRzIEFic3RyYWN0Q0lFOTQge1xcclxcbiAgICBfc2V0RGVmYXVsdHMoKSB7XFxyXFxuICAgICAgICB0aGlzLl9LbCA9IDEuMDtcXHJcXG4gICAgICAgIHRoaXMuX0sxID0gMC4wNDU7XFxyXFxuICAgICAgICB0aGlzLl9LMiA9IDAuMDE1O1xcclxcbiAgICAgICAgdGhpcy5fa0EgPSAwLjI1ICogMTAwIC8gMjU1O1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNpZTk0LmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2NpZWRlMjAwMC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2NpZWRlMjAwMC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQ0lFREUyMDAwICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQ0lFREUyMDAwXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDSUVERTIwMDA7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzdGFuY2VDYWxjdWxhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Rpc3RhbmNlQ2FsY3VsYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9kaXN0YW5jZUNhbGN1bGF0b3IuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnZlcnNpb25fcmdiMmxhYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29udmVyc2lvbi9yZ2IybGFiICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vcmdiMmxhYi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYXJpdGhtZXRpYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9hcml0aG1ldGljLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogY2llZGUyMDAwLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcblxcclxcblxcclxcbi8vIHRzbGludDpkaXNhYmxlOnZhcmlhYmxlLW5hbWVcXHJcXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuYW1pbmctY29udmVudGlvblxcclxcbi8qKlxcclxcbiAqIENJRURFMjAwMCBhbGdvcml0aG0gLSBBZGFwdGVkIGZyb20gU2hhcm1hIGV0IGFsJ3MgTUFUTEFCIGltcGxlbWVudGF0aW9uIGF0XFxyXFxuICogaHR0cDovL3d3dy5lY2Uucm9jaGVzdGVyLmVkdS9+Z3NoYXJtYS9jaWVkZTIwMDAvXFxyXFxuICovXFxyXFxuY2xhc3MgQ0lFREUyMDAwIGV4dGVuZHMgX2Rpc3RhbmNlQ2FsY3VsYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvclxcXCJdIHtcXHJcXG4gICAgX3NldERlZmF1bHRzKCkgeyB9XFxyXFxuICAgIHN0YXRpYyBfY2FsY3VsYXRlaHAoYiwgYXApIHtcXHJcXG4gICAgICAgIGNvbnN0IGhwID0gTWF0aC5hdGFuMihiLCBhcCk7XFxyXFxuICAgICAgICBpZiAoaHAgPj0gMClcXHJcXG4gICAgICAgICAgICByZXR1cm4gaHA7XFxyXFxuICAgICAgICByZXR1cm4gaHAgKyBDSUVERTIwMDAuX2RlZzM2MEluUmFkO1xcclxcbiAgICB9XFxyXFxuICAgIHN0YXRpYyBfY2FsY3VsYXRlUlQoYWhwLCBhQ3ApIHtcXHJcXG4gICAgICAgIGNvbnN0IGFDcF90b183ID0gTWF0aC5wb3coYUNwLCA3LjApO1xcclxcbiAgICAgICAgY29uc3QgUl9DID0gMi4wICogTWF0aC5zcXJ0KGFDcF90b183IC8gKGFDcF90b183ICsgQ0lFREUyMDAwLl9wb3cyNXRvNykpOyAvLyAyNV43XFxyXFxuICAgICAgICBjb25zdCBkZWx0YV90aGV0YSA9IENJRURFMjAwMC5fZGVnMzBJblJhZCAqIE1hdGguZXhwKC1NYXRoLnBvdygoYWhwIC0gQ0lFREUyMDAwLl9kZWcyNzVJblJhZCkgLyBDSUVERTIwMDAuX2RlZzI1SW5SYWQsIDIuMCkpO1xcclxcbiAgICAgICAgcmV0dXJuIC1NYXRoLnNpbigyLjAgKiBkZWx0YV90aGV0YSkgKiBSX0M7XFxyXFxuICAgIH1cXHJcXG4gICAgc3RhdGljIF9jYWxjdWxhdGVUKGFocCkge1xcclxcbiAgICAgICAgcmV0dXJuIDEuMCAtIC4xNyAqIE1hdGguY29zKGFocCAtIENJRURFMjAwMC5fZGVnMzBJblJhZCkgKyAuMjQgKiBNYXRoLmNvcyhhaHAgKiAyLjApICsgLjMyICogTWF0aC5jb3MoYWhwICogMy4wICsgQ0lFREUyMDAwLl9kZWc2SW5SYWQpIC0gLjIgKiBNYXRoLmNvcyhhaHAgKiA0LjAgLSBDSUVERTIwMDAuX2RlZzYzSW5SYWQpO1xcclxcbiAgICB9XFxyXFxuICAgIHN0YXRpYyBfY2FsY3VsYXRlX2FocChDMXBDMnAsIGhfYmFyLCBoMXAsIGgycCkge1xcclxcbiAgICAgICAgY29uc3QgaHBTdW0gPSBoMXAgKyBoMnA7XFxyXFxuICAgICAgICBpZiAoQzFwQzJwID09PSAwKVxcclxcbiAgICAgICAgICAgIHJldHVybiBocFN1bTtcXHJcXG4gICAgICAgIGlmIChoX2JhciA8PSBDSUVERTIwMDAuX2RlZzE4MEluUmFkKVxcclxcbiAgICAgICAgICAgIHJldHVybiBocFN1bSAvIDIuMDtcXHJcXG4gICAgICAgIGlmIChocFN1bSA8IENJRURFMjAwMC5fZGVnMzYwSW5SYWQpXFxyXFxuICAgICAgICAgICAgcmV0dXJuIChocFN1bSArIENJRURFMjAwMC5fZGVnMzYwSW5SYWQpIC8gMi4wO1xcclxcbiAgICAgICAgcmV0dXJuIChocFN1bSAtIENJRURFMjAwMC5fZGVnMzYwSW5SYWQpIC8gMi4wO1xcclxcbiAgICB9XFxyXFxuICAgIHN0YXRpYyBfY2FsY3VsYXRlX2RIcChDMXBDMnAsIGhfYmFyLCBoMnAsIGgxcCkge1xcclxcbiAgICAgICAgbGV0IGRocDtcXHJcXG4gICAgICAgIGlmIChDMXBDMnAgPT09IDApIHtcXHJcXG4gICAgICAgICAgICBkaHAgPSAwO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgZWxzZSBpZiAoaF9iYXIgPD0gQ0lFREUyMDAwLl9kZWcxODBJblJhZCkge1xcclxcbiAgICAgICAgICAgIGRocCA9IGgycCAtIGgxcDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGVsc2UgaWYgKGgycCA8PSBoMXApIHtcXHJcXG4gICAgICAgICAgICBkaHAgPSBoMnAgLSBoMXAgKyBDSUVERTIwMDAuX2RlZzM2MEluUmFkO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgZGhwID0gaDJwIC0gaDFwIC0gQ0lFREUyMDAwLl9kZWczNjBJblJhZDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiAyLjAgKiBNYXRoLnNxcnQoQzFwQzJwKSAqIE1hdGguc2luKGRocCAvIDIuMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xcclxcbiAgICAgICAgY29uc3QgbGFiMSA9IE9iamVjdChfY29udmVyc2lvbl9yZ2IybGFiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInJnYjJsYWJcXFwiXSkoT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImluUmFuZ2UwdG8yNTVcXFwiXSkocjEgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaW5SYW5nZTB0bzI1NVxcXCJdKShnMSAqIHRoaXMuX3doaXRlUG9pbnQuZyksIE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJpblJhbmdlMHRvMjU1XFxcIl0pKGIxICogdGhpcy5fd2hpdGVQb2ludC5iKSk7XFxyXFxuICAgICAgICBjb25zdCBsYWIyID0gT2JqZWN0KF9jb252ZXJzaW9uX3JnYjJsYWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicmdiMmxhYlxcXCJdKShPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaW5SYW5nZTB0bzI1NVxcXCJdKShyMiAqIHRoaXMuX3doaXRlUG9pbnQuciksIE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJpblJhbmdlMHRvMjU1XFxcIl0pKGcyICogdGhpcy5fd2hpdGVQb2ludC5nKSwgT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImluUmFuZ2UwdG8yNTVcXFwiXSkoYjIgKiB0aGlzLl93aGl0ZVBvaW50LmIpKTtcXHJcXG4gICAgICAgIGNvbnN0IGRBID0gKGEyIC0gYTEpICogdGhpcy5fd2hpdGVQb2ludC5hICogQ0lFREUyMDAwLl9rQTtcXHJcXG4gICAgICAgIGNvbnN0IGRFMiA9IHRoaXMuY2FsY3VsYXRlUmF3SW5MYWIobGFiMSwgbGFiMik7XFxyXFxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGRFMiArIGRBICogZEEpO1xcclxcbiAgICB9XFxyXFxuICAgIGNhbGN1bGF0ZVJhd0luTGFiKExhYjEsIExhYjIpIHtcXHJcXG4gICAgICAgIC8vIEdldCBMLGEsYiB2YWx1ZXMgZm9yIGNvbG9yIDFcXHJcXG4gICAgICAgIGNvbnN0IEwxID0gTGFiMS5MO1xcclxcbiAgICAgICAgY29uc3QgYTEgPSBMYWIxLmE7XFxyXFxuICAgICAgICBjb25zdCBiMSA9IExhYjEuYjtcXHJcXG4gICAgICAgIC8vIEdldCBMLGEsYiB2YWx1ZXMgZm9yIGNvbG9yIDJcXHJcXG4gICAgICAgIGNvbnN0IEwyID0gTGFiMi5MO1xcclxcbiAgICAgICAgY29uc3QgYTIgPSBMYWIyLmE7XFxyXFxuICAgICAgICBjb25zdCBiMiA9IExhYjIuYjtcXHJcXG4gICAgICAgIC8vIENhbGN1bGF0ZSBDcHJpbWUxLCBDcHJpbWUyLCBDYWJiYXJcXHJcXG4gICAgICAgIGNvbnN0IEMxID0gTWF0aC5zcXJ0KGExICogYTEgKyBiMSAqIGIxKTtcXHJcXG4gICAgICAgIGNvbnN0IEMyID0gTWF0aC5zcXJ0KGEyICogYTIgKyBiMiAqIGIyKTtcXHJcXG4gICAgICAgIGNvbnN0IHBvd19hX0MxX0MyX3RvXzcgPSBNYXRoLnBvdygoQzEgKyBDMikgLyAyLjAsIDcuMCk7XFxyXFxuICAgICAgICBjb25zdCBHID0gMC41ICogKDEuMCAtIE1hdGguc3FydChwb3dfYV9DMV9DMl90b183IC8gKHBvd19hX0MxX0MyX3RvXzcgKyBDSUVERTIwMDAuX3BvdzI1dG83KSkpOyAvLyAyNV43XFxyXFxuICAgICAgICBjb25zdCBhMXAgPSAoMS4wICsgRykgKiBhMTtcXHJcXG4gICAgICAgIGNvbnN0IGEycCA9ICgxLjAgKyBHKSAqIGEyO1xcclxcbiAgICAgICAgY29uc3QgQzFwID0gTWF0aC5zcXJ0KGExcCAqIGExcCArIGIxICogYjEpO1xcclxcbiAgICAgICAgY29uc3QgQzJwID0gTWF0aC5zcXJ0KGEycCAqIGEycCArIGIyICogYjIpO1xcclxcbiAgICAgICAgY29uc3QgQzFwQzJwID0gQzFwICogQzJwO1xcclxcbiAgICAgICAgLy8gQW5nbGVzIGluIERlZ3JlZS5cXHJcXG4gICAgICAgIGNvbnN0IGgxcCA9IENJRURFMjAwMC5fY2FsY3VsYXRlaHAoYjEsIGExcCk7XFxyXFxuICAgICAgICBjb25zdCBoMnAgPSBDSUVERTIwMDAuX2NhbGN1bGF0ZWhwKGIyLCBhMnApO1xcclxcbiAgICAgICAgY29uc3QgaF9iYXIgPSBNYXRoLmFicyhoMXAgLSBoMnApO1xcclxcbiAgICAgICAgY29uc3QgZExwID0gTDIgLSBMMTtcXHJcXG4gICAgICAgIGNvbnN0IGRDcCA9IEMycCAtIEMxcDtcXHJcXG4gICAgICAgIGNvbnN0IGRIcCA9IENJRURFMjAwMC5fY2FsY3VsYXRlX2RIcChDMXBDMnAsIGhfYmFyLCBoMnAsIGgxcCk7XFxyXFxuICAgICAgICBjb25zdCBhaHAgPSBDSUVERTIwMDAuX2NhbGN1bGF0ZV9haHAoQzFwQzJwLCBoX2JhciwgaDFwLCBoMnApO1xcclxcbiAgICAgICAgY29uc3QgVCA9IENJRURFMjAwMC5fY2FsY3VsYXRlVChhaHApO1xcclxcbiAgICAgICAgY29uc3QgYUNwID0gKEMxcCArIEMycCkgLyAyLjA7XFxyXFxuICAgICAgICBjb25zdCBhTHBfbWludXNfNTBfc3F1YXJlID0gTWF0aC5wb3coKEwxICsgTDIpIC8gMi4wIC0gNTAuMCwgMi4wKTtcXHJcXG4gICAgICAgIGNvbnN0IFNfTCA9IDEuMCArICguMDE1ICogYUxwX21pbnVzXzUwX3NxdWFyZSkgLyBNYXRoLnNxcnQoMjAuMCArIGFMcF9taW51c181MF9zcXVhcmUpO1xcclxcbiAgICAgICAgY29uc3QgU19DID0gMS4wICsgLjA0NSAqIGFDcDtcXHJcXG4gICAgICAgIGNvbnN0IFNfSCA9IDEuMCArIC4wMTUgKiBUICogYUNwO1xcclxcbiAgICAgICAgY29uc3QgUl9UID0gQ0lFREUyMDAwLl9jYWxjdWxhdGVSVChhaHAsIGFDcCk7XFxyXFxuICAgICAgICBjb25zdCBkTHBTTCA9IGRMcCAvIFNfTDsgLy8gU19MICoga0wsIHdoZXJlIGtMIGlzIDEuMFxcclxcbiAgICAgICAgY29uc3QgZENwU0MgPSBkQ3AgLyBTX0M7IC8vIFNfQyAqIGtDLCB3aGVyZSBrQyBpcyAxLjBcXHJcXG4gICAgICAgIGNvbnN0IGRIcFNIID0gZEhwIC8gU19IOyAvLyBTX0ggKiBrSCwgd2hlcmUga0ggaXMgMS4wXFxyXFxuICAgICAgICByZXR1cm4gTWF0aC5wb3coZExwU0wsIDIpICsgTWF0aC5wb3coZENwU0MsIDIpICsgTWF0aC5wb3coZEhwU0gsIDIpICsgUl9UICogZENwU0MgKiBkSHBTSDtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG4vKipcXHJcXG4gKiBXZWlnaHQgaW4gZGlzdGFuY2U6IDAuMjVcXHJcXG4gKiBNYXggRGVsdGFFOiAxMDBcXHJcXG4gKiBNYXggRGVsdGFBOiAyNTVcXHJcXG4gKi9cXHJcXG5DSUVERTIwMDAuX2tBID0gMC4yNSAqIDEwMCAvIDI1NTtcXHJcXG5DSUVERTIwMDAuX3BvdzI1dG83ID0gTWF0aC5wb3coMjUsIDcpO1xcclxcbkNJRURFMjAwMC5fZGVnMzYwSW5SYWQgPSBPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVncmVlczJyYWRpYW5zXFxcIl0pKDM2MCk7XFxyXFxuQ0lFREUyMDAwLl9kZWcxODBJblJhZCA9IE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWdyZWVzMnJhZGlhbnNcXFwiXSkoMTgwKTtcXHJcXG5DSUVERTIwMDAuX2RlZzMwSW5SYWQgPSBPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVncmVlczJyYWRpYW5zXFxcIl0pKDMwKTtcXHJcXG5DSUVERTIwMDAuX2RlZzZJblJhZCA9IE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWdyZWVzMnJhZGlhbnNcXFwiXSkoNik7XFxyXFxuQ0lFREUyMDAwLl9kZWc2M0luUmFkID0gT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZ3JlZXMycmFkaWFuc1xcXCJdKSg2Myk7XFxyXFxuQ0lFREUyMDAwLl9kZWcyNzVJblJhZCA9IE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWdyZWVzMnJhZGlhbnNcXFwiXSkoMjc1KTtcXHJcXG5DSUVERTIwMDAuX2RlZzI1SW5SYWQgPSBPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVncmVlczJyYWRpYW5zXFxcIl0pKDI1KTtcXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaWVkZTIwMDAuanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvY21ldHJpYy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9jbWV0cmljLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQ01ldHJpYyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkNNZXRyaWNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENNZXRyaWM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzdGFuY2VDYWxjdWxhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Rpc3RhbmNlQ2FsY3VsYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9kaXN0YW5jZUNhbGN1bGF0b3IuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBjbWV0cmljLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcbi8qKlxcclxcbiAqIFRPRE86IE5hbWUgaXQ6IGh0dHA6Ly93d3cuY29tcHVwaGFzZS5jb20vY21ldHJpYy5odG1cXHJcXG4gKi9cXHJcXG5jbGFzcyBDTWV0cmljIGV4dGVuZHMgX2Rpc3RhbmNlQ2FsY3VsYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvclxcXCJdIHtcXHJcXG4gICAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xcclxcbiAgICAgICAgY29uc3Qgcm1lYW4gPSAocjEgKyByMikgLyAyICogdGhpcy5fd2hpdGVQb2ludC5yO1xcclxcbiAgICAgICAgY29uc3QgciA9IChyMSAtIHIyKSAqIHRoaXMuX3doaXRlUG9pbnQucjtcXHJcXG4gICAgICAgIGNvbnN0IGcgPSAoZzEgLSBnMikgKiB0aGlzLl93aGl0ZVBvaW50Lmc7XFxyXFxuICAgICAgICBjb25zdCBiID0gKGIxIC0gYjIpICogdGhpcy5fd2hpdGVQb2ludC5iO1xcclxcbiAgICAgICAgY29uc3QgZEUgPSAoKCgoNTEyICsgcm1lYW4pICogciAqIHIpID4+IDgpICsgNCAqIGcgKiBnICsgKCgoNzY3IC0gcm1lYW4pICogYiAqIGIpID4+IDgpKTtcXHJcXG4gICAgICAgIGNvbnN0IGRBID0gKGEyIC0gYTEpICogdGhpcy5fd2hpdGVQb2ludC5hO1xcclxcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkRSArIGRBICogZEEpO1xcclxcbiAgICB9XFxyXFxuICAgIF9zZXREZWZhdWx0cygpIHsgfVxcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbWV0cmljLmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2Rpc3RhbmNlQ2FsY3VsYXRvci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2Rpc3RhbmNlQ2FsY3VsYXRvci5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3I7IH0pO1xcbmNsYXNzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcXHJcXG4gICAgY29uc3RydWN0b3IoKSB7XFxyXFxuICAgICAgICB0aGlzLl9zZXREZWZhdWx0cygpO1xcclxcbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgbWF4aW1hbCBjb2xvciBjb21wb25lbnQgZGVsdGFzICgyNTUgLSAwID0gMjU1KVxcclxcbiAgICAgICAgdGhpcy5zZXRXaGl0ZVBvaW50KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxyXFxuICAgIH1cXHJcXG4gICAgc2V0V2hpdGVQb2ludChyLCBnLCBiLCBhKSB7XFxyXFxuICAgICAgICB0aGlzLl93aGl0ZVBvaW50ID0ge1xcclxcbiAgICAgICAgICAgIHI6IChyID4gMCkgPyAyNTUgLyByIDogMCxcXHJcXG4gICAgICAgICAgICBnOiAoZyA+IDApID8gMjU1IC8gZyA6IDAsXFxyXFxuICAgICAgICAgICAgYjogKGIgPiAwKSA/IDI1NSAvIGIgOiAwLFxcclxcbiAgICAgICAgICAgIGE6IChhID4gMCkgPyAyNTUgLyBhIDogMCxcXHJcXG4gICAgICAgIH07XFxyXFxuICAgICAgICB0aGlzLl9tYXhEaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlUmF3KHIsIGcsIGIsIGEsIDAsIDAsIDAsIDApO1xcclxcbiAgICB9XFxyXFxuICAgIGNhbGN1bGF0ZU5vcm1hbGl6ZWQoY29sb3JBLCBjb2xvckIpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVJhdyhjb2xvckEuciwgY29sb3JBLmcsIGNvbG9yQS5iLCBjb2xvckEuYSwgY29sb3JCLnIsIGNvbG9yQi5nLCBjb2xvckIuYiwgY29sb3JCLmEpIC8gdGhpcy5fbWF4RGlzdGFuY2U7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGFuY2VDYWxjdWxhdG9yLmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2V1Y2xpZGVhbi5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2V1Y2xpZGVhbi5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWJzdHJhY3RFdWNsaWRlYW4sIEV1Y2xpZGVhbiwgRXVjbGlkZWFuQlQ3MDksIEV1Y2xpZGVhbkJUNzA5Tm9BbHBoYSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFic3RyYWN0RXVjbGlkZWFuXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBYnN0cmFjdEV1Y2xpZGVhbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiRXVjbGlkZWFuXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFdWNsaWRlYW47IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkV1Y2xpZGVhbkJUNzA5XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFdWNsaWRlYW5CVDcwOTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiRXVjbGlkZWFuQlQ3MDlOb0FscGhhXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFdWNsaWRlYW5CVDcwOU5vQWxwaGE7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzdGFuY2VDYWxjdWxhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Rpc3RhbmNlQ2FsY3VsYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9kaXN0YW5jZUNhbGN1bGF0b3IuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29uc3RhbnRzL2J0NzA5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9idDcwOS5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEBwcmVzZXJ2ZVxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIGV1Y2xpZGVhbi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBFdWNsaWRlYW4gY29sb3IgZGlzdGFuY2VcXHJcXG4gKi9cXHJcXG5jbGFzcyBBYnN0cmFjdEV1Y2xpZGVhbiBleHRlbmRzIF9kaXN0YW5jZUNhbGN1bGF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3JcXFwiXSB7XFxyXFxuICAgIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcXHJcXG4gICAgICAgIGNvbnN0IGRSID0gcjIgLSByMTtcXHJcXG4gICAgICAgIGNvbnN0IGRHID0gZzIgLSBnMTtcXHJcXG4gICAgICAgIGNvbnN0IGRCID0gYjIgLSBiMTtcXHJcXG4gICAgICAgIGNvbnN0IGRBID0gYTIgLSBhMTtcXHJcXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5fa1IgKiBkUiAqIGRSICsgdGhpcy5fa0cgKiBkRyAqIGRHICsgdGhpcy5fa0IgKiBkQiAqIGRCICsgdGhpcy5fa0EgKiBkQSAqIGRBKTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5jbGFzcyBFdWNsaWRlYW4gZXh0ZW5kcyBBYnN0cmFjdEV1Y2xpZGVhbiB7XFxyXFxuICAgIF9zZXREZWZhdWx0cygpIHtcXHJcXG4gICAgICAgIHRoaXMuX2tSID0gMTtcXHJcXG4gICAgICAgIHRoaXMuX2tHID0gMTtcXHJcXG4gICAgICAgIHRoaXMuX2tCID0gMTtcXHJcXG4gICAgICAgIHRoaXMuX2tBID0gMTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG4vKipcXHJcXG4gKiBFdWNsaWRlYW4gY29sb3IgZGlzdGFuY2UgKFJHQlF1YW50IG1vZGlmaWNhdGlvbiB3IEFscGhhKVxcclxcbiAqL1xcclxcbmNsYXNzIEV1Y2xpZGVhbkJUNzA5IGV4dGVuZHMgQWJzdHJhY3RFdWNsaWRlYW4ge1xcclxcbiAgICBfc2V0RGVmYXVsdHMoKSB7XFxyXFxuICAgICAgICB0aGlzLl9rUiA9IF9jb25zdGFudHNfYnQ3MDlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiWVxcXCJdLlJFRDtcXHJcXG4gICAgICAgIHRoaXMuX2tHID0gX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJZXFxcIl0uR1JFRU47XFxyXFxuICAgICAgICB0aGlzLl9rQiA9IF9jb25zdGFudHNfYnQ3MDlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiWVxcXCJdLkJMVUU7XFxyXFxuICAgICAgICAvLyBUT0RPOiB3aGF0IGlzIHRoZSBiZXN0IGNvZWZmaWNpZW50IGJlbG93P1xcclxcbiAgICAgICAgdGhpcy5fa0EgPSAxO1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8qKlxcclxcbiAqIEV1Y2xpZGVhbiBjb2xvciBkaXN0YW5jZSAoUkdCUXVhbnQgbW9kaWZpY2F0aW9uIHcvbyBBbHBoYSlcXHJcXG4gKi9cXHJcXG5jbGFzcyBFdWNsaWRlYW5CVDcwOU5vQWxwaGEgZXh0ZW5kcyBBYnN0cmFjdEV1Y2xpZGVhbiB7XFxyXFxuICAgIF9zZXREZWZhdWx0cygpIHtcXHJcXG4gICAgICAgIHRoaXMuX2tSID0gX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJZXFxcIl0uUkVEO1xcclxcbiAgICAgICAgdGhpcy5fa0cgPSBfY29uc3RhbnRzX2J0NzA5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIllcXFwiXS5HUkVFTjtcXHJcXG4gICAgICAgIHRoaXMuX2tCID0gX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJZXFxcIl0uQkxVRTtcXHJcXG4gICAgICAgIHRoaXMuX2tBID0gMDtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldWNsaWRlYW4uanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvaW5kZXguanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2luZGV4LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yLCBDSUU5NFRleHRpbGVzLCBDSUU5NEdyYXBoaWNBcnRzLCBDSUVERTIwMDAsIENNZXRyaWMsIEFic3RyYWN0RXVjbGlkZWFuLCBFdWNsaWRlYW4sIEV1Y2xpZGVhbkJUNzA5Tm9BbHBoYSwgRXVjbGlkZWFuQlQ3MDksIEFic3RyYWN0TWFuaGF0dGFuLCBNYW5oYXR0YW4sIE1hbmhhdHRhbkJUNzA5LCBNYW5oYXR0YW5Ob21teWRlLCBQTkdRdWFudCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzdGFuY2VDYWxjdWxhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Rpc3RhbmNlQ2FsY3VsYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9kaXN0YW5jZUNhbGN1bGF0b3IuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZGlzdGFuY2VDYWxjdWxhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIkFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2llOTRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2llOTQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvY2llOTQuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkNJRTk0VGV4dGlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jaWU5NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJDSUU5NFRleHRpbGVzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQ0lFOTRHcmFwaGljQXJ0c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2NpZTk0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkNJRTk0R3JhcGhpY0FydHNcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jaWVkZTIwMDBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2llZGUyMDAwICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2NpZWRlMjAwMC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQ0lFREUyMDAwXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY2llZGUyMDAwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkNJRURFMjAwMFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NtZXRyaWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY21ldHJpYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9jbWV0cmljLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJDTWV0cmljXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY21ldHJpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJDTWV0cmljXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXVjbGlkZWFuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V1Y2xpZGVhbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9ldWNsaWRlYW4uanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFic3RyYWN0RXVjbGlkZWFuXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZXVjbGlkZWFuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIkFic3RyYWN0RXVjbGlkZWFuXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiRXVjbGlkZWFuXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZXVjbGlkZWFuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIkV1Y2xpZGVhblxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkV1Y2xpZGVhbkJUNzA5Tm9BbHBoYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2V1Y2xpZGVhbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJFdWNsaWRlYW5CVDcwOU5vQWxwaGFcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJFdWNsaWRlYW5CVDcwOVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2V1Y2xpZGVhbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJFdWNsaWRlYW5CVDcwOVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21hbmhhdHRhbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYW5oYXR0YW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvbWFuaGF0dGFuLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJBYnN0cmFjdE1hbmhhdHRhblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21hbmhhdHRhbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJBYnN0cmFjdE1hbmhhdHRhblxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk1hbmhhdHRhblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21hbmhhdHRhbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJNYW5oYXR0YW5cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJNYW5oYXR0YW5CVDcwOVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21hbmhhdHRhbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJNYW5oYXR0YW5CVDcwOVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk1hbmhhdHRhbk5vbW15ZGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tYW5oYXR0YW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiTWFuaGF0dGFuTm9tbXlkZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BuZ1F1YW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BuZ1F1YW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL3BuZ1F1YW50LmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJQTkdRdWFudFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3BuZ1F1YW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcIlBOR1F1YW50XFxcIl07IH0pO1xcblxcbi8qKlxcclxcbiAqIEBwcmVzZXJ2ZVxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIGlxLnRzIC0gSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9tYW5oYXR0YW4uanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9tYW5oYXR0YW4uanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEFic3RyYWN0TWFuaGF0dGFuLCBNYW5oYXR0YW4sIE1hbmhhdHRhbk5vbW15ZGUsIE1hbmhhdHRhbkJUNzA5ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQWJzdHJhY3RNYW5oYXR0YW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFic3RyYWN0TWFuaGF0dGFuOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJNYW5oYXR0YW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1hbmhhdHRhbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiTWFuaGF0dGFuTm9tbXlkZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTWFuaGF0dGFuTm9tbXlkZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiTWFuaGF0dGFuQlQ3MDlcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1hbmhhdHRhbkJUNzA5OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Rpc3RhbmNlQ2FsY3VsYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kaXN0YW5jZUNhbGN1bGF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvZGlzdGFuY2VDYWxjdWxhdG9yLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25zdGFudHNfYnQ3MDlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvbnN0YW50cy9idDcwOSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb25zdGFudHMvYnQ3MDkuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBtYW5oYXR0YW5OZXVRdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBNYW5oYXR0YW4gZGlzdGFuY2UgKE5ldVF1YW50IG1vZGlmaWNhdGlvbikgLSB3L28gc1JHQiBjb2VmZmljaWVudHNcXHJcXG4gKi9cXHJcXG5jbGFzcyBBYnN0cmFjdE1hbmhhdHRhbiBleHRlbmRzIF9kaXN0YW5jZUNhbGN1bGF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3JcXFwiXSB7XFxyXFxuICAgIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcXHJcXG4gICAgICAgIGxldCBkUiA9IHIyIC0gcjE7XFxyXFxuICAgICAgICBsZXQgZEcgPSBnMiAtIGcxO1xcclxcbiAgICAgICAgbGV0IGRCID0gYjIgLSBiMTtcXHJcXG4gICAgICAgIGxldCBkQSA9IGEyIC0gYTE7XFxyXFxuICAgICAgICBpZiAoZFIgPCAwKVxcclxcbiAgICAgICAgICAgIGRSID0gMCAtIGRSO1xcclxcbiAgICAgICAgaWYgKGRHIDwgMClcXHJcXG4gICAgICAgICAgICBkRyA9IDAgLSBkRztcXHJcXG4gICAgICAgIGlmIChkQiA8IDApXFxyXFxuICAgICAgICAgICAgZEIgPSAwIC0gZEI7XFxyXFxuICAgICAgICBpZiAoZEEgPCAwKVxcclxcbiAgICAgICAgICAgIGRBID0gMCAtIGRBO1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tSICogZFIgKyB0aGlzLl9rRyAqIGRHICsgdGhpcy5fa0IgKiBkQiArIHRoaXMuX2tBICogZEE7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuY2xhc3MgTWFuaGF0dGFuIGV4dGVuZHMgQWJzdHJhY3RNYW5oYXR0YW4ge1xcclxcbiAgICBfc2V0RGVmYXVsdHMoKSB7XFxyXFxuICAgICAgICB0aGlzLl9rUiA9IDE7XFxyXFxuICAgICAgICB0aGlzLl9rRyA9IDE7XFxyXFxuICAgICAgICB0aGlzLl9rQiA9IDE7XFxyXFxuICAgICAgICB0aGlzLl9rQSA9IDE7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuLyoqXFxyXFxuICogTWFuaGF0dGFuIGRpc3RhbmNlIChOb21teWRlIG1vZGlmaWNhdGlvbilcXHJcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaWdvci1iZXprcm92bnkvaW1hZ2UtcXVhbnRpemF0aW9uL2lzc3Vlcy80I2lzc3VlY29tbWVudC0yMzUxNTUzMjBcXHJcXG4gKi9cXHJcXG5jbGFzcyBNYW5oYXR0YW5Ob21teWRlIGV4dGVuZHMgQWJzdHJhY3RNYW5oYXR0YW4ge1xcclxcbiAgICBfc2V0RGVmYXVsdHMoKSB7XFxyXFxuICAgICAgICB0aGlzLl9rUiA9IDAuNDk4NDtcXHJcXG4gICAgICAgIHRoaXMuX2tHID0gMC44NjI1O1xcclxcbiAgICAgICAgdGhpcy5fa0IgPSAwLjI5Nzk7XFxyXFxuICAgICAgICAvLyBUT0RPOiB3aGF0IGlzIHRoZSBiZXN0IGNvZWZmaWNpZW50IGJlbG93P1xcclxcbiAgICAgICAgdGhpcy5fa0EgPSAxO1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8qKlxcclxcbiAqIE1hbmhhdHRhbiBkaXN0YW5jZSAoc1JHQiBjb2VmZmljaWVudHMpXFxyXFxuICovXFxyXFxuY2xhc3MgTWFuaGF0dGFuQlQ3MDkgZXh0ZW5kcyBBYnN0cmFjdE1hbmhhdHRhbiB7XFxyXFxuICAgIF9zZXREZWZhdWx0cygpIHtcXHJcXG4gICAgICAgIHRoaXMuX2tSID0gX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJZXFxcIl0uUkVEO1xcclxcbiAgICAgICAgdGhpcy5fa0cgPSBfY29uc3RhbnRzX2J0NzA5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIllcXFwiXS5HUkVFTjtcXHJcXG4gICAgICAgIHRoaXMuX2tCID0gX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJZXFxcIl0uQkxVRTtcXHJcXG4gICAgICAgIC8vIFRPRE86IHdoYXQgaXMgdGhlIGJlc3QgY29lZmZpY2llbnQgYmVsb3c/XFxyXFxuICAgICAgICB0aGlzLl9rQSA9IDE7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFuaGF0dGFuLmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL3BuZ1F1YW50LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9kaXN0YW5jZS9wbmdRdWFudC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBQTkdRdWFudCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlBOR1F1YW50XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQTkdRdWFudDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXN0YW5jZUNhbGN1bGF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlzdGFuY2VDYWxjdWxhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2Rpc3RhbmNlL2Rpc3RhbmNlQ2FsY3VsYXRvci5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEBwcmVzZXJ2ZVxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIHBuZ1F1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcbi8qKlxcclxcbiAqIFRPRE86IGNoZWNrIHF1YWxpdHkgb2YgdGhpcyBkaXN0YW5jZSBlcXVhdGlvblxcclxcbiAqIFRPRE86IGFzayBhdXRob3IgZm9yIHVzYWdlIHJpZ2h0c1xcclxcbiAqIHRha2VuIGZyb206XFxyXFxuICoge0BsaW5rIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDc1NDUwNi9jb2xvci1zaW1pbGFyaXR5LWRpc3RhbmNlLWluLXJnYmEtY29sb3Itc3BhY2UvODc5Njg2NyM4Nzk2ODY3fVxcclxcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcG9ybmVsL3BuZ3F1YW50L2Jsb2IvY2MzOWI0Nzc5OWE3ZmYyZWYxN2I1MjlmOTQxNWZmNmU2YjIxM2I4Zi9saWIvcGFtLmgjTDE0OH1cXHJcXG4gKi9cXHJcXG5jbGFzcyBQTkdRdWFudCBleHRlbmRzIF9kaXN0YW5jZUNhbGN1bGF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3JcXFwiXSB7XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBBdXRob3IncyBjb21tZW50c1xcclxcbiAgICAgKiBweF9iLnJnYiA9IHB4LnJnYiArIDAqKDEtcHguYSkgLy8gYmxlbmQgcHggb24gYmxhY2tcXHJcXG4gICAgICogcHhfYi5hICAgPSBweC5hICAgKyAxKigxLXB4LmEpXFxyXFxuICAgICAqIHB4X3cucmdiID0gcHgucmdiICsgMSooMS1weC5hKSAvLyBibGVuZCBweCBvbiB3aGl0ZVxcclxcbiAgICAgKiBweF93LmEgICA9IHB4LmEgICArIDEqKDEtcHguYSlcXHJcXG4gICAgICpcXHJcXG4gICAgICogcHhfYi5yZ2IgPSBweC5yZ2IgICAgICAgICAgICAgIC8vIGRpZmZlcmVuY2Ugc2FtZSBhcyBpbiBvcGFxdWUgUkdCXFxyXFxuICAgICAqIHB4X2IuYSAgID0gMVxcclxcbiAgICAgKiBweF93LnJnYiA9IHB4LnJnYiAtIHB4LmEgICAgICAgLy8gZGlmZmVyZW5jZSBzaW1wbGlmaWVzIHRvIGZvcm11bGEgYmVsb3dcXHJcXG4gICAgICogcHhfdy5hICAgPSAxXFxyXFxuICAgICAqXFxyXFxuICAgICAqIChweC5yZ2IgLSBweC5hKSAtIChweS5yZ2IgLSBweS5hKVxcclxcbiAgICAgKiAocHgucmdiIC0gcHkucmdiKSArIChweS5hIC0gcHguYSlcXHJcXG4gICAgICpcXHJcXG4gICAgICovXFxyXFxuICAgIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcXHJcXG4gICAgICAgIGNvbnN0IGFscGhhcyA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYTtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcmRpZmZlcmVuY2VDaChyMSAqIHRoaXMuX3doaXRlUG9pbnQuciwgcjIgKiB0aGlzLl93aGl0ZVBvaW50LnIsIGFscGhhcykgK1xcclxcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yZGlmZmVyZW5jZUNoKGcxICogdGhpcy5fd2hpdGVQb2ludC5nLCBnMiAqIHRoaXMuX3doaXRlUG9pbnQuZywgYWxwaGFzKSArXFxyXFxuICAgICAgICAgICAgdGhpcy5fY29sb3JkaWZmZXJlbmNlQ2goYjEgKiB0aGlzLl93aGl0ZVBvaW50LmIsIGIyICogdGhpcy5fd2hpdGVQb2ludC5iLCBhbHBoYXMpO1xcclxcbiAgICB9XFxyXFxuICAgIF9jb2xvcmRpZmZlcmVuY2VDaCh4LCB5LCBhbHBoYXMpIHtcXHJcXG4gICAgICAgIC8vIG1heGltdW0gb2YgY2hhbm5lbCBibGVuZGVkIG9uIHdoaXRlLCBhbmQgYmxlbmRlZCBvbiBibGFja1xcclxcbiAgICAgICAgLy8gcHJlbXVsdGlwbGllZCBhbHBoYSBhbmQgYmFja2dyb3VuZHMgMC8xIHNob3J0ZW4gdGhlIGZvcm11bGFcXHJcXG4gICAgICAgIGNvbnN0IGJsYWNrID0geCAtIHk7XFxyXFxuICAgICAgICBjb25zdCB3aGl0ZSA9IGJsYWNrICsgYWxwaGFzO1xcclxcbiAgICAgICAgcmV0dXJuIGJsYWNrICogYmxhY2sgKyB3aGl0ZSAqIHdoaXRlO1xcclxcbiAgICB9XFxyXFxuICAgIF9zZXREZWZhdWx0cygpIHsgfVxcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbmdRdWFudC5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS1xLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2ltYWdlLXEuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBidWlsZFBhbGV0dGUsIGJ1aWxkUGFsZXR0ZVN5bmMsIGFwcGx5UGFsZXR0ZSwgYXBwbHlQYWxldHRlU3luYywgY29uc3RhbnRzLCBjb252ZXJzaW9uLCBkaXN0YW5jZSwgcGFsZXR0ZSwgaW1hZ2UsIHF1YWxpdHksIHV0aWxzICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKG1vZHVsZSBvYmplY3QpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY29uc3RhbnRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX187IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb252ZXJzaW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnZlcnNpb24vaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChtb2R1bGUgb2JqZWN0KSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNvbnZlcnNpb25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX187IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlzdGFuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlzdGFuY2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vZGlzdGFuY2UvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChtb2R1bGUgb2JqZWN0KSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRpc3RhbmNlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZGlzdGFuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXzsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wYWxldHRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhbGV0dGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKG1vZHVsZSBvYmplY3QpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicGFsZXR0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3BhbGV0dGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXzsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbWFnZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKG1vZHVsZSBvYmplY3QpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaW1hZ2VcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9pbWFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3F1YWxpdHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcXVhbGl0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9xdWFsaXR5L2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAobW9kdWxlIG9iamVjdCkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJxdWFsaXR5XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcXVhbGl0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAobW9kdWxlIG9iamVjdCkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ1dGlsc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X187IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzaWNBUElfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzaWNBUEkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vYmFzaWNBUEkuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJ1aWxkUGFsZXR0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2Jhc2ljQVBJX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImJ1aWxkUGFsZXR0ZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJ1aWxkUGFsZXR0ZVN5bmNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9iYXNpY0FQSV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJidWlsZFBhbGV0dGVTeW5jXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXBwbHlQYWxldHRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfYmFzaWNBUElfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiYXBwbHlQYWxldHRlXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXBwbHlQYWxldHRlU3luY1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2Jhc2ljQVBJX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImFwcGx5UGFsZXR0ZVN5bmNcXFwiXTsgfSk7XFxuXFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLXEuanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvYXJyYXkuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2ltYWdlL2FycmF5LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwsIEVycm9yRGlmZnVzaW9uQXJyYXkgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJFcnJvckRpZmZ1c2lvbkFycmF5XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFcnJvckRpZmZ1c2lvbkFycmF5OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ltYWdlUXVhbnRpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ltYWdlUXVhbnRpemVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2ltYWdlL2ltYWdlUXVhbnRpemVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19wb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvcG9pbnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcG9pbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2FyaXRobWV0aWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvYXJpdGhtZXRpYy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfcHJvZ3Jlc3NUcmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9wcm9ncmVzc1RyYWNrZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcHJvZ3Jlc3NUcmFja2VyLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogZGl0aGVyRXJyb3JEaWZmdXNpb25BcnJheS50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4vLyBUT0RPOiBpcyBpdCB0aGUgYmVzdCBuYW1lIGZvciB0aGlzIGVudW0gXFxcImtlcm5lbFxcXCI/XFxyXFxudmFyIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWw7XFxyXFxuKGZ1bmN0aW9uIChFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsKSB7XFxyXFxuICAgIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtcXFwiRmxveWRTdGVpbmJlcmdcXFwiXSA9IDBdID0gXFxcIkZsb3lkU3RlaW5iZXJnXFxcIjtcXHJcXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1xcXCJGYWxzZUZsb3lkU3RlaW5iZXJnXFxcIl0gPSAxXSA9IFxcXCJGYWxzZUZsb3lkU3RlaW5iZXJnXFxcIjtcXHJcXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1xcXCJTdHVja2lcXFwiXSA9IDJdID0gXFxcIlN0dWNraVxcXCI7XFxyXFxuICAgIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtcXFwiQXRraW5zb25cXFwiXSA9IDNdID0gXFxcIkF0a2luc29uXFxcIjtcXHJcXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1xcXCJKYXJ2aXNcXFwiXSA9IDRdID0gXFxcIkphcnZpc1xcXCI7XFxyXFxuICAgIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtcXFwiQnVya2VzXFxcIl0gPSA1XSA9IFxcXCJCdXJrZXNcXFwiO1xcclxcbiAgICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbXFxcIlNpZXJyYVxcXCJdID0gNl0gPSBcXFwiU2llcnJhXFxcIjtcXHJcXG4gICAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsW1xcXCJUd29TaWVycmFcXFwiXSA9IDddID0gXFxcIlR3b1NpZXJyYVxcXCI7XFxyXFxuICAgIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWxbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFtcXFwiU2llcnJhTGl0ZVxcXCJdID0gOF0gPSBcXFwiU2llcnJhTGl0ZVxcXCI7XFxyXFxufSkoRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbCB8fCAoRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbCA9IHt9KSk7XFxyXFxuLy8gaHR0cDovL3d3dy50YW5uZXJoZWxsYW5kLmNvbS80NjYwL2RpdGhlcmluZy1lbGV2ZW4tYWxnb3JpdGhtcy1zb3VyY2UtY29kZS9cXHJcXG5jbGFzcyBFcnJvckRpZmZ1c2lvbkFycmF5IGV4dGVuZHMgX2ltYWdlUXVhbnRpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIkFic3RyYWN0SW1hZ2VRdWFudGl6ZXJcXFwiXSB7XFxyXFxuICAgIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBrZXJuZWwsIHNlcnBlbnRpbmUgPSB0cnVlLCBtaW5pbXVtQ29sb3JEaXN0YW5jZVRvRGl0aGVyID0gMCwgY2FsY3VsYXRlRXJyb3JMaWtlR0lNUCA9IGZhbHNlKSB7XFxyXFxuICAgICAgICBzdXBlcigpO1xcclxcbiAgICAgICAgdGhpcy5fc2V0S2VybmVsKGtlcm5lbCk7XFxyXFxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xcclxcbiAgICAgICAgdGhpcy5fbWluQ29sb3JEaXN0YW5jZSA9IG1pbmltdW1Db2xvckRpc3RhbmNlVG9EaXRoZXI7XFxyXFxuICAgICAgICB0aGlzLl9zZXJwZW50aW5lID0gc2VycGVudGluZTtcXHJcXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUVycm9yTGlrZUdJTVAgPSBjYWxjdWxhdGVFcnJvckxpa2VHSU1QO1xcclxcbiAgICB9XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBhZGFwdGVkIGZyb20gaHR0cDovL2pzYmluLmNvbS9pWG9mSWppLzIvZWRpdCBieSBQQUV6XFxyXFxuICAgICAqIGZpeGVkIHZlcnNpb24uIGl0IGRvZXNuJ3QgdXNlIGltYWdlIHBpeGVscyBhcyBlcnJvciBzdG9yYWdlLCBhbHNvIGl0IGRvZXNuJ3QgaGF2ZSAwLjMgKyAwLjMgKyAwLjMgKyAwLjMgPSAwIGVycm9yXFxyXFxuICAgICAqIE11dGF0ZXMgcG9pbnRDb250YWluZXJcXHJcXG4gICAgICovXFxyXFxuICAgICpxdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkge1xcclxcbiAgICAgICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcXHJcXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUG9pbnQgPSBuZXcgX3V0aWxzX3BvaW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlBvaW50XFxcIl0oKTtcXHJcXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcXHJcXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBvaW50Q29udGFpbmVyLmdldEhlaWdodCgpO1xcclxcbiAgICAgICAgY29uc3QgZXJyb3JMaW5lcyA9IFtdO1xcclxcbiAgICAgICAgbGV0IGRpciA9IDE7XFxyXFxuICAgICAgICBsZXQgbWF4RXJyb3JMaW5lcyA9IDE7XFxyXFxuICAgICAgICAvLyBpbml0aWFsIGVycm9yIGxpbmVzIChudW1iZXIgaXMgdGFrZW4gZnJvbSBkaXRoZXJpbmcga2VybmVsKVxcclxcbiAgICAgICAgZm9yIChjb25zdCBrZXJuZWwgb2YgdGhpcy5fa2VybmVsKSB7XFxyXFxuICAgICAgICAgICAgY29uc3Qga2VybmVsRXJyb3JMaW5lcyA9IGtlcm5lbFsyXSArIDE7XFxyXFxuICAgICAgICAgICAgaWYgKG1heEVycm9yTGluZXMgPCBrZXJuZWxFcnJvckxpbmVzKVxcclxcbiAgICAgICAgICAgICAgICBtYXhFcnJvckxpbmVzID0ga2VybmVsRXJyb3JMaW5lcztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4RXJyb3JMaW5lczsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgdGhpcy5fZmlsbEVycm9yTGluZShlcnJvckxpbmVzW2ldID0gW10sIHdpZHRoKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgX3V0aWxzX3Byb2dyZXNzVHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJQcm9ncmVzc1RyYWNrZXJcXFwiXShoZWlnaHQsIDk5KTtcXHJcXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcXHJcXG4gICAgICAgICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkoeSkpIHtcXHJcXG4gICAgICAgICAgICAgICAgeWllbGQge1xcclxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3MsXFxyXFxuICAgICAgICAgICAgICAgIH07XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIGFsd2F5cyBzZXJwZW50aW5lXFxyXFxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlcnBlbnRpbmUpXFxyXFxuICAgICAgICAgICAgICAgIGRpciA9IGRpciAqIC0xO1xcclxcbiAgICAgICAgICAgIGNvbnN0IGxuaSA9IHkgKiB3aWR0aDtcXHJcXG4gICAgICAgICAgICBjb25zdCB4U3RhcnQgPSBkaXIgPT09IDEgPyAwIDogd2lkdGggLSAxO1xcclxcbiAgICAgICAgICAgIGNvbnN0IHhFbmQgPSBkaXIgPT09IDEgPyB3aWR0aCA6IC0xO1xcclxcbiAgICAgICAgICAgIC8vIGN5Y2xpYyBzaGlmdCB3aXRoIGVyYXNpbmdcXHJcXG4gICAgICAgICAgICB0aGlzLl9maWxsRXJyb3JMaW5lKGVycm9yTGluZXNbMF0sIHdpZHRoKTtcXHJcXG4gICAgICAgICAgICAvLyBUT0RPOiB3aHkgaXQgaXMgbmVlZGVkIHRvIGNhc3QgdHlwZXMgaGVyZT9cXHJcXG4gICAgICAgICAgICBlcnJvckxpbmVzLnB1c2goZXJyb3JMaW5lcy5zaGlmdCgpKTtcXHJcXG4gICAgICAgICAgICBjb25zdCBlcnJvckxpbmUgPSBlcnJvckxpbmVzWzBdO1xcclxcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB4U3RhcnQsIGlkeCA9IGxuaSArIHhTdGFydDsgeCAhPT0geEVuZDsgeCArPSBkaXIsIGlkeCArPSBkaXIpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gSW1hZ2UgcGl4ZWxcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludEFycmF5W2lkeF07XFxyXFxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsUG9pbnQgPSBuZXcgVXRpbHMuUG9pbnQoKSxcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckxpbmVbeF07XFxyXFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUG9pbnQuZnJvbShwb2ludCk7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZFBvaW50ID0gX3V0aWxzX3BvaW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlBvaW50XFxcIl0uY3JlYXRlQnlSR0JBKE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJpblJhbmdlMHRvMjU1Um91bmRlZFxcXCJdKShwb2ludC5yICsgZXJyb3JbMF0pLCBPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaW5SYW5nZTB0bzI1NVJvdW5kZWRcXFwiXSkocG9pbnQuZyArIGVycm9yWzFdKSwgT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImluUmFuZ2UwdG8yNTVSb3VuZGVkXFxcIl0pKHBvaW50LmIgKyBlcnJvclsyXSksIE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJpblJhbmdlMHRvMjU1Um91bmRlZFxcXCJdKShwb2ludC5hICsgZXJyb3JbM10pKTtcXHJcXG4gICAgICAgICAgICAgICAgLy8gUmVkdWNlZCBwaXhlbFxcclxcbiAgICAgICAgICAgICAgICBjb25zdCBwYWxldHRlUG9pbnQgPSBwYWxldHRlLmdldE5lYXJlc3RDb2xvcih0aGlzLl9kaXN0YW5jZSwgY29ycmVjdGVkUG9pbnQpO1xcclxcbiAgICAgICAgICAgICAgICBwb2ludC5mcm9tKHBhbGV0dGVQb2ludCk7XFxyXFxuICAgICAgICAgICAgICAgIC8vIGRpdGhlcmluZyBzdHJlbmd0aFxcclxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWluQ29sb3JEaXN0YW5jZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IHRoaXMuX2Rpc3RhbmNlLmNhbGN1bGF0ZU5vcm1hbGl6ZWQocG9pbnQsIHBhbGV0dGVQb2ludCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IHRoaXMuX21pbkNvbG9yRGlzdGFuY2UpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgLy8gQ29tcG9uZW50IGRpc3RhbmNlXFxyXFxuICAgICAgICAgICAgICAgIGxldCBlcjtcXHJcXG4gICAgICAgICAgICAgICAgbGV0IGVnO1xcclxcbiAgICAgICAgICAgICAgICBsZXQgZWI7XFxyXFxuICAgICAgICAgICAgICAgIGxldCBlYTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbGN1bGF0ZUVycm9yTGlrZUdJTVApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGVyID0gY29ycmVjdGVkUG9pbnQuciAtIHBhbGV0dGVQb2ludC5yO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZWcgPSBjb3JyZWN0ZWRQb2ludC5nIC0gcGFsZXR0ZVBvaW50Lmc7XFxyXFxuICAgICAgICAgICAgICAgICAgICBlYiA9IGNvcnJlY3RlZFBvaW50LmIgLSBwYWxldHRlUG9pbnQuYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGVhID0gY29ycmVjdGVkUG9pbnQuYSAtIHBhbGV0dGVQb2ludC5hO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXIgPSBvcmlnaW5hbFBvaW50LnIgLSBwYWxldHRlUG9pbnQucjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGVnID0gb3JpZ2luYWxQb2ludC5nIC0gcGFsZXR0ZVBvaW50Lmc7XFxyXFxuICAgICAgICAgICAgICAgICAgICBlYiA9IG9yaWdpbmFsUG9pbnQuYiAtIHBhbGV0dGVQb2ludC5iO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZWEgPSBvcmlnaW5hbFBvaW50LmEgLSBwYWxldHRlUG9pbnQuYTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBjb25zdCBkU3RhcnQgPSBkaXIgPT09IDEgPyAwIDogdGhpcy5fa2VybmVsLmxlbmd0aCAtIDE7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGRFbmQgPSBkaXIgPT09IDEgPyB0aGlzLl9rZXJuZWwubGVuZ3RoIDogLTE7XFxyXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBkU3RhcnQ7IGkgIT09IGRFbmQ7IGkgKz0gZGlyKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MSA9IHRoaXMuX2tlcm5lbFtpXVsxXSAqIGRpcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gdGhpcy5fa2VybmVsW2ldWzJdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgxICsgeCA+PSAwICYmIHgxICsgeCA8IHdpZHRoICYmIHkxICsgeSA+PSAwICYmIHkxICsgeSA8IGhlaWdodCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLl9rZXJuZWxbaV1bMF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGVycm9yTGluZXNbeTFdW3gxICsgeF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZVswXSA9IGVbMF0gKyBlciAqIGQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZVsxXSA9IGVbMV0gKyBlZyAqIGQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZVsyXSA9IGVbMl0gKyBlYiAqIGQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZVszXSA9IGVbM10gKyBlYSAqIGQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB5aWVsZCB7XFxyXFxuICAgICAgICAgICAgcG9pbnRDb250YWluZXIsXFxyXFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG4gICAgX2ZpbGxFcnJvckxpbmUoZXJyb3JMaW5lLCB3aWR0aCkge1xcclxcbiAgICAgICAgLy8gc2hyaW5rXFxyXFxuICAgICAgICBpZiAoZXJyb3JMaW5lLmxlbmd0aCA+IHdpZHRoKSB7XFxyXFxuICAgICAgICAgICAgZXJyb3JMaW5lLmxlbmd0aCA9IHdpZHRoO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gcmV1c2UgZXhpc3RpbmcgYXJyYXlzXFxyXFxuICAgICAgICBjb25zdCBsID0gZXJyb3JMaW5lLmxlbmd0aDtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckxpbmVbaV07XFxyXFxuICAgICAgICAgICAgZXJyb3JbMF0gPSBlcnJvclsxXSA9IGVycm9yWzJdID0gZXJyb3JbM10gPSAwO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gY3JlYXRlIG1pc3NpbmcgYXJyYXlzXFxyXFxuICAgICAgICBmb3IgKGxldCBpID0gbDsgaSA8IHdpZHRoOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBlcnJvckxpbmVbaV0gPSBbMC4wLCAwLjAsIDAuMCwgMC4wXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBfc2V0S2VybmVsKGtlcm5lbCkge1xcclxcbiAgICAgICAgc3dpdGNoIChrZXJuZWwpIHtcXHJcXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuRmxveWRTdGVpbmJlcmc6XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcXHJcXG4gICAgICAgICAgICAgICAgICAgIFs3IC8gMTYsIDEsIDBdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzMgLyAxNiwgLTEsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzUgLyAxNiwgMCwgMV0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMSAvIDE2LCAxLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgXTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLkZhbHNlRmxveWRTdGVpbmJlcmc6XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcXHJcXG4gICAgICAgICAgICAgICAgICAgIFszIC8gOCwgMSwgMF0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMyAvIDgsIDAsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzIgLyA4LCAxLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgXTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlN0dWNraTpcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5fa2VybmVsID0gW1xcclxcbiAgICAgICAgICAgICAgICAgICAgWzggLyA0MiwgMSwgMF0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbNCAvIDQyLCAyLCAwXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gNDIsIC0yLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gNDIsIC0xLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFs4IC8gNDIsIDAsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzQgLyA0MiwgMSwgMV0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMiAvIDQyLCAyLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gNDIsIC0yLCAyXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gNDIsIC0xLCAyXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gNDIsIDAsIDJdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzIgLyA0MiwgMSwgMl0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMSAvIDQyLCAyLCAyXSxcXHJcXG4gICAgICAgICAgICAgICAgXTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLkF0a2luc29uOlxcclxcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMSAvIDgsIDEsIDBdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA4LCAyLCAwXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gOCwgLTEsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA4LCAwLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gOCwgMSwgMV0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMSAvIDgsIDAsIDJdLFxcclxcbiAgICAgICAgICAgICAgICBdO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuSmFydmlzOlxcclxcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXFxyXFxuICAgICAgICAgICAgICAgICAgICBbNyAvIDQ4LCAxLCAwXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFs1IC8gNDgsIDIsIDBdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzMgLyA0OCwgLTIsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzUgLyA0OCwgLTEsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzcgLyA0OCwgMCwgMV0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbNSAvIDQ4LCAxLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFszIC8gNDgsIDIsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzEgLyA0OCwgLTIsIDJdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzMgLyA0OCwgLTEsIDJdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzUgLyA0OCwgMCwgMl0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMyAvIDQ4LCAxLCAyXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gNDgsIDIsIDJdLFxcclxcbiAgICAgICAgICAgICAgICBdO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuQnVya2VzOlxcclxcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXFxyXFxuICAgICAgICAgICAgICAgICAgICBbOCAvIDMyLCAxLCAwXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFs0IC8gMzIsIDIsIDBdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAzMiwgLTIsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzQgLyAzMiwgLTEsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzggLyAzMiwgMCwgMV0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbNCAvIDMyLCAxLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gMzIsIDIsIDFdLFxcclxcbiAgICAgICAgICAgICAgICBdO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBjYXNlIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwuU2llcnJhOlxcclxcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXFxyXFxuICAgICAgICAgICAgICAgICAgICBbNSAvIDMyLCAxLCAwXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFszIC8gMzIsIDIsIDBdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAzMiwgLTIsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzQgLyAzMiwgLTEsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzUgLyAzMiwgMCwgMV0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbNCAvIDMyLCAxLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gMzIsIDIsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAzMiwgLTEsIDJdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzMgLyAzMiwgMCwgMl0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMiAvIDMyLCAxLCAyXSxcXHJcXG4gICAgICAgICAgICAgICAgXTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlR3b1NpZXJyYTpcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5fa2VybmVsID0gW1xcclxcbiAgICAgICAgICAgICAgICAgICAgWzQgLyAxNiwgMSwgMF0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMyAvIDE2LCAyLCAwXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gMTYsIC0yLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gMTYsIC0xLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFszIC8gMTYsIDAsIDFdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgWzIgLyAxNiwgMSwgMV0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMSAvIDE2LCAyLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgXTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLlNpZXJyYUxpdGU6XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsyIC8gNCwgMSwgMF0sXFxyXFxuICAgICAgICAgICAgICAgICAgICBbMSAvIDQsIC0xLCAxXSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIFsxIC8gNCwgMCwgMV0sXFxyXFxuICAgICAgICAgICAgICAgIF07XFxyXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxyXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3JEaWZmdXNpb25BcnJheTogdW5rbm93biBrZXJuZWwgPSAnICsga2VybmVsKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbWFnZVF1YW50aXplci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvaW1hZ2VRdWFudGl6ZXIuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWJzdHJhY3RJbWFnZVF1YW50aXplciAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFic3RyYWN0SW1hZ2VRdWFudGl6ZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXI7IH0pO1xcbmNsYXNzIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIge1xcclxcbiAgICBxdWFudGl6ZVN5bmMocG9pbnRDb250YWluZXIsIHBhbGV0dGUpIHtcXHJcXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5xdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkpIHtcXHJcXG4gICAgICAgICAgICBpZiAodmFsdWUucG9pbnRDb250YWluZXIpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnBvaW50Q29udGFpbmVyO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZVF1YW50aXplci5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbmRleC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvaW5kZXguanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWJzdHJhY3RJbWFnZVF1YW50aXplciwgTmVhcmVzdENvbG9yLCBFcnJvckRpZmZ1c2lvbkFycmF5LCBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLCBFcnJvckRpZmZ1c2lvblJpZW1lcnNtYSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW1hZ2VRdWFudGl6ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW1hZ2VRdWFudGl6ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvaW1hZ2VRdWFudGl6ZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFic3RyYWN0SW1hZ2VRdWFudGl6ZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9pbWFnZVF1YW50aXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJBYnN0cmFjdEltYWdlUXVhbnRpemVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbmVhcmVzdENvbG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL25lYXJlc3RDb2xvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9uZWFyZXN0Q29sb3IuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk5lYXJlc3RDb2xvclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX25lYXJlc3RDb2xvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJOZWFyZXN0Q29sb3JcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcnJheSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9hcnJheS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiRXJyb3JEaWZmdXNpb25BcnJheVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkVycm9yRGlmZnVzaW9uQXJyYXlcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JpZW1lcnNtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yaWVtZXJzbWEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvcmllbWVyc21hLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJFcnJvckRpZmZ1c2lvblJpZW1lcnNtYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3JpZW1lcnNtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJFcnJvckRpZmZ1c2lvblJpZW1lcnNtYVxcXCJdOyB9KTtcXG5cXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvbmVhcmVzdENvbG9yLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2UvbmVhcmVzdENvbG9yLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBOZWFyZXN0Q29sb3IgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJOZWFyZXN0Q29sb3JcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE5lYXJlc3RDb2xvcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbWFnZVF1YW50aXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbWFnZVF1YW50aXplciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9pbWFnZVF1YW50aXplci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfcHJvZ3Jlc3NUcmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9wcm9ncmVzc1RyYWNrZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcHJvZ3Jlc3NUcmFja2VyLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogbmVhcmVzdENvbG9yLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcblxcclxcbmNsYXNzIE5lYXJlc3RDb2xvciBleHRlbmRzIF9pbWFnZVF1YW50aXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJBYnN0cmFjdEltYWdlUXVhbnRpemVyXFxcIl0ge1xcclxcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcikge1xcclxcbiAgICAgICAgc3VwZXIoKTtcXHJcXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XFxyXFxuICAgIH1cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIE11dGF0ZXMgcG9pbnRDb250YWluZXJcXHJcXG4gICAgICovXFxyXFxuICAgICpxdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkge1xcclxcbiAgICAgICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcXHJcXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcXHJcXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBvaW50Q29udGFpbmVyLmdldEhlaWdodCgpO1xcclxcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IG5ldyBfdXRpbHNfcHJvZ3Jlc3NUcmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlByb2dyZXNzVHJhY2tlclxcXCJdKGhlaWdodCwgOTkpO1xcclxcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xcclxcbiAgICAgICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeSh5KSkge1xcclxcbiAgICAgICAgICAgICAgICB5aWVsZCB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzcyxcXHJcXG4gICAgICAgICAgICAgICAgfTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIGlkeCA9IHkgKiB3aWR0aDsgeCA8IHdpZHRoOyB4KyssIGlkeCsrKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIEltYWdlIHBpeGVsXFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRBcnJheVtpZHhdO1xcclxcbiAgICAgICAgICAgICAgICAvLyBSZWR1Y2VkIHBpeGVsXFxyXFxuICAgICAgICAgICAgICAgIHBvaW50LmZyb20ocGFsZXR0ZS5nZXROZWFyZXN0Q29sb3IodGhpcy5fZGlzdGFuY2UsIHBvaW50KSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgeWllbGQge1xcclxcbiAgICAgICAgICAgIHBvaW50Q29udGFpbmVyLFxcclxcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5lYXJlc3RDb2xvci5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9yaWVtZXJzbWEuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9yaWVtZXJzbWEuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEVycm9yRGlmZnVzaW9uUmllbWVyc21hICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiRXJyb3JEaWZmdXNpb25SaWVtZXJzbWFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVycm9yRGlmZnVzaW9uUmllbWVyc21hOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ltYWdlUXVhbnRpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ltYWdlUXVhbnRpemVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2ltYWdlL2ltYWdlUXVhbnRpemVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zcGFjZUZpbGxpbmdDdXJ2ZXNfaGlsYmVydEN1cnZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NwYWNlRmlsbGluZ0N1cnZlcy9oaWxiZXJ0Q3VydmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vaW1hZ2Uvc3BhY2VGaWxsaW5nQ3VydmVzL2hpbGJlcnRDdXJ2ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3BvaW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BvaW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9hcml0aG1ldGljICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2FyaXRobWV0aWMuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBNSVQgTGljZW5zZVxcclxcbiAqXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKlxcclxcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXHJcXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcXFwiU29mdHdhcmVcXFwiKSwgdG9cXHJcXG4gKiBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxcclxcbiAqIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxcclxcbiAqIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxyXFxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXHJcXG4gKlxcclxcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxyXFxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxyXFxuICpcXHJcXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcclxcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcclxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMXFxyXFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXHJcXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xcclxcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcXHJcXG4gKiBJTiBUSEUgU09GVFdBUkUuXFxyXFxuICpcXHJcXG4gKiByaWVtZXJzbWEudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuY2xhc3MgRXJyb3JEaWZmdXNpb25SaWVtZXJzbWEgZXh0ZW5kcyBfaW1hZ2VRdWFudGl6ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiQWJzdHJhY3RJbWFnZVF1YW50aXplclxcXCJdIHtcXHJcXG4gICAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGVycm9yUXVldWVTaXplID0gMTYsIGVycm9yUHJvcGFnYXRpb24gPSAxKSB7XFxyXFxuICAgICAgICBzdXBlcigpO1xcclxcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcXHJcXG4gICAgICAgIHRoaXMuX2Vycm9yUXVldWVTaXplID0gZXJyb3JRdWV1ZVNpemU7XFxyXFxuICAgICAgICB0aGlzLl93ZWlnaHRzID0gRXJyb3JEaWZmdXNpb25SaWVtZXJzbWEuX2NyZWF0ZVdlaWdodHMoZXJyb3JQcm9wYWdhdGlvbiwgZXJyb3JRdWV1ZVNpemUpO1xcclxcbiAgICB9XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBNdXRhdGVzIHBvaW50Q29udGFpbmVyXFxyXFxuICAgICAqL1xcclxcbiAgICAqcXVhbnRpemUocG9pbnRDb250YWluZXIsIHBhbGV0dGUpIHtcXHJcXG4gICAgICAgIGNvbnN0IHBvaW50QXJyYXkgPSBwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XFxyXFxuICAgICAgICBjb25zdCB3aWR0aCA9IHBvaW50Q29udGFpbmVyLmdldFdpZHRoKCk7XFxyXFxuICAgICAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcXHJcXG4gICAgICAgIGNvbnN0IGVycm9yUXVldWUgPSBbXTtcXHJcXG4gICAgICAgIGxldCBoZWFkID0gMDtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JRdWV1ZVNpemU7IGkrKykge1xcclxcbiAgICAgICAgICAgIGVycm9yUXVldWVbaV0gPSB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDAgfTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHlpZWxkKiBPYmplY3QoX3NwYWNlRmlsbGluZ0N1cnZlc19oaWxiZXJ0Q3VydmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiaGlsYmVydEN1cnZlXFxcIl0pKHdpZHRoLCBoZWlnaHQsICh4LCB5KSA9PiB7XFxyXFxuICAgICAgICAgICAgY29uc3QgcCA9IHBvaW50QXJyYXlbeCArIHkgKiB3aWR0aF07XFxyXFxuICAgICAgICAgICAgbGV0IHIgPSBwLnI7XFxyXFxuICAgICAgICAgICAgbGV0IGcgPSBwLmc7XFxyXFxuICAgICAgICAgICAgbGV0IGIgPSBwLmI7XFxyXFxuICAgICAgICAgICAgbGV0IGEgPSBwLmE7XFxyXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9lcnJvclF1ZXVlU2l6ZTsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IHRoaXMuX3dlaWdodHNbaV07XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBlcnJvclF1ZXVlWyhpICsgaGVhZCkgJSB0aGlzLl9lcnJvclF1ZXVlU2l6ZV07XFxyXFxuICAgICAgICAgICAgICAgIHIgKz0gZS5yICogd2VpZ2h0O1xcclxcbiAgICAgICAgICAgICAgICBnICs9IGUuZyAqIHdlaWdodDtcXHJcXG4gICAgICAgICAgICAgICAgYiArPSBlLmIgKiB3ZWlnaHQ7XFxyXFxuICAgICAgICAgICAgICAgIGEgKz0gZS5hICogd2VpZ2h0O1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb2ludCA9IF91dGlsc19wb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJQb2ludFxcXCJdLmNyZWF0ZUJ5UkdCQShPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiaW5SYW5nZTB0bzI1NVJvdW5kZWRcXFwiXSkociksIE9iamVjdChfdXRpbHNfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJpblJhbmdlMHRvMjU1Um91bmRlZFxcXCJdKShnKSwgT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImluUmFuZ2UwdG8yNTVSb3VuZGVkXFxcIl0pKGIpLCBPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiaW5SYW5nZTB0bzI1NVJvdW5kZWRcXFwiXSkoYSkpO1xcclxcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXplZFBvaW50ID0gcGFsZXR0ZS5nZXROZWFyZXN0Q29sb3IodGhpcy5fZGlzdGFuY2UsIGNvcnJlY3RlZFBvaW50KTtcXHJcXG4gICAgICAgICAgICAvLyB1cGRhdGUgaGVhZCBhbmQgY2FsY3VsYXRlIHRhaWxcXHJcXG4gICAgICAgICAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHRoaXMuX2Vycm9yUXVldWVTaXplO1xcclxcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSAoaGVhZCArIHRoaXMuX2Vycm9yUXVldWVTaXplIC0gMSkgJSB0aGlzLl9lcnJvclF1ZXVlU2l6ZTtcXHJcXG4gICAgICAgICAgICAvLyB1cGRhdGUgZXJyb3Igd2l0aCBuZXcgdmFsdWVcXHJcXG4gICAgICAgICAgICBlcnJvclF1ZXVlW3RhaWxdLnIgPSBwLnIgLSBxdWFudGl6ZWRQb2ludC5yO1xcclxcbiAgICAgICAgICAgIGVycm9yUXVldWVbdGFpbF0uZyA9IHAuZyAtIHF1YW50aXplZFBvaW50Lmc7XFxyXFxuICAgICAgICAgICAgZXJyb3JRdWV1ZVt0YWlsXS5iID0gcC5iIC0gcXVhbnRpemVkUG9pbnQuYjtcXHJcXG4gICAgICAgICAgICBlcnJvclF1ZXVlW3RhaWxdLmEgPSBwLmEgLSBxdWFudGl6ZWRQb2ludC5hO1xcclxcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb2ludFxcclxcbiAgICAgICAgICAgIHAuZnJvbShxdWFudGl6ZWRQb2ludCk7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICAgIHlpZWxkIHtcXHJcXG4gICAgICAgICAgICBwb2ludENvbnRhaW5lcixcXHJcXG4gICAgICAgICAgICBwcm9ncmVzczogMTAwLFxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcbiAgICBzdGF0aWMgX2NyZWF0ZVdlaWdodHMoZXJyb3JQcm9wYWdhdGlvbiwgZXJyb3JRdWV1ZVNpemUpIHtcXHJcXG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSBbXTtcXHJcXG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLmV4cChNYXRoLmxvZyhlcnJvclF1ZXVlU2l6ZSkgLyAoZXJyb3JRdWV1ZVNpemUgLSAxKSk7XFxyXFxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbmV4dCA9IDE7IGkgPCBlcnJvclF1ZXVlU2l6ZTsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgd2VpZ2h0c1tpXSA9ICgoKG5leHQgKyAwLjUpIHwgMCkgLyBlcnJvclF1ZXVlU2l6ZSkgKiBlcnJvclByb3BhZ2F0aW9uO1xcclxcbiAgICAgICAgICAgIG5leHQgKj0gbXVsdGlwbGllcjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiB3ZWlnaHRzO1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpZW1lcnNtYS5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9pbWFnZS9zcGFjZUZpbGxpbmdDdXJ2ZXMvaGlsYmVydEN1cnZlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2ltYWdlL3NwYWNlRmlsbGluZ0N1cnZlcy9oaWxiZXJ0Q3VydmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBoaWxiZXJ0Q3VydmUgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJoaWxiZXJ0Q3VydmVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGhpbGJlcnRDdXJ2ZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19wcm9ncmVzc1RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL3Byb2dyZXNzVHJhY2tlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wcm9ncmVzc1RyYWNrZXIuanNcXFwiKTtcXG5cXHJcXG52YXIgRGlyZWN0aW9uO1xcclxcbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XFxyXFxuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXFxcIk5PTkVcXFwiXSA9IDBdID0gXFxcIk5PTkVcXFwiO1xcclxcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1xcXCJVUFxcXCJdID0gMV0gPSBcXFwiVVBcXFwiO1xcclxcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1xcXCJMRUZUXFxcIl0gPSAyXSA9IFxcXCJMRUZUXFxcIjtcXHJcXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcXFwiUklHSFRcXFwiXSA9IDNdID0gXFxcIlJJR0hUXFxcIjtcXHJcXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcXFwiRE9XTlxcXCJdID0gNF0gPSBcXFwiRE9XTlxcXCI7XFxyXFxufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xcclxcbmZ1bmN0aW9uKiBoaWxiZXJ0Q3VydmUod2lkdGgsIGhlaWdodCwgY2FsbGJhY2spIHtcXHJcXG4gICAgY29uc3QgbWF4Qm91bmQgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcXHJcXG4gICAgY29uc3QgbGV2ZWwgPSBNYXRoLmZsb29yKE1hdGgubG9nKG1heEJvdW5kKSAvIE1hdGgubG9nKDIpICsgMSk7XFxyXFxuICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgX3V0aWxzX3Byb2dyZXNzVHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJQcm9ncmVzc1RyYWNrZXJcXFwiXSh3aWR0aCAqIGhlaWdodCwgOTkpO1xcclxcbiAgICBjb25zdCBkYXRhID0ge1xcclxcbiAgICAgICAgd2lkdGgsXFxyXFxuICAgICAgICBoZWlnaHQsXFxyXFxuICAgICAgICBsZXZlbCxcXHJcXG4gICAgICAgIGNhbGxiYWNrLFxcclxcbiAgICAgICAgdHJhY2tlcixcXHJcXG4gICAgICAgIGluZGV4OiAwLFxcclxcbiAgICAgICAgeDogMCxcXHJcXG4gICAgICAgIHk6IDAsXFxyXFxuICAgIH07XFxyXFxuICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uVVApO1xcclxcbiAgICB2aXNpdChkYXRhLCBEaXJlY3Rpb24uTk9ORSk7XFxyXFxufVxcclxcbmZ1bmN0aW9uKiB3YWxrSGlsYmVydChkYXRhLCBkaXJlY3Rpb24pIHtcXHJcXG4gICAgaWYgKGRhdGEubGV2ZWwgPCAxKVxcclxcbiAgICAgICAgcmV0dXJuO1xcclxcbiAgICBpZiAoZGF0YS50cmFja2VyLnNob3VsZE5vdGlmeShkYXRhLmluZGV4KSlcXHJcXG4gICAgICAgIHlpZWxkIHsgcHJvZ3Jlc3M6IGRhdGEudHJhY2tlci5wcm9ncmVzcyB9O1xcclxcbiAgICBkYXRhLmxldmVsLS07XFxyXFxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XFxyXFxuICAgICAgICBjYXNlIERpcmVjdGlvbi5MRUZUOlxcclxcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uVVApO1xcclxcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XFxyXFxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5MRUZUKTtcXHJcXG4gICAgICAgICAgICB2aXNpdChkYXRhLCBEaXJlY3Rpb24uRE9XTik7XFxyXFxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5MRUZUKTtcXHJcXG4gICAgICAgICAgICB2aXNpdChkYXRhLCBEaXJlY3Rpb24uTEVGVCk7XFxyXFxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5ET1dOKTtcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLlJJR0hUOlxcclxcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uRE9XTik7XFxyXFxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLkxFRlQpO1xcclxcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uUklHSFQpO1xcclxcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5VUCk7XFxyXFxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XFxyXFxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLlJJR0hUKTtcXHJcXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLlVQKTtcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLlVQOlxcclxcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uTEVGVCk7XFxyXFxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLkRPV04pO1xcclxcbiAgICAgICAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCBEaXJlY3Rpb24uVVApO1xcclxcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XFxyXFxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5VUCk7XFxyXFxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLlVQKTtcXHJcXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLlJJR0hUKTtcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLkRPV046XFxyXFxuICAgICAgICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIERpcmVjdGlvbi5SSUdIVCk7XFxyXFxuICAgICAgICAgICAgdmlzaXQoZGF0YSwgRGlyZWN0aW9uLlVQKTtcXHJcXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLkRPV04pO1xcclxcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5MRUZUKTtcXHJcXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLkRPV04pO1xcclxcbiAgICAgICAgICAgIHZpc2l0KGRhdGEsIERpcmVjdGlvbi5ET1dOKTtcXHJcXG4gICAgICAgICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgRGlyZWN0aW9uLkxFRlQpO1xcclxcbiAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgZGVmYXVsdDpcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgfVxcclxcbiAgICBkYXRhLmxldmVsKys7XFxyXFxufVxcclxcbmZ1bmN0aW9uIHZpc2l0KGRhdGEsIGRpcmVjdGlvbikge1xcclxcbiAgICBpZiAoZGF0YS54ID49IDAgJiYgZGF0YS54IDwgZGF0YS53aWR0aCAmJiBkYXRhLnkgPj0gMCAmJiBkYXRhLnkgPCBkYXRhLmhlaWdodCkge1xcclxcbiAgICAgICAgZGF0YS5jYWxsYmFjayhkYXRhLngsIGRhdGEueSk7XFxyXFxuICAgICAgICBkYXRhLmluZGV4Kys7XFxyXFxuICAgIH1cXHJcXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcXHJcXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLkxFRlQ6XFxyXFxuICAgICAgICAgICAgZGF0YS54LS07XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICBjYXNlIERpcmVjdGlvbi5SSUdIVDpcXHJcXG4gICAgICAgICAgICBkYXRhLngrKztcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgIGNhc2UgRGlyZWN0aW9uLlVQOlxcclxcbiAgICAgICAgICAgIGRhdGEueS0tO1xcclxcbiAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgY2FzZSBEaXJlY3Rpb24uRE9XTjpcXHJcXG4gICAgICAgICAgICBkYXRhLnkrKztcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgfVxcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaWxiZXJ0Q3VydmUuanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9pbmRleC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL2luZGV4LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyLCBOZXVRdWFudCwgTmV1UXVhbnRGbG9hdCwgUkdCUXVhbnQsIENvbG9ySGlzdG9ncmFtLCBXdVF1YW50LCBXdUNvbG9yQ3ViZSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGFsZXR0ZVF1YW50aXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYWxldHRlUXVhbnRpemVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvcGFsZXR0ZVF1YW50aXplci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcGFsZXR0ZVF1YW50aXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9uZXVxdWFudF9uZXVxdWFudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9uZXVxdWFudC9uZXVxdWFudCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL25ldXF1YW50L25ldXF1YW50LmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJOZXVRdWFudFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX25ldXF1YW50X25ldXF1YW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk5ldVF1YW50XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbmV1cXVhbnRfbmV1cXVhbnRGbG9hdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9uZXVxdWFudC9uZXVxdWFudEZsb2F0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvbmV1cXVhbnQvbmV1cXVhbnRGbG9hdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiTmV1UXVhbnRGbG9hdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX25ldXF1YW50X25ldXF1YW50RmxvYXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiTmV1UXVhbnRGbG9hdFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JnYnF1YW50X3JnYnF1YW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JnYnF1YW50L3JnYnF1YW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvcmdicXVhbnQvcmdicXVhbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlJHQlF1YW50XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcmdicXVhbnRfcmdicXVhbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiUkdCUXVhbnRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZ2JxdWFudF9jb2xvckhpc3RvZ3JhbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZ2JxdWFudC9jb2xvckhpc3RvZ3JhbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3JnYnF1YW50L2NvbG9ySGlzdG9ncmFtLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJDb2xvckhpc3RvZ3JhbVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3JnYnF1YW50X2NvbG9ySGlzdG9ncmFtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIkNvbG9ySGlzdG9ncmFtXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd3Vfd3VRdWFudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi93dS93dVF1YW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvd3Uvd3VRdWFudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiV3VRdWFudFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3d1X3d1UXVhbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiV3VRdWFudFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIld1Q29sb3JDdWJlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfd3Vfd3VRdWFudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJXdUNvbG9yQ3ViZVxcXCJdOyB9KTtcXG5cXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9uZXVxdWFudC9uZXVxdWFudC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL25ldXF1YW50L25ldXF1YW50LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogTmV1UXVhbnQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJOZXVRdWFudFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTmV1UXVhbnQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfcGFsZXR0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvcGFsZXR0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wYWxldHRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19wb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvcG9pbnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcG9pbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BhbGV0dGVRdWFudGl6ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3BhbGV0dGVRdWFudGl6ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9wYWxldHRlUXVhbnRpemVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvaW5kZXguanNcXFwiKTtcXG4vKlxcclxcbiAqIE5ldVF1YW50IE5ldXJhbC1OZXQgUXVhbnRpemF0aW9uIEFsZ29yaXRobVxcclxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcclxcbiAqXFxyXFxuICogQ29weXJpZ2h0IChjKSAxOTk0IEFudGhvbnkgRGVra2VyXFxyXFxuICpcXHJcXG4gKiBORVVRVUFOVCBOZXVyYWwtTmV0IHF1YW50aXphdGlvbiBhbGdvcml0aG0gYnkgQW50aG9ueSBEZWtrZXIsIDE5OTQuIFNlZVxcclxcbiAqIFxcXCJLb2hvbmVuIG5ldXJhbCBuZXR3b3JrcyBmb3Igb3B0aW1hbCBjb2xvdXIgcXVhbnRpemF0aW9uXFxcIiBpbiBcXFwiTmV0d29yazpcXHJcXG4gKiBDb21wdXRhdGlvbiBpbiBOZXVyYWwgU3lzdGVtc1xcXCIgVm9sLiA1ICgxOTk0KSBwcCAzNTEtMzY3LiBmb3IgYSBkaXNjdXNzaW9uIG9mXFxyXFxuICogdGhlIGFsZ29yaXRobS5cXHJcXG4gKlxcclxcbiAqIEFueSBwYXJ0eSBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoZXNlIGZpbGVzIGZyb20gdGhlIGF1dGhvciwgZGlyZWN0bHkgb3JcXHJcXG4gKiBpbmRpcmVjdGx5LCBpcyBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgYSBmdWxsIGFuZCB1bnJlc3RyaWN0ZWQgaXJyZXZvY2FibGUsXFxyXFxuICogd29ybGQtd2lkZSwgcGFpZCB1cCwgcm95YWx0eS1mcmVlLCBub25leGNsdXNpdmUgcmlnaHQgYW5kIGxpY2Vuc2UgdG8gZGVhbCBpblxcclxcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcXFwiU29mdHdhcmVcXFwiKSwgaW5jbHVkaW5nIHdpdGhvdXRcXHJcXG4gKiBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLFxcclxcbiAqIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB3aG9cXHJcXG4gKiByZWNlaXZlIGNvcGllcyBmcm9tIGFueSBzdWNoIHBhcnR5IHRvIGRvIHNvLCB3aXRoIHRoZSBvbmx5IHJlcXVpcmVtZW50IGJlaW5nXFxyXFxuICogdGhhdCB0aGlzIGNvcHlyaWdodCBub3RpY2UgcmVtYWluIGludGFjdC5cXHJcXG4gKi9cXHJcXG4vKipcXHJcXG4gKiBAcHJlc2VydmUgVHlwZVNjcmlwdCBwb3J0OlxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIG5ldXF1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcblxcclxcblxcclxcblxcclxcbi8vIGJpYXMgZm9yIGNvbG91ciB2YWx1ZXNcXHJcXG5jb25zdCBuZXR3b3JrQmlhc1NoaWZ0ID0gMztcXHJcXG5jbGFzcyBOZXVyb24ge1xcclxcbiAgICBjb25zdHJ1Y3RvcihkZWZhdWx0VmFsdWUpIHtcXHJcXG4gICAgICAgIHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IHRoaXMuYSA9IGRlZmF1bHRWYWx1ZTtcXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogVGhlcmUgaXMgYSBmaXggaW4gb3JpZ2luYWwgTkVVUVVBTlQgYnkgQW50aG9ueSBEZWtrZXIgKGh0dHA6Ly9tZW1iZXJzLm96ZW1haWwuY29tLmF1L35kZWtrZXIvTkVVUVVBTlQuSFRNTClcXHJcXG4gICAgICogQGV4YW1wbGVcXHJcXG4gICAgICogciA9IE1hdGgubWluKDI1NSwgKG5ldXJvbi5yICsgKDEgPDwgKG5ldHdvcmtCaWFzU2hpZnQgLSAxKSkpID4+IG5ldHdvcmtCaWFzU2hpZnQpO1xcclxcbiAgICAgKi9cXHJcXG4gICAgdG9Qb2ludCgpIHtcXHJcXG4gICAgICAgIHJldHVybiBfdXRpbHNfcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiUG9pbnRcXFwiXS5jcmVhdGVCeVJHQkEodGhpcy5yID4+IG5ldHdvcmtCaWFzU2hpZnQsIHRoaXMuZyA+PiBuZXR3b3JrQmlhc1NoaWZ0LCB0aGlzLmIgPj4gbmV0d29ya0JpYXNTaGlmdCwgdGhpcy5hID4+IG5ldHdvcmtCaWFzU2hpZnQpO1xcclxcbiAgICB9XFxyXFxuICAgIHN1YnRyYWN0KHIsIGcsIGIsIGEpIHtcXHJcXG4gICAgICAgIHRoaXMuciAtPSByIHwgMDtcXHJcXG4gICAgICAgIHRoaXMuZyAtPSBnIHwgMDtcXHJcXG4gICAgICAgIHRoaXMuYiAtPSBiIHwgMDtcXHJcXG4gICAgICAgIHRoaXMuYSAtPSBhIHwgMDtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5jbGFzcyBOZXVRdWFudCBleHRlbmRzIF9wYWxldHRlUXVhbnRpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkFic3RyYWN0UGFsZXR0ZVF1YW50aXplclxcXCJdIHtcXHJcXG4gICAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyA9IDI1Nikge1xcclxcbiAgICAgICAgc3VwZXIoKTtcXHJcXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XFxyXFxuICAgICAgICB0aGlzLl9wb2ludEFycmF5ID0gW107XFxyXFxuICAgICAgICB0aGlzLl9zYW1wbGVGYWN0b3IgPSAxO1xcclxcbiAgICAgICAgdGhpcy5fbmV0d29ya1NpemUgPSBjb2xvcnM7XFxyXFxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zZXRXaGl0ZVBvaW50KDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0LCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0KTtcXHJcXG4gICAgfVxcclxcbiAgICBzYW1wbGUocG9pbnRDb250YWluZXIpIHtcXHJcXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkgPSB0aGlzLl9wb2ludEFycmF5LmNvbmNhdChwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCkpO1xcclxcbiAgICB9XFxyXFxuICAgICpxdWFudGl6ZSgpIHtcXHJcXG4gICAgICAgIHRoaXMuX2luaXQoKTtcXHJcXG4gICAgICAgIHlpZWxkKiB0aGlzLl9sZWFybigpO1xcclxcbiAgICAgICAgeWllbGQge1xcclxcbiAgICAgICAgICAgIHBhbGV0dGU6IHRoaXMuX2J1aWxkUGFsZXR0ZSgpLFxcclxcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuICAgIF9pbml0KCkge1xcclxcbiAgICAgICAgdGhpcy5fZnJlcSA9IFtdO1xcclxcbiAgICAgICAgdGhpcy5fYmlhcyA9IFtdO1xcclxcbiAgICAgICAgdGhpcy5fcmFkUG93ZXIgPSBbXTtcXHJcXG4gICAgICAgIHRoaXMuX25ldHdvcmsgPSBbXTtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xcclxcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtbaV0gPSBuZXcgTmV1cm9uKChpIDw8IChuZXR3b3JrQmlhc1NoaWZ0ICsgOCkpIC8gdGhpcy5fbmV0d29ya1NpemUgfCAwKTtcXHJcXG4gICAgICAgICAgICAvLyAxL3RoaXMuX25ldHdvcmtTaXplXFxyXFxuICAgICAgICAgICAgdGhpcy5fZnJlcVtpXSA9IE5ldVF1YW50Ll9pbml0aWFsQmlhcyAvIHRoaXMuX25ldHdvcmtTaXplIHwgMDtcXHJcXG4gICAgICAgICAgICB0aGlzLl9iaWFzW2ldID0gMDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogTWFpbiBMZWFybmluZyBMb29wXFxyXFxuICAgICAqL1xcclxcbiAgICAqX2xlYXJuKCkge1xcclxcbiAgICAgICAgbGV0IHNhbXBsZUZhY3RvciA9IHRoaXMuX3NhbXBsZUZhY3RvcjtcXHJcXG4gICAgICAgIGNvbnN0IHBvaW50c051bWJlciA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xcclxcbiAgICAgICAgaWYgKHBvaW50c051bWJlciA8IE5ldVF1YW50Ll9taW5waWN0dXJlYnl0ZXMpXFxyXFxuICAgICAgICAgICAgc2FtcGxlRmFjdG9yID0gMTtcXHJcXG4gICAgICAgIGNvbnN0IGFscGhhZGVjID0gMzAgKyAoc2FtcGxlRmFjdG9yIC0gMSkgLyAzIHwgMDtcXHJcXG4gICAgICAgIGNvbnN0IHBvaW50c1RvU2FtcGxlID0gcG9pbnRzTnVtYmVyIC8gc2FtcGxlRmFjdG9yIHwgMDtcXHJcXG4gICAgICAgIGxldCBkZWx0YSA9IHBvaW50c1RvU2FtcGxlIC8gTmV1UXVhbnQuX25DeWNsZXMgfCAwO1xcclxcbiAgICAgICAgbGV0IGFscGhhID0gTmV1UXVhbnQuX2luaXRBbHBoYTtcXHJcXG4gICAgICAgIGxldCByYWRpdXMgPSAodGhpcy5fbmV0d29ya1NpemUgPj4gMykgKiBOZXVRdWFudC5fcmFkaXVzQmlhcztcXHJcXG4gICAgICAgIGxldCByYWQgPSByYWRpdXMgPj4gTmV1UXVhbnQuX3JhZGl1c0JpYXNTaGlmdDtcXHJcXG4gICAgICAgIGlmIChyYWQgPD0gMSlcXHJcXG4gICAgICAgICAgICByYWQgPSAwO1xcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYWQ7IGkrKykge1xcclxcbiAgICAgICAgICAgIHRoaXMuX3JhZFBvd2VyW2ldID0gYWxwaGEgKiAoKChyYWQgKiByYWQgLSBpICogaSkgKiBOZXVRdWFudC5fcmFkQmlhcykgLyAocmFkICogcmFkKSkgPj4+IDA7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBsZXQgc3RlcDtcXHJcXG4gICAgICAgIGlmIChwb2ludHNOdW1iZXIgPCBOZXVRdWFudC5fbWlucGljdHVyZWJ5dGVzKSB7XFxyXFxuICAgICAgICAgICAgc3RlcCA9IDE7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBlbHNlIGlmIChwb2ludHNOdW1iZXIgJSBOZXVRdWFudC5fcHJpbWUxICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgc3RlcCA9IE5ldVF1YW50Ll9wcmltZTE7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBlbHNlIGlmICgocG9pbnRzTnVtYmVyICUgTmV1UXVhbnQuX3ByaW1lMikgIT09IDApIHtcXHJcXG4gICAgICAgICAgICBzdGVwID0gTmV1UXVhbnQuX3ByaW1lMjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGVsc2UgaWYgKChwb2ludHNOdW1iZXIgJSBOZXVRdWFudC5fcHJpbWUzKSAhPT0gMCkge1xcclxcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudC5fcHJpbWUzO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgc3RlcCA9IE5ldVF1YW50Ll9wcmltZTQ7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjb25zdCB0cmFja2VyID0gbmV3IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJQcm9ncmVzc1RyYWNrZXJcXFwiXShwb2ludHNUb1NhbXBsZSwgOTkpO1xcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvaW50SW5kZXggPSAwOyBpIDwgcG9pbnRzVG9TYW1wbGU7KSB7XFxyXFxuICAgICAgICAgICAgaWYgKHRyYWNrZXIuc2hvdWxkTm90aWZ5KGkpKSB7XFxyXFxuICAgICAgICAgICAgICAgIHlpZWxkIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzLFxcclxcbiAgICAgICAgICAgICAgICB9O1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX3BvaW50QXJyYXlbcG9pbnRJbmRleF07XFxyXFxuICAgICAgICAgICAgY29uc3QgYiA9IHBvaW50LmIgPDwgbmV0d29ya0JpYXNTaGlmdDtcXHJcXG4gICAgICAgICAgICBjb25zdCBnID0gcG9pbnQuZyA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xcclxcbiAgICAgICAgICAgIGNvbnN0IHIgPSBwb2ludC5yIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XFxyXFxuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LmEgPDwgbmV0d29ya0JpYXNTaGlmdDtcXHJcXG4gICAgICAgICAgICBjb25zdCBuZXVyb25JbmRleCA9IHRoaXMuX2NvbnRlc3QoYiwgZywgciwgYSk7XFxyXFxuICAgICAgICAgICAgdGhpcy5fYWx0ZXJTaW5nbGUoYWxwaGEsIG5ldXJvbkluZGV4LCBiLCBnLCByLCBhKTtcXHJcXG4gICAgICAgICAgICBpZiAocmFkICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICB0aGlzLl9hbHRlck5laWdoYm91cihyYWQsIG5ldXJvbkluZGV4LCBiLCBnLCByLCBhKTtcXHJcXG4gICAgICAgICAgICAvKiBhbHRlciBuZWlnaGJvdXJzICovXFxyXFxuICAgICAgICAgICAgcG9pbnRJbmRleCArPSBzdGVwO1xcclxcbiAgICAgICAgICAgIGlmIChwb2ludEluZGV4ID49IHBvaW50c051bWJlcilcXHJcXG4gICAgICAgICAgICAgICAgcG9pbnRJbmRleCAtPSBwb2ludHNOdW1iZXI7XFxyXFxuICAgICAgICAgICAgaSsrO1xcclxcbiAgICAgICAgICAgIGlmIChkZWx0YSA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAxO1xcclxcbiAgICAgICAgICAgIGlmIChpICUgZGVsdGEgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgYWxwaGEgLT0gKGFscGhhIC8gYWxwaGFkZWMpIHwgMDtcXHJcXG4gICAgICAgICAgICAgICAgcmFkaXVzIC09IChyYWRpdXMgLyBOZXVRdWFudC5fcmFkaXVzRGVjcmVhc2UpIHwgMDtcXHJcXG4gICAgICAgICAgICAgICAgcmFkID0gcmFkaXVzID4+IE5ldVF1YW50Ll9yYWRpdXNCaWFzU2hpZnQ7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChyYWQgPD0gMSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJhZCA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFkOyBqKyspXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYWRQb3dlcltqXSA9IGFscGhhICogKCgocmFkICogcmFkIC0gaiAqIGopICogTmV1UXVhbnQuX3JhZEJpYXMpIC8gKHJhZCAqIHJhZCkpID4+PiAwO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBfYnVpbGRQYWxldHRlKCkge1xcclxcbiAgICAgICAgY29uc3QgcGFsZXR0ZSA9IG5ldyBfdXRpbHNfcGFsZXR0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJQYWxldHRlXFxcIl0oKTtcXHJcXG4gICAgICAgIHRoaXMuX25ldHdvcmsuZm9yRWFjaChuZXVyb24gPT4ge1xcclxcbiAgICAgICAgICAgIHBhbGV0dGUuYWRkKG5ldXJvbi50b1BvaW50KCkpO1xcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgICBwYWxldHRlLnNvcnQoKTtcXHJcXG4gICAgICAgIHJldHVybiBwYWxldHRlO1xcclxcbiAgICB9XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBNb3ZlIGFkamFjZW50IG5ldXJvbnMgYnkgcHJlY29tcHV0ZWQgYWxwaGEqKDEtKChpLWopXjIvW3JdXjIpKSBpbiByYWRwb3dlclt8aS1qfF1cXHJcXG4gICAgICovXFxyXFxuICAgIF9hbHRlck5laWdoYm91cihyYWQsIGksIGIsIGcsIHIsIGFsKSB7XFxyXFxuICAgICAgICBsZXQgbG8gPSBpIC0gcmFkO1xcclxcbiAgICAgICAgaWYgKGxvIDwgLTEpXFxyXFxuICAgICAgICAgICAgbG8gPSAtMTtcXHJcXG4gICAgICAgIGxldCBoaSA9IGkgKyByYWQ7XFxyXFxuICAgICAgICBpZiAoaGkgPiB0aGlzLl9uZXR3b3JrU2l6ZSlcXHJcXG4gICAgICAgICAgICBoaSA9IHRoaXMuX25ldHdvcmtTaXplO1xcclxcbiAgICAgICAgbGV0IGogPSBpICsgMTtcXHJcXG4gICAgICAgIGxldCBrID0gaSAtIDE7XFxyXFxuICAgICAgICBsZXQgbSA9IDE7XFxyXFxuICAgICAgICB3aGlsZSAoaiA8IGhpIHx8IGsgPiBsbykge1xcclxcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLl9yYWRQb3dlclttKytdIC8gTmV1UXVhbnQuX2FscGhhUmFkQmlhcztcXHJcXG4gICAgICAgICAgICBpZiAoaiA8IGhpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9uZXR3b3JrW2orK107XFxyXFxuICAgICAgICAgICAgICAgIHAuc3VidHJhY3QoYSAqIChwLnIgLSByKSwgYSAqIChwLmcgLSBnKSwgYSAqIChwLmIgLSBiKSwgYSAqIChwLmEgLSBhbCkpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBpZiAoayA+IGxvKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9uZXR3b3JrW2stLV07XFxyXFxuICAgICAgICAgICAgICAgIHAuc3VidHJhY3QoYSAqIChwLnIgLSByKSwgYSAqIChwLmcgLSBnKSwgYSAqIChwLmIgLSBiKSwgYSAqIChwLmEgLSBhbCkpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogTW92ZSBuZXVyb24gaSB0b3dhcmRzIGJpYXNlZCAoYixnLHIpIGJ5IGZhY3RvciBhbHBoYVxcclxcbiAgICAgKi9cXHJcXG4gICAgX2FsdGVyU2luZ2xlKGFscGhhLCBpLCBiLCBnLCByLCBhKSB7XFxyXFxuICAgICAgICBhbHBoYSAvPSBOZXVRdWFudC5faW5pdEFscGhhO1xcclxcbiAgICAgICAgLyogYWx0ZXIgaGl0IG5ldXJvbiAqL1xcclxcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XFxyXFxuICAgICAgICBuLnN1YnRyYWN0KGFscGhhICogKG4uciAtIHIpLCBhbHBoYSAqIChuLmcgLSBnKSwgYWxwaGEgKiAobi5iIC0gYiksIGFscGhhICogKG4uYSAtIGEpKTtcXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogU2VhcmNoIGZvciBiaWFzZWQgQkdSIHZhbHVlc1xcclxcbiAgICAgKiBkZXNjcmlwdGlvbjpcXHJcXG4gICAgICogICAgZmluZHMgY2xvc2VzdCBuZXVyb24gKG1pbiBkaXN0KSBhbmQgdXBkYXRlcyBmcmVxXFxyXFxuICAgICAqICAgIGZpbmRzIGJlc3QgbmV1cm9uIChtaW4gZGlzdC1iaWFzKSBhbmQgcmV0dXJucyBwb3NpdGlvblxcclxcbiAgICAgKiAgICBmb3IgZnJlcXVlbnRseSBjaG9zZW4gbmV1cm9ucywgZnJlcVtpXSBpcyBoaWdoIGFuZCBiaWFzW2ldIGlzIG5lZ2F0aXZlXFxyXFxuICAgICAqICAgIGJpYXNbaV0gPSBfZ2FtbWEqKCgxL3RoaXMuX25ldHdvcmtTaXplKS1mcmVxW2ldKVxcclxcbiAgICAgKlxcclxcbiAgICAgKiBPcmlnaW5hbCBkaXN0YW5jZSBlcXVhdGlvbjpcXHJcXG4gICAgICogICAgICAgIGRpc3QgPSBhYnMoZFIpICsgYWJzKGRHKSArIGFicyhkQilcXHJcXG4gICAgICovXFxyXFxuICAgIF9jb250ZXN0KGIsIGcsIHIsIGEpIHtcXHJcXG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSAoMjU1ICogNCkgPDwgbmV0d29ya0JpYXNTaGlmdDtcXHJcXG4gICAgICAgIGxldCBiZXN0ZCA9IH4oMSA8PCAzMSk7XFxyXFxuICAgICAgICBsZXQgYmVzdGJpYXNkID0gYmVzdGQ7XFxyXFxuICAgICAgICBsZXQgYmVzdHBvcyA9IC0xO1xcclxcbiAgICAgICAgbGV0IGJlc3RiaWFzcG9zID0gYmVzdHBvcztcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xcclxcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLl9uZXR3b3JrW2ldO1xcclxcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLl9kaXN0YW5jZS5jYWxjdWxhdGVOb3JtYWxpemVkKG4sIHsgciwgZywgYiwgYSB9KSAqIG11bHRpcGxpZXIgfCAwO1xcclxcbiAgICAgICAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcXHJcXG4gICAgICAgICAgICAgICAgYmVzdGQgPSBkaXN0O1xcclxcbiAgICAgICAgICAgICAgICBiZXN0cG9zID0gaTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgY29uc3QgYmlhc2Rpc3QgPSBkaXN0IC0gKCh0aGlzLl9iaWFzW2ldKSA+PiAoTmV1UXVhbnQuX2luaXRpYWxCaWFzU2hpZnQgLSBuZXR3b3JrQmlhc1NoaWZ0KSk7XFxyXFxuICAgICAgICAgICAgaWYgKGJpYXNkaXN0IDwgYmVzdGJpYXNkKSB7XFxyXFxuICAgICAgICAgICAgICAgIGJlc3RiaWFzZCA9IGJpYXNkaXN0O1xcclxcbiAgICAgICAgICAgICAgICBiZXN0Ymlhc3BvcyA9IGk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGNvbnN0IGJldGFmcmVxID0gKHRoaXMuX2ZyZXFbaV0gPj4gTmV1UXVhbnQuX2JldGFTaGlmdCk7XFxyXFxuICAgICAgICAgICAgdGhpcy5fZnJlcVtpXSAtPSBiZXRhZnJlcTtcXHJcXG4gICAgICAgICAgICB0aGlzLl9iaWFzW2ldICs9IChiZXRhZnJlcSA8PCBOZXVRdWFudC5fZ2FtbWFTaGlmdCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB0aGlzLl9mcmVxW2Jlc3Rwb3NdICs9IE5ldVF1YW50Ll9iZXRhO1xcclxcbiAgICAgICAgdGhpcy5fYmlhc1tiZXN0cG9zXSAtPSBOZXVRdWFudC5fYmV0YUdhbW1hO1xcclxcbiAgICAgICAgcmV0dXJuIGJlc3RiaWFzcG9zO1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8qXFxyXFxuIGZvdXIgcHJpbWVzIG5lYXIgNTAwIC0gYXNzdW1lIG5vIGltYWdlIGhhcyBhIGxlbmd0aCBzbyBsYXJnZVxcclxcbiB0aGF0IGl0IGlzIGRpdmlzaWJsZSBieSBhbGwgZm91ciBwcmltZXNcXHJcXG4gKi9cXHJcXG5OZXVRdWFudC5fcHJpbWUxID0gNDk5O1xcclxcbk5ldVF1YW50Ll9wcmltZTIgPSA0OTE7XFxyXFxuTmV1UXVhbnQuX3ByaW1lMyA9IDQ4NztcXHJcXG5OZXVRdWFudC5fcHJpbWU0ID0gNTAzO1xcclxcbk5ldVF1YW50Ll9taW5waWN0dXJlYnl0ZXMgPSBOZXVRdWFudC5fcHJpbWU0O1xcclxcbi8vIG5vLiBvZiBsZWFybmluZyBjeWNsZXNcXHJcXG5OZXVRdWFudC5fbkN5Y2xlcyA9IDEwMDtcXHJcXG4vLyBkZWZzIGZvciBmcmVxIGFuZCBiaWFzXFxyXFxuTmV1UXVhbnQuX2luaXRpYWxCaWFzU2hpZnQgPSAxNjtcXHJcXG4vLyBiaWFzIGZvciBmcmFjdGlvbnNcXHJcXG5OZXVRdWFudC5faW5pdGlhbEJpYXMgPSAoMSA8PCBOZXVRdWFudC5faW5pdGlhbEJpYXNTaGlmdCk7XFxyXFxuTmV1UXVhbnQuX2dhbW1hU2hpZnQgPSAxMDtcXHJcXG4vLyBnYW1tYSA9IDEwMjRcXHJcXG4vLyBUT0RPOiB3aHkgZ2FtbWEgaXMgbmV2ZXIgdXNlZD9cXHJcXG4vLyBwcml2YXRlIHN0YXRpYyBfZ2FtbWEgOiBudW1iZXIgICAgID0gKDEgPDwgTmV1UXVhbnQuX2dhbW1hU2hpZnQpO1xcclxcbk5ldVF1YW50Ll9iZXRhU2hpZnQgPSAxMDtcXHJcXG5OZXVRdWFudC5fYmV0YSA9IChOZXVRdWFudC5faW5pdGlhbEJpYXMgPj4gTmV1UXVhbnQuX2JldGFTaGlmdCk7XFxyXFxuLy8gYmV0YSA9IDEvMTAyNFxcclxcbk5ldVF1YW50Ll9iZXRhR2FtbWEgPSAoTmV1UXVhbnQuX2luaXRpYWxCaWFzIDw8IChOZXVRdWFudC5fZ2FtbWFTaGlmdCAtIE5ldVF1YW50Ll9iZXRhU2hpZnQpKTtcXHJcXG4vKlxcclxcbiAqIGZvciAyNTYgY29scywgcmFkaXVzIHN0YXJ0c1xcclxcbiAqL1xcclxcbk5ldVF1YW50Ll9yYWRpdXNCaWFzU2hpZnQgPSA2O1xcclxcbi8vIGF0IDMyLjAgYmlhc2VkIGJ5IDYgYml0c1xcclxcbk5ldVF1YW50Ll9yYWRpdXNCaWFzID0gMSA8PCBOZXVRdWFudC5fcmFkaXVzQmlhc1NoaWZ0O1xcclxcbi8vIGFuZCBkZWNyZWFzZXMgYnkgYSBmYWN0b3Igb2YgMS8zMCBlYWNoIGN5Y2xlXFxyXFxuTmV1UXVhbnQuX3JhZGl1c0RlY3JlYXNlID0gMzA7XFxyXFxuLyogZGVmcyBmb3IgZGVjcmVhc2luZyBhbHBoYSBmYWN0b3IgKi9cXHJcXG4vLyBhbHBoYSBzdGFydHMgYXQgMS4wXFxyXFxuTmV1UXVhbnQuX2FscGhhQmlhc1NoaWZ0ID0gMTA7XFxyXFxuLy8gYmlhc2VkIGJ5IDEwIGJpdHNcXHJcXG5OZXVRdWFudC5faW5pdEFscGhhID0gKDEgPDwgTmV1UXVhbnQuX2FscGhhQmlhc1NoaWZ0KTtcXHJcXG4vKiByYWRCaWFzIGFuZCBhbHBoYVJhZEJpYXMgdXNlZCBmb3IgcmFkcG93ZXIgY2FsY3VsYXRpb24gKi9cXHJcXG5OZXVRdWFudC5fcmFkQmlhc1NoaWZ0ID0gODtcXHJcXG5OZXVRdWFudC5fcmFkQmlhcyA9IDEgPDwgTmV1UXVhbnQuX3JhZEJpYXNTaGlmdDtcXHJcXG5OZXVRdWFudC5fYWxwaGFSYWRCaWFzU2hpZnQgPSBOZXVRdWFudC5fYWxwaGFCaWFzU2hpZnQgKyBOZXVRdWFudC5fcmFkQmlhc1NoaWZ0O1xcclxcbk5ldVF1YW50Ll9hbHBoYVJhZEJpYXMgPSAxIDw8IE5ldVF1YW50Ll9hbHBoYVJhZEJpYXNTaGlmdDtcXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXVxdWFudC5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL25ldXF1YW50L25ldXF1YW50RmxvYXQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL25ldXF1YW50L25ldXF1YW50RmxvYXQuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IE5ldVF1YW50RmxvYXQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJOZXVRdWFudEZsb2F0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBOZXVRdWFudEZsb2F0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3BhbGV0dGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL3BhbGV0dGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcGFsZXR0ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL3BvaW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BvaW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wYWxldHRlUXVhbnRpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9wYWxldHRlUXVhbnRpemVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvcGFsZXR0ZVF1YW50aXplci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuLypcXHJcXG4gKiBOZXVRdWFudEZsb2F0IE5ldXJhbC1OZXQgUXVhbnRpemF0aW9uIEFsZ29yaXRobVxcclxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcclxcbiAqXFxyXFxuICogQ29weXJpZ2h0IChjKSAxOTk0IEFudGhvbnkgRGVra2VyXFxyXFxuICpcXHJcXG4gKiBORVVRVUFOVCBOZXVyYWwtTmV0IHF1YW50aXphdGlvbiBhbGdvcml0aG0gYnkgQW50aG9ueSBEZWtrZXIsIDE5OTQuIFNlZVxcclxcbiAqIFxcXCJLb2hvbmVuIG5ldXJhbCBuZXR3b3JrcyBmb3Igb3B0aW1hbCBjb2xvdXIgcXVhbnRpemF0aW9uXFxcIiBpbiBcXFwiTmV0d29yazpcXHJcXG4gKiBDb21wdXRhdGlvbiBpbiBOZXVyYWwgU3lzdGVtc1xcXCIgVm9sLiA1ICgxOTk0KSBwcCAzNTEtMzY3LiBmb3IgYSBkaXNjdXNzaW9uIG9mXFxyXFxuICogdGhlIGFsZ29yaXRobS5cXHJcXG4gKlxcclxcbiAqIEFueSBwYXJ0eSBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoZXNlIGZpbGVzIGZyb20gdGhlIGF1dGhvciwgZGlyZWN0bHkgb3JcXHJcXG4gKiBpbmRpcmVjdGx5LCBpcyBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgYSBmdWxsIGFuZCB1bnJlc3RyaWN0ZWQgaXJyZXZvY2FibGUsXFxyXFxuICogd29ybGQtd2lkZSwgcGFpZCB1cCwgcm95YWx0eS1mcmVlLCBub25leGNsdXNpdmUgcmlnaHQgYW5kIGxpY2Vuc2UgdG8gZGVhbCBpblxcclxcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcXFwiU29mdHdhcmVcXFwiKSwgaW5jbHVkaW5nIHdpdGhvdXRcXHJcXG4gKiBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLFxcclxcbiAqIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB3aG9cXHJcXG4gKiByZWNlaXZlIGNvcGllcyBmcm9tIGFueSBzdWNoIHBhcnR5IHRvIGRvIHNvLCB3aXRoIHRoZSBvbmx5IHJlcXVpcmVtZW50IGJlaW5nXFxyXFxuICogdGhhdCB0aGlzIGNvcHlyaWdodCBub3RpY2UgcmVtYWluIGludGFjdC5cXHJcXG4gKi9cXHJcXG4vKipcXHJcXG4gKiBAcHJlc2VydmUgVHlwZVNjcmlwdCBwb3J0OlxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIG5ldXF1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcblxcclxcblxcclxcblxcclxcbi8vIGJpYXMgZm9yIGNvbG91ciB2YWx1ZXNcXHJcXG5jb25zdCBuZXR3b3JrQmlhc1NoaWZ0ID0gMztcXHJcXG5jbGFzcyBOZXVyb25GbG9hdCB7XFxyXFxuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSkge1xcclxcbiAgICAgICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gdGhpcy5hID0gZGVmYXVsdFZhbHVlO1xcclxcbiAgICB9XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBUaGVyZSBpcyBhIGZpeCBpbiBvcmlnaW5hbCBORVVRVUFOVCBieSBBbnRob255IERla2tlciAoaHR0cDovL21lbWJlcnMub3plbWFpbC5jb20uYXUvfmRla2tlci9ORVVRVUFOVC5IVE1MKVxcclxcbiAgICAgKiBAZXhhbXBsZVxcclxcbiAgICAgKiByID0gTWF0aC5taW4oMjU1LCAobmV1cm9uLnIgKyAoMSA8PCAobmV0d29ya0JpYXNTaGlmdCAtIDEpKSkgPj4gbmV0d29ya0JpYXNTaGlmdCk7XFxyXFxuICAgICAqL1xcclxcbiAgICB0b1BvaW50KCkge1xcclxcbiAgICAgICAgcmV0dXJuIF91dGlsc19wb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJQb2ludFxcXCJdLmNyZWF0ZUJ5UkdCQSh0aGlzLnIgPj4gbmV0d29ya0JpYXNTaGlmdCwgdGhpcy5nID4+IG5ldHdvcmtCaWFzU2hpZnQsIHRoaXMuYiA+PiBuZXR3b3JrQmlhc1NoaWZ0LCB0aGlzLmEgPj4gbmV0d29ya0JpYXNTaGlmdCk7XFxyXFxuICAgIH1cXHJcXG4gICAgc3VidHJhY3QociwgZywgYiwgYSkge1xcclxcbiAgICAgICAgdGhpcy5yIC09IHI7XFxyXFxuICAgICAgICB0aGlzLmcgLT0gZztcXHJcXG4gICAgICAgIHRoaXMuYiAtPSBiO1xcclxcbiAgICAgICAgdGhpcy5hIC09IGE7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuY2xhc3MgTmV1UXVhbnRGbG9hdCBleHRlbmRzIF9wYWxldHRlUXVhbnRpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkFic3RyYWN0UGFsZXR0ZVF1YW50aXplclxcXCJdIHtcXHJcXG4gICAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyA9IDI1Nikge1xcclxcbiAgICAgICAgc3VwZXIoKTtcXHJcXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XFxyXFxuICAgICAgICB0aGlzLl9wb2ludEFycmF5ID0gW107XFxyXFxuICAgICAgICB0aGlzLl9zYW1wbGVGYWN0b3IgPSAxO1xcclxcbiAgICAgICAgdGhpcy5fbmV0d29ya1NpemUgPSBjb2xvcnM7XFxyXFxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zZXRXaGl0ZVBvaW50KDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0LCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0KTtcXHJcXG4gICAgfVxcclxcbiAgICBzYW1wbGUocG9pbnRDb250YWluZXIpIHtcXHJcXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkgPSB0aGlzLl9wb2ludEFycmF5LmNvbmNhdChwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCkpO1xcclxcbiAgICB9XFxyXFxuICAgICpxdWFudGl6ZSgpIHtcXHJcXG4gICAgICAgIHRoaXMuX2luaXQoKTtcXHJcXG4gICAgICAgIHlpZWxkKiB0aGlzLl9sZWFybigpO1xcclxcbiAgICAgICAgeWllbGQge1xcclxcbiAgICAgICAgICAgIHBhbGV0dGU6IHRoaXMuX2J1aWxkUGFsZXR0ZSgpLFxcclxcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuICAgIF9pbml0KCkge1xcclxcbiAgICAgICAgdGhpcy5fZnJlcSA9IFtdO1xcclxcbiAgICAgICAgdGhpcy5fYmlhcyA9IFtdO1xcclxcbiAgICAgICAgdGhpcy5fcmFkUG93ZXIgPSBbXTtcXHJcXG4gICAgICAgIHRoaXMuX25ldHdvcmsgPSBbXTtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xcclxcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtbaV0gPSBuZXcgTmV1cm9uRmxvYXQoKGkgPDwgKG5ldHdvcmtCaWFzU2hpZnQgKyA4KSkgLyB0aGlzLl9uZXR3b3JrU2l6ZSk7XFxyXFxuICAgICAgICAgICAgLy8gMS90aGlzLl9uZXR3b3JrU2l6ZVxcclxcbiAgICAgICAgICAgIHRoaXMuX2ZyZXFbaV0gPSBOZXVRdWFudEZsb2F0Ll9pbml0aWFsQmlhcyAvIHRoaXMuX25ldHdvcmtTaXplO1xcclxcbiAgICAgICAgICAgIHRoaXMuX2JpYXNbaV0gPSAwO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBNYWluIExlYXJuaW5nIExvb3BcXHJcXG4gICAgICovXFxyXFxuICAgICpfbGVhcm4oKSB7XFxyXFxuICAgICAgICBsZXQgc2FtcGxlRmFjdG9yID0gdGhpcy5fc2FtcGxlRmFjdG9yO1xcclxcbiAgICAgICAgY29uc3QgcG9pbnRzTnVtYmVyID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7XFxyXFxuICAgICAgICBpZiAocG9pbnRzTnVtYmVyIDwgTmV1UXVhbnRGbG9hdC5fbWlucGljdHVyZWJ5dGVzKVxcclxcbiAgICAgICAgICAgIHNhbXBsZUZhY3RvciA9IDE7XFxyXFxuICAgICAgICBjb25zdCBhbHBoYWRlYyA9IDMwICsgKHNhbXBsZUZhY3RvciAtIDEpIC8gMztcXHJcXG4gICAgICAgIGNvbnN0IHBvaW50c1RvU2FtcGxlID0gcG9pbnRzTnVtYmVyIC8gc2FtcGxlRmFjdG9yO1xcclxcbiAgICAgICAgbGV0IGRlbHRhID0gcG9pbnRzVG9TYW1wbGUgLyBOZXVRdWFudEZsb2F0Ll9uQ3ljbGVzIHwgMDtcXHJcXG4gICAgICAgIGxldCBhbHBoYSA9IE5ldVF1YW50RmxvYXQuX2luaXRBbHBoYTtcXHJcXG4gICAgICAgIGxldCByYWRpdXMgPSAodGhpcy5fbmV0d29ya1NpemUgPj4gMykgKiBOZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzO1xcclxcbiAgICAgICAgbGV0IHJhZCA9IHJhZGl1cyA+PiBOZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzU2hpZnQ7XFxyXFxuICAgICAgICBpZiAocmFkIDw9IDEpXFxyXFxuICAgICAgICAgICAgcmFkID0gMDtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFkOyBpKyspIHtcXHJcXG4gICAgICAgICAgICB0aGlzLl9yYWRQb3dlcltpXSA9IGFscGhhICogKCgocmFkICogcmFkIC0gaSAqIGkpICogTmV1UXVhbnRGbG9hdC5fcmFkQmlhcykgLyAocmFkICogcmFkKSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBsZXQgc3RlcDtcXHJcXG4gICAgICAgIGlmIChwb2ludHNOdW1iZXIgPCBOZXVRdWFudEZsb2F0Ll9taW5waWN0dXJlYnl0ZXMpIHtcXHJcXG4gICAgICAgICAgICBzdGVwID0gMTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGVsc2UgaWYgKHBvaW50c051bWJlciAlIE5ldVF1YW50RmxvYXQuX3ByaW1lMSAhPT0gMCkge1xcclxcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudEZsb2F0Ll9wcmltZTE7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBlbHNlIGlmICgocG9pbnRzTnVtYmVyICUgTmV1UXVhbnRGbG9hdC5fcHJpbWUyKSAhPT0gMCkge1xcclxcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudEZsb2F0Ll9wcmltZTI7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBlbHNlIGlmICgocG9pbnRzTnVtYmVyICUgTmV1UXVhbnRGbG9hdC5fcHJpbWUzKSAhPT0gMCkge1xcclxcbiAgICAgICAgICAgIHN0ZXAgPSBOZXVRdWFudEZsb2F0Ll9wcmltZTM7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBlbHNlIHtcXHJcXG4gICAgICAgICAgICBzdGVwID0gTmV1UXVhbnRGbG9hdC5fcHJpbWU0O1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IG5ldyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiUHJvZ3Jlc3NUcmFja2VyXFxcIl0ocG9pbnRzVG9TYW1wbGUsIDk5KTtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb2ludEluZGV4ID0gMDsgaSA8IHBvaW50c1RvU2FtcGxlOykge1xcclxcbiAgICAgICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeShpKSkge1xcclxcbiAgICAgICAgICAgICAgICB5aWVsZCB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzcyxcXHJcXG4gICAgICAgICAgICAgICAgfTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9wb2ludEFycmF5W3BvaW50SW5kZXhdO1xcclxcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwb2ludC5iIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XFxyXFxuICAgICAgICAgICAgY29uc3QgZyA9IHBvaW50LmcgPDwgbmV0d29ya0JpYXNTaGlmdDtcXHJcXG4gICAgICAgICAgICBjb25zdCByID0gcG9pbnQuciA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xcclxcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC5hIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XFxyXFxuICAgICAgICAgICAgY29uc3QgbmV1cm9uSW5kZXggPSB0aGlzLl9jb250ZXN0KGIsIGcsIHIsIGEpO1xcclxcbiAgICAgICAgICAgIHRoaXMuX2FsdGVyU2luZ2xlKGFscGhhLCBuZXVyb25JbmRleCwgYiwgZywgciwgYSk7XFxyXFxuICAgICAgICAgICAgaWYgKHJhZCAhPT0gMClcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5fYWx0ZXJOZWlnaGJvdXIocmFkLCBuZXVyb25JbmRleCwgYiwgZywgciwgYSk7XFxyXFxuICAgICAgICAgICAgLyogYWx0ZXIgbmVpZ2hib3VycyAqL1xcclxcbiAgICAgICAgICAgIHBvaW50SW5kZXggKz0gc3RlcDtcXHJcXG4gICAgICAgICAgICBpZiAocG9pbnRJbmRleCA+PSBwb2ludHNOdW1iZXIpXFxyXFxuICAgICAgICAgICAgICAgIHBvaW50SW5kZXggLT0gcG9pbnRzTnVtYmVyO1xcclxcbiAgICAgICAgICAgIGkrKztcXHJcXG4gICAgICAgICAgICBpZiAoZGVsdGEgPT09IDApXFxyXFxuICAgICAgICAgICAgICAgIGRlbHRhID0gMTtcXHJcXG4gICAgICAgICAgICBpZiAoaSAlIGRlbHRhID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGFscGhhIC09IChhbHBoYSAvIGFscGhhZGVjKTtcXHJcXG4gICAgICAgICAgICAgICAgcmFkaXVzIC09IChyYWRpdXMgLyBOZXVRdWFudEZsb2F0Ll9yYWRpdXNEZWNyZWFzZSk7XFxyXFxuICAgICAgICAgICAgICAgIHJhZCA9IHJhZGl1cyA+PiBOZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzU2hpZnQ7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChyYWQgPD0gMSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJhZCA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFkOyBqKyspXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYWRQb3dlcltqXSA9IGFscGhhICogKCgocmFkICogcmFkIC0gaiAqIGopICogTmV1UXVhbnRGbG9hdC5fcmFkQmlhcykgLyAocmFkICogcmFkKSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIF9idWlsZFBhbGV0dGUoKSB7XFxyXFxuICAgICAgICBjb25zdCBwYWxldHRlID0gbmV3IF91dGlsc19wYWxldHRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIlBhbGV0dGVcXFwiXSgpO1xcclxcbiAgICAgICAgdGhpcy5fbmV0d29yay5mb3JFYWNoKG5ldXJvbiA9PiB7XFxyXFxuICAgICAgICAgICAgcGFsZXR0ZS5hZGQobmV1cm9uLnRvUG9pbnQoKSk7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICAgIHBhbGV0dGUuc29ydCgpO1xcclxcbiAgICAgICAgcmV0dXJuIHBhbGV0dGU7XFxyXFxuICAgIH1cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIE1vdmUgYWRqYWNlbnQgbmV1cm9ucyBieSBwcmVjb21wdXRlZCBhbHBoYSooMS0oKGktaileMi9bcl1eMikpIGluIHJhZHBvd2VyW3xpLWp8XVxcclxcbiAgICAgKi9cXHJcXG4gICAgX2FsdGVyTmVpZ2hib3VyKHJhZCwgaSwgYiwgZywgciwgYWwpIHtcXHJcXG4gICAgICAgIGxldCBsbyA9IGkgLSByYWQ7XFxyXFxuICAgICAgICBpZiAobG8gPCAtMSlcXHJcXG4gICAgICAgICAgICBsbyA9IC0xO1xcclxcbiAgICAgICAgbGV0IGhpID0gaSArIHJhZDtcXHJcXG4gICAgICAgIGlmIChoaSA+IHRoaXMuX25ldHdvcmtTaXplKVxcclxcbiAgICAgICAgICAgIGhpID0gdGhpcy5fbmV0d29ya1NpemU7XFxyXFxuICAgICAgICBsZXQgaiA9IGkgKyAxO1xcclxcbiAgICAgICAgbGV0IGsgPSBpIC0gMTtcXHJcXG4gICAgICAgIGxldCBtID0gMTtcXHJcXG4gICAgICAgIHdoaWxlIChqIDwgaGkgfHwgayA+IGxvKSB7XFxyXFxuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuX3JhZFBvd2VyW20rK10gLyBOZXVRdWFudEZsb2F0Ll9hbHBoYVJhZEJpYXM7XFxyXFxuICAgICAgICAgICAgaWYgKGogPCBoaSkge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbmV0d29ya1tqKytdO1xcclxcbiAgICAgICAgICAgICAgICBwLnN1YnRyYWN0KGEgKiAocC5yIC0gciksIGEgKiAocC5nIC0gZyksIGEgKiAocC5iIC0gYiksIGEgKiAocC5hIC0gYWwpKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgaWYgKGsgPiBsbykge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbmV0d29ya1trLS1dO1xcclxcbiAgICAgICAgICAgICAgICBwLnN1YnRyYWN0KGEgKiAocC5yIC0gciksIGEgKiAocC5nIC0gZyksIGEgKiAocC5iIC0gYiksIGEgKiAocC5hIC0gYWwpKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIE1vdmUgbmV1cm9uIGkgdG93YXJkcyBiaWFzZWQgKGIsZyxyKSBieSBmYWN0b3IgYWxwaGFcXHJcXG4gICAgICovXFxyXFxuICAgIF9hbHRlclNpbmdsZShhbHBoYSwgaSwgYiwgZywgciwgYSkge1xcclxcbiAgICAgICAgYWxwaGEgLz0gTmV1UXVhbnRGbG9hdC5faW5pdEFscGhhO1xcclxcbiAgICAgICAgLyogYWx0ZXIgaGl0IG5ldXJvbiAqL1xcclxcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XFxyXFxuICAgICAgICBuLnN1YnRyYWN0KGFscGhhICogKG4uciAtIHIpLCBhbHBoYSAqIChuLmcgLSBnKSwgYWxwaGEgKiAobi5iIC0gYiksIGFscGhhICogKG4uYSAtIGEpKTtcXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogU2VhcmNoIGZvciBiaWFzZWQgQkdSIHZhbHVlc1xcclxcbiAgICAgKiBkZXNjcmlwdGlvbjpcXHJcXG4gICAgICogICAgZmluZHMgY2xvc2VzdCBuZXVyb24gKG1pbiBkaXN0KSBhbmQgdXBkYXRlcyBmcmVxXFxyXFxuICAgICAqICAgIGZpbmRzIGJlc3QgbmV1cm9uIChtaW4gZGlzdC1iaWFzKSBhbmQgcmV0dXJucyBwb3NpdGlvblxcclxcbiAgICAgKiAgICBmb3IgZnJlcXVlbnRseSBjaG9zZW4gbmV1cm9ucywgZnJlcVtpXSBpcyBoaWdoIGFuZCBiaWFzW2ldIGlzIG5lZ2F0aXZlXFxyXFxuICAgICAqICAgIGJpYXNbaV0gPSBfZ2FtbWEqKCgxL3RoaXMuX25ldHdvcmtTaXplKS1mcmVxW2ldKVxcclxcbiAgICAgKlxcclxcbiAgICAgKiBPcmlnaW5hbCBkaXN0YW5jZSBlcXVhdGlvbjpcXHJcXG4gICAgICogICAgICAgIGRpc3QgPSBhYnMoZFIpICsgYWJzKGRHKSArIGFicyhkQilcXHJcXG4gICAgICovXFxyXFxuICAgIF9jb250ZXN0KGIsIGcsIHIsIGFsKSB7XFxyXFxuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gKDI1NSAqIDQpIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XFxyXFxuICAgICAgICBsZXQgYmVzdGQgPSB+KDEgPDwgMzEpO1xcclxcbiAgICAgICAgbGV0IGJlc3RiaWFzZCA9IGJlc3RkO1xcclxcbiAgICAgICAgbGV0IGJlc3Rwb3MgPSAtMTtcXHJcXG4gICAgICAgIGxldCBiZXN0Ymlhc3BvcyA9IGJlc3Rwb3M7XFxyXFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25ldHdvcmtTaXplOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBjb25zdCBuID0gdGhpcy5fbmV0d29ya1tpXTtcXHJcXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlTm9ybWFsaXplZChuLCB7IHIsIGcsIGIsIGE6IGFsIH0pICogbXVsdGlwbGllcjtcXHJcXG4gICAgICAgICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XFxyXFxuICAgICAgICAgICAgICAgIGJlc3RkID0gZGlzdDtcXHJcXG4gICAgICAgICAgICAgICAgYmVzdHBvcyA9IGk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGNvbnN0IGJpYXNkaXN0ID0gZGlzdCAtICgodGhpcy5fYmlhc1tpXSkgPj4gKE5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzU2hpZnQgLSBuZXR3b3JrQmlhc1NoaWZ0KSk7XFxyXFxuICAgICAgICAgICAgaWYgKGJpYXNkaXN0IDwgYmVzdGJpYXNkKSB7XFxyXFxuICAgICAgICAgICAgICAgIGJlc3RiaWFzZCA9IGJpYXNkaXN0O1xcclxcbiAgICAgICAgICAgICAgICBiZXN0Ymlhc3BvcyA9IGk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGNvbnN0IGJldGFmcmVxID0gKHRoaXMuX2ZyZXFbaV0gPj4gTmV1UXVhbnRGbG9hdC5fYmV0YVNoaWZ0KTtcXHJcXG4gICAgICAgICAgICB0aGlzLl9mcmVxW2ldIC09IGJldGFmcmVxO1xcclxcbiAgICAgICAgICAgIHRoaXMuX2JpYXNbaV0gKz0gKGJldGFmcmVxIDw8IE5ldVF1YW50RmxvYXQuX2dhbW1hU2hpZnQpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdGhpcy5fZnJlcVtiZXN0cG9zXSArPSBOZXVRdWFudEZsb2F0Ll9iZXRhO1xcclxcbiAgICAgICAgdGhpcy5fYmlhc1tiZXN0cG9zXSAtPSBOZXVRdWFudEZsb2F0Ll9iZXRhR2FtbWE7XFxyXFxuICAgICAgICByZXR1cm4gYmVzdGJpYXNwb3M7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuLypcXHJcXG4gZm91ciBwcmltZXMgbmVhciA1MDAgLSBhc3N1bWUgbm8gaW1hZ2UgaGFzIGEgbGVuZ3RoIHNvIGxhcmdlXFxyXFxuIHRoYXQgaXQgaXMgZGl2aXNpYmxlIGJ5IGFsbCBmb3VyIHByaW1lc1xcclxcbiAqL1xcclxcbk5ldVF1YW50RmxvYXQuX3ByaW1lMSA9IDQ5OTtcXHJcXG5OZXVRdWFudEZsb2F0Ll9wcmltZTIgPSA0OTE7XFxyXFxuTmV1UXVhbnRGbG9hdC5fcHJpbWUzID0gNDg3O1xcclxcbk5ldVF1YW50RmxvYXQuX3ByaW1lNCA9IDUwMztcXHJcXG5OZXVRdWFudEZsb2F0Ll9taW5waWN0dXJlYnl0ZXMgPSBOZXVRdWFudEZsb2F0Ll9wcmltZTQ7XFxyXFxuLy8gbm8uIG9mIGxlYXJuaW5nIGN5Y2xlc1xcclxcbk5ldVF1YW50RmxvYXQuX25DeWNsZXMgPSAxMDA7XFxyXFxuLy8gZGVmcyBmb3IgZnJlcSBhbmQgYmlhc1xcclxcbk5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzU2hpZnQgPSAxNjtcXHJcXG4vLyBiaWFzIGZvciBmcmFjdGlvbnNcXHJcXG5OZXVRdWFudEZsb2F0Ll9pbml0aWFsQmlhcyA9ICgxIDw8IE5ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzU2hpZnQpO1xcclxcbk5ldVF1YW50RmxvYXQuX2dhbW1hU2hpZnQgPSAxMDtcXHJcXG4vLyBnYW1tYSA9IDEwMjRcXHJcXG4vLyBUT0RPOiB3aHkgZ2FtbWEgaXMgbmV2ZXIgdXNlZD9cXHJcXG4vLyBwcml2YXRlIHN0YXRpYyBfZ2FtbWEgOiBudW1iZXIgICAgID0gKDEgPDwgTmV1UXVhbnRGbG9hdC5fZ2FtbWFTaGlmdCk7XFxyXFxuTmV1UXVhbnRGbG9hdC5fYmV0YVNoaWZ0ID0gMTA7XFxyXFxuTmV1UXVhbnRGbG9hdC5fYmV0YSA9IChOZXVRdWFudEZsb2F0Ll9pbml0aWFsQmlhcyA+PiBOZXVRdWFudEZsb2F0Ll9iZXRhU2hpZnQpO1xcclxcbi8vIGJldGEgPSAxLzEwMjRcXHJcXG5OZXVRdWFudEZsb2F0Ll9iZXRhR2FtbWEgPSAoTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXMgPDwgKE5ldVF1YW50RmxvYXQuX2dhbW1hU2hpZnQgLSBOZXVRdWFudEZsb2F0Ll9iZXRhU2hpZnQpKTtcXHJcXG4vKlxcclxcbiAqIGZvciAyNTYgY29scywgcmFkaXVzIHN0YXJ0c1xcclxcbiAqL1xcclxcbk5ldVF1YW50RmxvYXQuX3JhZGl1c0JpYXNTaGlmdCA9IDY7XFxyXFxuLy8gYXQgMzIuMCBiaWFzZWQgYnkgNiBiaXRzXFxyXFxuTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhcyA9IDEgPDwgTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhc1NoaWZ0O1xcclxcbi8vIGFuZCBkZWNyZWFzZXMgYnkgYSBmYWN0b3Igb2YgMS8zMCBlYWNoIGN5Y2xlXFxyXFxuTmV1UXVhbnRGbG9hdC5fcmFkaXVzRGVjcmVhc2UgPSAzMDtcXHJcXG4vKiBkZWZzIGZvciBkZWNyZWFzaW5nIGFscGhhIGZhY3RvciAqL1xcclxcbi8vIGFscGhhIHN0YXJ0cyBhdCAxLjBcXHJcXG5OZXVRdWFudEZsb2F0Ll9hbHBoYUJpYXNTaGlmdCA9IDEwO1xcclxcbi8vIGJpYXNlZCBieSAxMCBiaXRzXFxyXFxuTmV1UXVhbnRGbG9hdC5faW5pdEFscGhhID0gKDEgPDwgTmV1UXVhbnRGbG9hdC5fYWxwaGFCaWFzU2hpZnQpO1xcclxcbi8qIHJhZEJpYXMgYW5kIGFscGhhUmFkQmlhcyB1c2VkIGZvciByYWRwb3dlciBjYWxjdWxhdGlvbiAqL1xcclxcbk5ldVF1YW50RmxvYXQuX3JhZEJpYXNTaGlmdCA9IDg7XFxyXFxuTmV1UXVhbnRGbG9hdC5fcmFkQmlhcyA9IDEgPDwgTmV1UXVhbnRGbG9hdC5fcmFkQmlhc1NoaWZ0O1xcclxcbk5ldVF1YW50RmxvYXQuX2FscGhhUmFkQmlhc1NoaWZ0ID0gTmV1UXVhbnRGbG9hdC5fYWxwaGFCaWFzU2hpZnQgKyBOZXVRdWFudEZsb2F0Ll9yYWRCaWFzU2hpZnQ7XFxyXFxuTmV1UXVhbnRGbG9hdC5fYWxwaGFSYWRCaWFzID0gMSA8PCBOZXVRdWFudEZsb2F0Ll9hbHBoYVJhZEJpYXNTaGlmdDtcXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXVxdWFudEZsb2F0LmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvcGFsZXR0ZVF1YW50aXplci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvcGFsZXR0ZVF1YW50aXplci5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXI7IH0pO1xcbmNsYXNzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XFxyXFxuICAgIHF1YW50aXplU3luYygpIHtcXHJcXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5xdWFudGl6ZSgpKSB7XFxyXFxuICAgICAgICAgICAgaWYgKHZhbHVlLnBhbGV0dGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnBhbGV0dGU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbGV0dGVRdWFudGl6ZXIuanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9yZ2JxdWFudC9jb2xvckhpc3RvZ3JhbS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3JnYnF1YW50L2NvbG9ySGlzdG9ncmFtLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQ29sb3JIaXN0b2dyYW0gKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJDb2xvckhpc3RvZ3JhbVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ29sb3JIaXN0b2dyYW07IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfaHVlU3RhdGlzdGljc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvaHVlU3RhdGlzdGljcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9odWVTdGF0aXN0aWNzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlscy9hcml0aG1ldGljICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2FyaXRobWV0aWMuanNcXFwiKTtcXG4vKlxcclxcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgTGVvbiBTb3Jva2luXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIENvbG9ySGlzdG9ncmFtLmpzIC0gYW4gaW1hZ2UgcXVhbnRpemF0aW9uIGxpYlxcclxcbiAqL1xcclxcbi8qKlxcclxcbiAqIEBwcmVzZXJ2ZSBUeXBlU2NyaXB0IHBvcnQ6XFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogY29sb3JIaXN0b2dyYW0udHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuXFxyXFxuY2xhc3MgQ29sb3JIaXN0b2dyYW0ge1xcclxcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIGNvbG9ycykge1xcclxcbiAgICAgICAgLy8gMSA9IGJ5IGdsb2JhbCBwb3B1bGF0aW9uLCAyID0gc3VicmVnaW9uIHBvcHVsYXRpb24gdGhyZXNob2xkXFxyXFxuICAgICAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XFxyXFxuICAgICAgICAvLyBpZiA+IDAsIGVuYWJsZXMgaHVlcyBzdGF0cyBhbmQgbWluLWNvbG9yIHJldGVudGlvbiBwZXIgZ3JvdXBcXHJcXG4gICAgICAgIHRoaXMuX21pbkh1ZUNvbHMgPSBjb2xvcnMgPDwgMjsgLy8gb3B0cy5taW5IdWVDb2xzIHx8IDA7XFxyXFxuICAgICAgICAvLyAjIG9mIGhpZ2hlc3QtZnJlcXVlbmN5IGNvbG9ycyB0byBzdGFydCB3aXRoIGZvciBwYWxldHRlIHJlZHVjdGlvblxcclxcbiAgICAgICAgdGhpcy5faW5pdENvbG9ycyA9IGNvbG9ycyA8PCAyO1xcclxcbiAgICAgICAgLy8gSHVlU3RhdGlzdGljcyBpbnN0YW5jZVxcclxcbiAgICAgICAgdGhpcy5faHVlU3RhdHMgPSBuZXcgX3V0aWxzX2h1ZVN0YXRpc3RpY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiSHVlU3RhdGlzdGljc1xcXCJdKENvbG9ySGlzdG9ncmFtLl9odWVHcm91cHMsIHRoaXMuX21pbkh1ZUNvbHMpO1xcclxcbiAgICAgICAgdGhpcy5faGlzdG9ncmFtID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1udWxsLWtleXdvcmRcXHJcXG4gICAgfVxcclxcbiAgICBzYW1wbGUocG9pbnRDb250YWluZXIpIHtcXHJcXG4gICAgICAgIHN3aXRjaCAodGhpcy5fbWV0aG9kKSB7XFxyXFxuICAgICAgICAgICAgY2FzZSAxOlxcclxcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvclN0YXRzMUQocG9pbnRDb250YWluZXIpO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBjYXNlIDI6XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yU3RhdHMyRChwb2ludENvbnRhaW5lcik7XFxyXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIGdldEltcG9ydGFuY2VTb3J0ZWRDb2xvcnNJRFhJMzIoKSB7XFxyXFxuICAgICAgICAvLyBUT0RPOiBmaXggdHlwaW5nIGlzc3VlIGluIHN0YWJsZVNvcnQgZnVuY1xcclxcbiAgICAgICAgY29uc3Qgc29ydGVkID0gT2JqZWN0KF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInN0YWJsZVNvcnRcXFwiXSkoT2JqZWN0LmtleXModGhpcy5faGlzdG9ncmFtKSwgKGEsIGIpID0+IHRoaXMuX2hpc3RvZ3JhbVtiXSAtIHRoaXMuX2hpc3RvZ3JhbVthXSk7XFxyXFxuICAgICAgICBpZiAoc29ydGVkLmxlbmd0aCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBbXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGxldCBpZHhpMzI7XFxyXFxuICAgICAgICBzd2l0Y2ggKHRoaXMuX21ldGhvZCkge1xcclxcbiAgICAgICAgICAgIGNhc2UgMTpcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbENvbG9yc0xpbWl0ID0gTWF0aC5taW4oc29ydGVkLmxlbmd0aCwgdGhpcy5faW5pdENvbG9ycyk7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBzb3J0ZWRbaW5pdGlhbENvbG9yc0xpbWl0IC0gMV07XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGZyZXEgPSB0aGlzLl9oaXN0b2dyYW1bbGFzdF07XFxyXFxuICAgICAgICAgICAgICAgIGlkeGkzMiA9IHNvcnRlZC5zbGljZSgwLCBpbml0aWFsQ29sb3JzTGltaXQpO1xcclxcbiAgICAgICAgICAgICAgICAvLyBhZGQgYW55IGN1dCBvZmYgY29sb3JzIHdpdGggc2FtZSBmcmVxIGFzIGxhc3RcXHJcXG4gICAgICAgICAgICAgICAgbGV0IHBvcyA9IGluaXRpYWxDb2xvcnNMaW1pdDtcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gc29ydGVkLmxlbmd0aDtcXHJcXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGxlbiAmJiB0aGlzLl9oaXN0b2dyYW1bc29ydGVkW3Bvc11dID09PSBmcmVxKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZHhpMzIucHVzaChzb3J0ZWRbcG9zKytdKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAvLyBpbmplY3QgbWluIGh1ZWdyb3VwIGNvbG9yc1xcclxcbiAgICAgICAgICAgICAgICB0aGlzLl9odWVTdGF0cy5pbmplY3RJbnRvQXJyYXkoaWR4aTMyKTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSAyOlxcclxcbiAgICAgICAgICAgICAgICBpZHhpMzIgPSBzb3J0ZWQ7XFxyXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxyXFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJldGhpbmsgZXJyb3JzXFxyXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG1ldGhvZCcpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gaW50MzItaWZ5IHZhbHVlc1xcclxcbiAgICAgICAgcmV0dXJuIGlkeGkzMi5tYXAoZnVuY3Rpb24gKHYpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gK3Y7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgfVxcclxcbiAgICAvLyBnbG9iYWwgdG9wLXBvcHVsYXRpb25cXHJcXG4gICAgX2NvbG9yU3RhdHMxRChwb2ludENvbnRhaW5lcikge1xcclxcbiAgICAgICAgY29uc3QgaGlzdEcgPSB0aGlzLl9oaXN0b2dyYW07XFxyXFxuICAgICAgICBjb25zdCBwb2ludEFycmF5ID0gcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xcclxcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnRBcnJheS5sZW5ndGg7XFxyXFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgY29uc3QgY29sID0gcG9pbnRBcnJheVtpXS51aW50MzI7XFxyXFxuICAgICAgICAgICAgLy8gY29sbGVjdCBodWUgc3RhdHNcXHJcXG4gICAgICAgICAgICB0aGlzLl9odWVTdGF0cy5jaGVjayhjb2wpO1xcclxcbiAgICAgICAgICAgIGlmIChjb2wgaW4gaGlzdEcpIHtcXHJcXG4gICAgICAgICAgICAgICAgaGlzdEdbY29sXSsrO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgaGlzdEdbY29sXSA9IDE7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIC8vIHBvcHVsYXRpb24gdGhyZXNob2xkIHdpdGhpbiBzdWJyZWdpb25zXFxyXFxuICAgIC8vIEZJWE1FOiB0aGlzIGNhbiBvdmVyLXJlZHVjZSAoZmV3L25vIGNvbG9ycyBzYW1lPyksIG5lZWQgYSB3YXkgdG8ga2VlcFxcclxcbiAgICAvLyBpbXBvcnRhbnQgY29sb3JzIHRoYXQgZG9udCBldmVyIHJlYWNoIGxvY2FsIHRocmVzaG9sZHMgKGdyYWRpZW50cz8pXFxyXFxuICAgIF9jb2xvclN0YXRzMkQocG9pbnRDb250YWluZXIpIHtcXHJcXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcXHJcXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBvaW50Q29udGFpbmVyLmdldEhlaWdodCgpO1xcclxcbiAgICAgICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcXHJcXG4gICAgICAgIGNvbnN0IGJveFcgPSBDb2xvckhpc3RvZ3JhbS5fYm94U2l6ZVswXTtcXHJcXG4gICAgICAgIGNvbnN0IGJveEggPSBDb2xvckhpc3RvZ3JhbS5fYm94U2l6ZVsxXTtcXHJcXG4gICAgICAgIGNvbnN0IGFyZWEgPSBib3hXICogYm94SDtcXHJcXG4gICAgICAgIGNvbnN0IGJveGVzID0gdGhpcy5fbWFrZUJveGVzKHdpZHRoLCBoZWlnaHQsIGJveFcsIGJveEgpO1xcclxcbiAgICAgICAgY29uc3QgaGlzdEcgPSB0aGlzLl9oaXN0b2dyYW07XFxyXFxuICAgICAgICBib3hlcy5mb3JFYWNoKGJveCA9PiB7XFxyXFxuICAgICAgICAgICAgbGV0IGVmZmMgPSBNYXRoLnJvdW5kKChib3gudyAqIGJveC5oKSAvIGFyZWEpICogQ29sb3JIaXN0b2dyYW0uX2JveFBpeGVscztcXHJcXG4gICAgICAgICAgICBpZiAoZWZmYyA8IDIpXFxyXFxuICAgICAgICAgICAgICAgIGVmZmMgPSAyO1xcclxcbiAgICAgICAgICAgIGNvbnN0IGhpc3RMID0ge307XFxyXFxuICAgICAgICAgICAgdGhpcy5faXRlcmF0ZUJveChib3gsIHdpZHRoLCAoaSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBwb2ludEFycmF5W2ldLnVpbnQzMjtcXHJcXG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBodWUgc3RhdHNcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5faHVlU3RhdHMuY2hlY2soY29sKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGNvbCBpbiBoaXN0Rykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaGlzdEdbY29sXSsrO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbCBpbiBoaXN0TCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsraGlzdExbY29sXSA+PSBlZmZjKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdEdbY29sXSA9IGhpc3RMW2NvbF07XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBoaXN0TFtjb2xdID0gMTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgICAvLyBpbmplY3QgbWluIGh1ZWdyb3VwIGNvbG9yc1xcclxcbiAgICAgICAgdGhpcy5faHVlU3RhdHMuaW5qZWN0SW50b0RpY3Rpb25hcnkoaGlzdEcpO1xcclxcbiAgICB9XFxyXFxuICAgIC8vIGl0ZXJhdGVzIEBiYm94IHdpdGhpbiBhIHBhcmVudCByZWN0IG9mIHdpZHRoIEB3aWQ7IGNhbGxzIEBmbiwgcGFzc2luZyBpbmRleCB3aXRoaW4gcGFyZW50XFxyXFxuICAgIF9pdGVyYXRlQm94KGJib3gsIHdpZCwgZm4pIHtcXHJcXG4gICAgICAgIGNvbnN0IGIgPSBiYm94O1xcclxcbiAgICAgICAgY29uc3QgaTAgPSBiLnkgKiB3aWQgKyBiLng7XFxyXFxuICAgICAgICBjb25zdCBpMSA9IChiLnkgKyBiLmggLSAxKSAqIHdpZCArIChiLnggKyBiLncgLSAxKTtcXHJcXG4gICAgICAgIGNvbnN0IGluY3IgPSB3aWQgLSBiLncgKyAxO1xcclxcbiAgICAgICAgbGV0IGNudCA9IDA7XFxyXFxuICAgICAgICBsZXQgaSA9IGkwO1xcclxcbiAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgaSk7XFxyXFxuICAgICAgICAgICAgaSArPSAoKytjbnQgJSBiLncgPT09IDApID8gaW5jciA6IDE7XFxyXFxuICAgICAgICB9IHdoaWxlIChpIDw9IGkxKTtcXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogICAgcGFydGl0aW9ucyBhIHJlY3RhbmdsZSBvZiB3aWR0aCB4IGhlaWdodCBpbnRvXFxyXFxuICAgICAqICAgIGFycmF5IG9mIGJveGVzIHN0ZXBYIHggc3RlcFkgKG9yIGxlc3MpXFxyXFxuICAgICAqL1xcclxcbiAgICBfbWFrZUJveGVzKHdpZHRoLCBoZWlnaHQsIHN0ZXBYLCBzdGVwWSkge1xcclxcbiAgICAgICAgY29uc3Qgd3JlbSA9IHdpZHRoICUgc3RlcFg7XFxyXFxuICAgICAgICBjb25zdCBocmVtID0gaGVpZ2h0ICUgc3RlcFk7XFxyXFxuICAgICAgICBjb25zdCB4ZW5kID0gd2lkdGggLSB3cmVtO1xcclxcbiAgICAgICAgY29uc3QgeWVuZCA9IGhlaWdodCAtIGhyZW07XFxyXFxuICAgICAgICBjb25zdCBib3hlc0FycmF5ID0gW107XFxyXFxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSBzdGVwWSkge1xcclxcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHggKz0gc3RlcFgpIHtcXHJcXG4gICAgICAgICAgICAgICAgYm94ZXNBcnJheS5wdXNoKHsgeCwgeSwgdzogKHggPT09IHhlbmQgPyB3cmVtIDogc3RlcFgpLCBoOiAoeSA9PT0geWVuZCA/IGhyZW0gOiBzdGVwWSkgfSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIGJveGVzQXJyYXk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuQ29sb3JIaXN0b2dyYW0uX2JveFNpemUgPSBbNjQsIDY0XTtcXHJcXG5Db2xvckhpc3RvZ3JhbS5fYm94UGl4ZWxzID0gMjtcXHJcXG5Db2xvckhpc3RvZ3JhbS5faHVlR3JvdXBzID0gMTA7XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3JIaXN0b2dyYW0uanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9yZ2JxdWFudC9yZ2JxdWFudC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3JnYnF1YW50L3JnYnF1YW50LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogUkdCUXVhbnQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJSR0JRdWFudFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUkdCUXVhbnQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfcGFsZXR0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvcGFsZXR0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wYWxldHRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19wb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbHMvcG9pbnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcG9pbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbG9ySGlzdG9ncmFtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbG9ySGlzdG9ncmFtICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvcmdicXVhbnQvY29sb3JIaXN0b2dyYW0uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BhbGV0dGVRdWFudGl6ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3BhbGV0dGVRdWFudGl6ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcGFsZXR0ZS9wYWxldHRlUXVhbnRpemVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19hcml0aG1ldGljX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlscy9hcml0aG1ldGljICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2FyaXRobWV0aWMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9pbmRleC5qc1xcXCIpO1xcbi8qXFxyXFxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBMZW9uIFNvcm9raW5cXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogUkdCUXVhbnQuanMgLSBhbiBpbWFnZSBxdWFudGl6YXRpb24gbGliXFxyXFxuICovXFxyXFxuLyoqXFxyXFxuICogQHByZXNlcnZlIFR5cGVTY3JpcHQgcG9ydDpcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiByZ2JxdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5jbGFzcyBSZW1vdmVkQ29sb3Ige1xcclxcbiAgICBjb25zdHJ1Y3RvcihpbmRleCwgY29sb3IsIGRpc3RhbmNlKSB7XFxyXFxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XFxyXFxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XFxyXFxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuLy8gVE9ETzogbWFrZSBpbnB1dC9vdXRwdXQgaW1hZ2UgYW5kIGlucHV0L291dHB1dCBwYWxldHRlcyB3aXRoIGluc3RhbmNlcyBvZiBjbGFzcyBQb2ludCBvbmx5IVxcclxcbmNsYXNzIFJHQlF1YW50IGV4dGVuZHMgX3BhbGV0dGVRdWFudGl6ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyXFxcIl0ge1xcclxcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzID0gMjU2LCBtZXRob2QgPSAyKSB7XFxyXFxuICAgICAgICBzdXBlcigpO1xcclxcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcXHJcXG4gICAgICAgIC8vIGRlc2lyZWQgZmluYWwgcGFsZXR0ZSBzaXplXFxyXFxuICAgICAgICB0aGlzLl9jb2xvcnMgPSBjb2xvcnM7XFxyXFxuICAgICAgICAvLyBoaXN0b2dyYW0gdG8gYWNjdW11bGF0ZVxcclxcbiAgICAgICAgdGhpcy5faGlzdG9ncmFtID0gbmV3IF9jb2xvckhpc3RvZ3JhbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJDb2xvckhpc3RvZ3JhbVxcXCJdKG1ldGhvZCwgY29sb3JzKTtcXHJcXG4gICAgICAgIHRoaXMuX2luaXRpYWxEaXN0YW5jZSA9IDAuMDE7XFxyXFxuICAgICAgICB0aGlzLl9kaXN0YW5jZUluY3JlbWVudCA9IDAuMDA1O1xcclxcbiAgICB9XFxyXFxuICAgIC8vIGdhdGhlcnMgaGlzdG9ncmFtIGluZm9cXHJcXG4gICAgc2FtcGxlKGltYWdlKSB7XFxyXFxuICAgICAgICAvKlxcclxcbiAgICAgICAgIHZhciBwb2ludEFycmF5ID0gaW1hZ2UuZ2V0UG9pbnRBcnJheSgpLCBtYXggPSBbMCwgMCwgMCwgMF0sIG1pbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xcclxcbiAgICBcXHJcXG4gICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBvaW50QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxyXFxuICAgICAgICAgdmFyIGNvbG9yID0gcG9pbnRBcnJheVtpXTtcXHJcXG4gICAgICAgICBmb3IgKHZhciBjb21wb25lbnRJbmRleCA9IDA7IGNvbXBvbmVudEluZGV4IDwgNDsgY29tcG9uZW50SW5kZXgrKykge1xcclxcbiAgICAgICAgIGlmIChtYXhbY29tcG9uZW50SW5kZXhdIDwgY29sb3IucmdiYVtjb21wb25lbnRJbmRleF0pIG1heFtjb21wb25lbnRJbmRleF0gPSBjb2xvci5yZ2JhW2NvbXBvbmVudEluZGV4XTtcXHJcXG4gICAgICAgICBpZiAobWluW2NvbXBvbmVudEluZGV4XSA+IGNvbG9yLnJnYmFbY29tcG9uZW50SW5kZXhdKSBtaW5bY29tcG9uZW50SW5kZXhdID0gY29sb3IucmdiYVtjb21wb25lbnRJbmRleF07XFxyXFxuICAgICAgICAgfVxcclxcbiAgICAgICAgIH1cXHJcXG4gICAgICAgICB2YXIgcmQgPSBtYXhbMF0gLSBtaW5bMF0sIGdkID0gbWF4WzFdIC0gbWluWzFdLCBiZCA9IG1heFsyXSAtIG1pblsyXSwgYWQgPSBtYXhbM10gLSBtaW5bM107XFxyXFxuICAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc2V0V2hpdGVQb2ludChyZCwgZ2QsIGJkLCBhZCk7XFxyXFxuICAgIFxcclxcbiAgICAgICAgIHRoaXMuX2luaXRpYWxEaXN0YW5jZSA9IChNYXRoLnNxcnQocmQgKiByZCArIGdkICogZ2QgKyBiZCAqIGJkICsgYWQgKiBhZCkgLyBNYXRoLnNxcnQoMjU1ICogMjU1ICsgMjU1ICogMjU1ICsgMjU1ICogMjU1KSkgKiAwLjAxO1xcclxcbiAgICAgICAgICovXFxyXFxuICAgICAgICB0aGlzLl9oaXN0b2dyYW0uc2FtcGxlKGltYWdlKTtcXHJcXG4gICAgfVxcclxcbiAgICAvLyByZWR1Y2VzIGhpc3RvZ3JhbSB0byBwYWxldHRlLCByZW1hcHMgJiBtZW1vaXplcyByZWR1Y2VkIGNvbG9yc1xcclxcbiAgICAqcXVhbnRpemUoKSB7XFxyXFxuICAgICAgICBjb25zdCBpZHhpMzIgPSB0aGlzLl9oaXN0b2dyYW0uZ2V0SW1wb3J0YW5jZVNvcnRlZENvbG9yc0lEWEkzMigpO1xcclxcbiAgICAgICAgaWYgKGlkeGkzMi5sZW5ndGggPT09IDApIHtcXHJcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbG9ycyBpbiBpbWFnZScpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgeWllbGQqIHRoaXMuX2J1aWxkUGFsZXR0ZShpZHhpMzIpO1xcclxcbiAgICB9XFxyXFxuICAgIC8vIHJlZHVjZXMgc2ltaWxhciBjb2xvcnMgZnJvbSBhbiBpbXBvcnRhbmNlLXNvcnRlZCBVaW50MzIgcmdiYSBhcnJheVxcclxcbiAgICAqX2J1aWxkUGFsZXR0ZShpZHhpMzIpIHtcXHJcXG4gICAgICAgIC8vIHJlZHVjZSBoaXN0b2dyYW0gdG8gY3JlYXRlIGluaXRpYWwgcGFsZXR0ZVxcclxcbiAgICAgICAgLy8gYnVpbGQgZnVsbCByZ2IgcGFsZXR0ZVxcclxcbiAgICAgICAgY29uc3QgcGFsZXR0ZSA9IG5ldyBfdXRpbHNfcGFsZXR0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJQYWxldHRlXFxcIl0oKTtcXHJcXG4gICAgICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBwYWxldHRlLmdldFBvaW50Q29udGFpbmVyKCkuZ2V0UG9pbnRBcnJheSgpO1xcclxcbiAgICAgICAgY29uc3QgdXNhZ2VBcnJheSA9IG5ldyBBcnJheShpZHhpMzIubGVuZ3RoKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpwcmVmZXItYXJyYXktbGl0ZXJhbFxcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHhpMzIubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBjb2xvckFycmF5LnB1c2goX3V0aWxzX3BvaW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlBvaW50XFxcIl0uY3JlYXRlQnlVaW50MzIoaWR4aTMyW2ldKSk7XFxyXFxuICAgICAgICAgICAgdXNhZ2VBcnJheVtpXSA9IDE7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjb25zdCBsZW4gPSBjb2xvckFycmF5Lmxlbmd0aDtcXHJcXG4gICAgICAgIGNvbnN0IG1lbURpc3QgPSBbXTtcXHJcXG4gICAgICAgIGxldCBwYWxMZW4gPSBsZW47XFxyXFxuICAgICAgICBsZXQgdGhvbGQgPSB0aGlzLl9pbml0aWFsRGlzdGFuY2U7XFxyXFxuICAgICAgICAvLyBwYWxldHRlIGFscmVhZHkgYXQgb3IgYmVsb3cgZGVzaXJlZCBsZW5ndGhcXHJcXG4gICAgICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlByb2dyZXNzVHJhY2tlclxcXCJdKHBhbExlbiAtIHRoaXMuX2NvbG9ycywgOTkpO1xcclxcbiAgICAgICAgd2hpbGUgKHBhbExlbiA+IHRoaXMuX2NvbG9ycykge1xcclxcbiAgICAgICAgICAgIG1lbURpc3QubGVuZ3RoID0gMDtcXHJcXG4gICAgICAgICAgICAvLyBpdGVyYXRlIHBhbGV0dGVcXHJcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeShsZW4gLSBwYWxMZW4pKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3MsXFxyXFxuICAgICAgICAgICAgICAgICAgICB9O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGlmICh1c2FnZUFycmF5W2ldID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHB4aSA9IGNvbG9yQXJyYXlbaV07XFxyXFxuICAgICAgICAgICAgICAgIC8vIGlmICghcHhpKSBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2FnZUFycmF5W2pdID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHhqID0gY29sb3JBcnJheVtqXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICghcHhqKSBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLl9kaXN0YW5jZS5jYWxjdWxhdGVOb3JtYWxpemVkKHB4aSwgcHhqKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgdGhvbGQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBpbmRleCxyZ2IsZGlzdFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbURpc3QucHVzaChuZXcgUmVtb3ZlZENvbG9yKGosIHB4aiwgZGlzdCkpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlQXJyYXlbal0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbExlbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIHBhbGV0dGUgcmVkdWN0aW9uIHBhc3NcXHJcXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcXFwicGFsZXR0ZSBsZW5ndGg6IFxcXCIgKyBwYWxMZW4pO1xcclxcbiAgICAgICAgICAgIC8vIGlmIHBhbGV0dGUgaXMgc3RpbGwgbXVjaCBsYXJnZXIgdGhhbiB0YXJnZXQsIGluY3JlbWVudCBieSBsYXJnZXIgaW5pdERpc3RcXHJcXG4gICAgICAgICAgICB0aG9sZCArPSAocGFsTGVuID4gdGhpcy5fY29sb3JzICogMykgPyB0aGlzLl9pbml0aWFsRGlzdGFuY2UgOiB0aGlzLl9kaXN0YW5jZUluY3JlbWVudDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIGlmIHBhbGV0dGUgaXMgb3Zlci1yZWR1Y2VkLCByZS1hZGQgcmVtb3ZlZCBjb2xvcnMgd2l0aCBsYXJnZXN0IGRpc3RhbmNlcyBmcm9tIGxhc3Qgcm91bmRcXHJcXG4gICAgICAgIGlmIChwYWxMZW4gPCB0aGlzLl9jb2xvcnMpIHtcXHJcXG4gICAgICAgICAgICAvLyBzb3J0IGRlc2NlbmRpbmdcXHJcXG4gICAgICAgICAgICBPYmplY3QoX3V0aWxzX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwic3RhYmxlU29ydFxcXCJdKShtZW1EaXN0LCBmdW5jdGlvbiAoYSwgYikge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5kaXN0YW5jZSAtIGEuZGlzdGFuY2U7XFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuICAgICAgICAgICAgbGV0IGsgPSAwO1xcclxcbiAgICAgICAgICAgIHdoaWxlIChwYWxMZW4gPCB0aGlzLl9jb2xvcnMgJiYgayA8IG1lbURpc3QubGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRDb2xvciA9IG1lbURpc3Rba107XFxyXFxuICAgICAgICAgICAgICAgIC8vIHJlLWluamVjdCByZ2IgaW50byBmaW5hbCBwYWxldHRlXFxyXFxuICAgICAgICAgICAgICAgIHVzYWdlQXJyYXlbcmVtb3ZlZENvbG9yLmluZGV4XSA9IDE7XFxyXFxuICAgICAgICAgICAgICAgIHBhbExlbisrO1xcclxcbiAgICAgICAgICAgICAgICBrKys7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgbGV0IGNvbG9ycyA9IGNvbG9yQXJyYXkubGVuZ3RoO1xcclxcbiAgICAgICAgZm9yIChsZXQgY29sb3JJbmRleCA9IGNvbG9ycyAtIDE7IGNvbG9ySW5kZXggPj0gMDsgY29sb3JJbmRleC0tKSB7XFxyXFxuICAgICAgICAgICAgaWYgKHVzYWdlQXJyYXlbY29sb3JJbmRleF0gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9ySW5kZXggIT09IGNvbG9ycyAtIDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyYXlbY29sb3JJbmRleF0gPSBjb2xvckFycmF5W2NvbG9ycyAtIDFdO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIC0tY29sb3JzO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGNvbG9yQXJyYXkubGVuZ3RoID0gY29sb3JzO1xcclxcbiAgICAgICAgcGFsZXR0ZS5zb3J0KCk7XFxyXFxuICAgICAgICB5aWVsZCB7XFxyXFxuICAgICAgICAgICAgcGFsZXR0ZSxcXHJcXG4gICAgICAgICAgICBwcm9ncmVzczogMTAwLFxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZ2JxdWFudC5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3d1L3d1UXVhbnQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9wYWxldHRlL3d1L3d1UXVhbnQuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFd1Q29sb3JDdWJlLCBXdVF1YW50ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiV3VDb2xvckN1YmVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFd1Q29sb3JDdWJlOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJXdVF1YW50XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBXdVF1YW50OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3BhbGV0dGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL3BhbGV0dGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcGFsZXR0ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzL3BvaW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BvaW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wYWxldHRlUXVhbnRpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9wYWxldHRlUXVhbnRpemVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3BhbGV0dGUvcGFsZXR0ZVF1YW50aXplci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogd3VRdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5mdW5jdGlvbiBjcmVhdGVBcnJheTFEKGRpbWVuc2lvbjEpIHtcXHJcXG4gICAgY29uc3QgYSA9IFtdO1xcclxcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGRpbWVuc2lvbjE7IGsrKykge1xcclxcbiAgICAgICAgYVtrXSA9IDA7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGE7XFxyXFxufVxcclxcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5NEQoZGltZW5zaW9uMSwgZGltZW5zaW9uMiwgZGltZW5zaW9uMywgZGltZW5zaW9uNCkge1xcclxcbiAgICBjb25zdCBhID0gbmV3IEFycmF5KGRpbWVuc2lvbjEpO1xcclxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xcclxcbiAgICAgICAgYVtpXSA9IG5ldyBBcnJheShkaW1lbnNpb24yKTtcXHJcXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9uMjsgaisrKSB7XFxyXFxuICAgICAgICAgICAgYVtpXVtqXSA9IG5ldyBBcnJheShkaW1lbnNpb24zKTtcXHJcXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRpbWVuc2lvbjM7IGsrKykge1xcclxcbiAgICAgICAgICAgICAgICBhW2ldW2pdW2tdID0gbmV3IEFycmF5KGRpbWVuc2lvbjQpO1xcclxcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IGRpbWVuc2lvbjQ7IGwrKykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYVtpXVtqXVtrXVtsXSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGE7XFxyXFxufVxcclxcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5M0QoZGltZW5zaW9uMSwgZGltZW5zaW9uMiwgZGltZW5zaW9uMykge1xcclxcbiAgICBjb25zdCBhID0gbmV3IEFycmF5KGRpbWVuc2lvbjEpO1xcclxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xcclxcbiAgICAgICAgYVtpXSA9IG5ldyBBcnJheShkaW1lbnNpb24yKTtcXHJcXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9uMjsgaisrKSB7XFxyXFxuICAgICAgICAgICAgYVtpXVtqXSA9IG5ldyBBcnJheShkaW1lbnNpb24zKTtcXHJcXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRpbWVuc2lvbjM7IGsrKykge1xcclxcbiAgICAgICAgICAgICAgICBhW2ldW2pdW2tdID0gMDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGE7XFxyXFxufVxcclxcbmZ1bmN0aW9uIGZpbGxBcnJheTNEKGEsIGRpbWVuc2lvbjEsIGRpbWVuc2lvbjIsIGRpbWVuc2lvbjMsIHZhbHVlKSB7XFxyXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uMTsgaSsrKSB7XFxyXFxuICAgICAgICBhW2ldID0gW107XFxyXFxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbjI7IGorKykge1xcclxcbiAgICAgICAgICAgIGFbaV1bal0gPSBbXTtcXHJcXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRpbWVuc2lvbjM7IGsrKykge1xcclxcbiAgICAgICAgICAgICAgICBhW2ldW2pdW2tdID0gdmFsdWU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxufVxcclxcbmZ1bmN0aW9uIGZpbGxBcnJheTFEKGEsIGRpbWVuc2lvbjEsIHZhbHVlKSB7XFxyXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uMTsgaSsrKSB7XFxyXFxuICAgICAgICBhW2ldID0gdmFsdWU7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuY2xhc3MgV3VDb2xvckN1YmUge1xcclxcbn1cXHJcXG5jbGFzcyBXdVF1YW50IGV4dGVuZHMgX3BhbGV0dGVRdWFudGl6ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyXFxcIl0ge1xcclxcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzID0gMjU2LCBzaWduaWZpY2FudEJpdHNQZXJDaGFubmVsID0gNSkge1xcclxcbiAgICAgICAgc3VwZXIoKTtcXHJcXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XFxyXFxuICAgICAgICB0aGlzLl9zZXRRdWFsaXR5KHNpZ25pZmljYW50Qml0c1BlckNoYW5uZWwpO1xcclxcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShjb2xvcnMpO1xcclxcbiAgICB9XFxyXFxuICAgIHNhbXBsZShpbWFnZSkge1xcclxcbiAgICAgICAgY29uc3QgcG9pbnRBcnJheSA9IGltYWdlLmdldFBvaW50QXJyYXkoKTtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gcG9pbnRBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXHJcXG4gICAgICAgICAgICB0aGlzLl9hZGRDb2xvcihwb2ludEFycmF5W2ldKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHRoaXMuX3BpeGVscyA9IHRoaXMuX3BpeGVscy5jb25jYXQocG9pbnRBcnJheSk7XFxyXFxuICAgIH1cXHJcXG4gICAgKnF1YW50aXplKCkge1xcclxcbiAgICAgICAgeWllbGQqIHRoaXMuX3ByZXBhcmVQYWxldHRlKCk7XFxyXFxuICAgICAgICBjb25zdCBwYWxldHRlID0gbmV3IF91dGlsc19wYWxldHRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIlBhbGV0dGVcXFwiXSgpO1xcclxcbiAgICAgICAgLy8gZ2VuZXJhdGVzIHBhbGV0dGVcXHJcXG4gICAgICAgIGZvciAobGV0IHBhbGV0dGVJbmRleCA9IDA7IHBhbGV0dGVJbmRleCA8IHRoaXMuX2NvbG9yczsgcGFsZXR0ZUluZGV4KyspIHtcXHJcXG4gICAgICAgICAgICBpZiAodGhpcy5fc3Vtc1twYWxldHRlSW5kZXhdID4gMCkge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSB0aGlzLl9zdW1zW3BhbGV0dGVJbmRleF07XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9yZWRzW3BhbGV0dGVJbmRleF0gLyBzdW07XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLl9ncmVlbnNbcGFsZXR0ZUluZGV4XSAvIHN1bTtcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMuX2JsdWVzW3BhbGV0dGVJbmRleF0gLyBzdW07XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLl9hbHBoYXNbcGFsZXR0ZUluZGV4XSAvIHN1bTtcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBfdXRpbHNfcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiUG9pbnRcXFwiXS5jcmVhdGVCeVJHQkEociB8IDAsIGcgfCAwLCBiIHwgMCwgYSB8IDApO1xcclxcbiAgICAgICAgICAgICAgICBwYWxldHRlLmFkZChjb2xvcik7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcGFsZXR0ZS5zb3J0KCk7XFxyXFxuICAgICAgICB5aWVsZCB7XFxyXFxuICAgICAgICAgICAgcGFsZXR0ZSxcXHJcXG4gICAgICAgICAgICBwcm9ncmVzczogMTAwLFxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcbiAgICAqX3ByZXBhcmVQYWxldHRlKCkge1xcclxcbiAgICAgICAgLy8gcHJlcHJvY2VzcyB0aGUgY29sb3JzXFxyXFxuICAgICAgICB5aWVsZCogdGhpcy5fY2FsY3VsYXRlTW9tZW50cygpO1xcclxcbiAgICAgICAgbGV0IG5leHQgPSAwO1xcclxcbiAgICAgICAgY29uc3Qgdm9sdW1lVmFyaWFuY2UgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyk7XFxyXFxuICAgICAgICAvLyBwcm9jZXNzZXMgdGhlIGN1YmVzXFxyXFxuICAgICAgICBmb3IgKGxldCBjdWJlSW5kZXggPSAxOyBjdWJlSW5kZXggPCB0aGlzLl9jb2xvcnM7ICsrY3ViZUluZGV4KSB7XFxyXFxuICAgICAgICAgICAgLy8gaWYgY3V0IGlzIHBvc3NpYmxlOyBtYWtlIGl0XFxyXFxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1dCh0aGlzLl9jdWJlc1tuZXh0XSwgdGhpcy5fY3ViZXNbY3ViZUluZGV4XSkpIHtcXHJcXG4gICAgICAgICAgICAgICAgdm9sdW1lVmFyaWFuY2VbbmV4dF0gPSB0aGlzLl9jdWJlc1tuZXh0XS52b2x1bWUgPiAxID8gdGhpcy5fY2FsY3VsYXRlVmFyaWFuY2UodGhpcy5fY3ViZXNbbmV4dF0pIDogMC4wO1xcclxcbiAgICAgICAgICAgICAgICB2b2x1bWVWYXJpYW5jZVtjdWJlSW5kZXhdID0gdGhpcy5fY3ViZXNbY3ViZUluZGV4XS52b2x1bWUgPiAxID8gdGhpcy5fY2FsY3VsYXRlVmFyaWFuY2UodGhpcy5fY3ViZXNbY3ViZUluZGV4XSkgOiAwLjA7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3V0IHdhcyBub3QgcG9zc2libGUsIHJldmVydCB0aGUgaW5kZXhcXHJcXG4gICAgICAgICAgICAgICAgdm9sdW1lVmFyaWFuY2VbbmV4dF0gPSAwLjA7XFxyXFxuICAgICAgICAgICAgICAgIGN1YmVJbmRleC0tO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBuZXh0ID0gMDtcXHJcXG4gICAgICAgICAgICBsZXQgdGVtcCA9IHZvbHVtZVZhcmlhbmNlWzBdO1xcclxcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPD0gY3ViZUluZGV4OyArK2luZGV4KSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh2b2x1bWVWYXJpYW5jZVtpbmRleF0gPiB0ZW1wKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdm9sdW1lVmFyaWFuY2VbaW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGluZGV4O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmICh0ZW1wIDw9IDAuMCkge1xcclxcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvcnMgPSBjdWJlSW5kZXggKyAxO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjb25zdCBsb29rdXBSZWQgPSBbXTtcXHJcXG4gICAgICAgIGNvbnN0IGxvb2t1cEdyZWVuID0gW107XFxyXFxuICAgICAgICBjb25zdCBsb29rdXBCbHVlID0gW107XFxyXFxuICAgICAgICBjb25zdCBsb29rdXBBbHBoYSA9IFtdO1xcclxcbiAgICAgICAgLy8gcHJlY2FsY3VsYXRlcyBsb29rdXAgdGFibGVzXFxyXFxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMuX2NvbG9yczsgKytrKSB7XFxyXFxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gV3VRdWFudC5fdm9sdW1lKHRoaXMuX2N1YmVzW2tdLCB0aGlzLl93ZWlnaHRzKTtcXHJcXG4gICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xcclxcbiAgICAgICAgICAgICAgICBsb29rdXBSZWRba10gPSAoV3VRdWFudC5fdm9sdW1lKHRoaXMuX2N1YmVzW2tdLCB0aGlzLl9tb21lbnRzUmVkKSAvIHdlaWdodCkgfCAwO1xcclxcbiAgICAgICAgICAgICAgICBsb29rdXBHcmVlbltrXSA9IChXdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX21vbWVudHNHcmVlbikgLyB3ZWlnaHQpIHwgMDtcXHJcXG4gICAgICAgICAgICAgICAgbG9va3VwQmx1ZVtrXSA9IChXdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX21vbWVudHNCbHVlKSAvIHdlaWdodCkgfCAwO1xcclxcbiAgICAgICAgICAgICAgICBsb29rdXBBbHBoYVtrXSA9IChXdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX21vbWVudHNBbHBoYSkgLyB3ZWlnaHQpIHwgMDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIGxvb2t1cFJlZFtrXSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIGxvb2t1cEdyZWVuW2tdID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgbG9va3VwQmx1ZVtrXSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIGxvb2t1cEFscGhhW2tdID0gMDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB0aGlzLl9yZWRzID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcXHJcXG4gICAgICAgIHRoaXMuX2dyZWVucyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XFxyXFxuICAgICAgICB0aGlzLl9ibHVlcyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XFxyXFxuICAgICAgICB0aGlzLl9hbHBoYXMgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyArIDEpO1xcclxcbiAgICAgICAgdGhpcy5fc3VtcyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XFxyXFxuICAgICAgICAvLyBzY2FucyBhbmQgYWRkcyBjb2xvcnNcXHJcXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMCwgbCA9IHRoaXMuX3BpeGVscy5sZW5ndGg7IGluZGV4IDwgbDsgaW5kZXgrKykge1xcclxcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fcGl4ZWxzW2luZGV4XTtcXHJcXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IC0xO1xcclxcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBtYXRjaDtcXHJcXG4gICAgICAgICAgICBsZXQgYmVzdERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcXHJcXG4gICAgICAgICAgICBmb3IgKGxldCBsb29rdXAgPSAwOyBsb29rdXAgPCB0aGlzLl9jb2xvcnM7IGxvb2t1cCsrKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kUmVkID0gbG9va3VwUmVkW2xvb2t1cF07XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kR3JlZW4gPSBsb29rdXBHcmVlbltsb29rdXBdO1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEJsdWUgPSBsb29rdXBCbHVlW2xvb2t1cF07XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kQWxwaGEgPSBsb29rdXBBbHBoYVtsb29rdXBdO1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlLmNhbGN1bGF0ZVJhdyhmb3VuZFJlZCwgZm91bmRHcmVlbiwgZm91bmRCbHVlLCBmb3VuZEFscGhhLCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgYmVzdERpc3RhbmNlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IGxvb2t1cDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB0aGlzLl9yZWRzW2Jlc3RNYXRjaF0gKz0gY29sb3IucjtcXHJcXG4gICAgICAgICAgICB0aGlzLl9ncmVlbnNbYmVzdE1hdGNoXSArPSBjb2xvci5nO1xcclxcbiAgICAgICAgICAgIHRoaXMuX2JsdWVzW2Jlc3RNYXRjaF0gKz0gY29sb3IuYjtcXHJcXG4gICAgICAgICAgICB0aGlzLl9hbHBoYXNbYmVzdE1hdGNoXSArPSBjb2xvci5hO1xcclxcbiAgICAgICAgICAgIHRoaXMuX3N1bXNbYmVzdE1hdGNoXSsrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIF9hZGRDb2xvcihjb2xvcikge1xcclxcbiAgICAgICAgY29uc3QgYml0c1RvUmVtb3ZlID0gOCAtIHRoaXMuX3NpZ25pZmljYW50Qml0c1BlckNoYW5uZWw7XFxyXFxuICAgICAgICBjb25zdCBpbmRleFJlZCA9IChjb2xvci5yID4+IGJpdHNUb1JlbW92ZSkgKyAxO1xcclxcbiAgICAgICAgY29uc3QgaW5kZXhHcmVlbiA9IChjb2xvci5nID4+IGJpdHNUb1JlbW92ZSkgKyAxO1xcclxcbiAgICAgICAgY29uc3QgaW5kZXhCbHVlID0gKGNvbG9yLmIgPj4gYml0c1RvUmVtb3ZlKSArIDE7XFxyXFxuICAgICAgICBjb25zdCBpbmRleEFscGhhID0gKGNvbG9yLmEgPj4gYml0c1RvUmVtb3ZlKSArIDE7XFxyXFxuICAgICAgICAvLyBpZihjb2xvci5hID4gMTApIHtcXHJcXG4gICAgICAgIHRoaXMuX3dlaWdodHNbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0rKztcXHJcXG4gICAgICAgIHRoaXMuX21vbWVudHNSZWRbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gY29sb3IucjtcXHJcXG4gICAgICAgIHRoaXMuX21vbWVudHNHcmVlbltpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSBjb2xvci5nO1xcclxcbiAgICAgICAgdGhpcy5fbW9tZW50c0JsdWVbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gY29sb3IuYjtcXHJcXG4gICAgICAgIHRoaXMuX21vbWVudHNBbHBoYVtpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSBjb2xvci5hO1xcclxcbiAgICAgICAgdGhpcy5fbW9tZW50c1tpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSB0aGlzLl90YWJsZVtjb2xvci5yXSArIHRoaXMuX3RhYmxlW2NvbG9yLmddICsgdGhpcy5fdGFibGVbY29sb3IuYl0gKyB0aGlzLl90YWJsZVtjb2xvci5hXTtcXHJcXG4gICAgICAgIC8vIH1cXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogQ29udmVydHMgdGhlIGhpc3RvZ3JhbSB0byBhIHNlcmllcyBvZiBfbW9tZW50cy5cXHJcXG4gICAgICovXFxyXFxuICAgICpfY2FsY3VsYXRlTW9tZW50cygpIHtcXHJcXG4gICAgICAgIGNvbnN0IGFyZWEgPSBbXTtcXHJcXG4gICAgICAgIGNvbnN0IGFyZWFSZWQgPSBbXTtcXHJcXG4gICAgICAgIGNvbnN0IGFyZWFHcmVlbiA9IFtdO1xcclxcbiAgICAgICAgY29uc3QgYXJlYUJsdWUgPSBbXTtcXHJcXG4gICAgICAgIGNvbnN0IGFyZWFBbHBoYSA9IFtdO1xcclxcbiAgICAgICAgY29uc3QgYXJlYTIgPSBbXTtcXHJcXG4gICAgICAgIGNvbnN0IHhhcmVhID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcXHJcXG4gICAgICAgIGNvbnN0IHhhcmVhUmVkID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcXHJcXG4gICAgICAgIGNvbnN0IHhhcmVhR3JlZW4gPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xcclxcbiAgICAgICAgY29uc3QgeGFyZWFCbHVlID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcXHJcXG4gICAgICAgIGNvbnN0IHhhcmVhQWxwaGEgPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xcclxcbiAgICAgICAgY29uc3QgeGFyZWEyID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcXHJcXG4gICAgICAgIGxldCB0cmFja2VyUHJvZ3Jlc3MgPSAwO1xcclxcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IG5ldyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiUHJvZ3Jlc3NUcmFja2VyXFxcIl0odGhpcy5fYWxwaGFNYXhTaWRlSW5kZXggKiB0aGlzLl9tYXhTaWRlSW5kZXgsIDk5KTtcXHJcXG4gICAgICAgIGZvciAobGV0IGFscGhhSW5kZXggPSAxOyBhbHBoYUluZGV4IDw9IHRoaXMuX2FscGhhTWF4U2lkZUluZGV4OyArK2FscGhhSW5kZXgpIHtcXHJcXG4gICAgICAgICAgICBmaWxsQXJyYXkzRCh4YXJlYSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XFxyXFxuICAgICAgICAgICAgZmlsbEFycmF5M0QoeGFyZWFSZWQsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xcclxcbiAgICAgICAgICAgIGZpbGxBcnJheTNEKHhhcmVhR3JlZW4sIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xcclxcbiAgICAgICAgICAgIGZpbGxBcnJheTNEKHhhcmVhQmx1ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XFxyXFxuICAgICAgICAgICAgZmlsbEFycmF5M0QoeGFyZWFBbHBoYSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XFxyXFxuICAgICAgICAgICAgZmlsbEFycmF5M0QoeGFyZWEyLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcXHJcXG4gICAgICAgICAgICBmb3IgKGxldCByZWRJbmRleCA9IDE7IHJlZEluZGV4IDw9IHRoaXMuX21heFNpZGVJbmRleDsgKytyZWRJbmRleCwgKyt0cmFja2VyUHJvZ3Jlc3MpIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZXIuc2hvdWxkTm90aWZ5KHRyYWNrZXJQcm9ncmVzcykpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzcyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIH07XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgZmlsbEFycmF5MUQoYXJlYSwgdGhpcy5fc2lkZVNpemUsIDApO1xcclxcbiAgICAgICAgICAgICAgICBmaWxsQXJyYXkxRChhcmVhUmVkLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XFxyXFxuICAgICAgICAgICAgICAgIGZpbGxBcnJheTFEKGFyZWFHcmVlbiwgdGhpcy5fc2lkZVNpemUsIDApO1xcclxcbiAgICAgICAgICAgICAgICBmaWxsQXJyYXkxRChhcmVhQmx1ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xcclxcbiAgICAgICAgICAgICAgICBmaWxsQXJyYXkxRChhcmVhQWxwaGEsIHRoaXMuX3NpZGVTaXplLCAwKTtcXHJcXG4gICAgICAgICAgICAgICAgZmlsbEFycmF5MUQoYXJlYTIsIHRoaXMuX3NpZGVTaXplLCAwKTtcXHJcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZ3JlZW5JbmRleCA9IDE7IGdyZWVuSW5kZXggPD0gdGhpcy5fbWF4U2lkZUluZGV4OyArK2dyZWVuSW5kZXgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lUmVkID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lR3JlZW4gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVCbHVlID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lQWxwaGEgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmUyID0gMC4wO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYmx1ZUluZGV4ID0gMTsgYmx1ZUluZGV4IDw9IHRoaXMuX21heFNpZGVJbmRleDsgKytibHVlSW5kZXgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lICs9IHRoaXMuX3dlaWdodHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVJlZCArPSB0aGlzLl9tb21lbnRzUmVkW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVHcmVlbiArPSB0aGlzLl9tb21lbnRzR3JlZW5bYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUJsdWUgKz0gdGhpcy5fbW9tZW50c0JsdWVbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUFscGhhICs9IHRoaXMuX21vbWVudHNBbHBoYVthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lMiArPSB0aGlzLl9tb21lbnRzW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWFbYmx1ZUluZGV4XSArPSBsaW5lO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWFSZWRbYmx1ZUluZGV4XSArPSBsaW5lUmVkO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWFHcmVlbltibHVlSW5kZXhdICs9IGxpbmVHcmVlbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhQmx1ZVtibHVlSW5kZXhdICs9IGxpbmVCbHVlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWFBbHBoYVtibHVlSW5kZXhdICs9IGxpbmVBbHBoYTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhMltibHVlSW5kZXhdICs9IGxpbmUyO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWFbcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhUmVkW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWFSZWRbcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYVJlZFtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhR3JlZW5bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYUdyZWVuW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWFHcmVlbltibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhQmx1ZVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhQmx1ZVtyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhQmx1ZVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhQWxwaGFbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYUFscGhhW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWFBbHBoYVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhhcmVhMltyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhMltyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhMltibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlaWdodHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl93ZWlnaHRzW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbWVudHNSZWRbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl9tb21lbnRzUmVkW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhUmVkW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbWVudHNHcmVlblthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX21vbWVudHNHcmVlblthbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYUdyZWVuW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbWVudHNCbHVlW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c0JsdWVbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFCbHVlW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbWVudHNBbHBoYVthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX21vbWVudHNBbHBoYVthbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYUFscGhhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbWVudHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl9tb21lbnRzW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhMltyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogQ29tcHV0ZXMgdGhlIHZvbHVtZSBvZiB0aGUgY3ViZSBpbiBhIHNwZWNpZmljIG1vbWVudC5cXHJcXG4gICAgICovXFxyXFxuICAgIHN0YXRpYyBfdm9sdW1lRmxvYXQoY3ViZSwgbW9tZW50KSB7XFxyXFxuICAgICAgICByZXR1cm4gKG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxcclxcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxcclxcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xcclxcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxcclxcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xcclxcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xcclxcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxcclxcbiAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0pIC1cXHJcXG4gICAgICAgICAgICAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXFxyXFxuICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXFxyXFxuICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xcclxcbiAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXFxyXFxuICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xcclxcbiAgICB9XFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBDb21wdXRlcyB0aGUgdm9sdW1lIG9mIHRoZSBjdWJlIGluIGEgc3BlY2lmaWMgbW9tZW50LlxcclxcbiAgICAgKi9cXHJcXG4gICAgc3RhdGljIF92b2x1bWUoY3ViZSwgbW9tZW50KSB7XFxyXFxuICAgICAgICByZXR1cm4gV3VRdWFudC5fdm9sdW1lRmxvYXQoY3ViZSwgbW9tZW50KSB8IDA7XFxyXFxuICAgIH1cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIFNwbGl0cyB0aGUgY3ViZSBpbiBnaXZlbiBwb3NpdGlvbl1bYW5kIGNvbG9yIGRpcmVjdGlvbi5cXHJcXG4gICAgICovXFxyXFxuICAgIHN0YXRpYyBfdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIG1vbWVudCkge1xcclxcbiAgICAgICAgbGV0IHJlc3VsdDtcXHJcXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XFxyXFxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9hbHBoYTpcXHJcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0pIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgIChtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9yZWQ6XFxyXFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0pIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgIChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX2dyZWVuOlxcclxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSAtXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1heGltdW1dIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWF4aW11bV0gK1xcclxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSkgLVxcclxcbiAgICAgICAgICAgICAgICAgICAgKG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0gK1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0pO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX2JsdWU6XFxyXFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW3Bvc2l0aW9uXSAtXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSAtXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW3Bvc2l0aW9uXSArXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSkgLVxcclxcbiAgICAgICAgICAgICAgICAgICAgKG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bcG9zaXRpb25dIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSAtXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtwb3NpdGlvbl0gK1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bcG9zaXRpb25dKTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgZGVmYXVsdDpcXHJcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbXBvc3NpYmxlJyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gcmVzdWx0IHwgMDtcXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogU3BsaXRzIHRoZSBjdWJlIGluIGEgZ2l2ZW4gY29sb3IgZGlyZWN0aW9uIGF0IGl0cyBtaW5pbXVtLlxcclxcbiAgICAgKi9cXHJcXG4gICAgc3RhdGljIF9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCBtb21lbnQpIHtcXHJcXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XFxyXFxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9hbHBoYTpcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICgtbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSkgLVxcclxcbiAgICAgICAgICAgICAgICAgICAgKC1tb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcXHJcXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX3JlZDpcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICgtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSkgLVxcclxcbiAgICAgICAgICAgICAgICAgICAgKC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcXHJcXG4gICAgICAgICAgICBjYXNlIFd1UXVhbnQuX2dyZWVuOlxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gKC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gK1xcclxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dKSAtXFxyXFxuICAgICAgICAgICAgICAgICAgICAoLW1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gK1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xcclxcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fYmx1ZTpcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICgtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSkgLVxcclxcbiAgICAgICAgICAgICAgICAgICAgKC1tb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcXHJcXG4gICAgICAgICAgICBkZWZhdWx0OlxcclxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aHkgaGVyZSBpcyByZXR1cm4gMCwgYW5kIGluIHRoaXMuX3RvcCB0aGVyZSBpcyBubyBkZWZhdWx0IGF0IGFsbCAobm93IGl0IGlzIHRocm93IGVycm9yKT9cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIENhbGN1bGF0ZXMgc3RhdGlzdGljYWwgdmFyaWFuY2UgZm9yIGEgZ2l2ZW4gY3ViZS5cXHJcXG4gICAgICovXFxyXFxuICAgIF9jYWxjdWxhdGVWYXJpYW5jZShjdWJlKSB7XFxyXFxuICAgICAgICBjb25zdCB2b2x1bWVSZWQgPSBXdVF1YW50Ll92b2x1bWUoY3ViZSwgdGhpcy5fbW9tZW50c1JlZCk7XFxyXFxuICAgICAgICBjb25zdCB2b2x1bWVHcmVlbiA9IFd1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzR3JlZW4pO1xcclxcbiAgICAgICAgY29uc3Qgdm9sdW1lQmx1ZSA9IFd1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzQmx1ZSk7XFxyXFxuICAgICAgICBjb25zdCB2b2x1bWVBbHBoYSA9IFd1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzQWxwaGEpO1xcclxcbiAgICAgICAgY29uc3Qgdm9sdW1lTW9tZW50ID0gV3VRdWFudC5fdm9sdW1lRmxvYXQoY3ViZSwgdGhpcy5fbW9tZW50cyk7XFxyXFxuICAgICAgICBjb25zdCB2b2x1bWVXZWlnaHQgPSBXdVF1YW50Ll92b2x1bWUoY3ViZSwgdGhpcy5fd2VpZ2h0cyk7XFxyXFxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHZvbHVtZVJlZCAqIHZvbHVtZVJlZCArIHZvbHVtZUdyZWVuICogdm9sdW1lR3JlZW4gKyB2b2x1bWVCbHVlICogdm9sdW1lQmx1ZSArIHZvbHVtZUFscGhhICogdm9sdW1lQWxwaGE7XFxyXFxuICAgICAgICByZXR1cm4gdm9sdW1lTW9tZW50IC0gKGRpc3RhbmNlIC8gdm9sdW1lV2VpZ2h0KTtcXHJcXG4gICAgfVxcclxcbiAgICAvKipcXHJcXG4gICAgICogRmluZHMgdGhlIG9wdGltYWwgKG1heGltYWwpIHBvc2l0aW9uIGZvciB0aGUgY3V0LlxcclxcbiAgICAgKi9cXHJcXG4gICAgX21heGltaXplKGN1YmUsIGRpcmVjdGlvbiwgZmlyc3QsIGxhc3QsIHdob2xlUmVkLCB3aG9sZUdyZWVuLCB3aG9sZUJsdWUsIHdob2xlQWxwaGEsIHdob2xlV2VpZ2h0KSB7XFxyXFxuICAgICAgICBjb25zdCBib3R0b21SZWQgPSBXdVF1YW50Ll9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCB0aGlzLl9tb21lbnRzUmVkKSB8IDA7XFxyXFxuICAgICAgICBjb25zdCBib3R0b21HcmVlbiA9IFd1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX21vbWVudHNHcmVlbikgfCAwO1xcclxcbiAgICAgICAgY29uc3QgYm90dG9tQmx1ZSA9IFd1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX21vbWVudHNCbHVlKSB8IDA7XFxyXFxuICAgICAgICBjb25zdCBib3R0b21BbHBoYSA9IFd1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX21vbWVudHNBbHBoYSkgfCAwO1xcclxcbiAgICAgICAgY29uc3QgYm90dG9tV2VpZ2h0ID0gV3VRdWFudC5fYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgdGhpcy5fd2VpZ2h0cykgfCAwO1xcclxcbiAgICAgICAgbGV0IHJlc3VsdCA9IDAuMDtcXHJcXG4gICAgICAgIGxldCBjdXRQb3NpdGlvbiA9IC0xO1xcclxcbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb24gPSBmaXJzdDsgcG9zaXRpb24gPCBsYXN0OyArK3Bvc2l0aW9uKSB7XFxyXFxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lcyB0aGUgY3ViZSBjdXQgYXQgYSBjZXJ0YWluIHBvc2l0aW9uXFxyXFxuICAgICAgICAgICAgbGV0IGhhbGZSZWQgPSBib3R0b21SZWQgKyBXdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fbW9tZW50c1JlZCk7XFxyXFxuICAgICAgICAgICAgbGV0IGhhbGZHcmVlbiA9IGJvdHRvbUdyZWVuICsgV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX21vbWVudHNHcmVlbik7XFxyXFxuICAgICAgICAgICAgbGV0IGhhbGZCbHVlID0gYm90dG9tQmx1ZSArIFd1UXVhbnQuX3RvcChjdWJlLCBkaXJlY3Rpb24sIHBvc2l0aW9uLCB0aGlzLl9tb21lbnRzQmx1ZSk7XFxyXFxuICAgICAgICAgICAgbGV0IGhhbGZBbHBoYSA9IGJvdHRvbUFscGhhICsgV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX21vbWVudHNBbHBoYSk7XFxyXFxuICAgICAgICAgICAgbGV0IGhhbGZXZWlnaHQgPSBib3R0b21XZWlnaHQgKyBXdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fd2VpZ2h0cyk7XFxyXFxuICAgICAgICAgICAgLy8gdGhlIGN1YmUgY2Fubm90IGJlIGN1dCBhdCBib3R0b20gKHRoaXMgd291bGQgbGVhZCB0byBlbXB0eSBjdWJlKVxcclxcbiAgICAgICAgICAgIGlmIChoYWxmV2VpZ2h0ICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCBoYWxmRGlzdGFuY2UgPSBoYWxmUmVkICogaGFsZlJlZCArIGhhbGZHcmVlbiAqIGhhbGZHcmVlbiArIGhhbGZCbHVlICogaGFsZkJsdWUgKyBoYWxmQWxwaGEgKiBoYWxmQWxwaGE7XFxyXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gaGFsZkRpc3RhbmNlIC8gaGFsZldlaWdodDtcXHJcXG4gICAgICAgICAgICAgICAgaGFsZlJlZCA9IHdob2xlUmVkIC0gaGFsZlJlZDtcXHJcXG4gICAgICAgICAgICAgICAgaGFsZkdyZWVuID0gd2hvbGVHcmVlbiAtIGhhbGZHcmVlbjtcXHJcXG4gICAgICAgICAgICAgICAgaGFsZkJsdWUgPSB3aG9sZUJsdWUgLSBoYWxmQmx1ZTtcXHJcXG4gICAgICAgICAgICAgICAgaGFsZkFscGhhID0gd2hvbGVBbHBoYSAtIGhhbGZBbHBoYTtcXHJcXG4gICAgICAgICAgICAgICAgaGFsZldlaWdodCA9IHdob2xlV2VpZ2h0IC0gaGFsZldlaWdodDtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGhhbGZXZWlnaHQgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhhbGZEaXN0YW5jZSA9IGhhbGZSZWQgKiBoYWxmUmVkICsgaGFsZkdyZWVuICogaGFsZkdyZWVuICsgaGFsZkJsdWUgKiBoYWxmQmx1ZSArIGhhbGZBbHBoYSAqIGhhbGZBbHBoYTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgKz0gaGFsZkRpc3RhbmNlIC8gaGFsZldlaWdodDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wID4gcmVzdWx0KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGVtcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHsgbWF4OiByZXN1bHQsIHBvc2l0aW9uOiBjdXRQb3NpdGlvbiB9O1xcclxcbiAgICB9XFxyXFxuICAgIC8vIEN1dHMgYSBjdWJlIHdpdGggYW5vdGhlciBvbmUuXFxyXFxuICAgIF9jdXQoZmlyc3QsIHNlY29uZCkge1xcclxcbiAgICAgICAgbGV0IGRpcmVjdGlvbjtcXHJcXG4gICAgICAgIGNvbnN0IHdob2xlUmVkID0gV3VRdWFudC5fdm9sdW1lKGZpcnN0LCB0aGlzLl9tb21lbnRzUmVkKTtcXHJcXG4gICAgICAgIGNvbnN0IHdob2xlR3JlZW4gPSBXdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNHcmVlbik7XFxyXFxuICAgICAgICBjb25zdCB3aG9sZUJsdWUgPSBXdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNCbHVlKTtcXHJcXG4gICAgICAgIGNvbnN0IHdob2xlQWxwaGEgPSBXdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNBbHBoYSk7XFxyXFxuICAgICAgICBjb25zdCB3aG9sZVdlaWdodCA9IFd1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fd2VpZ2h0cyk7XFxyXFxuICAgICAgICBjb25zdCByZWQgPSB0aGlzLl9tYXhpbWl6ZShmaXJzdCwgV3VRdWFudC5fcmVkLCBmaXJzdC5yZWRNaW5pbXVtICsgMSwgZmlyc3QucmVkTWF4aW11bSwgd2hvbGVSZWQsIHdob2xlR3JlZW4sIHdob2xlQmx1ZSwgd2hvbGVBbHBoYSwgd2hvbGVXZWlnaHQpO1xcclxcbiAgICAgICAgY29uc3QgZ3JlZW4gPSB0aGlzLl9tYXhpbWl6ZShmaXJzdCwgV3VRdWFudC5fZ3JlZW4sIGZpcnN0LmdyZWVuTWluaW11bSArIDEsIGZpcnN0LmdyZWVuTWF4aW11bSwgd2hvbGVSZWQsIHdob2xlR3JlZW4sIHdob2xlQmx1ZSwgd2hvbGVBbHBoYSwgd2hvbGVXZWlnaHQpO1xcclxcbiAgICAgICAgY29uc3QgYmx1ZSA9IHRoaXMuX21heGltaXplKGZpcnN0LCBXdVF1YW50Ll9ibHVlLCBmaXJzdC5ibHVlTWluaW11bSArIDEsIGZpcnN0LmJsdWVNYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XFxyXFxuICAgICAgICBjb25zdCBhbHBoYSA9IHRoaXMuX21heGltaXplKGZpcnN0LCBXdVF1YW50Ll9hbHBoYSwgZmlyc3QuYWxwaGFNaW5pbXVtICsgMSwgZmlyc3QuYWxwaGFNYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XFxyXFxuICAgICAgICBpZiAoYWxwaGEubWF4ID49IHJlZC5tYXggJiYgYWxwaGEubWF4ID49IGdyZWVuLm1heCAmJiBhbHBoYS5tYXggPj0gYmx1ZS5tYXgpIHtcXHJcXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBXdVF1YW50Ll9hbHBoYTtcXHJcXG4gICAgICAgICAgICAvLyBjYW5ub3Qgc3BsaXQgZW1wdHkgY3ViZVxcclxcbiAgICAgICAgICAgIGlmIChhbHBoYS5wb3NpdGlvbiA8IDApXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgIGlmIChyZWQubWF4ID49IGFscGhhLm1heCAmJiByZWQubWF4ID49IGdyZWVuLm1heCAmJiByZWQubWF4ID49IGJsdWUubWF4KSB7XFxyXFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFd1UXVhbnQuX3JlZDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZWxzZSBpZiAoZ3JlZW4ubWF4ID49IGFscGhhLm1heCAmJiBncmVlbi5tYXggPj0gcmVkLm1heCAmJiBncmVlbi5tYXggPj0gYmx1ZS5tYXgpIHtcXHJcXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gV3VRdWFudC5fZ3JlZW47XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBXdVF1YW50Ll9ibHVlO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHNlY29uZC5yZWRNYXhpbXVtID0gZmlyc3QucmVkTWF4aW11bTtcXHJcXG4gICAgICAgIHNlY29uZC5ncmVlbk1heGltdW0gPSBmaXJzdC5ncmVlbk1heGltdW07XFxyXFxuICAgICAgICBzZWNvbmQuYmx1ZU1heGltdW0gPSBmaXJzdC5ibHVlTWF4aW11bTtcXHJcXG4gICAgICAgIHNlY29uZC5hbHBoYU1heGltdW0gPSBmaXJzdC5hbHBoYU1heGltdW07XFxyXFxuICAgICAgICAvLyBjdXRzIGluIGEgY2VydGFpbiBkaXJlY3Rpb25cXHJcXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XFxyXFxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9yZWQ6XFxyXFxuICAgICAgICAgICAgICAgIHNlY29uZC5yZWRNaW5pbXVtID0gZmlyc3QucmVkTWF4aW11bSA9IHJlZC5wb3NpdGlvbjtcXHJcXG4gICAgICAgICAgICAgICAgc2Vjb25kLmdyZWVuTWluaW11bSA9IGZpcnN0LmdyZWVuTWluaW11bTtcXHJcXG4gICAgICAgICAgICAgICAgc2Vjb25kLmJsdWVNaW5pbXVtID0gZmlyc3QuYmx1ZU1pbmltdW07XFxyXFxuICAgICAgICAgICAgICAgIHNlY29uZC5hbHBoYU1pbmltdW0gPSBmaXJzdC5hbHBoYU1pbmltdW07XFxyXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgIGNhc2UgV3VRdWFudC5fZ3JlZW46XFxyXFxuICAgICAgICAgICAgICAgIHNlY29uZC5ncmVlbk1pbmltdW0gPSBmaXJzdC5ncmVlbk1heGltdW0gPSBncmVlbi5wb3NpdGlvbjtcXHJcXG4gICAgICAgICAgICAgICAgc2Vjb25kLnJlZE1pbmltdW0gPSBmaXJzdC5yZWRNaW5pbXVtO1xcclxcbiAgICAgICAgICAgICAgICBzZWNvbmQuYmx1ZU1pbmltdW0gPSBmaXJzdC5ibHVlTWluaW11bTtcXHJcXG4gICAgICAgICAgICAgICAgc2Vjb25kLmFscGhhTWluaW11bSA9IGZpcnN0LmFscGhhTWluaW11bTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9ibHVlOlxcclxcbiAgICAgICAgICAgICAgICBzZWNvbmQuYmx1ZU1pbmltdW0gPSBmaXJzdC5ibHVlTWF4aW11bSA9IGJsdWUucG9zaXRpb247XFxyXFxuICAgICAgICAgICAgICAgIHNlY29uZC5yZWRNaW5pbXVtID0gZmlyc3QucmVkTWluaW11bTtcXHJcXG4gICAgICAgICAgICAgICAgc2Vjb25kLmdyZWVuTWluaW11bSA9IGZpcnN0LmdyZWVuTWluaW11bTtcXHJcXG4gICAgICAgICAgICAgICAgc2Vjb25kLmFscGhhTWluaW11bSA9IGZpcnN0LmFscGhhTWluaW11bTtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgY2FzZSBXdVF1YW50Ll9hbHBoYTpcXHJcXG4gICAgICAgICAgICAgICAgc2Vjb25kLmFscGhhTWluaW11bSA9IGZpcnN0LmFscGhhTWF4aW11bSA9IGFscGhhLnBvc2l0aW9uO1xcclxcbiAgICAgICAgICAgICAgICBzZWNvbmQuYmx1ZU1pbmltdW0gPSBmaXJzdC5ibHVlTWluaW11bTtcXHJcXG4gICAgICAgICAgICAgICAgc2Vjb25kLnJlZE1pbmltdW0gPSBmaXJzdC5yZWRNaW5pbXVtO1xcclxcbiAgICAgICAgICAgICAgICBzZWNvbmQuZ3JlZW5NaW5pbXVtID0gZmlyc3QuZ3JlZW5NaW5pbXVtO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIC8vIGRldGVybWluZXMgdGhlIHZvbHVtZXMgYWZ0ZXIgY3V0XFxyXFxuICAgICAgICBmaXJzdC52b2x1bWUgPSAoZmlyc3QucmVkTWF4aW11bSAtIGZpcnN0LnJlZE1pbmltdW0pICogKGZpcnN0LmdyZWVuTWF4aW11bSAtIGZpcnN0LmdyZWVuTWluaW11bSkgKiAoZmlyc3QuYmx1ZU1heGltdW0gLSBmaXJzdC5ibHVlTWluaW11bSkgKiAoZmlyc3QuYWxwaGFNYXhpbXVtIC0gZmlyc3QuYWxwaGFNaW5pbXVtKTtcXHJcXG4gICAgICAgIHNlY29uZC52b2x1bWUgPSAoc2Vjb25kLnJlZE1heGltdW0gLSBzZWNvbmQucmVkTWluaW11bSkgKiAoc2Vjb25kLmdyZWVuTWF4aW11bSAtIHNlY29uZC5ncmVlbk1pbmltdW0pICogKHNlY29uZC5ibHVlTWF4aW11bSAtIHNlY29uZC5ibHVlTWluaW11bSkgKiAoc2Vjb25kLmFscGhhTWF4aW11bSAtIHNlY29uZC5hbHBoYU1pbmltdW0pO1xcclxcbiAgICAgICAgLy8gdGhlIGN1dCB3YXMgc3VjY2Vzc2Z1bFxcclxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgIH1cXHJcXG4gICAgX2luaXRpYWxpemUoY29sb3JzKSB7XFxyXFxuICAgICAgICB0aGlzLl9jb2xvcnMgPSBjb2xvcnM7XFxyXFxuICAgICAgICAvLyBjcmVhdGVzIGFsbCB0aGUgX2N1YmVzXFxyXFxuICAgICAgICB0aGlzLl9jdWJlcyA9IFtdO1xcclxcbiAgICAgICAgLy8gaW5pdGlhbGl6ZXMgYWxsIHRoZSBfY3ViZXNcXHJcXG4gICAgICAgIGZvciAobGV0IGN1YmVJbmRleCA9IDA7IGN1YmVJbmRleCA8IGNvbG9yczsgY3ViZUluZGV4KyspIHtcXHJcXG4gICAgICAgICAgICB0aGlzLl9jdWJlc1tjdWJlSW5kZXhdID0gbmV3IFd1Q29sb3JDdWJlKCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyByZXNldHMgdGhlIHJlZmVyZW5jZSBtaW5pbXVtc1xcclxcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0ucmVkTWluaW11bSA9IDA7XFxyXFxuICAgICAgICB0aGlzLl9jdWJlc1swXS5ncmVlbk1pbmltdW0gPSAwO1xcclxcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0uYmx1ZU1pbmltdW0gPSAwO1xcclxcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0uYWxwaGFNaW5pbXVtID0gMDtcXHJcXG4gICAgICAgIC8vIHJlc2V0cyB0aGUgcmVmZXJlbmNlIG1heGltdW1zXFxyXFxuICAgICAgICB0aGlzLl9jdWJlc1swXS5yZWRNYXhpbXVtID0gdGhpcy5fbWF4U2lkZUluZGV4O1xcclxcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0uZ3JlZW5NYXhpbXVtID0gdGhpcy5fbWF4U2lkZUluZGV4O1xcclxcbiAgICAgICAgdGhpcy5fY3ViZXNbMF0uYmx1ZU1heGltdW0gPSB0aGlzLl9tYXhTaWRlSW5kZXg7XFxyXFxuICAgICAgICB0aGlzLl9jdWJlc1swXS5hbHBoYU1heGltdW0gPSB0aGlzLl9hbHBoYU1heFNpZGVJbmRleDtcXHJcXG4gICAgICAgIHRoaXMuX3dlaWdodHMgPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xcclxcbiAgICAgICAgdGhpcy5fbW9tZW50c1JlZCA9IGNyZWF0ZUFycmF5NEQodGhpcy5fYWxwaGFTaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XFxyXFxuICAgICAgICB0aGlzLl9tb21lbnRzR3JlZW4gPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xcclxcbiAgICAgICAgdGhpcy5fbW9tZW50c0JsdWUgPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xcclxcbiAgICAgICAgdGhpcy5fbW9tZW50c0FscGhhID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcXHJcXG4gICAgICAgIHRoaXMuX21vbWVudHMgPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xcclxcbiAgICAgICAgdGhpcy5fdGFibGUgPSBbXTtcXHJcXG4gICAgICAgIGZvciAobGV0IHRhYmxlSW5kZXggPSAwOyB0YWJsZUluZGV4IDwgMjU2OyArK3RhYmxlSW5kZXgpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLl90YWJsZVt0YWJsZUluZGV4XSA9IHRhYmxlSW5kZXggKiB0YWJsZUluZGV4O1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdGhpcy5fcGl4ZWxzID0gW107XFxyXFxuICAgIH1cXHJcXG4gICAgX3NldFF1YWxpdHkoc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbCA9IDUpIHtcXHJcXG4gICAgICAgIHRoaXMuX3NpZ25pZmljYW50Qml0c1BlckNoYW5uZWwgPSBzaWduaWZpY2FudEJpdHNQZXJDaGFubmVsO1xcclxcbiAgICAgICAgdGhpcy5fbWF4U2lkZUluZGV4ID0gMSA8PCB0aGlzLl9zaWduaWZpY2FudEJpdHNQZXJDaGFubmVsO1xcclxcbiAgICAgICAgdGhpcy5fYWxwaGFNYXhTaWRlSW5kZXggPSB0aGlzLl9tYXhTaWRlSW5kZXg7XFxyXFxuICAgICAgICB0aGlzLl9zaWRlU2l6ZSA9IHRoaXMuX21heFNpZGVJbmRleCArIDE7XFxyXFxuICAgICAgICB0aGlzLl9hbHBoYVNpZGVTaXplID0gdGhpcy5fYWxwaGFNYXhTaWRlSW5kZXggKyAxO1xcclxcbiAgICB9XFxyXFxufVxcclxcbld1UXVhbnQuX2FscGhhID0gMztcXHJcXG5XdVF1YW50Ll9yZWQgPSAyO1xcclxcbld1UXVhbnQuX2dyZWVuID0gMTtcXHJcXG5XdVF1YW50Ll9ibHVlID0gMDtcXHJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD13dVF1YW50LmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3F1YWxpdHkvaW5kZXguanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vcXVhbGl0eS9pbmRleC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNzaW0gKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NzaW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3NpbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9xdWFsaXR5L3NzaW0uanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNzaW1cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9zc2ltX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInNzaW1cXFwiXTsgfSk7XFxuXFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3F1YWxpdHkvc3NpbS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3F1YWxpdHkvc3NpbS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogc3NpbSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNzaW1cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNzaW07IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uc3RhbnRzX2J0NzA5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb25zdGFudHMvYnQ3MDkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vY29uc3RhbnRzL2J0NzA5LmpzXFxcIik7XFxuXFxyXFxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3JoeXMtZS9zdHJ1Y3R1cmFsLXNpbWlsYXJpdHlcXHJcXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0cnVjdHVyYWxfc2ltaWxhcml0eVxcclxcbmNvbnN0IEsxID0gMC4wMTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuYW1pbmctY29udmVudGlvblxcclxcbmNvbnN0IEsyID0gMC4wMzsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuYW1pbmctY29udmVudGlvblxcclxcbmZ1bmN0aW9uIHNzaW0oaW1hZ2UxLCBpbWFnZTIpIHtcXHJcXG4gICAgaWYgKGltYWdlMS5nZXRIZWlnaHQoKSAhPT0gaW1hZ2UyLmdldEhlaWdodCgpIHx8IGltYWdlMS5nZXRXaWR0aCgpICE9PSBpbWFnZTIuZ2V0V2lkdGgoKSkge1xcclxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZXMgaGF2ZSBkaWZmZXJlbnQgc2l6ZXMhJyk7XFxyXFxuICAgIH1cXHJcXG4gICAgY29uc3QgYml0c1BlckNvbXBvbmVudCA9IDg7XFxyXFxuICAgIGNvbnN0IEwgPSAoMSA8PCBiaXRzUGVyQ29tcG9uZW50KSAtIDE7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bmFtaW5nLWNvbnZlbnRpb25cXHJcXG4gICAgY29uc3QgYzEgPSBNYXRoLnBvdygoSzEgKiBMKSwgMik7XFxyXFxuICAgIGNvbnN0IGMyID0gTWF0aC5wb3coKEsyICogTCksIDIpO1xcclxcbiAgICBsZXQgbnVtV2luZG93cyA9IDA7XFxyXFxuICAgIGxldCBtc3NpbSA9IDAuMDtcXHJcXG4gICAgLy8gY2FsY3VsYXRlIHNzaW0gZm9yIGVhY2ggd2luZG93XFxyXFxuICAgIGl0ZXJhdGUoaW1hZ2UxLCBpbWFnZTIsIChsdW1hVmFsdWVzMSwgbHVtYVZhbHVlczIsIGF2ZXJhZ2VMdW1hVmFsdWUxLCBhdmVyYWdlTHVtYVZhbHVlMikgPT4ge1xcclxcbiAgICAgICAgLy8gY2FsY3VsYXRlIHZhcmlhbmNlIGFuZCBjb3ZhcmlhbmNlXFxyXFxuICAgICAgICBsZXQgc2lneHkgPSAwLjA7XFxyXFxuICAgICAgICBsZXQgc2lnc3F4ID0gMC4wO1xcclxcbiAgICAgICAgbGV0IHNpZ3NxeSA9IDAuMDtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHVtYVZhbHVlczEubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBzaWdzcXggKz0gTWF0aC5wb3coKGx1bWFWYWx1ZXMxW2ldIC0gYXZlcmFnZUx1bWFWYWx1ZTEpLCAyKTtcXHJcXG4gICAgICAgICAgICBzaWdzcXkgKz0gTWF0aC5wb3coKGx1bWFWYWx1ZXMyW2ldIC0gYXZlcmFnZUx1bWFWYWx1ZTIpLCAyKTtcXHJcXG4gICAgICAgICAgICBzaWd4eSArPSAobHVtYVZhbHVlczFbaV0gLSBhdmVyYWdlTHVtYVZhbHVlMSkgKiAobHVtYVZhbHVlczJbaV0gLSBhdmVyYWdlTHVtYVZhbHVlMik7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjb25zdCBudW1QaXhlbHNJbldpbiA9IGx1bWFWYWx1ZXMxLmxlbmd0aCAtIDE7XFxyXFxuICAgICAgICBzaWdzcXggLz0gbnVtUGl4ZWxzSW5XaW47XFxyXFxuICAgICAgICBzaWdzcXkgLz0gbnVtUGl4ZWxzSW5XaW47XFxyXFxuICAgICAgICBzaWd4eSAvPSBudW1QaXhlbHNJbldpbjtcXHJcXG4gICAgICAgIC8vIHBlcmZvcm0gc3NpbSBjYWxjdWxhdGlvbiBvbiB3aW5kb3dcXHJcXG4gICAgICAgIGNvbnN0IG51bWVyYXRvciA9ICgyICogYXZlcmFnZUx1bWFWYWx1ZTEgKiBhdmVyYWdlTHVtYVZhbHVlMiArIGMxKSAqICgyICogc2lneHkgKyBjMik7XFxyXFxuICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IChNYXRoLnBvdyhhdmVyYWdlTHVtYVZhbHVlMSwgMikgKyBNYXRoLnBvdyhhdmVyYWdlTHVtYVZhbHVlMiwgMikgKyBjMSkgKiAoc2lnc3F4ICsgc2lnc3F5ICsgYzIpO1xcclxcbiAgICAgICAgY29uc3Qgc3NpbSA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xcclxcbiAgICAgICAgbXNzaW0gKz0gc3NpbTtcXHJcXG4gICAgICAgIG51bVdpbmRvd3MrKztcXHJcXG4gICAgfSk7XFxyXFxuICAgIHJldHVybiBtc3NpbSAvIG51bVdpbmRvd3M7XFxyXFxufVxcclxcbmZ1bmN0aW9uIGl0ZXJhdGUoaW1hZ2UxLCBpbWFnZTIsIGNhbGxiYWNrKSB7XFxyXFxuICAgIGNvbnN0IHdpbmRvd1NpemUgPSA4O1xcclxcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlMS5nZXRXaWR0aCgpO1xcclxcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZTEuZ2V0SGVpZ2h0KCk7XFxyXFxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IHdpbmRvd1NpemUpIHtcXHJcXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHggKz0gd2luZG93U2l6ZSkge1xcclxcbiAgICAgICAgICAgIC8vIGF2b2lkIG91dC1vZi13aWR0aC9oZWlnaHRcXHJcXG4gICAgICAgICAgICBjb25zdCB3aW5kb3dXaWR0aCA9IE1hdGgubWluKHdpbmRvd1NpemUsIHdpZHRoIC0geCk7XFxyXFxuICAgICAgICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gTWF0aC5taW4od2luZG93U2l6ZSwgaGVpZ2h0IC0geSk7XFxyXFxuICAgICAgICAgICAgY29uc3QgbHVtYVZhbHVlczEgPSBjYWxjdWxhdGVMdW1hVmFsdWVzRm9yV2luZG93KGltYWdlMSwgeCwgeSwgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodCk7XFxyXFxuICAgICAgICAgICAgY29uc3QgbHVtYVZhbHVlczIgPSBjYWxjdWxhdGVMdW1hVmFsdWVzRm9yV2luZG93KGltYWdlMiwgeCwgeSwgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodCk7XFxyXFxuICAgICAgICAgICAgY29uc3QgYXZlcmFnZUx1bWExID0gY2FsY3VsYXRlQXZlcmFnZUx1bWEobHVtYVZhbHVlczEpO1xcclxcbiAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VMdW1hMiA9IGNhbGN1bGF0ZUF2ZXJhZ2VMdW1hKGx1bWFWYWx1ZXMyKTtcXHJcXG4gICAgICAgICAgICBjYWxsYmFjayhsdW1hVmFsdWVzMSwgbHVtYVZhbHVlczIsIGF2ZXJhZ2VMdW1hMSwgYXZlcmFnZUx1bWEyKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG5mdW5jdGlvbiBjYWxjdWxhdGVMdW1hVmFsdWVzRm9yV2luZG93KGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XFxyXFxuICAgIGNvbnN0IHBvaW50QXJyYXkgPSBpbWFnZS5nZXRQb2ludEFycmF5KCk7XFxyXFxuICAgIGNvbnN0IGx1bWFWYWx1ZXMgPSBbXTtcXHJcXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xcclxcbiAgICBmb3IgKGxldCBqID0geTsgaiA8IHkgKyBoZWlnaHQ7IGorKykge1xcclxcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaiAqIGltYWdlLmdldFdpZHRoKCk7XFxyXFxuICAgICAgICBmb3IgKGxldCBpID0geDsgaSA8IHggKyB3aWR0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludEFycmF5W29mZnNldCArIGldO1xcclxcbiAgICAgICAgICAgIGx1bWFWYWx1ZXNbY291bnRlcl0gPSBwb2ludC5yICogX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJZXFxcIl0uUkVEICsgcG9pbnQuZyAqIF9jb25zdGFudHNfYnQ3MDlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiWVxcXCJdLkdSRUVOICsgcG9pbnQuYiAqIF9jb25zdGFudHNfYnQ3MDlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiWVxcXCJdLkJMVUU7XFxyXFxuICAgICAgICAgICAgY291bnRlcisrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBsdW1hVmFsdWVzO1xcclxcbn1cXHJcXG5mdW5jdGlvbiBjYWxjdWxhdGVBdmVyYWdlTHVtYShsdW1hVmFsdWVzKSB7XFxyXFxuICAgIGxldCBzdW1MdW1hID0gMC4wO1xcclxcbiAgICBmb3IgKGNvbnN0IGx1bWEgb2YgbHVtYVZhbHVlcykge1xcclxcbiAgICAgICAgc3VtTHVtYSArPSBsdW1hO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBzdW1MdW1hIC8gbHVtYVZhbHVlcy5sZW5ndGg7XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNzaW0uanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvYXJpdGhtZXRpYy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9hcml0aG1ldGljLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVncmVlczJyYWRpYW5zLCBtYXgzLCBtaW4zLCBpbnRJblJhbmdlLCBpblJhbmdlMHRvMjU1Um91bmRlZCwgaW5SYW5nZTB0bzI1NSwgc3RhYmxlU29ydCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZ3JlZXMycmFkaWFuc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVncmVlczJyYWRpYW5zOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtYXgzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYXgzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtaW4zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtaW4zOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpbnRJblJhbmdlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbnRJblJhbmdlOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpblJhbmdlMHRvMjU1Um91bmRlZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5SYW5nZTB0bzI1NVJvdW5kZWQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImluUmFuZ2UwdG8yNTVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluUmFuZ2UwdG8yNTU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInN0YWJsZVNvcnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YWJsZVNvcnQ7IH0pO1xcbmZ1bmN0aW9uIGRlZ3JlZXMycmFkaWFucyhuKSB7XFxyXFxuICAgIHJldHVybiBuICogKE1hdGguUEkgLyAxODApO1xcclxcbn1cXHJcXG5mdW5jdGlvbiBtYXgzKGEsIGIsIGMpIHtcXHJcXG4gICAgbGV0IG0gPSBhO1xcclxcbiAgICBpZiAobSA8IGIpXFxyXFxuICAgICAgICBtID0gYjtcXHJcXG4gICAgaWYgKG0gPCBjKVxcclxcbiAgICAgICAgbSA9IGM7XFxyXFxuICAgIHJldHVybiBtO1xcclxcbn1cXHJcXG5mdW5jdGlvbiBtaW4zKGEsIGIsIGMpIHtcXHJcXG4gICAgbGV0IG0gPSBhO1xcclxcbiAgICBpZiAobSA+IGIpXFxyXFxuICAgICAgICBtID0gYjtcXHJcXG4gICAgaWYgKG0gPiBjKVxcclxcbiAgICAgICAgbSA9IGM7XFxyXFxuICAgIHJldHVybiBtO1xcclxcbn1cXHJcXG5mdW5jdGlvbiBpbnRJblJhbmdlKHZhbHVlLCBsb3csIGhpZ2gpIHtcXHJcXG4gICAgaWYgKHZhbHVlID4gaGlnaClcXHJcXG4gICAgICAgIHZhbHVlID0gaGlnaDtcXHJcXG4gICAgaWYgKHZhbHVlIDwgbG93KVxcclxcbiAgICAgICAgdmFsdWUgPSBsb3c7XFxyXFxuICAgIHJldHVybiB2YWx1ZSB8IDA7XFxyXFxufVxcclxcbmZ1bmN0aW9uIGluUmFuZ2UwdG8yNTVSb3VuZGVkKG4pIHtcXHJcXG4gICAgbiA9IE1hdGgucm91bmQobik7XFxyXFxuICAgIGlmIChuID4gMjU1KVxcclxcbiAgICAgICAgbiA9IDI1NTtcXHJcXG4gICAgZWxzZSBpZiAobiA8IDApXFxyXFxuICAgICAgICBuID0gMDtcXHJcXG4gICAgcmV0dXJuIG47XFxyXFxufVxcclxcbmZ1bmN0aW9uIGluUmFuZ2UwdG8yNTUobikge1xcclxcbiAgICBpZiAobiA+IDI1NSlcXHJcXG4gICAgICAgIG4gPSAyNTU7XFxyXFxuICAgIGVsc2UgaWYgKG4gPCAwKVxcclxcbiAgICAgICAgbiA9IDA7XFxyXFxuICAgIHJldHVybiBuO1xcclxcbn1cXHJcXG5mdW5jdGlvbiBzdGFibGVTb3J0KGFycmF5VG9Tb3J0LCBjYWxsYmFjaykge1xcclxcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGFycmF5VG9Tb3J0WzBdO1xcclxcbiAgICBsZXQgc29ydGVkO1xcclxcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ3N0cmluZycpIHtcXHJcXG4gICAgICAgIGNvbnN0IG9yZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tbnVsbC1rZXl3b3JkXFxyXFxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5VG9Tb3J0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xcclxcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGFycmF5VG9Tb3J0W2ldOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWFueVxcclxcbiAgICAgICAgICAgIGlmIChvcmRbdmFsXSB8fCBvcmRbdmFsXSA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxyXFxuICAgICAgICAgICAgb3JkW3ZhbF0gPSBpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgc29ydGVkID0gYXJyYXlUb1NvcnQuc29ydChmdW5jdGlvbiAoYSwgYikge1xcclxcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhLCBiKSB8fCBvcmRbYV0gLSBvcmRbYl07XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgfVxcclxcbiAgICBlbHNlIHtcXHJcXG4gICAgICAgIGNvbnN0IG9yZDIgPSBhcnJheVRvU29ydC5zbGljZSgwKTtcXHJcXG4gICAgICAgIHNvcnRlZCA9IGFycmF5VG9Tb3J0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYSwgYikgfHwgb3JkMi5pbmRleE9mKGEpIC0gb3JkMi5pbmRleE9mKGIpO1xcclxcbiAgICAgICAgfSk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIHNvcnRlZDtcXHJcXG59XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJpdGhtZXRpYy5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9odWVTdGF0aXN0aWNzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL2h1ZVN0YXRpc3RpY3MuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBIdWVTdGF0aXN0aWNzICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiSHVlU3RhdGlzdGljc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSHVlU3RhdGlzdGljczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb252ZXJzaW9uX3JnYjJoc2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvbnZlcnNpb24vcmdiMmhzbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3JnYjJoc2wuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BhbGV0dGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFsZXR0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wYWxldHRlLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogaHVlU3RhdGlzdGljcy50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcXHJcXG4gKi9cXHJcXG5cXHJcXG5cXHJcXG5jbGFzcyBIdWVHcm91cCB7XFxyXFxuICAgIGNvbnN0cnVjdG9yKCkge1xcclxcbiAgICAgICAgdGhpcy5udW0gPSAwO1xcclxcbiAgICAgICAgdGhpcy5jb2xzID0gW107XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuY2xhc3MgSHVlU3RhdGlzdGljcyB7XFxyXFxuICAgIGNvbnN0cnVjdG9yKG51bUdyb3VwcywgbWluQ29scykge1xcclxcbiAgICAgICAgdGhpcy5fbnVtR3JvdXBzID0gbnVtR3JvdXBzO1xcclxcbiAgICAgICAgdGhpcy5fbWluQ29scyA9IG1pbkNvbHM7XFxyXFxuICAgICAgICB0aGlzLl9zdGF0cyA9IFtdO1xcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbnVtR3JvdXBzOyBpKyspIHtcXHJcXG4gICAgICAgICAgICB0aGlzLl9zdGF0c1tpXSA9IG5ldyBIdWVHcm91cCgpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdGhpcy5fZ3JvdXBzRnVsbCA9IDA7XFxyXFxuICAgIH1cXHJcXG4gICAgY2hlY2soaTMyKSB7XFxyXFxuICAgICAgICBpZiAodGhpcy5fZ3JvdXBzRnVsbCA9PT0gdGhpcy5fbnVtR3JvdXBzICsgMSkge1xcclxcbiAgICAgICAgICAgIHRoaXMuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgfTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGNvbnN0IHIgPSAoaTMyICYgMHhmZik7XFxyXFxuICAgICAgICBjb25zdCBnID0gKGkzMiA+Pj4gOCkgJiAweGZmO1xcclxcbiAgICAgICAgY29uc3QgYiA9IChpMzIgPj4+IDE2KSAmIDB4ZmY7XFxyXFxuICAgICAgICBjb25zdCBoZyA9IChyID09PSBnICYmIGcgPT09IGIpID8gMCA6IDEgKyBPYmplY3QoX3BhbGV0dGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiaHVlR3JvdXBcXFwiXSkoT2JqZWN0KF9jb252ZXJzaW9uX3JnYjJoc2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmdiMmhzbFxcXCJdKShyLCBnLCBiKS5oLCB0aGlzLl9udW1Hcm91cHMpO1xcclxcbiAgICAgICAgY29uc3QgZ3IgPSB0aGlzLl9zdGF0c1toZ107XFxyXFxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLl9taW5Db2xzO1xcclxcbiAgICAgICAgZ3IubnVtKys7XFxyXFxuICAgICAgICBpZiAoZ3IubnVtID4gbWluKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGdyLm51bSA9PT0gbWluKSB7XFxyXFxuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzRnVsbCsrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKGdyLm51bSA8PSBtaW4pIHtcXHJcXG4gICAgICAgICAgICB0aGlzLl9zdGF0c1toZ10uY29scy5wdXNoKGkzMik7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgaW5qZWN0SW50b0RpY3Rpb25hcnkoaGlzdEcpIHtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuX251bUdyb3VwczsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRzW2ldLm51bSA8PSB0aGlzLl9taW5Db2xzKSB7XFxyXFxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRzW2ldLmNvbHMuZm9yRWFjaCgoY29sKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhpc3RHW2NvbF0pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0R1tjb2xdID0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RHW2NvbF0rKztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIGluamVjdEludG9BcnJheShoaXN0Rykge1xcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5fbnVtR3JvdXBzOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdHNbaV0ubnVtIDw9IHRoaXMuX21pbkNvbHMpIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHNbaV0uY29scy5mb3JFYWNoKChjb2wpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXN0Ry5pbmRleE9mKGNvbCkgPT09IC0xKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdEcucHVzaChjb2wpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHVlU3RhdGlzdGljcy5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9pbmRleC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvaW5kZXguanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogUG9pbnQsIFBvaW50Q29udGFpbmVyLCBQYWxldHRlLCBIdWVTdGF0aXN0aWNzLCBQcm9ncmVzc1RyYWNrZXIsIGFyaXRobWV0aWMgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FyaXRobWV0aWNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXJpdGhtZXRpYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9hcml0aG1ldGljLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAobW9kdWxlIG9iamVjdCkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhcml0aG1ldGljXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfYXJpdGhtZXRpY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2h1ZVN0YXRpc3RpY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaHVlU3RhdGlzdGljcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9odWVTdGF0aXN0aWNzLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJIdWVTdGF0aXN0aWNzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfaHVlU3RhdGlzdGljc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJIdWVTdGF0aXN0aWNzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGFsZXR0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYWxldHRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BhbGV0dGUuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlBhbGV0dGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9wYWxldHRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIlBhbGV0dGVcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wb2ludCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wb2ludC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiUG9pbnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9wb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJQb2ludFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BvaW50Q29udGFpbmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BvaW50Q29udGFpbmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BvaW50Q29udGFpbmVyLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJQb2ludENvbnRhaW5lclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3BvaW50Q29udGFpbmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIlBvaW50Q29udGFpbmVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJvZ3Jlc3NUcmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Byb2dyZXNzVHJhY2tlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS91dGlscy9wcm9ncmVzc1RyYWNrZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlByb2dyZXNzVHJhY2tlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3Byb2dyZXNzVHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJQcm9ncmVzc1RyYWNrZXJcXFwiXTsgfSk7XFxuXFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BhbGV0dGUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcGFsZXR0ZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGh1ZUdyb3VwLCBQYWxldHRlICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaHVlR3JvdXBcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGh1ZUdyb3VwOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJQYWxldHRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQYWxldHRlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BvaW50Q29udGFpbmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BvaW50Q29udGFpbmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BvaW50Q29udGFpbmVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb252ZXJzaW9uX3JnYjJoc2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvbnZlcnNpb24vcmdiMmhzbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2VzbS9jb252ZXJzaW9uL3JnYjJoc2wuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBAcHJlc2VydmVcXHJcXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxcclxcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXFxyXFxuICpcXHJcXG4gKiBwYWxldHRlLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcblxcclxcbi8vIFRPRE86IG1ha2UgcGFsZXR0ZUFycmF5IHZpYSBwb2ludENvbnRhaW5lciwgc28sIGV4cG9ydCB3aWxsIGJlIGF2YWlsYWJsZSB2aWEgcG9pbnRDb250YWluZXIuZXhwb3J0WFhYXFxyXFxuY29uc3QgaHVlR3JvdXBzID0gMTA7XFxyXFxuZnVuY3Rpb24gaHVlR3JvdXAoaHVlLCBzZWdtZW50c051bWJlcikge1xcclxcbiAgICBjb25zdCBtYXhIdWUgPSAzNjA7XFxyXFxuICAgIGNvbnN0IHNlZyA9IG1heEh1ZSAvIHNlZ21lbnRzTnVtYmVyO1xcclxcbiAgICBjb25zdCBoYWxmID0gc2VnIC8gMjtcXHJcXG4gICAgZm9yIChsZXQgaSA9IDEsIG1pZCA9IHNlZyAtIGhhbGY7IGkgPCBzZWdtZW50c051bWJlcjsgaSsrLCBtaWQgKz0gc2VnKSB7XFxyXFxuICAgICAgICBpZiAoaHVlID49IG1pZCAmJiBodWUgPCBtaWQgKyBzZWcpXFxyXFxuICAgICAgICAgICAgcmV0dXJuIGk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIDA7XFxyXFxufVxcclxcbmNsYXNzIFBhbGV0dGUge1xcclxcbiAgICBjb25zdHJ1Y3RvcigpIHtcXHJcXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkgPSBbXTtcXHJcXG4gICAgICAgIHRoaXMuX2kzMmlkeCA9IHt9O1xcclxcbiAgICAgICAgdGhpcy5fcG9pbnRDb250YWluZXIgPSBuZXcgX3BvaW50Q29udGFpbmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIlBvaW50Q29udGFpbmVyXFxcIl0oKTtcXHJcXG4gICAgICAgIHRoaXMuX3BvaW50Q29udGFpbmVyLnNldEhlaWdodCgxKTtcXHJcXG4gICAgICAgIHRoaXMuX3BvaW50QXJyYXkgPSB0aGlzLl9wb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XFxyXFxuICAgIH1cXHJcXG4gICAgYWRkKGNvbG9yKSB7XFxyXFxuICAgICAgICB0aGlzLl9wb2ludEFycmF5LnB1c2goY29sb3IpO1xcclxcbiAgICAgICAgdGhpcy5fcG9pbnRDb250YWluZXIuc2V0V2lkdGgodGhpcy5fcG9pbnRBcnJheS5sZW5ndGgpO1xcclxcbiAgICB9XFxyXFxuICAgIGhhcyhjb2xvcikge1xcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXHJcXG4gICAgICAgICAgICBpZiAoY29sb3IudWludDMyID09PSB0aGlzLl9wb2ludEFycmF5W2ldLnVpbnQzMilcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG4gICAgLy8gVE9UUlk6IHVzZSBIVVNMIC0gaHR0cDovL2Jvcm9uaW5lLmNvbS9odXNsLyBodHRwOi8vd3d3Lmh1c2wtY29sb3JzLm9yZy8gaHR0cHM6Ly9naXRodWIuY29tL2h1c2wtY29sb3JzL2h1c2xcXHJcXG4gICAgZ2V0TmVhcmVzdENvbG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcikge1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50QXJyYXlbdGhpcy5fZ2V0TmVhcmVzdEluZGV4KGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcikgfCAwXTtcXHJcXG4gICAgfVxcclxcbiAgICBnZXRQb2ludENvbnRhaW5lcigpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludENvbnRhaW5lcjtcXHJcXG4gICAgfVxcclxcbiAgICAvLyBUT1RSWTogdXNlIEhVU0wgLSBodHRwOi8vYm9yb25pbmUuY29tL2h1c2wvXFxyXFxuICAgIC8qXFxyXFxuICAgICBwdWJsaWMgbmVhcmVzdEluZGV4QnlVaW50MzIoaTMyKSB7XFxyXFxuICAgICB2YXIgaWR4IDogbnVtYmVyID0gdGhpcy5fbmVhcmVzdFBvaW50RnJvbUNhY2hlKFxcXCJcXFwiICsgaTMyKTtcXHJcXG4gICAgIGlmIChpZHggPj0gMCkgcmV0dXJuIGlkeDtcXHJcXG4gIFxcclxcbiAgICAgdmFyIG1pbiA9IDEwMDAsXFxyXFxuICAgICByZ2IgPSBbXFxyXFxuICAgICAoaTMyICYgMHhmZiksXFxyXFxuICAgICAoaTMyID4+PiA4KSAmIDB4ZmYsXFxyXFxuICAgICAoaTMyID4+PiAxNikgJiAweGZmLFxcclxcbiAgICAgKGkzMiA+Pj4gMjQpICYgMHhmZlxcclxcbiAgICAgXSxcXHJcXG4gICAgIGxlbiA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xcclxcbiAgXFxyXFxuICAgICBpZHggPSAwO1xcclxcbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgdmFyIGRpc3QgPSBVdGlscy5kaXN0RXVjbGlkZWFuKHJnYiwgdGhpcy5fcG9pbnRBcnJheVtpXS5yZ2JhKTtcXHJcXG4gIFxcclxcbiAgICAgaWYgKGRpc3QgPCBtaW4pIHtcXHJcXG4gICAgIG1pbiA9IGRpc3Q7XFxyXFxuICAgICBpZHggPSBpO1xcclxcbiAgICAgfVxcclxcbiAgICAgfVxcclxcbiAgXFxyXFxuICAgICB0aGlzLl9pMzJpZHhbaTMyXSA9IGlkeDtcXHJcXG4gICAgIHJldHVybiBpZHg7XFxyXFxuICAgICB9XFxyXFxuICAgICAqL1xcclxcbiAgICBfbmVhcmVzdFBvaW50RnJvbUNhY2hlKGtleSkge1xcclxcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9pMzJpZHhba2V5XSA9PT0gJ251bWJlcicgPyB0aGlzLl9pMzJpZHhba2V5XSA6IC0xO1xcclxcbiAgICB9XFxyXFxuICAgIF9nZXROZWFyZXN0SW5kZXgoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIHBvaW50KSB7XFxyXFxuICAgICAgICBsZXQgaWR4ID0gdGhpcy5fbmVhcmVzdFBvaW50RnJvbUNhY2hlKCcnICsgcG9pbnQudWludDMyKTtcXHJcXG4gICAgICAgIGlmIChpZHggPj0gMClcXHJcXG4gICAgICAgICAgICByZXR1cm4gaWR4O1xcclxcbiAgICAgICAgbGV0IG1pbmltYWxEaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XFxyXFxuICAgICAgICBpZHggPSAwO1xcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xcclxcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9wb2ludEFycmF5W2ldO1xcclxcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IuY2FsY3VsYXRlUmF3KHBvaW50LnIsIHBvaW50LmcsIHBvaW50LmIsIHBvaW50LmEsIHAuciwgcC5nLCBwLmIsIHAuYSk7XFxyXFxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluaW1hbERpc3RhbmNlKSB7XFxyXFxuICAgICAgICAgICAgICAgIG1pbmltYWxEaXN0YW5jZSA9IGRpc3RhbmNlO1xcclxcbiAgICAgICAgICAgICAgICBpZHggPSBpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHRoaXMuX2kzMmlkeFtwb2ludC51aW50MzJdID0gaWR4O1xcclxcbiAgICAgICAgcmV0dXJuIGlkeDtcXHJcXG4gICAgfVxcclxcbiAgICAvKlxcclxcbiAgICAgcHVibGljIHJlZHVjZShoaXN0b2dyYW0gOiBDb2xvckhpc3RvZ3JhbSwgY29sb3JzIDogbnVtYmVyKSB7XFxyXFxuICAgICBpZiAodGhpcy5fcG9pbnRBcnJheS5sZW5ndGggPiBjb2xvcnMpIHtcXHJcXG4gICAgIHZhciBpZHhpMzIgPSBoaXN0b2dyYW0uZ2V0SW1wb3J0YW5jZVNvcnRlZENvbG9yc0lEWEkzMigpO1xcclxcbiAgXFxyXFxuICAgICAvLyBxdWFudGl6ZSBoaXN0b2dyYW0gdG8gZXhpc3RpbmcgcGFsZXR0ZVxcclxcbiAgICAgdmFyIGtlZXAgPSBbXSwgdW5pcXVlQ29sb3JzID0gMCwgaWR4LCBwcnVuZWQgPSBmYWxzZTtcXHJcXG4gIFxcclxcbiAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkeGkzMi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgLy8gcGFsZXR0ZSBsZW5ndGggcmVhY2hlZCwgdW5zZXQgYWxsIHJlbWFpbmluZyBjb2xvcnMgKHNwYXJzZSBwYWxldHRlKVxcclxcbiAgICAgaWYgKHVuaXF1ZUNvbG9ycyA+PSBjb2xvcnMpIHtcXHJcXG4gICAgIHRoaXMucHJ1bmVQYWwoa2VlcCk7XFxyXFxuICAgICBwcnVuZWQgPSB0cnVlO1xcclxcbiAgICAgYnJlYWs7XFxyXFxuICAgICB9IGVsc2Uge1xcclxcbiAgICAgaWR4ID0gdGhpcy5uZWFyZXN0SW5kZXhCeVVpbnQzMihpZHhpMzJbaV0pO1xcclxcbiAgICAgaWYgKGtlZXAuaW5kZXhPZihpZHgpIDwgMCkge1xcclxcbiAgICAga2VlcC5wdXNoKGlkeCk7XFxyXFxuICAgICB1bmlxdWVDb2xvcnMrKztcXHJcXG4gICAgIH1cXHJcXG4gICAgIH1cXHJcXG4gICAgIH1cXHJcXG4gIFxcclxcbiAgICAgaWYgKCFwcnVuZWQpIHtcXHJcXG4gICAgIHRoaXMucHJ1bmVQYWwoa2VlcCk7XFxyXFxuICAgICB9XFxyXFxuICAgICB9XFxyXFxuICAgICB9XFxyXFxuICBcXHJcXG4gICAgIC8vIFRPRE86IGNoZWNrIHVzYWdlLCBub3QgdGVzdGVkIVxcclxcbiAgICAgcHVibGljIHBydW5lUGFsKGtlZXAgOiBudW1iZXJbXSkge1xcclxcbiAgICAgdmFyIGNvbG9ycyA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xcclxcbiAgICAgZm9yICh2YXIgY29sb3JJbmRleCA9IGNvbG9ycyAtIDE7IGNvbG9ySW5kZXggPj0gMDsgY29sb3JJbmRleC0tKSB7XFxyXFxuICAgICBpZiAoa2VlcC5pbmRleE9mKGNvbG9ySW5kZXgpIDwgMCkge1xcclxcbiAgXFxyXFxuICAgICBpZihjb2xvckluZGV4ICsgMSA8IGNvbG9ycykge1xcclxcbiAgICAgdGhpcy5fcG9pbnRBcnJheVsgY29sb3JJbmRleCBdID0gdGhpcy5fcG9pbnRBcnJheSBbIGNvbG9ycyAtIDEgXTtcXHJcXG4gICAgIH1cXHJcXG4gICAgIC0tY29sb3JzO1xcclxcbiAgICAgLy90aGlzLl9wb2ludEFycmF5W2NvbG9ySW5kZXhdID0gbnVsbDtcXHJcXG4gICAgIH1cXHJcXG4gICAgIH1cXHJcXG4gICAgIGNvbnNvbGUubG9nKFxcXCJjb2xvcnMgcHJ1bmVkOiBcXFwiICsgKHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoIC0gY29sb3JzKSk7XFxyXFxuICAgICB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aCA9IGNvbG9ycztcXHJcXG4gICAgIHRoaXMuX2kzMmlkeCA9IHt9O1xcclxcbiAgICAgfVxcclxcbiAgICAgKi9cXHJcXG4gICAgLy8gVE9ETzogZ3JvdXAgdmVyeSBsb3cgbHVtIGFuZCB2ZXJ5IGhpZ2ggbHVtIGNvbG9yc1xcclxcbiAgICAvLyBUT0RPOiBwYXNzIGN1c3RvbSBzb3J0IG9yZGVyXFxyXFxuICAgIC8vIFRPRE86IHNvcnQgY3JpdGVyaWEgZnVuY3Rpb24gc2hvdWxkIGJlIHBsYWNlZCB0byBIdWVTdGF0cyBjbGFzc1xcclxcbiAgICBzb3J0KCkge1xcclxcbiAgICAgICAgdGhpcy5faTMyaWR4ID0ge307XFxyXFxuICAgICAgICB0aGlzLl9wb2ludEFycmF5LnNvcnQoKGEsIGIpID0+IHtcXHJcXG4gICAgICAgICAgICBjb25zdCBoc2xBID0gT2JqZWN0KF9jb252ZXJzaW9uX3JnYjJoc2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicmdiMmhzbFxcXCJdKShhLnIsIGEuZywgYS5iKTtcXHJcXG4gICAgICAgICAgICBjb25zdCBoc2xCID0gT2JqZWN0KF9jb252ZXJzaW9uX3JnYjJoc2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicmdiMmhzbFxcXCJdKShiLnIsIGIuZywgYi5iKTtcXHJcXG4gICAgICAgICAgICAvLyBzb3J0IGFsbCBncmF5cyArIHdoaXRlcyB0b2dldGhlclxcclxcbiAgICAgICAgICAgIGNvbnN0IGh1ZUEgPSAoYS5yID09PSBhLmcgJiYgYS5nID09PSBhLmIpID8gMCA6IDEgKyBodWVHcm91cChoc2xBLmgsIGh1ZUdyb3Vwcyk7XFxyXFxuICAgICAgICAgICAgY29uc3QgaHVlQiA9IChiLnIgPT09IGIuZyAmJiBiLmcgPT09IGIuYikgPyAwIDogMSArIGh1ZUdyb3VwKGhzbEIuaCwgaHVlR3JvdXBzKTtcXHJcXG4gICAgICAgICAgICAvKlxcclxcbiAgICAgICAgICAgICB2YXIgaHVlQSA9IChhLnIgPT09IGEuZyAmJiBhLmcgPT09IGEuYikgPyAwIDogMSArIFV0aWxzLmh1ZUdyb3VwKGhzbEEuaCwgaHVlR3JvdXBzKTtcXHJcXG4gICAgICAgICAgICAgdmFyIGh1ZUIgPSAoYi5yID09PSBiLmcgJiYgYi5nID09PSBiLmIpID8gMCA6IDEgKyBVdGlscy5odWVHcm91cChoc2xCLmgsIGh1ZUdyb3Vwcyk7XFxyXFxuICAgICAgICAgICAgICovXFxyXFxuICAgICAgICAgICAgY29uc3QgaHVlRGlmZiA9IGh1ZUIgLSBodWVBO1xcclxcbiAgICAgICAgICAgIGlmIChodWVEaWZmKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gLWh1ZURpZmY7XFxyXFxuICAgICAgICAgICAgLypcXHJcXG4gICAgICAgICAgICAgdmFyIGx1bURpZmYgPSBVdGlscy5sdW1Hcm91cCgraHNsQi5sLnRvRml4ZWQoMikpIC0gVXRpbHMubHVtR3JvdXAoK2hzbEEubC50b0ZpeGVkKDIpKTtcXHJcXG4gICAgICAgICAgICAgaWYgKGx1bURpZmYpIHJldHVybiAtbHVtRGlmZjtcXHJcXG4gICAgICAgICAgICAgKi9cXHJcXG4gICAgICAgICAgICBjb25zdCBsQSA9IGEuZ2V0THVtaW5vc2l0eSh0cnVlKTtcXHJcXG4gICAgICAgICAgICBjb25zdCBsQiA9IGIuZ2V0THVtaW5vc2l0eSh0cnVlKTtcXHJcXG4gICAgICAgICAgICBpZiAobEIgLSBsQSAhPT0gMClcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxCIC0gbEE7XFxyXFxuICAgICAgICAgICAgY29uc3Qgc2F0RGlmZiA9ICgoaHNsQi5zICogMTAwKSB8IDApIC0gKChoc2xBLnMgKiAxMDApIHwgMCk7XFxyXFxuICAgICAgICAgICAgaWYgKHNhdERpZmYpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAtc2F0RGlmZjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gMDtcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhbGV0dGUuanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcG9pbnQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BvaW50LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFBvaW50ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiUG9pbnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBvaW50OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29uc3RhbnRzL2J0NzA5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2NvbnN0YW50cy9idDcwOS5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEBwcmVzZXJ2ZVxcclxcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXFxyXFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcXHJcXG4gKlxcclxcbiAqIHBvaW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxcclxcbiAqL1xcclxcblxcclxcbi8qKlxcclxcbiAqIHY4IG9wdGltaXplZCBjbGFzc1xcclxcbiAqIDEpIFxcXCJjb25zdHJ1Y3RvclxcXCIgc2hvdWxkIGhhdmUgaW5pdGlhbGl6YXRpb24gd2l0aCB3b3JzdCB0eXBlc1xcclxcbiAqIDIpIFxcXCJzZXRcXFwiIHNob3VsZCBoYXZlIHwwIC8gPj4+IDBcXHJcXG4gKi9cXHJcXG5jbGFzcyBQb2ludCB7XFxyXFxuICAgIC8vIExhYiA6IHsgTCA6IG51bWJlcjsgYSA6IG51bWJlcjsgYiA6IG51bWJlciB9O1xcclxcbiAgICBzdGF0aWMgY3JlYXRlQnlRdWFkcnVwbGV0KHF1YWRydXBsZXQpIHtcXHJcXG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KCk7XFxyXFxuICAgICAgICBwb2ludC5yID0gcXVhZHJ1cGxldFswXSB8IDA7XFxyXFxuICAgICAgICBwb2ludC5nID0gcXVhZHJ1cGxldFsxXSB8IDA7XFxyXFxuICAgICAgICBwb2ludC5iID0gcXVhZHJ1cGxldFsyXSB8IDA7XFxyXFxuICAgICAgICBwb2ludC5hID0gcXVhZHJ1cGxldFszXSB8IDA7XFxyXFxuICAgICAgICBwb2ludC5fbG9hZFVJTlQzMigpO1xcclxcbiAgICAgICAgcG9pbnQuX2xvYWRRdWFkcnVwbGV0KCk7XFxyXFxuICAgICAgICAvLyBwb2ludC5fbG9hZExhYigpO1xcclxcbiAgICAgICAgcmV0dXJuIHBvaW50O1xcclxcbiAgICB9XFxyXFxuICAgIHN0YXRpYyBjcmVhdGVCeVJHQkEocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcXHJcXG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KCk7XFxyXFxuICAgICAgICBwb2ludC5yID0gcmVkIHwgMDtcXHJcXG4gICAgICAgIHBvaW50LmcgPSBncmVlbiB8IDA7XFxyXFxuICAgICAgICBwb2ludC5iID0gYmx1ZSB8IDA7XFxyXFxuICAgICAgICBwb2ludC5hID0gYWxwaGEgfCAwO1xcclxcbiAgICAgICAgcG9pbnQuX2xvYWRVSU5UMzIoKTtcXHJcXG4gICAgICAgIHBvaW50Ll9sb2FkUXVhZHJ1cGxldCgpO1xcclxcbiAgICAgICAgLy8gcG9pbnQuX2xvYWRMYWIoKTtcXHJcXG4gICAgICAgIHJldHVybiBwb2ludDtcXHJcXG4gICAgfVxcclxcbiAgICBzdGF0aWMgY3JlYXRlQnlVaW50MzIodWludDMyKSB7XFxyXFxuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCgpO1xcclxcbiAgICAgICAgcG9pbnQudWludDMyID0gdWludDMyID4+PiAwO1xcclxcbiAgICAgICAgcG9pbnQuX2xvYWRSR0JBKCk7XFxyXFxuICAgICAgICBwb2ludC5fbG9hZFF1YWRydXBsZXQoKTtcXHJcXG4gICAgICAgIC8vIHBvaW50Ll9sb2FkTGFiKCk7XFxyXFxuICAgICAgICByZXR1cm4gcG9pbnQ7XFxyXFxuICAgIH1cXHJcXG4gICAgY29uc3RydWN0b3IoKSB7XFxyXFxuICAgICAgICB0aGlzLnVpbnQzMiA9IC0xID4+PiAwO1xcclxcbiAgICAgICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gdGhpcy5hID0gMDtcXHJcXG4gICAgICAgIHRoaXMucmdiYSA9IG5ldyBBcnJheSg0KTtcXHJcXG4gICAgICAgIHRoaXMucmdiYVswXSA9IDA7XFxyXFxuICAgICAgICB0aGlzLnJnYmFbMV0gPSAwO1xcclxcbiAgICAgICAgdGhpcy5yZ2JhWzJdID0gMDtcXHJcXG4gICAgICAgIHRoaXMucmdiYVszXSA9IDA7XFxyXFxuICAgICAgICAvKlxcclxcbiAgICAgICAgIHRoaXMuTGFiID0ge1xcclxcbiAgICAgICAgIEwgOiAwLjAsXFxyXFxuICAgICAgICAgYSA6IDAuMCxcXHJcXG4gICAgICAgICBiIDogMC4wXFxyXFxuICAgICAgICAgfTtcXHJcXG4gICAgICAgICAqL1xcclxcbiAgICB9XFxyXFxuICAgIGZyb20ocG9pbnQpIHtcXHJcXG4gICAgICAgIHRoaXMuciA9IHBvaW50LnI7XFxyXFxuICAgICAgICB0aGlzLmcgPSBwb2ludC5nO1xcclxcbiAgICAgICAgdGhpcy5iID0gcG9pbnQuYjtcXHJcXG4gICAgICAgIHRoaXMuYSA9IHBvaW50LmE7XFxyXFxuICAgICAgICB0aGlzLnVpbnQzMiA9IHBvaW50LnVpbnQzMjtcXHJcXG4gICAgICAgIHRoaXMucmdiYVswXSA9IHBvaW50LnI7XFxyXFxuICAgICAgICB0aGlzLnJnYmFbMV0gPSBwb2ludC5nO1xcclxcbiAgICAgICAgdGhpcy5yZ2JhWzJdID0gcG9pbnQuYjtcXHJcXG4gICAgICAgIHRoaXMucmdiYVszXSA9IHBvaW50LmE7XFxyXFxuICAgICAgICAvKlxcclxcbiAgICAgICAgIHRoaXMuTGFiLkwgPSBwb2ludC5MYWIuTDtcXHJcXG4gICAgICAgICB0aGlzLkxhYi5hID0gcG9pbnQuTGFiLmE7XFxyXFxuICAgICAgICAgdGhpcy5MYWIuYiA9IHBvaW50LkxhYi5iO1xcclxcbiAgICAgICAgICovXFxyXFxuICAgIH1cXHJcXG4gICAgLypcXHJcXG4gICAgICogVE9ETzpcXHJcXG4gICAgIEx1bWluYW5jZSBmcm9tIFJHQjpcXHJcXG4gIFxcclxcbiAgICAgTHVtaW5hbmNlIChzdGFuZGFyZCBmb3IgY2VydGFpbiBjb2xvdXIgc3BhY2VzKTogKDAuMjEyNipSICsgMC43MTUyKkcgKyAwLjA3MjIqQikgWzFdXFxyXFxuICAgICBMdW1pbmFuY2UgKHBlcmNlaXZlZCBvcHRpb24gMSk6ICgwLjI5OSpSICsgMC41ODcqRyArIDAuMTE0KkIpIFsyXVxcclxcbiAgICAgTHVtaW5hbmNlIChwZXJjZWl2ZWQgb3B0aW9uIDIsIHNsb3dlciB0byBjYWxjdWxhdGUpOiAgc3FydCggMC4yNDEqUl4yICsgMC42OTEqR14yICsgMC4wNjgqQl4yICkgPyBzcXJ0KCAwLjI5OSpSXjIgKyAwLjU4NypHXjIgKyAwLjExNCpCXjIgKSAodGhhbmtzIHRvIEBNYXR0aGV3SGVyYnN0KSBbaHR0cDovL2FsaWVucnlkZXJmbGV4LmNvbS9oc3AuaHRtbF1cXHJcXG4gICAgICovXFxyXFxuICAgIGdldEx1bWlub3NpdHkodXNlQWxwaGFDaGFubmVsKSB7XFxyXFxuICAgICAgICBsZXQgciA9IHRoaXMucjtcXHJcXG4gICAgICAgIGxldCBnID0gdGhpcy5nO1xcclxcbiAgICAgICAgbGV0IGIgPSB0aGlzLmI7XFxyXFxuICAgICAgICBpZiAodXNlQWxwaGFDaGFubmVsKSB7XFxyXFxuICAgICAgICAgICAgciA9IE1hdGgubWluKDI1NSwgMjU1IC0gdGhpcy5hICsgdGhpcy5hICogciAvIDI1NSk7XFxyXFxuICAgICAgICAgICAgZyA9IE1hdGgubWluKDI1NSwgMjU1IC0gdGhpcy5hICsgdGhpcy5hICogZyAvIDI1NSk7XFxyXFxuICAgICAgICAgICAgYiA9IE1hdGgubWluKDI1NSwgMjU1IC0gdGhpcy5hICsgdGhpcy5hICogYiAvIDI1NSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyB2YXIgbHVtYSA9IHRoaXMuciAqIFBvaW50Ll9SRURfQ09FRkZJQ0lFTlQgKyB0aGlzLmcgKiBQb2ludC5fR1JFRU5fQ09FRkZJQ0lFTlQgKyB0aGlzLmIgKiBQb2ludC5fQkxVRV9DT0VGRklDSUVOVDtcXHJcXG4gICAgICAgIC8qXFxyXFxuICAgICAgICAgaWYodXNlQWxwaGFDaGFubmVsKSB7XFxyXFxuICAgICAgICAgbHVtYSA9IChsdW1hICogKDI1NSAtIHRoaXMuYSkpIC8gMjU1O1xcclxcbiAgICAgICAgIH1cXHJcXG4gICAgICAgICAqL1xcclxcbiAgICAgICAgcmV0dXJuIHIgKiBfY29uc3RhbnRzX2J0NzA5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIllcXFwiXS5SRUQgKyBnICogX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJZXFxcIl0uR1JFRU4gKyBiICogX2NvbnN0YW50c19idDcwOV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJZXFxcIl0uQkxVRTtcXHJcXG4gICAgfVxcclxcbiAgICBfbG9hZFVJTlQzMigpIHtcXHJcXG4gICAgICAgIHRoaXMudWludDMyID0gKHRoaXMuYSA8PCAyNCB8IHRoaXMuYiA8PCAxNiB8IHRoaXMuZyA8PCA4IHwgdGhpcy5yKSA+Pj4gMDtcXHJcXG4gICAgfVxcclxcbiAgICBfbG9hZFJHQkEoKSB7XFxyXFxuICAgICAgICB0aGlzLnIgPSB0aGlzLnVpbnQzMiAmIDB4ZmY7XFxyXFxuICAgICAgICB0aGlzLmcgPSAodGhpcy51aW50MzIgPj4+IDgpICYgMHhmZjtcXHJcXG4gICAgICAgIHRoaXMuYiA9ICh0aGlzLnVpbnQzMiA+Pj4gMTYpICYgMHhmZjtcXHJcXG4gICAgICAgIHRoaXMuYSA9ICh0aGlzLnVpbnQzMiA+Pj4gMjQpICYgMHhmZjtcXHJcXG4gICAgfVxcclxcbiAgICBfbG9hZFF1YWRydXBsZXQoKSB7XFxyXFxuICAgICAgICB0aGlzLnJnYmFbMF0gPSB0aGlzLnI7XFxyXFxuICAgICAgICB0aGlzLnJnYmFbMV0gPSB0aGlzLmc7XFxyXFxuICAgICAgICB0aGlzLnJnYmFbMl0gPSB0aGlzLmI7XFxyXFxuICAgICAgICB0aGlzLnJnYmFbM10gPSB0aGlzLmE7XFxyXFxuICAgICAgICAvKlxcclxcbiAgICAgICAgIHZhciB4eXogPSByZ2IyeHl6KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xcclxcbiAgICAgICAgIHZhciBsYWIgPSB4eXoybGFiKHh5ei54LCB4eXoueSwgeHl6LnopO1xcclxcbiAgICAgICAgIHRoaXMubGFiLmwgPSBsYWIubDtcXHJcXG4gICAgICAgICB0aGlzLmxhYi5hID0gbGFiLmE7XFxyXFxuICAgICAgICAgdGhpcy5sYWIuYiA9IGxhYi5iO1xcclxcbiAgICAgICAgICovXFxyXFxuICAgIH1cXHJcXG59XFxyXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9pbnQuanMubWFwXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9lc20vdXRpbHMvcG9pbnRDb250YWluZXIuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BvaW50Q29udGFpbmVyLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFBvaW50Q29udGFpbmVyICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiUG9pbnRDb250YWluZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBvaW50Q29udGFpbmVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BvaW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BvaW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3BvaW50LmpzXFxcIik7XFxuLyoqXFxyXFxuICogQHByZXNlcnZlXFxyXFxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcXHJcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxcclxcbiAqXFxyXFxuICogcG9pbnRDb250YWluZXIudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XFxyXFxuICovXFxyXFxuXFxyXFxuLyoqXFxyXFxuICogdjggb3B0aW1pemF0aW9ucyBkb25lLlxcclxcbiAqIGZyb21YWFggbWV0aG9kcyBhcmUgc3RhdGljIHRvIG1vdmUgb3V0IHBvbHltb3JwaGljIGNvZGUgZnJvbSBjbGFzcyBpbnN0YW5jZSBpdHNlbGYuXFxyXFxuICovXFxyXFxuY2xhc3MgUG9pbnRDb250YWluZXIge1xcclxcbiAgICBjb25zdHJ1Y3RvcigpIHtcXHJcXG4gICAgICAgIHRoaXMuX3dpZHRoID0gMDtcXHJcXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IDA7XFxyXFxuICAgICAgICB0aGlzLl9wb2ludEFycmF5ID0gW107XFxyXFxuICAgIH1cXHJcXG4gICAgZ2V0V2lkdGgoKSB7XFxyXFxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XFxyXFxuICAgIH1cXHJcXG4gICAgZ2V0SGVpZ2h0KCkge1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcXHJcXG4gICAgfVxcclxcbiAgICBzZXRXaWR0aCh3aWR0aCkge1xcclxcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcXHJcXG4gICAgfVxcclxcbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XFxyXFxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XFxyXFxuICAgIH1cXHJcXG4gICAgZ2V0UG9pbnRBcnJheSgpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludEFycmF5O1xcclxcbiAgICB9XFxyXFxuICAgIGNsb25lKCkge1xcclxcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgUG9pbnRDb250YWluZXIoKTtcXHJcXG4gICAgICAgIGNsb25lLl93aWR0aCA9IHRoaXMuX3dpZHRoO1xcclxcbiAgICAgICAgY2xvbmUuX2hlaWdodCA9IHRoaXMuX2hlaWdodDtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBjbG9uZS5fcG9pbnRBcnJheVtpXSA9IF9wb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJQb2ludFxcXCJdLmNyZWF0ZUJ5VWludDMyKHRoaXMuX3BvaW50QXJyYXlbaV0udWludDMyIHwgMCk7IC8vIFxcXCJ8IDBcXFwiIGlzIGFkZGVkIGZvciB2OCBvcHRpbWl6YXRpb25cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBjbG9uZTtcXHJcXG4gICAgfVxcclxcbiAgICB0b1VpbnQzMkFycmF5KCkge1xcclxcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xcclxcbiAgICAgICAgY29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkobCk7XFxyXFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xcclxcbiAgICAgICAgICAgIHVpbnQzMkFycmF5W2ldID0gdGhpcy5fcG9pbnRBcnJheVtpXS51aW50MzI7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gdWludDMyQXJyYXk7XFxyXFxuICAgIH1cXHJcXG4gICAgdG9VaW50OEFycmF5KCkge1xcclxcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMudG9VaW50MzJBcnJheSgpLmJ1ZmZlcik7XFxyXFxuICAgIH1cXHJcXG4gICAgc3RhdGljIGZyb21IVE1MSW1hZ2VFbGVtZW50KGltZykge1xcclxcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWcubmF0dXJhbFdpZHRoO1xcclxcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1nLm5hdHVyYWxIZWlnaHQ7XFxyXFxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcXHJcXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xcclxcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcXHJcXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW5vbi1udWxsLWFzc2VydGlvblxcclxcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xcclxcbiAgICAgICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21IVE1MQ2FudmFzRWxlbWVudChjYW52YXMpO1xcclxcbiAgICB9XFxyXFxuICAgIHN0YXRpYyBmcm9tSFRNTENhbnZhc0VsZW1lbnQoY2FudmFzKSB7XFxyXFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aDtcXHJcXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XFxyXFxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1ub24tbnVsbC1hc3NlcnRpb25cXHJcXG4gICAgICAgIGNvbnN0IGltZ0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xcclxcbiAgICAgICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21JbWFnZURhdGEoaW1nRGF0YSk7XFxyXFxuICAgIH1cXHJcXG4gICAgc3RhdGljIGZyb21JbWFnZURhdGEoaW1hZ2VEYXRhKSB7XFxyXFxuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlRGF0YS53aWR0aDtcXHJcXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XFxyXFxuICAgICAgICByZXR1cm4gUG9pbnRDb250YWluZXIuZnJvbVVpbnQ4QXJyYXkoaW1hZ2VEYXRhLmRhdGEsIHdpZHRoLCBoZWlnaHQpO1xcclxcbiAgICB9XFxyXFxuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheSh1aW50OEFycmF5LCB3aWR0aCwgaGVpZ2h0KSB7XFxyXFxuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh1aW50OEFycmF5KSkge1xcclxcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzpcXHJcXG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IFVpbnQ4QXJyYXldJzpcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgZGVmYXVsdDpcXHJcXG4gICAgICAgICAgICAgICAgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KHVpbnQ4QXJyYXkpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgY29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkodWludDhBcnJheS5idWZmZXIpO1xcclxcbiAgICAgICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21VaW50MzJBcnJheSh1aW50MzJBcnJheSwgd2lkdGgsIGhlaWdodCk7XFxyXFxuICAgIH1cXHJcXG4gICAgc3RhdGljIGZyb21VaW50MzJBcnJheSh1aW50MzJBcnJheSwgd2lkdGgsIGhlaWdodCkge1xcclxcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbmV3IFBvaW50Q29udGFpbmVyKCk7XFxyXFxuICAgICAgICBjb250YWluZXIuX3dpZHRoID0gd2lkdGg7XFxyXFxuICAgICAgICBjb250YWluZXIuX2hlaWdodCA9IGhlaWdodDtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdWludDMyQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgY29udGFpbmVyLl9wb2ludEFycmF5W2ldID0gX3BvaW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIlBvaW50XFxcIl0uY3JlYXRlQnlVaW50MzIodWludDMyQXJyYXlbaV0gfCAwKTsgLy8gXFxcInwgMFxcXCIgaXMgYWRkZWQgZm9yIHY4IG9wdGltaXphdGlvblxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcXHJcXG4gICAgfVxcclxcbiAgICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQpIHtcXHJcXG4gICAgICAgIGNvbnN0IHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCAvIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcXHJcXG4gICAgICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tVWludDMyQXJyYXkodWludDMyQXJyYXksIHdpZHRoLCBoZWlnaHQpO1xcclxcbiAgICB9XFxyXFxufVxcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvaW50Q29udGFpbmVyLmpzLm1hcFxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3Byb2dyZXNzVHJhY2tlci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL3V0aWxzL3Byb2dyZXNzVHJhY2tlci5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogUHJvZ3Jlc3NUcmFja2VyICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiUHJvZ3Jlc3NUcmFja2VyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQcm9ncmVzc1RyYWNrZXI7IH0pO1xcbmNsYXNzIFByb2dyZXNzVHJhY2tlciB7XFxyXFxuICAgIGNvbnN0cnVjdG9yKHZhbHVlUmFuZ2UsIHByb2dyZXNzUmFuZ2UpIHtcXHJcXG4gICAgICAgIHRoaXMuX3JhbmdlID0gdmFsdWVSYW5nZTtcXHJcXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzUmFuZ2UgPSBwcm9ncmVzc1JhbmdlO1xcclxcbiAgICAgICAgdGhpcy5fc3RlcCA9IE1hdGgubWF4KDEsIHRoaXMuX3JhbmdlIC8gKFByb2dyZXNzVHJhY2tlci5zdGVwcyArIDEpIHwgMCk7XFxyXFxuICAgICAgICB0aGlzLl9sYXN0ID0gLXRoaXMuX3N0ZXA7XFxyXFxuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcXHJcXG4gICAgfVxcclxcbiAgICBzaG91bGROb3RpZnkoY3VycmVudCkge1xcclxcbiAgICAgICAgaWYgKGN1cnJlbnQgLSB0aGlzLl9sYXN0ID49IHRoaXMuX3N0ZXApIHtcXHJcXG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gY3VycmVudDtcXHJcXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gTWF0aC5taW4odGhpcy5fcHJvZ3Jlc3NSYW5nZSAqIHRoaXMuX2xhc3QgLyB0aGlzLl9yYW5nZSwgdGhpcy5fcHJvZ3Jlc3NSYW5nZSk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuUHJvZ3Jlc3NUcmFja2VyLnN0ZXBzID0gMTAwO1xcclxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2dyZXNzVHJhY2tlci5qcy5tYXBcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvQW5pbWF0ZWRfR0lGLndvcmtlci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vc3JjL0FuaW1hdGVkX0dJRi53b3JrZXIuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gZXhwb3J0cyBwcm92aWRlZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBpbWFnZV9xX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpbWFnZS1xICovIFxcXCIuL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvZXNtL2ltYWdlLXEuanNcXFwiKTtcXG5cXG5cXG4vKipcXG4gKiBTZWFyY2hlcyBmb3IgYW4gdW51c2VkIGNvbG91ciBpbiB0aGUgaW1hZ2UgZGF0YSBzbyBpdCBjYW4gYmUgdXNlZCBhcyBhIHVuaXF1ZSBjb2xvdXJcXG4gKiBmb3IgdHJhbnNwYXJlbnQgcGl4ZWxzLiBCdWlsZHMgdXAgYSBzZXQgb2YgYWxsIGtub3duIGNvbG91cnMgdGhlbiBzZWFyY2hlcyBmcm9tXFxuICogMHgwMDAwMDAgdG8gMHhGRkZGRkYgZm9yIGEgY29sb3VyIG5vdCBpbiB0aGUgc2V0LiBUaGV5J3JlIGlzIHByb2JhYmx5IGEgbXVjaCBtb3JlIGVmZmVjaWVudFxcbiAqIHdheSBvZiBkb2luZyB0aGlzLiBUaGVyZSBpcyBhbHNvIGEgcG9zc2liaWx0eSBhbGwgY29sb3VycyBhcmUgdXNlZCwgYnV0IHRoYXQncyBwcm9iYWJseVxcbiAqIGp1c3QgYSB0ZXN0IGltYWdlLlxcbiAqIEBwYXJhbSB7Kn0gZGF0YVxcbiAqIEBwYXJhbSB7Kn0gd2lkdGhcXG4gKiBAcGFyYW0geyp9IGhlaWdodFxcbiAqL1xcbmZ1bmN0aW9uIHNlYXJjaEZvclVudXNlZENvbG91cihkYXRhLCB3aWR0aCwgaGVpZ2h0KSB7XFxuICBsZXQgaSA9IDBcXG4gIGNvbnN0IGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogNFxcbiAgY29uc3Qga25vd25Db2xvdXJzID0gbmV3IFNldCgpXFxuXFxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xcbiAgICBjb25zdCByID0gZGF0YVtpKytdXFxuICAgIGNvbnN0IGcgPSBkYXRhW2krK11cXG4gICAgY29uc3QgYiA9IGRhdGFbaSsrXVxcbiAgICBpKysgLy8gZG9uJ3QgdHJhY2sgdGhlIHRyYW5zcGFyZW5jeSBoZXJlIGp1c3QgdGhlIHJnYiB2YWx1ZXNcXG4gICAgY29uc3QgcGl4ZWxDb2xvdXIgPSAociA8PCAxNikgfCAoZyA8PCA4KSB8IGJcXG4gICAga25vd25Db2xvdXJzLmFkZChwaXhlbENvbG91cilcXG4gIH1cXG5cXG4gIGxldCB1bnVzZWRDb2xvdXIgPSAweDAwXFxuICB3aGlsZSAodW51c2VkQ29sb3VyIDwgMHhmZmZmZmYpIHtcXG4gICAgaWYgKCFrbm93bkNvbG91cnMuaGFzKHVudXNlZENvbG91cikpIGJyZWFrXFxuICAgIHVudXNlZENvbG91cisrXFxuICB9XFxuXFxuICByZXR1cm4gdW51c2VkQ29sb3VyXFxufVxcblxcbmZ1bmN0aW9uIGRhdGFUb1JHQkFOb3JtYWxpemVkKFxcbiAgZGF0YSxcXG4gIHdpZHRoLFxcbiAgaGVpZ2h0LFxcbiAgdW51c2VkQ29sb3VyLFxcbiAgdHJhbnNwYXJlbmN5Q3V0T2ZmID0gMC43XFxuKSB7XFxuICBsZXQgaSA9IDBcXG4gIGNvbnN0IGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogNFxcbiAgY29uc3QgcmdiYSA9IFtdXFxuICBjb25zdCB0cmFuc3BhcmVuY3lDdXRPZmZWYWx1ZSA9IE1hdGgudHJ1bmMoMjU1ICogdHJhbnNwYXJlbmN5Q3V0T2ZmKVxcbiAgbGV0IGhhc1RyYW5zcGFyZW5jeSA9IGZhbHNlXFxuXFxuICBjb25zdCB1bnVzZWRDb2xvdXJSID0gKHVudXNlZENvbG91ciAmIDB4ZmYwMDAwKSA+PiAxNlxcbiAgY29uc3QgdW51c2VkQ29sb3VyRyA9ICh1bnVzZWRDb2xvdXIgJiAweDAwZmYwMCkgPj4gOFxcbiAgY29uc3QgdW51c2VkQ29sb3VyQiA9IHVudXNlZENvbG91ciAmIDB4MDAwMGZmXFxuXFxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xcbiAgICBjb25zdCByID0gZGF0YVtpKytdXFxuICAgIGNvbnN0IGcgPSBkYXRhW2krK11cXG4gICAgY29uc3QgYiA9IGRhdGFbaSsrXVxcbiAgICBsZXQgYSA9IGRhdGFbaSsrXVxcbiAgICBhID0gYSA+PSB0cmFuc3BhcmVuY3lDdXRPZmZWYWx1ZSA/IDB4ZmYgOiAweDAwXFxuXFxuICAgIGlmICh1bnVzZWRDb2xvdXIgIT09IHVuZGVmaW5lZCAmJiBhID09PSAwKSB7XFxuICAgICAgcmdiYS5wdXNoKHVudXNlZENvbG91clIpXFxuICAgICAgcmdiYS5wdXNoKHVudXNlZENvbG91ckcpXFxuICAgICAgcmdiYS5wdXNoKHVudXNlZENvbG91ckIpXFxuICAgICAgcmdiYS5wdXNoKDB4MDApXFxuICAgICAgaGFzVHJhbnNwYXJlbmN5ID0gdHJ1ZVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJnYmEucHVzaChyKVxcbiAgICAgIHJnYmEucHVzaChnKVxcbiAgICAgIHJnYmEucHVzaChiKVxcbiAgICAgIHJnYmEucHVzaCgweGZmKVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4geyByZ2JhLCBoYXNUcmFuc3BhcmVuY3kgfVxcbn1cXG5cXG4vKipcXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBwb2ludHMgZnJvbSBpbWFnZS1xIGFuZCBjb252ZXJ0cyB0aGVtIHRvIGFuIGFycmF5IG9mIHNvcnRlZCByZ2IgdmFsdWVzXFxuICogQHBhcmFtIHtBcnJheVtQb2ludHNdfSBwb2ludHNcXG4gKiByZXR1cm5zIHtBcnJheX1cXG4gKi9cXG5mdW5jdGlvbiBwb2ludHNUb1JnYihwb2ludHMpIHtcXG4gIHJldHVybiBwb2ludHMubWFwKHBvaW50ID0+IChwb2ludC5yIDw8IDE2KSB8IChwb2ludC5nIDw8IDgpIHwgcG9pbnQuYilcXG59XFxuXFxuLyoqXFxuICogQHBhcmFtIHtVaW50MzJBcnJheX0gcGl4ZWxzXFxuICogQHBhcmFtIHtVaW50MzJBcnJheX0gcGFsZXR0ZVxcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxcbiAqL1xcbmZ1bmN0aW9uIGluZGV4UGl4ZWxzV2l0aFBhbGV0dGUocGl4ZWxzLCBwYWxldHRlKSB7XFxuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHBpeGVscy5tYXAocGl4ZWwgPT4gcGFsZXR0ZS5pbmRleE9mKHBpeGVsKSkpXFxufVxcblxcbmZ1bmN0aW9uIHByb2Nlc3NGcmFtZVdpdGhRdWFudGl6ZXIoXFxuICBpbWFnZURhdGEsXFxuICB3aWR0aCxcXG4gIGhlaWdodCxcXG4gIHRyYW5zcGFyZW5jeUN1dE9mZixcXG4gIGRpdGhlcmluZ1xcbikge1xcbiAgY29uc3QgdW51c2VkQ29sb3VyID0gc2VhcmNoRm9yVW51c2VkQ29sb3VyKGltYWdlRGF0YSwgd2lkdGgsIGhlaWdodClcXG4gIGNvbnN0IHsgcmdiYSwgaGFzVHJhbnNwYXJlbmN5IH0gPSBkYXRhVG9SR0JBTm9ybWFsaXplZChcXG4gICAgaW1hZ2VEYXRhLFxcbiAgICB3aWR0aCxcXG4gICAgaGVpZ2h0LFxcbiAgICB1bnVzZWRDb2xvdXIsXFxuICAgIHRyYW5zcGFyZW5jeUN1dE9mZlxcbiAgKVxcblxcbiAgY29uc3QgcG9pbnRDb250YWluZXIgPSBpbWFnZV9xX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInV0aWxzXFxcIl0uUG9pbnRDb250YWluZXIuZnJvbVVpbnQ4QXJyYXkoXFxuICAgIG5ldyBVaW50OEFycmF5KHJnYmEpLFxcbiAgICB3aWR0aCxcXG4gICAgaGVpZ2h0XFxuICApXFxuICBjb25zdCBwYWxldHRlID0gT2JqZWN0KGltYWdlX3FfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYnVpbGRQYWxldHRlU3luY1xcXCJdKShbcG9pbnRDb250YWluZXJdLCB7XFxuICAgIHBhbGV0dGVRdWFudGl6YXRpb246ICdyZ2JxdWFudCcsXFxuICAgIGNvbG9yczogaGFzVHJhbnNwYXJlbmN5ICYmIHVudXNlZENvbG91ciA/IDI1NSA6IDI1NiwgLy8gbGVhdmUgb25lIGZvciB0cmFuc3BhcmVuY3lcXG4gIH0pXFxuICBpZiAoaGFzVHJhbnNwYXJlbmN5ICYmIHVudXNlZENvbG91cikge1xcbiAgICBwYWxldHRlLmFkZChpbWFnZV9xX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInV0aWxzXFxcIl0uUG9pbnQuY3JlYXRlQnlVaW50MzIodW51c2VkQ29sb3VyKSlcXG4gIH1cXG4gIGNvbnN0IG91dFBvaW50Q29udGFpbmVyID0gT2JqZWN0KGltYWdlX3FfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYXBwbHlQYWxldHRlU3luY1xcXCJdKShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSwge1xcbiAgICBpbWFnZVF1YW50aXphdGlvbjogZGl0aGVyaW5nLFxcbiAgfSlcXG4gIGNvbnN0IHBhbGV0dGVSZ2JBcnJheSA9IHBvaW50c1RvUmdiKFxcbiAgICBwYWxldHRlLmdldFBvaW50Q29udGFpbmVyKCkuZ2V0UG9pbnRBcnJheSgpXFxuICApXFxuICBwYWxldHRlUmdiQXJyYXkuc29ydCgoYSwgYikgPT4gYSAtIGIpXFxuICBjb25zdCB0cmFuc3BhcmVuY3lJbmRleCA9IHBhbGV0dGVSZ2JBcnJheS5pbmRleE9mKHVudXNlZENvbG91cilcXG5cXG4gIGNvbnN0IGluZGV4ZWRQaXhlbHMgPSBpbmRleFBpeGVsc1dpdGhQYWxldHRlKFxcbiAgICBwb2ludHNUb1JnYihvdXRQb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCkpLFxcbiAgICBwYWxldHRlUmdiQXJyYXlcXG4gIClcXG5cXG4gIHJldHVybiB7XFxuICAgIHBpeGVsczogaW5kZXhlZFBpeGVscyxcXG4gICAgcGFsZXR0ZTogQXJyYXkuZnJvbShwYWxldHRlUmdiQXJyYXkpLFxcbiAgICB0cmFuc3BhcmVuY3lJbmRleDogdHJhbnNwYXJlbmN5SW5kZXggPiAtMSA/IHRyYW5zcGFyZW5jeUluZGV4IDogdW5kZWZpbmVkLFxcbiAgfVxcbn1cXG5cXG4vLyB+fn5cXG5cXG5mdW5jdGlvbiBydW4oZnJhbWUpIHtcXG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgZGF0YSwgZGl0aGVyaW5nLCB0cmFuc3BhcmVuY3lDdXRPZmYgfSA9IGZyYW1lXFxuXFxuICByZXR1cm4gcHJvY2Vzc0ZyYW1lV2l0aFF1YW50aXplcihcXG4gICAgZGF0YSxcXG4gICAgd2lkdGgsXFxuICAgIGhlaWdodCxcXG4gICAgdHJhbnNwYXJlbmN5Q3V0T2ZmLFxcbiAgICBkaXRoZXJpbmdcXG4gIClcXG59XFxuXFxuc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldikge1xcbiAgdmFyIGRhdGEgPSBldi5kYXRhXFxuICB2YXIgcmVzcG9uc2UgPSBydW4oZGF0YSlcXG4gIHBvc3RNZXNzYWdlKHJlc3BvbnNlKVxcbn1cXG5cXG5cXG4vKioqLyB9KVxcblxcbi8qKioqKiovIH0pO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OHZkMlZpY0dGamF5OWliMjkwYzNSeVlYQWlMQ0ozWldKd1lXTnJPaTh2THk0dmJtOWtaVjl0YjJSMWJHVnpMMk52Y21VdGFuTXZabTR2YzJWMExXbHRiV1ZrYVdGMFpTNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXViMlJsWDIxdlpIVnNaWE12WTI5eVpTMXFjeTl0YjJSMWJHVnpMMTloTFdaMWJtTjBhVzl1TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDI1dlpHVmZiVzlrZFd4bGN5OWpiM0psTFdwekwyMXZaSFZzWlhNdlgyRnVMVzlpYW1WamRDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXViMlJsWDIxdlpIVnNaWE12WTI5eVpTMXFjeTl0YjJSMWJHVnpMMTlqYjJZdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmJtOWtaVjl0YjJSMWJHVnpMMk52Y21VdGFuTXZiVzlrZFd4bGN5OWZZMjl5WlM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5dWIyUmxYMjF2WkhWc1pYTXZZMjl5WlMxcWN5OXRiMlIxYkdWekwxOWpkSGd1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwyTnZjbVV0YW5NdmJXOWtkV3hsY3k5ZlpHVnpZM0pwY0hSdmNuTXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZibTlrWlY5dGIyUjFiR1Z6TDJOdmNtVXRhbk12Ylc5a2RXeGxjeTlmWkc5dExXTnlaV0YwWlM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5dWIyUmxYMjF2WkhWc1pYTXZZMjl5WlMxcWN5OXRiMlIxYkdWekwxOWxlSEJ2Y25RdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmJtOWtaVjl0YjJSMWJHVnpMMk52Y21VdGFuTXZiVzlrZFd4bGN5OWZabUZwYkhNdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmJtOWtaVjl0YjJSMWJHVnpMMk52Y21VdGFuTXZiVzlrZFd4bGN5OWZaMnh2WW1Gc0xtcHpJaXdpZDJWaWNHRmphem92THk4dUwyNXZaR1ZmYlc5a2RXeGxjeTlqYjNKbExXcHpMMjF2WkhWc1pYTXZYMmhoY3k1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5dWIyUmxYMjF2WkhWc1pYTXZZMjl5WlMxcWN5OXRiMlIxYkdWekwxOW9hV1JsTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDI1dlpHVmZiVzlrZFd4bGN5OWpiM0psTFdwekwyMXZaSFZzWlhNdlgyaDBiV3d1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwyTnZjbVV0YW5NdmJXOWtkV3hsY3k5ZmFXVTRMV1J2YlMxa1pXWnBibVV1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwyTnZjbVV0YW5NdmJXOWtkV3hsY3k5ZmFXNTJiMnRsTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDI1dlpHVmZiVzlrZFd4bGN5OWpiM0psTFdwekwyMXZaSFZzWlhNdlgybHpMVzlpYW1WamRDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXViMlJsWDIxdlpIVnNaWE12WTI5eVpTMXFjeTl0YjJSMWJHVnpMMTl2WW1wbFkzUXRaSEF1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwyTnZjbVV0YW5NdmJXOWtkV3hsY3k5ZmNISnZjR1Z5ZEhrdFpHVnpZeTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdlkyOXlaUzFxY3k5dGIyUjFiR1Z6TDE5eVpXUmxabWx1WlM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5dWIyUmxYMjF2WkhWc1pYTXZZMjl5WlMxcWN5OXRiMlIxYkdWekwxOTBZWE5yTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDI1dlpHVmZiVzlrZFd4bGN5OWpiM0psTFdwekwyMXZaSFZzWlhNdlgzUnZMWEJ5YVcxcGRHbDJaUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdlkyOXlaUzFxY3k5dGIyUjFiR1Z6TDE5MWFXUXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZibTlrWlY5dGIyUjFiR1Z6TDJOdmNtVXRhbk12Ylc5a2RXeGxjeTkzWldJdWFXMXRaV1JwWVhSbExtcHpJaXdpZDJWaWNHRmphem92THk4dUwyNXZaR1ZmYlc5a2RXeGxjeTlwYldGblpTMXhMMlJwYzNRdlpYTnRMMkpoYzJsalFWQkpMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMjV2WkdWZmJXOWtkV3hsY3k5cGJXRm5aUzF4TDJScGMzUXZaWE50TDJOdmJuTjBZVzUwY3k5aWREY3dPUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5amIyNXpkR0Z1ZEhNdmFXNWtaWGd1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwybHRZV2RsTFhFdlpHbHpkQzlsYzIwdlkyOXVkbVZ5YzJsdmJpOXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5dWIyUmxYMjF2WkhWc1pYTXZhVzFoWjJVdGNTOWthWE4wTDJWemJTOWpiMjUyWlhKemFXOXVMMnhoWWpKeVoySXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZibTlrWlY5dGIyUjFiR1Z6TDJsdFlXZGxMWEV2WkdsemRDOWxjMjB2WTI5dWRtVnljMmx2Ymk5c1lXSXllSGw2TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDI1dlpHVmZiVzlrZFd4bGN5OXBiV0ZuWlMxeEwyUnBjM1F2WlhOdEwyTnZiblpsY25OcGIyNHZjbWRpTW1oemJDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXViMlJsWDIxdlpIVnNaWE12YVcxaFoyVXRjUzlrYVhOMEwyVnpiUzlqYjI1MlpYSnphVzl1TDNKbllqSnNZV0l1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwybHRZV2RsTFhFdlpHbHpkQzlsYzIwdlkyOXVkbVZ5YzJsdmJpOXlaMkl5ZUhsNkxtcHpJaXdpZDJWaWNHRmphem92THk4dUwyNXZaR1ZmYlc5a2RXeGxjeTlwYldGblpTMXhMMlJwYzNRdlpYTnRMMk52Ym5abGNuTnBiMjR2ZUhsNk1teGhZaTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5amIyNTJaWEp6YVc5dUwzaDVlakp5WjJJdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmJtOWtaVjl0YjJSMWJHVnpMMmx0WVdkbExYRXZaR2x6ZEM5bGMyMHZaR2x6ZEdGdVkyVXZZMmxsT1RRdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmJtOWtaVjl0YjJSMWJHVnpMMmx0WVdkbExYRXZaR2x6ZEM5bGMyMHZaR2x6ZEdGdVkyVXZZMmxsWkdVeU1EQXdMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMjV2WkdWZmJXOWtkV3hsY3k5cGJXRm5aUzF4TDJScGMzUXZaWE50TDJScGMzUmhibU5sTDJOdFpYUnlhV011YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwybHRZV2RsTFhFdlpHbHpkQzlsYzIwdlpHbHpkR0Z1WTJVdlpHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwyNXZaR1ZmYlc5a2RXeGxjeTlwYldGblpTMXhMMlJwYzNRdlpYTnRMMlJwYzNSaGJtTmxMMlYxWTJ4cFpHVmhiaTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5a2FYTjBZVzVqWlM5cGJtUmxlQzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5a2FYTjBZVzVqWlM5dFlXNW9ZWFIwWVc0dWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmJtOWtaVjl0YjJSMWJHVnpMMmx0WVdkbExYRXZaR2x6ZEM5bGMyMHZaR2x6ZEdGdVkyVXZjRzVuVVhWaGJuUXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZibTlrWlY5dGIyUjFiR1Z6TDJsdFlXZGxMWEV2WkdsemRDOWxjMjB2YVcxaFoyVXRjUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5cGJXRm5aUzloY25KaGVTNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXViMlJsWDIxdlpIVnNaWE12YVcxaFoyVXRjUzlrYVhOMEwyVnpiUzlwYldGblpTOXBiV0ZuWlZGMVlXNTBhWHBsY2k1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5dWIyUmxYMjF2WkhWc1pYTXZhVzFoWjJVdGNTOWthWE4wTDJWemJTOXBiV0ZuWlM5cGJtUmxlQzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5cGJXRm5aUzl1WldGeVpYTjBRMjlzYjNJdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmJtOWtaVjl0YjJSMWJHVnpMMmx0WVdkbExYRXZaR2x6ZEM5bGMyMHZhVzFoWjJVdmNtbGxiV1Z5YzIxaExtcHpJaXdpZDJWaWNHRmphem92THk4dUwyNXZaR1ZmYlc5a2RXeGxjeTlwYldGblpTMXhMMlJwYzNRdlpYTnRMMmx0WVdkbEwzTndZV05sUm1sc2JHbHVaME4xY25abGN5OW9hV3hpWlhKMFEzVnlkbVV1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwybHRZV2RsTFhFdlpHbHpkQzlsYzIwdmNHRnNaWFIwWlM5cGJtUmxlQzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5d1lXeGxkSFJsTDI1bGRYRjFZVzUwTDI1bGRYRjFZVzUwTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDI1dlpHVmZiVzlrZFd4bGN5OXBiV0ZuWlMxeEwyUnBjM1F2WlhOdEwzQmhiR1YwZEdVdmJtVjFjWFZoYm5RdmJtVjFjWFZoYm5SR2JHOWhkQzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5d1lXeGxkSFJsTDNCaGJHVjBkR1ZSZFdGdWRHbDZaWEl1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwybHRZV2RsTFhFdlpHbHpkQzlsYzIwdmNHRnNaWFIwWlM5eVoySnhkV0Z1ZEM5amIyeHZja2hwYzNSdlozSmhiUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5d1lXeGxkSFJsTDNKblluRjFZVzUwTDNKblluRjFZVzUwTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDI1dlpHVmZiVzlrZFd4bGN5OXBiV0ZuWlMxeEwyUnBjM1F2WlhOdEwzQmhiR1YwZEdVdmQzVXZkM1ZSZFdGdWRDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXViMlJsWDIxdlpIVnNaWE12YVcxaFoyVXRjUzlrYVhOMEwyVnpiUzl4ZFdGc2FYUjVMMmx1WkdWNExtcHpJaXdpZDJWaWNHRmphem92THk4dUwyNXZaR1ZmYlc5a2RXeGxjeTlwYldGblpTMXhMMlJwYzNRdlpYTnRMM0YxWVd4cGRIa3ZjM05wYlM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5dWIyUmxYMjF2WkhWc1pYTXZhVzFoWjJVdGNTOWthWE4wTDJWemJTOTFkR2xzY3k5aGNtbDBhRzFsZEdsakxtcHpJaXdpZDJWaWNHRmphem92THk4dUwyNXZaR1ZmYlc5a2RXeGxjeTlwYldGblpTMXhMMlJwYzNRdlpYTnRMM1YwYVd4ekwyaDFaVk4wWVhScGMzUnBZM011YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Ym05a1pWOXRiMlIxYkdWekwybHRZV2RsTFhFdlpHbHpkQzlsYzIwdmRYUnBiSE12YVc1a1pYZ3Vhbk1pTENKM1pXSndZV05yT2k4dkx5NHZibTlrWlY5dGIyUjFiR1Z6TDJsdFlXZGxMWEV2WkdsemRDOWxjMjB2ZFhScGJITXZjR0ZzWlhSMFpTNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOXViMlJsWDIxdlpIVnNaWE12YVcxaFoyVXRjUzlrYVhOMEwyVnpiUzkxZEdsc2N5OXdiMmx1ZEM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5dWIyUmxYMjF2WkhWc1pYTXZhVzFoWjJVdGNTOWthWE4wTDJWemJTOTFkR2xzY3k5d2IybHVkRU52Ym5SaGFXNWxjaTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTl1YjJSbFgyMXZaSFZzWlhNdmFXMWhaMlV0Y1M5a2FYTjBMMlZ6YlM5MWRHbHNjeTl3Y205bmNtVnpjMVJ5WVdOclpYSXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZjM0pqTDBGdWFXMWhkR1ZrWDBkSlJpNTNiM0pyWlhJdWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdFJRVUZCTzFGQlEwRTdPMUZCUlVFN1VVRkRRVHM3VVVGRlFUdFJRVU5CTzFGQlEwRTdVVUZEUVR0UlFVTkJPMUZCUTBFN1VVRkRRVHRSUVVOQk8xRkJRMEU3VVVGRFFUczdVVUZGUVR0UlFVTkJPenRSUVVWQk8xRkJRMEU3TzFGQlJVRTdVVUZEUVR0UlFVTkJPenM3VVVGSFFUdFJRVU5CT3p0UlFVVkJPMUZCUTBFN08xRkJSVUU3VVVGRFFUdFJRVU5CTzFGQlEwRXNNRU5CUVRCRExHZERRVUZuUXp0UlFVTXhSVHRSUVVOQk96dFJRVVZCTzFGQlEwRTdVVUZEUVR0UlFVTkJMSGRFUVVGM1JDeHJRa0ZCYTBJN1VVRkRNVVU3VVVGRFFTeHBSRUZCYVVRc1kwRkJZenRSUVVNdlJEczdVVUZGUVR0UlFVTkJPMUZCUTBFN1VVRkRRVHRSUVVOQk8xRkJRMEU3VVVGRFFUdFJRVU5CTzFGQlEwRTdVVUZEUVR0UlFVTkJPMUZCUTBFc2VVTkJRWGxETEdsRFFVRnBRenRSUVVNeFJTeG5TRUZCWjBnc2JVSkJRVzFDTEVWQlFVVTdVVUZEY2trN1VVRkRRVHM3VVVGRlFUdFJRVU5CTzFGQlEwRTdVVUZEUVN3eVFrRkJNa0lzTUVKQlFUQkNMRVZCUVVVN1VVRkRka1FzYVVOQlFXbERMR1ZCUVdVN1VVRkRhRVE3VVVGRFFUdFJRVU5CT3p0UlFVVkJPMUZCUTBFc2MwUkJRWE5FTEN0RVFVRXJSRHM3VVVGRmNrZzdVVUZEUVRzN08xRkJSMEU3VVVGRFFUczdPenM3T3pzN096czdPMEZEYkVaQkxHMUNRVUZQTEVOQlFVTXNhVVpCUVRCQ08wRkJRMnhETEdsQ1FVRnBRaXh0UWtGQlR5eERRVUZETEdsRlFVRnJRanM3T3pzN096czdPenM3TzBGRFJETkRPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU5JUVN4bFFVRmxMRzFDUVVGUExFTkJRVU1zYTBWQlFXTTdRVUZEY2tNN1FVRkRRVHRCUVVOQk8wRkJRMEU3T3pzN096czdPenM3T3p0QlEwcEJMR2xDUVVGcFFqczdRVUZGYWtJN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU5LUVN3MlFrRkJOa0k3UVVGRE4wSXNkVU5CUVhWRE96czdPenM3T3pzN096czdRVU5FZGtNN1FVRkRRU3huUWtGQlowSXNiVUpCUVU4c1EwRkJReXh2UlVGQlpUdEJRVU4yUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenM3T3pzN096czdPenRCUTI1Q1FUdEJRVU5CTEd0Q1FVRnJRaXh0UWtGQlR5eERRVUZETERCRVFVRlZPMEZCUTNCRExHbERRVUZwUXl4UlFVRlJMRzFDUVVGdFFpeFZRVUZWTEVWQlFVVXNSVUZCUlR0QlFVTXhSU3hEUVVGRE96czdPenM3T3pzN096czdRVU5JUkN4bFFVRmxMRzFDUVVGUExFTkJRVU1zYTBWQlFXTTdRVUZEY2tNc1pVRkJaU3h0UWtGQlR5eERRVUZETERSRVFVRlhPMEZCUTJ4RE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenM3T3pzN096czdPenRCUTA1QkxHRkJRV0VzYlVKQlFVOHNRMEZCUXl3MFJFRkJWenRCUVVOb1F5eFhRVUZYTEcxQ1FVRlBMRU5CUVVNc2QwUkJRVk03UVVGRE5VSXNWMEZCVnl4dFFrRkJUeXhEUVVGRExIZEVRVUZUTzBGQlF6VkNMR1ZCUVdVc2JVSkJRVThzUTBGQlF5eG5SVUZCWVR0QlFVTndReXhWUVVGVkxHMUNRVUZQTEVOQlFVTXNjMFJCUVZFN1FVRkRNVUk3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYTBaQlFXdEdMSFZDUVVGMVFqdEJRVU42Unl4cFJVRkJhVVU3UVVGRGFrVXNLMFJCUVN0RU8wRkJReTlFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdOQlFXTTdRVUZEWkN4alFVRmpPMEZCUTJRc1kwRkJZenRCUVVOa0xHTkJRV003UVVGRFpDeGxRVUZsTzBGQlEyWXNaVUZCWlR0QlFVTm1MR1ZCUVdVN1FVRkRaaXhuUWtGQlowSTdRVUZEYUVJN096czdPenM3T3pzN096dEJRekZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTk9RVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNlVU5CUVhsRE96czdPenM3T3pzN096czdRVU5NZWtNc2RVSkJRWFZDTzBGQlEzWkNPMEZCUTBFN1FVRkRRVHM3T3pzN096czdPenM3TzBGRFNFRXNVMEZCVXl4dFFrRkJUeXhEUVVGRExHdEZRVUZqTzBGQlF5OUNMR2xDUVVGcFFpeHRRa0ZCVHl4RFFVRkRMREJGUVVGclFqdEJRVU16UXl4cFFrRkJhVUlzYlVKQlFVOHNRMEZCUXl4elJVRkJaMEk3UVVGRGVrTTdRVUZEUVN4RFFVRkRPMEZCUTBRN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU5RUVN4bFFVRmxMRzFDUVVGUExFTkJRVU1zTkVSQlFWYzdRVUZEYkVNN096czdPenM3T3pzN096dEJRMFJCTEd0Q1FVRnJRaXh0UWtGQlR5eERRVUZETEhORlFVRm5RaXhOUVVGTkxHMUNRVUZQTEVOQlFVTXNNRVJCUVZVN1FVRkRiRVVzSzBKQlFTdENMRzFDUVVGUExFTkJRVU1zYjBWQlFXVXNaMEpCUVdkQ0xHMUNRVUZ0UWl4VlFVRlZMRVZCUVVVc1JVRkJSVHRCUVVOMlJ5eERRVUZET3pzN096czdPenM3T3pzN1FVTkdSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPenM3T3pzN096czdPenM3UVVObVFUdEJRVU5CTzBGQlEwRTdPenM3T3pzN096czdPenRCUTBaQkxHVkJRV1VzYlVKQlFVOHNRMEZCUXl4clJVRkJZenRCUVVOeVF5eHhRa0ZCY1VJc2JVSkJRVThzUTBGQlF5dzBSVUZCYlVJN1FVRkRhRVFzYTBKQlFXdENMRzFDUVVGUExFTkJRVU1zZDBWQlFXbENPMEZCUXpORE96dEJRVVZCTEZsQlFWa3NiVUpCUVU4c1EwRkJReXh6UlVGQlowSTdRVUZEY0VNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVY3NXVUZCV1R0QlFVTm1PMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU5tUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTlFRU3hoUVVGaExHMUNRVUZQTEVOQlFVTXNORVJCUVZjN1FVRkRhRU1zVjBGQlZ5eHRRa0ZCVHl4RFFVRkRMSGRFUVVGVE8wRkJRelZDTEZWQlFWVXNiVUpCUVU4c1EwRkJReXh6UkVGQlVUdEJRVU14UWl4VlFVRlZMRzFDUVVGUExFTkJRVU1zYzBSQlFWRTdRVUZETVVJN1FVRkRRVHRCUVVOQk96dEJRVVZCTEcxQ1FVRlBMRU5CUVVNc2QwUkJRVk03UVVGRGFrSTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQkxFTkJRVU03UVVGRFJEdEJRVU5CTEVOQlFVTTdPenM3T3pzN096czdPenRCUXpsQ1JDeFZRVUZWTEcxQ1FVRlBMRU5CUVVNc2MwUkJRVkU3UVVGRE1VSXNZVUZCWVN4dFFrRkJUeXhEUVVGRExEUkVRVUZYTzBGQlEyaERMRmRCUVZjc2JVSkJRVThzUTBGQlF5eDNSRUZCVXp0QlFVTTFRaXhWUVVGVkxHMUNRVUZQTEVOQlFVTXNiMFZCUVdVN1FVRkRha01zWVVGQllTeHRRa0ZCVHl4RFFVRkRMRFJFUVVGWE8wRkJRMmhETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TlFVRk5MRzFDUVVGUExFTkJRVU1zYzBSQlFWRTdRVUZEZEVJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVOdVJrRTdRVUZEUVN4bFFVRmxMRzFDUVVGUExFTkJRVU1zYTBWQlFXTTdRVUZEY2tNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096czdPenM3T3pzN096dEJRMWhCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096czdPenM3T3pzN096dEJRMHBCTEdOQlFXTXNiVUpCUVU4c1EwRkJReXcwUkVGQlZ6dEJRVU5xUXl4WlFVRlpMRzFDUVVGUExFTkJRVU1zZDBSQlFWTTdRVUZETjBJN1FVRkRRVHRCUVVOQk8wRkJRMEVzUTBGQlF6czdPenM3T3pzN096czdPenRCUTB4RU8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRlVVE3UVVGRGJFSTdRVUZEVGp0QlFVTkpPMEZCUXpsQ0xHMURRVUZ0UXl4dlJFRkJiMFFzUzBGQlN6dEJRVU51Unp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMDhzY1VOQlFYRkRMR2RGUVVGblJTeExRVUZMTzBGQlEycElPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRGhDUVVFNFFpeHhSRUZCV1R0QlFVTXhRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR3RDUVVGclFpeHhSRUZCV1R0QlFVTTVRaXhMUVVGTE8wRkJRMHc3UVVGRFR5d3lRMEZCTWtNc01FTkJRVEJETEV0QlFVczdRVUZEYWtjN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFR5dzJRMEZCTmtNc2MwUkJRWE5FTEV0QlFVczdRVUZETDBjN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRGhDUVVFNFFpeHhSRUZCV1R0QlFVTXhRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR3RDUVVGclFpeHhSRUZCV1R0QlFVTTVRaXhMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRXNPRU5CUVRoRExEQkVRVUY1UWp0QlFVTjJSU3d3UTBGQk1FTXNkVVJCUVhOQ08wRkJRMmhGTEhGRFFVRnhReXh0UkVGQmEwSTdRVUZEZGtRc2QwTkJRWGRETEdsRVFVRm5RanRCUVVONFJDeHhRMEZCY1VNc2JVUkJRV3RDTzBGQlEzWkVMREpEUVVFeVF5eDNSRUZCZFVJN1FVRkRiRVVzYlVSQlFXMUVMQ3RFUVVFNFFqdEJRVU5xUml4eFEwRkJjVU1zYlVSQlFXdENPMEZCUTNaRUxESkRRVUV5UXl4M1JFRkJkVUk3UVVGRGJFVXNOa05CUVRaRExEQkVRVUY1UWp0QlFVTjBSU3h2UTBGQmIwTXNhMFJCUVdsQ08wRkJRM0pFTEdsRlFVRnBSU3h4UWtGQmNVSTdRVUZEZEVZN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHRRMEZCYlVNc2JVUkJRV3RDTzBGQlEzSkVMSEZEUVVGeFF5dzRSRUZCTmtJN1FVRkRiRVVzTWtOQlFUSkRMREJFUVVGNVFpeHhRa0ZCY1VJc1owVkJRU3RDTzBGQlEzaElMR2xFUVVGcFJDd3dSRUZCZVVJc2NVSkJRWEZDTEdkRlFVRXJRanRCUVVNNVNDeHJRMEZCYTBNc01FUkJRWGxDTEhGQ1FVRnhRaXhuUlVGQkswSTdRVUZETDBjc2IwTkJRVzlETERCRVFVRjVRaXh4UWtGQmNVSXNaMFZCUVN0Q08wRkJRMnBJTEd0RFFVRnJReXd3UkVGQmVVSXNjVUpCUVhGQ0xHZEZRVUVyUWp0QlFVTXZSeXhyUTBGQmEwTXNNRVJCUVhsQ0xIRkNRVUZ4UWl4blJVRkJLMEk3UVVGREwwY3NhME5CUVd0RExEQkVRVUY1UWl4eFFrRkJjVUlzWjBWQlFTdENPMEZCUXk5SExITkRRVUZ6UXl3d1JFRkJlVUlzY1VKQlFYRkNMR2RGUVVFclFqdEJRVU51U0N4MVEwRkJkVU1zTUVSQlFYbENMSEZDUVVGeFFpeG5SVUZCSzBJN1FVRkRjRWdzT0VSQlFUaEVMR3RDUVVGclFqdEJRVU5vUmp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHOURRVUZ2UXl4cFJFRkJaMEk3UVVGRGNFUXNiME5CUVc5RExHbEVRVUZuUWp0QlFVTndSQ3h0UTBGQmJVTXNaMFJCUVdVN1FVRkRiRVFzTUVOQlFUQkRMSE5FUVVGeFFqdEJRVU12UkN4blJVRkJaMFVzYjBKQlFXOUNPMEZCUTNCR08wRkJRMEU3UVVGRFFTeHZRenM3T3pzN096czdPenM3TzBGRE1VaEJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5QTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFTkJRVU1zWTBGQll6dEJRVU5tTzBGQlEwODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUTBGQlF5eGpRVUZqTzBGQlEyWTdRVUZEVHp0QlFVTlFPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeERRVUZETEdOQlFXTTdRVUZEWml4cFF6czdPenM3T3pzN096czdPMEZEYkVOQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMmxETzBGQlEyWTdRVUZEYkVJc2FVTTdPenM3T3pzN096czdPenRCUTFSQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRGIwTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRGNFTXNhVU03T3pzN096czdPenM3T3p0QlEyUkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRiME03UVVGRFFUdEJRVU53UXp0QlFVTlBPMEZCUTFBc1owSkJRV2RDTEhkRVFVRlBPMEZCUTNaQ0xGZEJRVmNzZDBSQlFVODdRVUZEYkVJN1FVRkRRU3h0UXpzN096czdPenM3T3pzN08wRkRaRUU3UVVGQlFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzY1VKQlFYRkNPMEZCUTNKQ0xIRkNRVUZ4UWp0QlFVTnlRaXh4UWtGQmNVSTdRVUZEY2tJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFR6dEJRVU5RTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEcxRE96czdPenM3T3pzN096czdRVU40UWtFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRhVVE3UVVGRGFrUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFR6dEJRVU5RTEdkQ1FVRm5RaXc0UkVGQlNUdEJRVU53UWl4blFrRkJaMElzT0VSQlFVazdRVUZEY0VJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGbEJRVms3UVVGRFdqdEJRVU5CTEcxRE96czdPenM3T3pzN096czdRVU40UTBFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOdlF6dEJRVU5CTzBGQlF6ZENPMEZCUTFBc1owSkJRV2RDTEhkRVFVRlBPMEZCUTNaQ0xGZEJRVmNzZDBSQlFVODdRVUZEYkVJN1FVRkRRU3h0UXpzN096czdPenM3T3pzN08wRkRZa0U3UVVGQlFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVTTdPenM3T3pzN096czdPenRCUTNSQ1FUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHhRa0ZCY1VJN1FVRkRja0lzY1VKQlFYRkNPMEZCUTNKQ0xIRkNRVUZ4UWp0QlFVTnlRanRCUVVOQk8wRkJRMEU3UVVGRFR6dEJRVU5RTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4dFF6czdPenM3T3pzN096czdPMEZEZWtKQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRekpFTzBGQlF6TkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMDg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXc0UlVGQmIwSTdRVUZETDBJc1YwRkJWeXc0UlVGQmIwSTdRVUZETDBJc1YwRkJWeXc0UlVGQmIwSTdRVUZETDBJN1FVRkRRVHRCUVVOQkxHMURPenM3T3pzN096czdPenM3UVVOMlFrRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOclJUdEJRVU5zUWp0QlFVTkpPMEZCUTNCRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwOHNORUpCUVRSQ0xEaEZRVUV3UWp0QlFVTTNSRHRCUVVOQkxIRkNRVUZ4UWl4dFJVRkJUeXhEUVVGRExIVkZRVUZoTERKQ1FVRXlRaXgxUlVGQllTd3lRa0ZCTWtJc2RVVkJRV0U3UVVGRE1VZ3NjVUpCUVhGQ0xHMUZRVUZQTEVOQlFVTXNkVVZCUVdFc01rSkJRVEpDTEhWRlFVRmhMREpDUVVFeVFpeDFSVUZCWVR0QlFVTXhTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEVHp0QlFVTlFPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNhVU03T3pzN096czdPenM3T3p0QlEyeEVRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRGEwVTdRVUZEYkVJN1FVRkRjVUk3UVVGRGNrVTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMDhzZDBKQlFYZENMRGhGUVVFd1FqdEJRVU42UkN4dlFrRkJiMEk3UVVGRGNFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdsR1FVRnBSanRCUVVOcVJqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h4UWtGQmNVSXNiVVZCUVU4c1EwRkJReXgxUlVGQllTd3lRa0ZCTWtJc2RVVkJRV0VzTWtKQlFUSkNMSFZGUVVGaE8wRkJRekZJTEhGQ1FVRnhRaXh0UlVGQlR5eERRVUZETEhWRlFVRmhMREpDUVVFeVFpeDFSVUZCWVN3eVFrRkJNa0lzZFVWQlFXRTdRVUZETVVnN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSFZIUVVGMVJ6dEJRVU4yUnp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1owTkJRV2RETzBGQlEyaERMR2REUVVGblF6dEJRVU5vUXl4blEwRkJaME03UVVGRGFFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4NVFrRkJlVUlzZVVWQlFXVTdRVUZEZUVNc2VVSkJRWGxDTEhsRlFVRmxPMEZCUTNoRExIZENRVUYzUWl4NVJVRkJaVHRCUVVOMlF5eDFRa0ZCZFVJc2VVVkJRV1U3UVVGRGRFTXNkMEpCUVhkQ0xIbEZRVUZsTzBGQlEzWkRMSGxDUVVGNVFpeDVSVUZCWlR0QlFVTjRReXgzUWtGQmQwSXNlVVZCUVdVN1FVRkRka01zY1VNN096czdPenM3T3pzN096dEJRM2hJUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTnJSVHRCUVVOc1JUdEJRVU5CTzBGQlEwRTdRVUZEVHl4elFrRkJjMElzT0VWQlFUQkNPMEZCUTNaRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHOUNRVUZ2UWp0QlFVTndRanRCUVVOQkxHMURPenM3T3pzN096czdPenM3UVVOMlFrRTdRVUZCUVR0QlFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc09FTTdPenM3T3pzN096czdPenRCUTI1Q1FUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTJ0Rk8wRkJRek5DTzBGQlEzWkRPMEZCUTBFN1FVRkRRVHRCUVVOUExHZERRVUZuUXl3NFJVRkJNRUk3UVVGRGFrVTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5QTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEVHp0QlFVTlFPMEZCUTBFc2JVSkJRVzFDTEd0RVFVRkRPMEZCUTNCQ0xHMUNRVUZ0UWl4clJFRkJRenRCUVVOd1FpeHRRa0ZCYlVJc2EwUkJRVU03UVVGRGNFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFR6dEJRVU5RTzBGQlEwRXNiVUpCUVcxQ0xHdEVRVUZETzBGQlEzQkNMRzFDUVVGdFFpeHJSRUZCUXp0QlFVTndRaXh0UWtGQmJVSXNhMFJCUVVNN1FVRkRjRUk3UVVGRFFUdEJRVU5CTzBGQlEwRXNjVU03T3pzN096czdPenM3T3p0QlEzQkVRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTnJSVHRCUVVOU08wRkJRMnhDTzBGQlEwbzdRVUZET0VRN1FVRkRURHRCUVVOMlJEdEJRVU4wUXl4cFF6czdPenM3T3pzN096czdPMEZEWkVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5yUlR0QlFVTXpRanRCUVVOMlF6dEJRVU5CTzBGQlEwRTdRVUZEVHl4blEwRkJaME1zT0VWQlFUQkNPMEZCUTJwRk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTA4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMDg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwODdRVUZEVUR0QlFVTkJMRzFDUVVGdFFpeHJSRUZCUXp0QlFVTndRaXh0UWtGQmJVSXNhMFJCUVVNN1FVRkRjRUlzYlVKQlFXMUNMR3RFUVVGRE8wRkJRM0JDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVTTdPenM3T3pzN096czdPenRCUXpsRVFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5yUlR0QlFVTnNSVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVazdRVUZEU2l4SlFVRkpPMEZCUTBvN1FVRkRUeXgxUWtGQmRVSXNPRVZCUVRCQ08wRkJRM2hFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4dlFrRkJiMEk3UVVGRGNFSTdRVUZEUVN4dlF6czdPenM3T3pzN096czdPMEZETDBOQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEzbERPMEZCUTBVN1FVRkRTanRCUVVOR08wRkJRMG83UVVGRFNUdEJRVU5LTzBGQlF6UkVPMEZCUTJwQ08wRkJRelZGTEcxRE96czdPenM3T3pzN096czdRVU5vUWtFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU13UkR0QlFVTnVRanRCUVVOdlFqdEJRVU5CTzBGQlF6TkVPMEZCUTA4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFTkJRVU1zT0VSQlFUaEVPMEZCUXk5RU8wRkJRMDhzYTBOQlFXdERMSE5GUVVGelFqdEJRVU12UkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHJRMEZCYTBNc2EwUkJRVXM3UVVGRGRrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSFZDUVVGMVFpeHRRa0ZCYlVJN1FVRkRNVU03UVVGRFFUdEJRVU5CTERSQ1FVRTBRaXh6UlVGQlpUdEJRVU16UXl4MVFrRkJkVUlzV1VGQldUdEJRVU51UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEc5RVFVRnZSQ3haUVVGWk8wRkJRMmhGTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gxUTBGQmRVTXNhMFJCUVVzc1kwRkJZeXc0UlVGQmIwSXNjMEpCUVhOQ0xEaEZRVUZ2UWl4elFrRkJjMElzT0VWQlFXOUNMSE5DUVVGelFpdzRSVUZCYjBJN1FVRkROVTA3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHZRMEZCYjBNc1dVRkJXVHRCUVVOb1JEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIVkNRVUYxUWl4UFFVRlBPMEZCUXpsQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNkVUpCUVhWQ0xGZEJRVmM3UVVGRGJFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2xET3pzN096czdPenM3T3pzN1FVTXpVRUU3UVVGQlFUdEJRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNNRU03T3pzN096czdPenM3T3p0QlExWkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRekJFTzBGQlExbzdRVUZETWtJN1FVRkRia0k3UVVGRGRFUXNhVU03T3pzN096czdPenM3T3p0QlExaEJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRNRVE3UVVGRFF6dEJRVU53UkN3eVFrRkJNa0lzYzBWQlFYTkNPMEZCUTNoRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTdzBRa0ZCTkVJc2MwVkJRV1U3UVVGRE0wTXNkVUpCUVhWQ0xGbEJRVms3UVVGRGJrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEUkRRVUUwUXl4WFFVRlhPMEZCUTNaRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhkRE96czdPenM3T3pzN096czdRVU42UTBFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU13UkR0QlFVTlBPMEZCUXpGQ08wRkJRMjlDTzBGQlEzQkVMSE5EUVVGelF5eHpSVUZCYzBJN1FVRkRia1U3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2RVSkJRWFZDTERCQ1FVRXdRanRCUVVOcVJDdzJRa0ZCTmtJN1FVRkROMEk3UVVGRFFTeGxRVUZsTEhGR1FVRlpPMEZCUXpOQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN3eVFrRkJNa0lzTUVKQlFUQkNPMEZCUTNKRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVTkJRVzFETEd0RVFVRkxMR05CUVdNc09FVkJRVzlDTEV0QlFVc3NPRVZCUVc5Q0xFdEJRVXNzT0VWQlFXOUNMRXRCUVVzc09FVkJRVzlDTzBGQlEzSktPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hUUVVGVE8wRkJRMVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHbERRVUZwUXl4dlFrRkJiMEk3UVVGRGNrUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzY1VNN096czdPenM3T3pzN096dEJRek5HUVR0QlFVRkJPMEZCUVVFN1FVRkJPRVE3UVVGRE9VUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeERRVUZETERoQ1FVRTRRanRCUVVONFFqdEJRVU5RTzBGQlEwRTdRVUZEUVN4M1FrRkJkMElzYzBWQlFXVTdRVUZEZGtNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR1ZCUVdVN1FVRkRaanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gzUXpzN096czdPenM3T3pzN08wRkRPVVpCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlF6aEVPMEZCUTJZN1FVRkRWVHRCUVVOV08wRkJRMWs3UVVGRFVEdEJRVU53UkN4cFF6czdPenM3T3pzN096czdPMEZEWWtFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlF6aERPMEZCUTBvN1FVRkRjVUk3UVVGRGFrSTdRVUZET1VNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWlVGQlpTeHJSRUZCU3p0QlFVTndRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTA4c2RVSkJRWFZDTERCRlFVRjNRanRCUVVOMFJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gxUWtGQmRVSXNkVUpCUVhWQ08wRkJRemxETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2RVSkJRWFZDTEZOQlFWTTdRVUZEYUVNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc05FSkJRVFJDTEhORVFVRmxPMEZCUXpORExIVkRRVUYxUXl4dlFrRkJiMEk3UVVGRE0wUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNLMEpCUVN0Q0xGTkJRVk03UVVGRGVFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEUkNRVUUwUWl4elJFRkJUenRCUVVOdVF6dEJRVU5CTzBGQlEwRXNVMEZCVXp0QlFVTlVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSFZDUVVGMVFpeDFRa0ZCZFVJN1FVRkRPVU03UVVGRFFTeG5SVUZCWjBVc1lVRkJZVHRCUVVNM1JUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2IwTTdPenM3T3pzN096czdPenRCUTJ4U1FUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRPRU03UVVGRFNqdEJRVU54UWp0QlFVTnFRanRCUVVNNVF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4bFFVRmxMR3RFUVVGTE8wRkJRM0JDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFR5dzBRa0ZCTkVJc01FVkJRWGRDTzBGQlF6TkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhWQ1FVRjFRaXgxUWtGQmRVSTdRVUZET1VNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeDFRa0ZCZFVJc1UwRkJVenRCUVVOb1F6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTdzBRa0ZCTkVJc2MwUkJRV1U3UVVGRE0wTXNkVU5CUVhWRExHOUNRVUZ2UWp0QlFVTXpSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3dyUWtGQkswSXNVMEZCVXp0QlFVTjRRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNORUpCUVRSQ0xITkVRVUZQTzBGQlEyNURPMEZCUTBFN1FVRkRRU3hUUVVGVE8wRkJRMVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzZFVKQlFYVkNMSFZDUVVGMVFqdEJRVU01UXp0QlFVTkJMR2RGUVVGblJTeHBRa0ZCYVVJN1FVRkRha1k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGxET3pzN096czdPenM3T3pzN1FVTnNVa0U3UVVGQlFUdEJRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNORU03T3pzN096czdPenM3T3p0QlExWkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZETUVRN1FVRkRUanRCUVVNM1F6dEJRVU5RTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2RVTkJRWFZETzBGQlEzWkRPMEZCUTBFN1FVRkRRVHRCUVVOQkxEWkNRVUUyUWl4clJVRkJZVHRCUVVNeFF5dzRRMEZCT0VNN1FVRkRPVU03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4MVFrRkJkVUlzYjBWQlFWVTdRVUZEYWtNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gxUWtGQmRVSXNVMEZCVXp0QlFVTm9RenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR0ZCUVdFN1FVRkRZaXhUUVVGVE8wRkJRMVE3UVVGRFFUdEJRVU5CTzBGQlEwRXNlVVJCUVhsRU8wRkJRM3BFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNVMEZCVXp0QlFVTlVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gxUWtGQmRVSXNXVUZCV1R0QlFVTnVReXd5UWtGQk1rSXNWMEZCVnp0QlFVTjBReXhwUTBGQmFVTXNkVVZCUVhWRk8wRkJRM2hITzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTd3dRenM3T3pzN096czdPenM3TzBGREwwcEJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVNNFF6dEJRVU5LTzBGQlExRTdRVUZEWVR0QlFVTllPMEZCUTA0N1FVRkRPVU03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOUExIVkNRVUYxUWl3d1JVRkJkMEk3UVVGRGRFUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzT0VKQlFUaENMRGhFUVVGak8wRkJRelZETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEN0RFFVRXJReXhQUVVGUE8wRkJRM1JFTzBGQlEwRXNjVU5CUVhGRExHOUNRVUZ2UWp0QlFVTjZSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN3MFFrRkJORUlzYzBSQlFVODdRVUZEYmtNN1FVRkRRU3h2UkVGQmIwUTdRVUZEY0VRc2RVSkJRWFZDTEcxQ1FVRnRRanRCUVVNeFF5dzBRa0ZCTkVJc2EwUkJRVXM3UVVGRGFrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTdzBRa0ZCTkVJc2MwUkJRV1U3UVVGRE0wTTdRVUZEUVR0QlFVTkJPMEZCUTBFc01rSkJRVEpDTEZOQlFWTTdRVUZEY0VNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVTkJRVzFETEZOQlFWTTdRVUZETlVNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzV1VGQldTeHZSVUZCVlR0QlFVTjBRanRCUVVOQkxHRkJRV0U3UVVGRFlqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhsRFFVRjVReXhwUWtGQmFVSTdRVUZETVVRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiME03T3pzN096czdPenM3T3p0QlEyeEtRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlF6aERPMEZCUTBvN1FVRkRjVUk3UVVGRGFrSTdRVUZET1VNN1FVRkRRVHRCUVVOQkxHMUNRVUZ0UWl4blFrRkJaMEk3UVVGRGJrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVKQlFXMUNMR2RDUVVGblFqdEJRVU51UXp0QlFVTkJMSFZDUVVGMVFpeG5Ra0ZCWjBJN1FVRkRka003UVVGRFFTd3lRa0ZCTWtJc1owSkJRV2RDTzBGQlF6TkRPMEZCUTBFc0swSkJRU3RDTEdkQ1FVRm5RanRCUVVNdlF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHRRa0ZCYlVJc1owSkJRV2RDTzBGQlEyNURPMEZCUTBFc2RVSkJRWFZDTEdkQ1FVRm5RanRCUVVOMlF6dEJRVU5CTERKQ1FVRXlRaXhuUWtGQlowSTdRVUZETTBNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4dFFrRkJiVUlzWjBKQlFXZENPMEZCUTI1RE8wRkJRMEVzZFVKQlFYVkNMR2RDUVVGblFqdEJRVU4yUXp0QlFVTkJMREpDUVVFeVFpeG5Ra0ZCWjBJN1FVRkRNME03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDTEdkQ1FVRm5RanRCUVVOdVF6dEJRVU5CTzBGQlEwRTdRVUZEVHp0QlFVTlFPMEZCUTA4c2MwSkJRWE5DTERCRlFVRjNRanRCUVVOeVJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzT0VOQlFUaERMRTlCUVU4N1FVRkRja1E3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc05FSkJRVFJDTEhORVFVRlBPMEZCUTI1RE8wRkJRMEVzYTBOQlFXdERMRFpDUVVFMlFqdEJRVU12UkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTdzRRa0ZCT0VJc2EwUkJRVXM3UVVGRGJrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzSzBKQlFTdENMREJDUVVFd1FqdEJRVU42UkN4clEwRkJhME03UVVGRGJFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMQ3RDUVVFclFpeHZRa0ZCYjBJN1FVRkRia1E3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2RVSkJRWFZDTEd0Q1FVRnJRanRCUVVONlF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiMFJCUVc5RUxGZEJRVmM3UVVGREwwUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3huUTBGQlowTXNkVUpCUVhWQ08wRkJRM1pFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc05FSkJRVFJDTEhORVFVRmxPMEZCUXpORExHZERRVUZuUXl4MVEwRkJkVU03UVVGRGRrVTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYTBOQlFXdERMR2REUVVGblF6dEJRVU5zUlR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2QwTkJRWGRETEd0RFFVRnJRenRCUVVNeFJUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3d5UTBGQk1rTXNhVU5CUVdsRE8wRkJRelZGTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHdERRVUZyUXl4cFFrRkJhVUk3UVVGRGJrUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeG5Ra0ZCWjBJN1FVRkRhRUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzSzBKQlFTdENMRzlDUVVGdlFqdEJRVU51UkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2REUVVGblF5eHJRa0ZCYTBJN1FVRkRiRVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h0UXpzN096czdPenM3T3pzN08wRkRlR2xDUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUXpoQ08wRkJRemxDTEdsRE96czdPenM3T3pzN096czdRVU5TUVR0QlFVRkJPMEZCUVVFN1FVRkJkVU03UVVGRGRrTTdRVUZEUVR0QlFVTkJMR2RDUVVGblFqdEJRVU5vUWl4blFrRkJaMEk3UVVGRFZEdEJRVU5RTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc01FTkJRVEJETzBGQlF6RkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2RVSkJRWFZDTEhkQ1FVRjNRanRCUVVNdlF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRzFDUVVGdFFpeFpRVUZaTzBGQlF5OUNMSFZDUVVGMVFpeFhRVUZYTzBGQlEyeERPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEcxQ1FVRnRRaXhuUWtGQlowSTdRVUZEYmtNN1FVRkRRU3gxUWtGQmRVSXNaVUZCWlR0QlFVTjBRenRCUVVOQkxEUkRRVUUwUXl4clJFRkJReXhwUWtGQmFVSXNhMFJCUVVNc2JVSkJRVzFDTEd0RVFVRkRPMEZCUTI1R08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdkRE96czdPenM3T3pzN096czdRVU0zUlVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOUE8wRkJRMUE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRUenRCUVVOUU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTA4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEVHp0QlFVTlFPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFR6dEJRVU5RTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGREUVVGM1F6dEJRVU40UXl3clEwRkJLME1zVDBGQlR6dEJRVU4wUkN4MVEwRkJkVU03UVVGRGRrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVTBGQlV6dEJRVU5VTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hUUVVGVE8wRkJRMVE3UVVGRFFUdEJRVU5CTzBGQlEwRXNjME03T3pzN096czdPenM3T3p0QlEyaEZRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMmRFTzBGQlExZzdRVUZEY2tNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIVkNRVUYxUWl4blFrRkJaMEk3UVVGRGRrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2EwUkJRV3RFTEhsRVFVRlJMRU5CUVVNc2JVVkJRVTg3UVVGRGJFVTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIVkNRVUYxUWl4elFrRkJjMEk3UVVGRE4wTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdsQ1FVRnBRanRCUVVOcVFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSFZDUVVGMVFpeHpRa0ZCYzBJN1FVRkROME03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2xDUVVGcFFqdEJRVU5xUWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIbERPenM3T3pzN096czdPenM3UVVONlJVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRE1rTTdRVUZEU3p0QlFVTmFPMEZCUTBvN1FVRkRhMEk3UVVGRFJUdEJRVU50UXp0QlFVTjJSaXhwUXpzN096czdPenM3T3pzN08wRkRaRUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEydEVPMEZCUTBZN1FVRkRhRVE3UVVGRFFUdEJRVU5QTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVTkJRWEZETEc5Q1FVRnZRanRCUVVONlJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTA4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFTeHRRMEZCYlVNc09FUkJRV003UVVGRGFrUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdsRVFVRnBSQ3hSUVVGUk8wRkJRM3BFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMRzlDUVVGdlFpeFRRVUZUTzBGQlF6ZENPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHZSRUZCYjBRc1QwRkJUenRCUVVNelJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRXNlVU5CUVhsRExGTkJRVk03UVVGRGJFUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFMUJRVTA3UVVGRFRqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhORFFVRnpReXhwUWtGQmFVSTdRVUZEZGtRN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzZVVKQlFYbENMRzFGUVVGUE8wRkJRMmhETEhsQ1FVRjVRaXh0UlVGQlR6dEJRVU5vUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRXNiVU03T3pzN096czdPenM3T3p0QlEyaE1RVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOMVF6dEJRVU4yUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMDg3UVVGRFVDeGpRVUZqTEZsQlFWa3NXVUZCV1R0QlFVTjBRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiVUpCUVcxQ0xHdEVRVUZETEZkQlFWY3NhMFJCUVVNc1lVRkJZU3hyUkVGQlF6dEJRVU01UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRenM3T3pzN096czdPenM3TzBGRE4waEJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTJkRE8wRkJRMmhETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTA4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4dlJFRkJiMFFzVDBGQlR6dEJRVU16UkN4dFEwRkJiVU1zTkVOQlFVc3NaMFJCUVdkRU8wRkJRM2hHTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIVkNRVUYxUWl4UFFVRlBPMEZCUXpsQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNORU5CUVRSRE8wRkJRelZETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEUkRRVUUwUXp0QlFVTTFRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNLME5CUVN0RExFOUJRVTg3UVVGRGRFUXNkVU5CUVhWRExEUkRRVUZMTEc5RFFVRnZRenRCUVVOb1JqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzTUVNN096czdPenM3T3pzN096dEJRM0JIUVR0QlFVRkJPMEZCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc01rTTdPenM3T3pzN096czdPenRCUTJ4Q1FUdEJRVUZCTzBGQlFXMUZPenRCUVVWdVJUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExFVkJRVVU3UVVGRFlpeFhRVUZYTEVWQlFVVTdRVUZEWWl4WFFVRlhMRVZCUVVVN1FVRkRZanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc1ZVRkJWVHRCUVVOV096dEJRVVZCTzBGQlEwRTdRVUZEUVN4WFFVRlhMR05CUVdNN1FVRkRla0lzV1VGQldUdEJRVU5hTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzVjBGQlZ5eFpRVUZaTzBGQlEzWkNMRmRCUVZjc1dVRkJXVHRCUVVOMlFpeGhRVUZoTzBGQlEySTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk1zZDBKQlFYZENPMEZCUTJwRE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRU3g1UWtGQmVVSXNOa05CUVVzN1FVRkRPVUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4clFrRkJhMElzWjBWQlFXZENPMEZCUTJ4RE8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVN4blFrRkJaMElzTmtOQlFVczdRVUZEY2tJN1FVRkRRU3cwUWtGQk5FSXNaMFZCUVdkQ08wRkJRelZETzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRXNVMEZCVXl4eFJFRkJjVVE3TzBGQlJUbEVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSXlNalEzWkdSaU5qYzROVEE0WmpneE5ESTRNQzUzYjNKclpYSXVhbk1pTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJZ1hIUXZMeUJVYUdVZ2JXOWtkV3hsSUdOaFkyaGxYRzRnWEhSMllYSWdhVzV6ZEdGc2JHVmtUVzlrZFd4bGN5QTlJSHQ5TzF4dVhHNGdYSFF2THlCVWFHVWdjbVZ4ZFdseVpTQm1kVzVqZEdsdmJseHVJRngwWm5WdVkzUnBiMjRnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHlodGIyUjFiR1ZKWkNrZ2UxeHVYRzRnWEhSY2RDOHZJRU5vWldOcklHbG1JRzF2WkhWc1pTQnBjeUJwYmlCallXTm9aVnh1SUZ4MFhIUnBaaWhwYm5OMFlXeHNaV1JOYjJSMWJHVnpXMjF2WkhWc1pVbGtYU2tnZTF4dUlGeDBYSFJjZEhKbGRIVnliaUJwYm5OMFlXeHNaV1JOYjJSMWJHVnpXMjF2WkhWc1pVbGtYUzVsZUhCdmNuUnpPMXh1SUZ4MFhIUjlYRzRnWEhSY2RDOHZJRU55WldGMFpTQmhJRzVsZHlCdGIyUjFiR1VnS0dGdVpDQndkWFFnYVhRZ2FXNTBieUIwYUdVZ1kyRmphR1VwWEc0Z1hIUmNkSFpoY2lCdGIyUjFiR1VnUFNCcGJuTjBZV3hzWldSTmIyUjFiR1Z6VzIxdlpIVnNaVWxrWFNBOUlIdGNiaUJjZEZ4MFhIUnBPaUJ0YjJSMWJHVkpaQ3hjYmlCY2RGeDBYSFJzT2lCbVlXeHpaU3hjYmlCY2RGeDBYSFJsZUhCdmNuUnpPaUI3ZlZ4dUlGeDBYSFI5TzF4dVhHNGdYSFJjZEM4dklFVjRaV04xZEdVZ2RHaGxJRzF2WkhWc1pTQm1kVzVqZEdsdmJseHVJRngwWEhSdGIyUjFiR1Z6VzIxdlpIVnNaVWxrWFM1allXeHNLRzF2WkhWc1pTNWxlSEJ2Y25SekxDQnRiMlIxYkdVc0lHMXZaSFZzWlM1bGVIQnZjblJ6TENCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktUdGNibHh1SUZ4MFhIUXZMeUJHYkdGbklIUm9aU0J0YjJSMWJHVWdZWE1nYkc5aFpHVmtYRzRnWEhSY2RHMXZaSFZzWlM1c0lEMGdkSEoxWlR0Y2JseHVJRngwWEhRdkx5QlNaWFIxY200Z2RHaGxJR1Y0Y0c5eWRITWdiMllnZEdobElHMXZaSFZzWlZ4dUlGeDBYSFJ5WlhSMWNtNGdiVzlrZFd4bExtVjRjRzl5ZEhNN1hHNGdYSFI5WEc1Y2JseHVJRngwTHk4Z1pYaHdiM05sSUhSb1pTQnRiMlIxYkdWeklHOWlhbVZqZENBb1gxOTNaV0p3WVdOclgyMXZaSFZzWlhOZlh5bGNiaUJjZEY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4dWJTQTlJRzF2WkhWc1pYTTdYRzVjYmlCY2RDOHZJR1Y0Y0c5elpTQjBhR1VnYlc5a2RXeGxJR05oWTJobFhHNGdYSFJmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmTG1NZ1BTQnBibk4wWVd4c1pXUk5iMlIxYkdWek8xeHVYRzRnWEhRdkx5QmtaV1pwYm1VZ1oyVjBkR1Z5SUdaMWJtTjBhVzl1SUdadmNpQm9ZWEp0YjI1NUlHVjRjRzl5ZEhOY2JpQmNkRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMTh1WkNBOUlHWjFibU4wYVc5dUtHVjRjRzl5ZEhNc0lHNWhiV1VzSUdkbGRIUmxjaWtnZTF4dUlGeDBYSFJwWmlnaFgxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5NXZLR1Y0Y0c5eWRITXNJRzVoYldVcEtTQjdYRzRnWEhSY2RGeDBUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0dWNGNHOXlkSE1zSUc1aGJXVXNJSHNnWlc1MWJXVnlZV0pzWlRvZ2RISjFaU3dnWjJWME9pQm5aWFIwWlhJZ2ZTazdYRzRnWEhSY2RIMWNiaUJjZEgwN1hHNWNiaUJjZEM4dklHUmxabWx1WlNCZlgyVnpUVzlrZFd4bElHOXVJR1Y0Y0c5eWRITmNiaUJjZEY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4dWNpQTlJR1oxYm1OMGFXOXVLR1Y0Y0c5eWRITXBJSHRjYmlCY2RGeDBhV1lvZEhsd1pXOW1JRk41YldKdmJDQWhQVDBnSjNWdVpHVm1hVzVsWkNjZ0ppWWdVM2x0WW05c0xuUnZVM1J5YVc1blZHRm5LU0I3WEc0Z1hIUmNkRngwVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUtHVjRjRzl5ZEhNc0lGTjViV0p2YkM1MGIxTjBjbWx1WjFSaFp5d2dleUIyWVd4MVpUb2dKMDF2WkhWc1pTY2dmU2s3WEc0Z1hIUmNkSDFjYmlCY2RGeDBUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0dWNGNHOXlkSE1zSUNkZlgyVnpUVzlrZFd4bEp5d2dleUIyWVd4MVpUb2dkSEoxWlNCOUtUdGNiaUJjZEgwN1hHNWNiaUJjZEM4dklHTnlaV0YwWlNCaElHWmhhMlVnYm1GdFpYTndZV05sSUc5aWFtVmpkRnh1SUZ4MEx5OGdiVzlrWlNBbUlERTZJSFpoYkhWbElHbHpJR0VnYlc5a2RXeGxJR2xrTENCeVpYRjFhWEpsSUdsMFhHNGdYSFF2THlCdGIyUmxJQ1lnTWpvZ2JXVnlaMlVnWVd4c0lIQnliM0JsY25ScFpYTWdiMllnZG1Gc2RXVWdhVzUwYnlCMGFHVWdibk5jYmlCY2RDOHZJRzF2WkdVZ0ppQTBPaUJ5WlhSMWNtNGdkbUZzZFdVZ2QyaGxiaUJoYkhKbFlXUjVJRzV6SUc5aWFtVmpkRnh1SUZ4MEx5OGdiVzlrWlNBbUlEaDhNVG9nWW1Wb1lYWmxJR3hwYTJVZ2NtVnhkV2x5WlZ4dUlGeDBYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeTUwSUQwZ1puVnVZM1JwYjI0b2RtRnNkV1VzSUcxdlpHVXBJSHRjYmlCY2RGeDBhV1lvYlc5a1pTQW1JREVwSUhaaGJIVmxJRDBnWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHloMllXeDFaU2s3WEc0Z1hIUmNkR2xtS0cxdlpHVWdKaUE0S1NCeVpYUjFjbTRnZG1Gc2RXVTdYRzRnWEhSY2RHbG1LQ2h0YjJSbElDWWdOQ2tnSmlZZ2RIbHdaVzltSUhaaGJIVmxJRDA5UFNBbmIySnFaV04wSnlBbUppQjJZV3gxWlNBbUppQjJZV3gxWlM1ZlgyVnpUVzlrZFd4bEtTQnlaWFIxY200Z2RtRnNkV1U3WEc0Z1hIUmNkSFpoY2lCdWN5QTlJRTlpYW1WamRDNWpjbVZoZEdVb2JuVnNiQ2s3WEc0Z1hIUmNkRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMTh1Y2lodWN5azdYRzRnWEhSY2RFOWlhbVZqZEM1a1pXWnBibVZRY205d1pYSjBlU2h1Y3l3Z0oyUmxabUYxYkhRbkxDQjdJR1Z1ZFcxbGNtRmliR1U2SUhSeWRXVXNJSFpoYkhWbE9pQjJZV3gxWlNCOUtUdGNiaUJjZEZ4MGFXWW9iVzlrWlNBbUlESWdKaVlnZEhsd1pXOW1JSFpoYkhWbElDRTlJQ2R6ZEhKcGJtY25LU0JtYjNJb2RtRnlJR3RsZVNCcGJpQjJZV3gxWlNrZ1gxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5NWtLRzV6TENCclpYa3NJR1oxYm1OMGFXOXVLR3RsZVNrZ2V5QnlaWFIxY200Z2RtRnNkV1ZiYTJWNVhUc2dmUzVpYVc1a0tHNTFiR3dzSUd0bGVTa3BPMXh1SUZ4MFhIUnlaWFIxY200Z2JuTTdYRzRnWEhSOU8xeHVYRzRnWEhRdkx5Qm5aWFJFWldaaGRXeDBSWGh3YjNKMElHWjFibU4wYVc5dUlHWnZjaUJqYjIxd1lYUnBZbWxzYVhSNUlIZHBkR2dnYm05dUxXaGhjbTF2Ym5rZ2JXOWtkV3hsYzF4dUlGeDBYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeTV1SUQwZ1puVnVZM1JwYjI0b2JXOWtkV3hsS1NCN1hHNGdYSFJjZEhaaGNpQm5aWFIwWlhJZ1BTQnRiMlIxYkdVZ0ppWWdiVzlrZFd4bExsOWZaWE5OYjJSMWJHVWdQMXh1SUZ4MFhIUmNkR1oxYm1OMGFXOXVJR2RsZEVSbFptRjFiSFFvS1NCN0lISmxkSFZ5YmlCdGIyUjFiR1ZiSjJSbFptRjFiSFFuWFRzZ2ZTQTZYRzRnWEhSY2RGeDBablZ1WTNScGIyNGdaMlYwVFc5a2RXeGxSWGh3YjNKMGN5Z3BJSHNnY21WMGRYSnVJRzF2WkhWc1pUc2dmVHRjYmlCY2RGeDBYMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeTVrS0dkbGRIUmxjaXdnSjJFbkxDQm5aWFIwWlhJcE8xeHVJRngwWEhSeVpYUjFjbTRnWjJWMGRHVnlPMXh1SUZ4MGZUdGNibHh1SUZ4MEx5OGdUMkpxWldOMExuQnliM1J2ZEhsd1pTNW9ZWE5QZDI1UWNtOXdaWEowZVM1allXeHNYRzRnWEhSZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxtOGdQU0JtZFc1amRHbHZiaWh2WW1wbFkzUXNJSEJ5YjNCbGNuUjVLU0I3SUhKbGRIVnliaUJQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMbWhoYzA5M2JsQnliM0JsY25SNUxtTmhiR3dvYjJKcVpXTjBMQ0J3Y205d1pYSjBlU2s3SUgwN1hHNWNiaUJjZEM4dklGOWZkMlZpY0dGamExOXdkV0pzYVdOZmNHRjBhRjlmWEc0Z1hIUmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZMbkFnUFNCY0lsd2lPMXh1WEc1Y2JpQmNkQzh2SUV4dllXUWdaVzUwY25rZ2JXOWtkV3hsSUdGdVpDQnlaWFIxY200Z1pYaHdiM0owYzF4dUlGeDBjbVYwZFhKdUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9YMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeTV6SUQwZ1hDSXVMM055WXk5QmJtbHRZWFJsWkY5SFNVWXVkMjl5YTJWeUxtcHpYQ0lwTzF4dUlpd2ljbVZ4ZFdseVpTZ25MaTR2Ylc5a2RXeGxjeTkzWldJdWFXMXRaV1JwWVhSbEp5azdYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSEpsY1hWcGNtVW9KeTR1TDIxdlpIVnNaWE12WDJOdmNtVW5LUzV6WlhSSmJXMWxaR2xoZEdVN1hHNGlMQ0p0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJQ2hwZENrZ2UxeHVJQ0JwWmlBb2RIbHdaVzltSUdsMElDRTlJQ2RtZFc1amRHbHZiaWNwSUhSb2NtOTNJRlI1Y0dWRmNuSnZjaWhwZENBcklDY2dhWE1nYm05MElHRWdablZ1WTNScGIyNGhKeWs3WEc0Z0lISmxkSFZ5YmlCcGREdGNibjA3WEc0aUxDSjJZWElnYVhOUFltcGxZM1FnUFNCeVpYRjFhWEpsS0NjdUwxOXBjeTF2WW1wbFkzUW5LVHRjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnS0dsMEtTQjdYRzRnSUdsbUlDZ2hhWE5QWW1wbFkzUW9hWFFwS1NCMGFISnZkeUJVZVhCbFJYSnliM0lvYVhRZ0t5QW5JR2x6SUc1dmRDQmhiaUJ2WW1wbFkzUWhKeWs3WEc0Z0lISmxkSFZ5YmlCcGREdGNibjA3WEc0aUxDSjJZWElnZEc5VGRISnBibWNnUFNCN2ZTNTBiMU4wY21sdVp6dGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUFvYVhRcElIdGNiaUFnY21WMGRYSnVJSFJ2VTNSeWFXNW5MbU5oYkd3b2FYUXBMbk5zYVdObEtEZ3NJQzB4S1R0Y2JuMDdYRzRpTENKMllYSWdZMjl5WlNBOUlHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2V5QjJaWEp6YVc5dU9pQW5NaTQxTGpJbklIMDdYRzVwWmlBb2RIbHdaVzltSUY5ZlpTQTlQU0FuYm5WdFltVnlKeWtnWDE5bElEMGdZMjl5WlRzZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJHbHVaU0J1YnkxMWJtUmxabHh1SWl3aUx5OGdiM0IwYVc5dVlXd2dMeUJ6YVcxd2JHVWdZMjl1ZEdWNGRDQmlhVzVrYVc1blhHNTJZWElnWVVaMWJtTjBhVzl1SUQwZ2NtVnhkV2x5WlNnbkxpOWZZUzFtZFc1amRHbHZiaWNwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlBb1ptNHNJSFJvWVhRc0lHeGxibWQwYUNrZ2UxeHVJQ0JoUm5WdVkzUnBiMjRvWm00cE8xeHVJQ0JwWmlBb2RHaGhkQ0E5UFQwZ2RXNWtaV1pwYm1Wa0tTQnlaWFIxY200Z1ptNDdYRzRnSUhOM2FYUmphQ0FvYkdWdVozUm9LU0I3WEc0Z0lDQWdZMkZ6WlNBeE9pQnlaWFIxY200Z1puVnVZM1JwYjI0Z0tHRXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1iaTVqWVd4c0tIUm9ZWFFzSUdFcE8xeHVJQ0FnSUgwN1hHNGdJQ0FnWTJGelpTQXlPaUJ5WlhSMWNtNGdablZ1WTNScGIyNGdLR0VzSUdJcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbWJpNWpZV3hzS0hSb1lYUXNJR0VzSUdJcE8xeHVJQ0FnSUgwN1hHNGdJQ0FnWTJGelpTQXpPaUJ5WlhSMWNtNGdablZ1WTNScGIyNGdLR0VzSUdJc0lHTXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1iaTVqWVd4c0tIUm9ZWFFzSUdFc0lHSXNJR01wTzF4dUlDQWdJSDA3WEc0Z0lIMWNiaUFnY21WMGRYSnVJR1oxYm1OMGFXOXVJQ2d2S2lBdUxpNWhjbWR6SUNvdktTQjdYRzRnSUNBZ2NtVjBkWEp1SUdadUxtRndjR3g1S0hSb1lYUXNJR0Z5WjNWdFpXNTBjeWs3WEc0Z0lIMDdYRzU5TzF4dUlpd2lMeThnVkdoaGJtc25jeUJKUlRnZ1ptOXlJR2hwY3lCbWRXNXVlU0JrWldacGJtVlFjbTl3WlhKMGVWeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQWhjbVZ4ZFdseVpTZ25MaTlmWm1GcGJITW5LU2htZFc1amRHbHZiaUFvS1NCN1hHNGdJSEpsZEhWeWJpQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvZTMwc0lDZGhKeXdnZXlCblpYUTZJR1oxYm1OMGFXOXVJQ2dwSUhzZ2NtVjBkWEp1SURjN0lIMGdmU2t1WVNBaFBTQTNPMXh1ZlNrN1hHNGlMQ0oyWVhJZ2FYTlBZbXBsWTNRZ1BTQnlaWEYxYVhKbEtDY3VMMTlwY3kxdlltcGxZM1FuS1R0Y2JuWmhjaUJrYjJOMWJXVnVkQ0E5SUhKbGNYVnBjbVVvSnk0dlgyZHNiMkpoYkNjcExtUnZZM1Z0Wlc1ME8xeHVMeThnZEhsd1pXOW1JR1J2WTNWdFpXNTBMbU55WldGMFpVVnNaVzFsYm5RZ2FYTWdKMjlpYW1WamRDY2dhVzRnYjJ4a0lFbEZYRzUyWVhJZ2FYTWdQU0JwYzA5aWFtVmpkQ2hrYjJOMWJXVnVkQ2tnSmlZZ2FYTlBZbXBsWTNRb1pHOWpkVzFsYm5RdVkzSmxZWFJsUld4bGJXVnVkQ2s3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUNocGRDa2dlMXh1SUNCeVpYUjFjbTRnYVhNZ1B5QmtiMk4xYldWdWRDNWpjbVZoZEdWRmJHVnRaVzUwS0dsMEtTQTZJSHQ5TzF4dWZUdGNiaUlzSW5aaGNpQm5iRzlpWVd3Z1BTQnlaWEYxYVhKbEtDY3VMMTluYkc5aVlXd25LVHRjYm5aaGNpQmpiM0psSUQwZ2NtVnhkV2x5WlNnbkxpOWZZMjl5WlNjcE8xeHVkbUZ5SUdocFpHVWdQU0J5WlhGMWFYSmxLQ2N1TDE5b2FXUmxKeWs3WEc1MllYSWdjbVZrWldacGJtVWdQU0J5WlhGMWFYSmxLQ2N1TDE5eVpXUmxabWx1WlNjcE8xeHVkbUZ5SUdOMGVDQTlJSEpsY1hWcGNtVW9KeTR2WDJOMGVDY3BPMXh1ZG1GeUlGQlNUMVJQVkZsUVJTQTlJQ2R3Y205MGIzUjVjR1VuTzF4dVhHNTJZWElnSkdWNGNHOXlkQ0E5SUdaMWJtTjBhVzl1SUNoMGVYQmxMQ0J1WVcxbExDQnpiM1Z5WTJVcElIdGNiaUFnZG1GeUlFbFRYMFpQVWtORlJDQTlJSFI1Y0dVZ0ppQWtaWGh3YjNKMExrWTdYRzRnSUhaaGNpQkpVMTlIVEU5Q1FVd2dQU0IwZVhCbElDWWdKR1Y0Y0c5eWRDNUhPMXh1SUNCMllYSWdTVk5mVTFSQlZFbERJRDBnZEhsd1pTQW1JQ1JsZUhCdmNuUXVVenRjYmlBZ2RtRnlJRWxUWDFCU1QxUlBJRDBnZEhsd1pTQW1JQ1JsZUhCdmNuUXVVRHRjYmlBZ2RtRnlJRWxUWDBKSlRrUWdQU0IwZVhCbElDWWdKR1Y0Y0c5eWRDNUNPMXh1SUNCMllYSWdkR0Z5WjJWMElEMGdTVk5mUjB4UFFrRk1JRDhnWjJ4dlltRnNJRG9nU1ZOZlUxUkJWRWxESUQ4Z1oyeHZZbUZzVzI1aGJXVmRJSHg4SUNobmJHOWlZV3hiYm1GdFpWMGdQU0I3ZlNrZ09pQW9aMnh2WW1Gc1cyNWhiV1ZkSUh4OElIdDlLVnRRVWs5VVQxUlpVRVZkTzF4dUlDQjJZWElnWlhod2IzSjBjeUE5SUVsVFgwZE1UMEpCVENBL0lHTnZjbVVnT2lCamIzSmxXMjVoYldWZElIeDhJQ2hqYjNKbFcyNWhiV1ZkSUQwZ2UzMHBPMXh1SUNCMllYSWdaWGh3VUhKdmRHOGdQU0JsZUhCdmNuUnpXMUJTVDFSUFZGbFFSVjBnZkh3Z0tHVjRjRzl5ZEhOYlVGSlBWRTlVV1ZCRlhTQTlJSHQ5S1R0Y2JpQWdkbUZ5SUd0bGVTd2diM2R1TENCdmRYUXNJR1Y0Y0R0Y2JpQWdhV1lnS0VsVFgwZE1UMEpCVENrZ2MyOTFjbU5sSUQwZ2JtRnRaVHRjYmlBZ1ptOXlJQ2hyWlhrZ2FXNGdjMjkxY21ObEtTQjdYRzRnSUNBZ0x5OGdZMjl1ZEdGcGJuTWdhVzRnYm1GMGFYWmxYRzRnSUNBZ2IzZHVJRDBnSVVsVFgwWlBVa05GUkNBbUppQjBZWEpuWlhRZ0ppWWdkR0Z5WjJWMFcydGxlVjBnSVQwOUlIVnVaR1ZtYVc1bFpEdGNiaUFnSUNBdkx5QmxlSEJ2Y25RZ2JtRjBhWFpsSUc5eUlIQmhjM05sWkZ4dUlDQWdJRzkxZENBOUlDaHZkMjRnUHlCMFlYSm5aWFFnT2lCemIzVnlZMlVwVzJ0bGVWMDdYRzRnSUNBZ0x5OGdZbWx1WkNCMGFXMWxjbk1nZEc4Z1oyeHZZbUZzSUdadmNpQmpZV3hzSUdaeWIyMGdaWGh3YjNKMElHTnZiblJsZUhSY2JpQWdJQ0JsZUhBZ1BTQkpVMTlDU1U1RUlDWW1JRzkzYmlBL0lHTjBlQ2h2ZFhRc0lHZHNiMkpoYkNrZ09pQkpVMTlRVWs5VVR5QW1KaUIwZVhCbGIyWWdiM1YwSUQwOUlDZG1kVzVqZEdsdmJpY2dQeUJqZEhnb1JuVnVZM1JwYjI0dVkyRnNiQ3dnYjNWMEtTQTZJRzkxZER0Y2JpQWdJQ0F2THlCbGVIUmxibVFnWjJ4dlltRnNYRzRnSUNBZ2FXWWdLSFJoY21kbGRDa2djbVZrWldacGJtVW9kR0Z5WjJWMExDQnJaWGtzSUc5MWRDd2dkSGx3WlNBbUlDUmxlSEJ2Y25RdVZTazdYRzRnSUNBZ0x5OGdaWGh3YjNKMFhHNGdJQ0FnYVdZZ0tHVjRjRzl5ZEhOYmEyVjVYU0FoUFNCdmRYUXBJR2hwWkdVb1pYaHdiM0owY3l3Z2EyVjVMQ0JsZUhBcE8xeHVJQ0FnSUdsbUlDaEpVMTlRVWs5VVR5QW1KaUJsZUhCUWNtOTBiMXRyWlhsZElDRTlJRzkxZENrZ1pYaHdVSEp2ZEc5YmEyVjVYU0E5SUc5MWREdGNiaUFnZlZ4dWZUdGNibWRzYjJKaGJDNWpiM0psSUQwZ1kyOXlaVHRjYmk4dklIUjVjR1VnWW1sMGJXRndYRzRrWlhod2IzSjBMa1lnUFNBeE95QWdJQzh2SUdadmNtTmxaRnh1SkdWNGNHOXlkQzVISUQwZ01qc2dJQ0F2THlCbmJHOWlZV3hjYmlSbGVIQnZjblF1VXlBOUlEUTdJQ0FnTHk4Z2MzUmhkR2xqWEc0a1pYaHdiM0owTGxBZ1BTQTRPeUFnSUM4dklIQnliM1J2WEc0a1pYaHdiM0owTGtJZ1BTQXhOanNnSUM4dklHSnBibVJjYmlSbGVIQnZjblF1VnlBOUlETXlPeUFnTHk4Z2QzSmhjRnh1SkdWNGNHOXlkQzVWSUQwZ05qUTdJQ0F2THlCellXWmxYRzRrWlhod2IzSjBMbElnUFNBeE1qZzdJQzh2SUhKbFlXd2djSEp2ZEc4Z2JXVjBhRzlrSUdadmNpQmdiR2xpY21GeWVXQmNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdKR1Y0Y0c5eWREdGNiaUlzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnS0dWNFpXTXBJSHRjYmlBZ2RISjVJSHRjYmlBZ0lDQnlaWFIxY200Z0lTRmxlR1ZqS0NrN1hHNGdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JpQWdmVnh1ZlR0Y2JpSXNJaTh2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5NmJHOXBjbTlqYXk5amIzSmxMV3B6TDJsemMzVmxjeTg0TmlOcGMzTjFaV052YlcxbGJuUXRNVEUxTnpVNU1ESTRYRzUyWVhJZ1oyeHZZbUZzSUQwZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCMGVYQmxiMllnZDJsdVpHOTNJQ0U5SUNkMWJtUmxabWx1WldRbklDWW1JSGRwYm1SdmR5NU5ZWFJvSUQwOUlFMWhkR2hjYmlBZ1B5QjNhVzVrYjNjZ09pQjBlWEJsYjJZZ2MyVnNaaUFoUFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUJ6Wld4bUxrMWhkR2dnUFQwZ1RXRjBhQ0EvSUhObGJHWmNiaUFnTHk4Z1pYTnNhVzUwTFdScGMyRmliR1V0Ym1WNGRDMXNhVzVsSUc1dkxXNWxkeTFtZFc1alhHNGdJRG9nUm5WdVkzUnBiMjRvSjNKbGRIVnliaUIwYUdsekp5a29LVHRjYm1sbUlDaDBlWEJsYjJZZ1gxOW5JRDA5SUNkdWRXMWlaWEluS1NCZlgyY2dQU0JuYkc5aVlXdzdJQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMV3hwYm1VZ2JtOHRkVzVrWldaY2JpSXNJblpoY2lCb1lYTlBkMjVRY205d1pYSjBlU0E5SUh0OUxtaGhjMDkzYmxCeWIzQmxjblI1TzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlBb2FYUXNJR3RsZVNrZ2UxeHVJQ0J5WlhSMWNtNGdhR0Z6VDNkdVVISnZjR1Z5ZEhrdVkyRnNiQ2hwZEN3Z2EyVjVLVHRjYm4wN1hHNGlMQ0oyWVhJZ1pGQWdQU0J5WlhGMWFYSmxLQ2N1TDE5dlltcGxZM1F0WkhBbktUdGNiblpoY2lCamNtVmhkR1ZFWlhOaklEMGdjbVZ4ZFdseVpTZ25MaTlmY0hKdmNHVnlkSGt0WkdWell5Y3BPMXh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0J5WlhGMWFYSmxLQ2N1TDE5a1pYTmpjbWx3ZEc5eWN5Y3BJRDhnWm5WdVkzUnBiMjRnS0c5aWFtVmpkQ3dnYTJWNUxDQjJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdaRkF1WmlodlltcGxZM1FzSUd0bGVTd2dZM0psWVhSbFJHVnpZeWd4TENCMllXeDFaU2twTzF4dWZTQTZJR1oxYm1OMGFXOXVJQ2h2WW1wbFkzUXNJR3RsZVN3Z2RtRnNkV1VwSUh0Y2JpQWdiMkpxWldOMFcydGxlVjBnUFNCMllXeDFaVHRjYmlBZ2NtVjBkWEp1SUc5aWFtVmpkRHRjYm4wN1hHNGlMQ0oyWVhJZ1pHOWpkVzFsYm5RZ1BTQnlaWEYxYVhKbEtDY3VMMTluYkc5aVlXd25LUzVrYjJOMWJXVnVkRHRjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWkc5amRXMWxiblFnSmlZZ1pHOWpkVzFsYm5RdVpHOWpkVzFsYm5SRmJHVnRaVzUwTzF4dUlpd2liVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQWhjbVZ4ZFdseVpTZ25MaTlmWkdWelkzSnBjSFJ2Y25NbktTQW1KaUFoY21WeGRXbHlaU2duTGk5ZlptRnBiSE1uS1NobWRXNWpkR2x2YmlBb0tTQjdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb2NtVnhkV2x5WlNnbkxpOWZaRzl0TFdOeVpXRjBaU2NwS0Nka2FYWW5LU3dnSjJFbkxDQjdJR2RsZERvZ1puVnVZM1JwYjI0Z0tDa2dleUJ5WlhSMWNtNGdOenNnZlNCOUtTNWhJQ0U5SURjN1hHNTlLVHRjYmlJc0lpOHZJR1poYzNRZ1lYQndiSGtzSUdoMGRIQTZMeTlxYzNCbGNtWXViRzVyYVhRdVkyOXRMMlpoYzNRdFlYQndiSGt2TlZ4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlBb1ptNHNJR0Z5WjNNc0lIUm9ZWFFwSUh0Y2JpQWdkbUZ5SUhWdUlEMGdkR2hoZENBOVBUMGdkVzVrWldacGJtVmtPMXh1SUNCemQybDBZMmdnS0dGeVozTXViR1Z1WjNSb0tTQjdYRzRnSUNBZ1kyRnpaU0F3T2lCeVpYUjFjbTRnZFc0Z1B5Qm1iaWdwWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdPaUJtYmk1allXeHNLSFJvWVhRcE8xeHVJQ0FnSUdOaGMyVWdNVG9nY21WMGRYSnVJSFZ1SUQ4Z1ptNG9ZWEpuYzFzd1hTbGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBNklHWnVMbU5oYkd3b2RHaGhkQ3dnWVhKbmMxc3dYU2s3WEc0Z0lDQWdZMkZ6WlNBeU9pQnlaWFIxY200Z2RXNGdQeUJtYmloaGNtZHpXekJkTENCaGNtZHpXekZkS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRG9nWm00dVkyRnNiQ2gwYUdGMExDQmhjbWR6V3pCZExDQmhjbWR6V3pGZEtUdGNiaUFnSUNCallYTmxJRE02SUhKbGRIVnliaUIxYmlBL0lHWnVLR0Z5WjNOYk1GMHNJR0Z5WjNOYk1WMHNJR0Z5WjNOYk1sMHBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ09pQm1iaTVqWVd4c0tIUm9ZWFFzSUdGeVozTmJNRjBzSUdGeVozTmJNVjBzSUdGeVozTmJNbDBwTzF4dUlDQWdJR05oYzJVZ05Eb2djbVYwZFhKdUlIVnVJRDhnWm00b1lYSm5jMXN3WFN3Z1lYSm5jMXN4WFN3Z1lYSm5jMXN5WFN3Z1lYSm5jMXN6WFNsY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E2SUdadUxtTmhiR3dvZEdoaGRDd2dZWEpuYzFzd1hTd2dZWEpuYzFzeFhTd2dZWEpuYzFzeVhTd2dZWEpuYzFzelhTazdYRzRnSUgwZ2NtVjBkWEp1SUdadUxtRndjR3g1S0hSb1lYUXNJR0Z5WjNNcE8xeHVmVHRjYmlJc0ltMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z0tHbDBLU0I3WEc0Z0lISmxkSFZ5YmlCMGVYQmxiMllnYVhRZ1BUMDlJQ2R2WW1wbFkzUW5JRDhnYVhRZ0lUMDlJRzUxYkd3Z09pQjBlWEJsYjJZZ2FYUWdQVDA5SUNkbWRXNWpkR2x2YmljN1hHNTlPMXh1SWl3aWRtRnlJR0Z1VDJKcVpXTjBJRDBnY21WeGRXbHlaU2duTGk5ZllXNHRiMkpxWldOMEp5azdYRzUyWVhJZ1NVVTRYMFJQVFY5RVJVWkpUa1VnUFNCeVpYRjFhWEpsS0NjdUwxOXBaVGd0Wkc5dExXUmxabWx1WlNjcE8xeHVkbUZ5SUhSdlVISnBiV2wwYVhabElEMGdjbVZ4ZFdseVpTZ25MaTlmZEc4dGNISnBiV2wwYVhabEp5azdYRzUyWVhJZ1pGQWdQU0JQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrN1hHNWNibVY0Y0c5eWRITXVaaUE5SUhKbGNYVnBjbVVvSnk0dlgyUmxjMk55YVhCMGIzSnpKeWtnUHlCUFltcGxZM1F1WkdWbWFXNWxVSEp2Y0dWeWRIa2dPaUJtZFc1amRHbHZiaUJrWldacGJtVlFjbTl3WlhKMGVTaFBMQ0JRTENCQmRIUnlhV0oxZEdWektTQjdYRzRnSUdGdVQySnFaV04wS0U4cE8xeHVJQ0JRSUQwZ2RHOVFjbWx0YVhScGRtVW9VQ3dnZEhKMVpTazdYRzRnSUdGdVQySnFaV04wS0VGMGRISnBZblYwWlhNcE8xeHVJQ0JwWmlBb1NVVTRYMFJQVFY5RVJVWkpUa1VwSUhSeWVTQjdYRzRnSUNBZ2NtVjBkWEp1SUdSUUtFOHNJRkFzSUVGMGRISnBZblYwWlhNcE8xeHVJQ0I5SUdOaGRHTm9JQ2hsS1NCN0lDOHFJR1Z0Y0hSNUlDb3ZJSDFjYmlBZ2FXWWdLQ2RuWlhRbklHbHVJRUYwZEhKcFluVjBaWE1nZkh3Z0ozTmxkQ2NnYVc0Z1FYUjBjbWxpZFhSbGN5a2dkR2h5YjNjZ1ZIbHdaVVZ5Y205eUtDZEJZMk5sYzNOdmNuTWdibTkwSUhOMWNIQnZjblJsWkNFbktUdGNiaUFnYVdZZ0tDZDJZV3gxWlNjZ2FXNGdRWFIwY21saWRYUmxjeWtnVDF0UVhTQTlJRUYwZEhKcFluVjBaWE11ZG1Gc2RXVTdYRzRnSUhKbGRIVnliaUJQTzF4dWZUdGNiaUlzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnS0dKcGRHMWhjQ3dnZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0JsYm5WdFpYSmhZbXhsT2lBaEtHSnBkRzFoY0NBbUlERXBMRnh1SUNBZ0lHTnZibVpwWjNWeVlXSnNaVG9nSVNoaWFYUnRZWEFnSmlBeUtTeGNiaUFnSUNCM2NtbDBZV0pzWlRvZ0lTaGlhWFJ0WVhBZ0ppQTBLU3hjYmlBZ0lDQjJZV3gxWlRvZ2RtRnNkV1ZjYmlBZ2ZUdGNibjA3WEc0aUxDSjJZWElnWjJ4dlltRnNJRDBnY21WeGRXbHlaU2duTGk5ZloyeHZZbUZzSnlrN1hHNTJZWElnYUdsa1pTQTlJSEpsY1hWcGNtVW9KeTR2WDJocFpHVW5LVHRjYm5aaGNpQm9ZWE1nUFNCeVpYRjFhWEpsS0NjdUwxOW9ZWE1uS1R0Y2JuWmhjaUJUVWtNZ1BTQnlaWEYxYVhKbEtDY3VMMTkxYVdRbktTZ25jM0pqSnlrN1hHNTJZWElnVkU5ZlUxUlNTVTVISUQwZ0ozUnZVM1J5YVc1bkp6dGNiblpoY2lBa2RHOVRkSEpwYm1jZ1BTQkdkVzVqZEdsdmJsdFVUMTlUVkZKSlRrZGRPMXh1ZG1GeUlGUlFUQ0E5SUNnbkp5QXJJQ1IwYjFOMGNtbHVaeWt1YzNCc2FYUW9WRTlmVTFSU1NVNUhLVHRjYmx4dWNtVnhkV2x5WlNnbkxpOWZZMjl5WlNjcExtbHVjM0JsWTNSVGIzVnlZMlVnUFNCbWRXNWpkR2x2YmlBb2FYUXBJSHRjYmlBZ2NtVjBkWEp1SUNSMGIxTjBjbWx1Wnk1allXeHNLR2wwS1R0Y2JuMDdYRzVjYmlodGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUNoUExDQnJaWGtzSUhaaGJDd2djMkZtWlNrZ2UxeHVJQ0IyWVhJZ2FYTkdkVzVqZEdsdmJpQTlJSFI1Y0dWdlppQjJZV3dnUFQwZ0oyWjFibU4wYVc5dUp6dGNiaUFnYVdZZ0tHbHpSblZ1WTNScGIyNHBJR2hoY3loMllXd3NJQ2R1WVcxbEp5a2dmSHdnYUdsa1pTaDJZV3dzSUNkdVlXMWxKeXdnYTJWNUtUdGNiaUFnYVdZZ0tFOWJhMlY1WFNBOVBUMGdkbUZzS1NCeVpYUjFjbTQ3WEc0Z0lHbG1JQ2hwYzBaMWJtTjBhVzl1S1NCb1lYTW9kbUZzTENCVFVrTXBJSHg4SUdocFpHVW9kbUZzTENCVFVrTXNJRTliYTJWNVhTQS9JQ2NuSUNzZ1QxdHJaWGxkSURvZ1ZGQk1MbXB2YVc0b1UzUnlhVzVuS0d0bGVTa3BLVHRjYmlBZ2FXWWdLRThnUFQwOUlHZHNiMkpoYkNrZ2UxeHVJQ0FnSUU5YmEyVjVYU0E5SUhaaGJEdGNiaUFnZlNCbGJITmxJR2xtSUNnaGMyRm1aU2tnZTF4dUlDQWdJR1JsYkdWMFpTQlBXMnRsZVYwN1hHNGdJQ0FnYUdsa1pTaFBMQ0JyWlhrc0lIWmhiQ2s3WEc0Z0lIMGdaV3h6WlNCcFppQW9UMXRyWlhsZEtTQjdYRzRnSUNBZ1QxdHJaWGxkSUQwZ2RtRnNPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR2hwWkdVb1R5d2dhMlY1TENCMllXd3BPMXh1SUNCOVhHNHZMeUJoWkdRZ1ptRnJaU0JHZFc1amRHbHZiaU4wYjFOMGNtbHVaeUJtYjNJZ1kyOXljbVZqZENCM2IzSnJJSGR5WVhCd1pXUWdiV1YwYUc5a2N5QXZJR052Ym5OMGNuVmpkRzl5Y3lCM2FYUm9JRzFsZEdodlpITWdiR2xyWlNCTWIwUmhjMmdnYVhOT1lYUnBkbVZjYm4wcEtFWjFibU4wYVc5dUxuQnliM1J2ZEhsd1pTd2dWRTlmVTFSU1NVNUhMQ0JtZFc1amRHbHZiaUIwYjFOMGNtbHVaeWdwSUh0Y2JpQWdjbVYwZFhKdUlIUjVjR1Z2WmlCMGFHbHpJRDA5SUNkbWRXNWpkR2x2YmljZ0ppWWdkR2hwYzF0VFVrTmRJSHg4SUNSMGIxTjBjbWx1Wnk1allXeHNLSFJvYVhNcE8xeHVmU2s3WEc0aUxDSjJZWElnWTNSNElEMGdjbVZ4ZFdseVpTZ25MaTlmWTNSNEp5azdYRzUyWVhJZ2FXNTJiMnRsSUQwZ2NtVnhkV2x5WlNnbkxpOWZhVzUyYjJ0bEp5azdYRzUyWVhJZ2FIUnRiQ0E5SUhKbGNYVnBjbVVvSnk0dlgyaDBiV3duS1R0Y2JuWmhjaUJqWld3Z1BTQnlaWEYxYVhKbEtDY3VMMTlrYjIwdFkzSmxZWFJsSnlrN1hHNTJZWElnWjJ4dlltRnNJRDBnY21WeGRXbHlaU2duTGk5ZloyeHZZbUZzSnlrN1hHNTJZWElnY0hKdlkyVnpjeUE5SUdkc2IySmhiQzV3Y205alpYTnpPMXh1ZG1GeUlITmxkRlJoYzJzZ1BTQm5iRzlpWVd3dWMyVjBTVzF0WldScFlYUmxPMXh1ZG1GeUlHTnNaV0Z5VkdGemF5QTlJR2RzYjJKaGJDNWpiR1ZoY2tsdGJXVmthV0YwWlR0Y2JuWmhjaUJOWlhOellXZGxRMmhoYm01bGJDQTlJR2RzYjJKaGJDNU5aWE56WVdkbFEyaGhibTVsYkR0Y2JuWmhjaUJFYVhOd1lYUmphQ0E5SUdkc2IySmhiQzVFYVhOd1lYUmphRHRjYm5aaGNpQmpiM1Z1ZEdWeUlEMGdNRHRjYm5aaGNpQnhkV1YxWlNBOUlIdDlPMXh1ZG1GeUlFOU9Va1ZCUkZsVFZFRlVSVU5JUVU1SFJTQTlJQ2R2Ym5KbFlXUjVjM1JoZEdWamFHRnVaMlVuTzF4dWRtRnlJR1JsWm1WeUxDQmphR0Z1Ym1Wc0xDQndiM0owTzF4dWRtRnlJSEoxYmlBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ2RtRnlJR2xrSUQwZ0szUm9hWE03WEc0Z0lDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXNWxlSFF0YkdsdVpTQnVieTF3Y205MGIzUjVjR1V0WW5WcGJIUnBibk5jYmlBZ2FXWWdLSEYxWlhWbExtaGhjMDkzYmxCeWIzQmxjblI1S0dsa0tTa2dlMXh1SUNBZ0lIWmhjaUJtYmlBOUlIRjFaWFZsVzJsa1hUdGNiaUFnSUNCa1pXeGxkR1VnY1hWbGRXVmJhV1JkTzF4dUlDQWdJR1p1S0NrN1hHNGdJSDFjYm4wN1hHNTJZWElnYkdsemRHVnVaWElnUFNCbWRXNWpkR2x2YmlBb1pYWmxiblFwSUh0Y2JpQWdjblZ1TG1OaGJHd29aWFpsYm5RdVpHRjBZU2s3WEc1OU8xeHVMeThnVG05a1pTNXFjeUF3TGprcklDWWdTVVV4TUNzZ2FHRnpJSE5sZEVsdGJXVmthV0YwWlN3Z2IzUm9aWEozYVhObE9seHVhV1lnS0NGelpYUlVZWE5ySUh4OElDRmpiR1ZoY2xSaGMyc3BJSHRjYmlBZ2MyVjBWR0Z6YXlBOUlHWjFibU4wYVc5dUlITmxkRWx0YldWa2FXRjBaU2htYmlrZ2UxeHVJQ0FnSUhaaGNpQmhjbWR6SUQwZ1cxMDdYRzRnSUNBZ2RtRnlJR2tnUFNBeE8xeHVJQ0FnSUhkb2FXeGxJQ2hoY21kMWJXVnVkSE11YkdWdVozUm9JRDRnYVNrZ1lYSm5jeTV3ZFhOb0tHRnlaM1Z0Wlc1MGMxdHBLeXRkS1R0Y2JpQWdJQ0J4ZFdWMVpWc3JLMk52ZFc1MFpYSmRJRDBnWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0FnSUNBZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJtVjRkQzFzYVc1bElHNXZMVzVsZHkxbWRXNWpYRzRnSUNBZ0lDQnBiblp2YTJVb2RIbHdaVzltSUdadUlEMDlJQ2RtZFc1amRHbHZiaWNnUHlCbWJpQTZJRVoxYm1OMGFXOXVLR1p1S1N3Z1lYSm5jeWs3WEc0Z0lDQWdmVHRjYmlBZ0lDQmtaV1psY2loamIzVnVkR1Z5S1R0Y2JpQWdJQ0J5WlhSMWNtNGdZMjkxYm5SbGNqdGNiaUFnZlR0Y2JpQWdZMnhsWVhKVVlYTnJJRDBnWm5WdVkzUnBiMjRnWTJ4bFlYSkpiVzFsWkdsaGRHVW9hV1FwSUh0Y2JpQWdJQ0JrWld4bGRHVWdjWFZsZFdWYmFXUmRPMXh1SUNCOU8xeHVJQ0F2THlCT2IyUmxMbXB6SURBdU9DMWNiaUFnYVdZZ0tISmxjWFZwY21Vb0p5NHZYMk52WmljcEtIQnliMk5sYzNNcElEMDlJQ2R3Y205alpYTnpKeWtnZTF4dUlDQWdJR1JsWm1WeUlEMGdablZ1WTNScGIyNGdLR2xrS1NCN1hHNGdJQ0FnSUNCd2NtOWpaWE56TG01bGVIUlVhV05yS0dOMGVDaHlkVzRzSUdsa0xDQXhLU2s3WEc0Z0lDQWdmVHRjYmlBZ0x5OGdVM0JvWlhKbElDaEtVeUJuWVcxbElHVnVaMmx1WlNrZ1JHbHpjR0YwWTJnZ1FWQkpYRzRnSUgwZ1pXeHpaU0JwWmlBb1JHbHpjR0YwWTJnZ0ppWWdSR2x6Y0dGMFkyZ3VibTkzS1NCN1hHNGdJQ0FnWkdWbVpYSWdQU0JtZFc1amRHbHZiaUFvYVdRcElIdGNiaUFnSUNBZ0lFUnBjM0JoZEdOb0xtNXZkeWhqZEhnb2NuVnVMQ0JwWkN3Z01Ta3BPMXh1SUNBZ0lIMDdYRzRnSUM4dklFSnliM2R6WlhKeklIZHBkR2dnVFdWemMyRm5aVU5vWVc1dVpXd3NJR2x1WTJ4MVpHVnpJRmRsWWxkdmNtdGxjbk5jYmlBZ2ZTQmxiSE5sSUdsbUlDaE5aWE56WVdkbFEyaGhibTVsYkNrZ2UxeHVJQ0FnSUdOb1lXNXVaV3dnUFNCdVpYY2dUV1Z6YzJGblpVTm9ZVzV1Wld3b0tUdGNiaUFnSUNCd2IzSjBJRDBnWTJoaGJtNWxiQzV3YjNKME1qdGNiaUFnSUNCamFHRnVibVZzTG5CdmNuUXhMbTl1YldWemMyRm5aU0E5SUd4cGMzUmxibVZ5TzF4dUlDQWdJR1JsWm1WeUlEMGdZM1I0S0hCdmNuUXVjRzl6ZEUxbGMzTmhaMlVzSUhCdmNuUXNJREVwTzF4dUlDQXZMeUJDY205M2MyVnljeUIzYVhSb0lIQnZjM1JOWlhOellXZGxMQ0J6YTJsd0lGZGxZbGR2Y210bGNuTmNiaUFnTHk4Z1NVVTRJR2hoY3lCd2IzTjBUV1Z6YzJGblpTd2dZblYwSUdsMEozTWdjM2x1WXlBbUlIUjVjR1Z2WmlCcGRITWdjRzl6ZEUxbGMzTmhaMlVnYVhNZ0oyOWlhbVZqZENkY2JpQWdmU0JsYkhObElHbG1JQ2huYkc5aVlXd3VZV1JrUlhabGJuUk1hWE4wWlc1bGNpQW1KaUIwZVhCbGIyWWdjRzl6ZEUxbGMzTmhaMlVnUFQwZ0oyWjFibU4wYVc5dUp5QW1KaUFoWjJ4dlltRnNMbWx0Y0c5eWRGTmpjbWx3ZEhNcElIdGNiaUFnSUNCa1pXWmxjaUE5SUdaMWJtTjBhVzl1SUNocFpDa2dlMXh1SUNBZ0lDQWdaMnh2WW1Gc0xuQnZjM1JOWlhOellXZGxLR2xrSUNzZ0p5Y3NJQ2NxSnlrN1hHNGdJQ0FnZlR0Y2JpQWdJQ0JuYkc5aVlXd3VZV1JrUlhabGJuUk1hWE4wWlc1bGNpZ25iV1Z6YzJGblpTY3NJR3hwYzNSbGJtVnlMQ0JtWVd4elpTazdYRzRnSUM4dklFbEZPQzFjYmlBZ2ZTQmxiSE5sSUdsbUlDaFBUbEpGUVVSWlUxUkJWRVZEU0VGT1IwVWdhVzRnWTJWc0tDZHpZM0pwY0hRbktTa2dlMXh1SUNBZ0lHUmxabVZ5SUQwZ1puVnVZM1JwYjI0Z0tHbGtLU0I3WEc0Z0lDQWdJQ0JvZEcxc0xtRndjR1Z1WkVOb2FXeGtLR05sYkNnbmMyTnlhWEIwSnlrcFcwOU9Va1ZCUkZsVFZFRlVSVU5JUVU1SFJWMGdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnSUNBZ0lHaDBiV3d1Y21WdGIzWmxRMmhwYkdRb2RHaHBjeWs3WEc0Z0lDQWdJQ0FnSUhKMWJpNWpZV3hzS0dsa0tUdGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ2ZUdGNiaUFnTHk4Z1VtVnpkQ0J2YkdRZ1luSnZkM05sY25OY2JpQWdmU0JsYkhObElIdGNiaUFnSUNCa1pXWmxjaUE5SUdaMWJtTjBhVzl1SUNocFpDa2dlMXh1SUNBZ0lDQWdjMlYwVkdsdFpXOTFkQ2hqZEhnb2NuVnVMQ0JwWkN3Z01Ta3NJREFwTzF4dUlDQWdJSDA3WEc0Z0lIMWNibjFjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnZTF4dUlDQnpaWFE2SUhObGRGUmhjMnNzWEc0Z0lHTnNaV0Z5T2lCamJHVmhjbFJoYzJ0Y2JuMDdYRzRpTENJdkx5QTNMakV1TVNCVWIxQnlhVzFwZEdsMlpTaHBibkIxZENCYkxDQlFjbVZtWlhKeVpXUlVlWEJsWFNsY2JuWmhjaUJwYzA5aWFtVmpkQ0E5SUhKbGNYVnBjbVVvSnk0dlgybHpMVzlpYW1WamRDY3BPMXh1THk4Z2FXNXpkR1ZoWkNCdlppQjBhR1VnUlZNMklITndaV01nZG1WeWMybHZiaXdnZDJVZ1pHbGtiaWQwSUdsdGNHeGxiV1Z1ZENCQVFIUnZVSEpwYldsMGFYWmxJR05oYzJWY2JpOHZJR0Z1WkNCMGFHVWdjMlZqYjI1a0lHRnlaM1Z0Wlc1MElDMGdabXhoWnlBdElIQnlaV1psY25KbFpDQjBlWEJsSUdseklHRWdjM1J5YVc1blhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUlDaHBkQ3dnVXlrZ2UxeHVJQ0JwWmlBb0lXbHpUMkpxWldOMEtHbDBLU2tnY21WMGRYSnVJR2wwTzF4dUlDQjJZWElnWm00c0lIWmhiRHRjYmlBZ2FXWWdLRk1nSmlZZ2RIbHdaVzltSUNobWJpQTlJR2wwTG5SdlUzUnlhVzVuS1NBOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUNGcGMwOWlhbVZqZENoMllXd2dQU0JtYmk1allXeHNLR2wwS1NrcElISmxkSFZ5YmlCMllXdzdYRzRnSUdsbUlDaDBlWEJsYjJZZ0tHWnVJRDBnYVhRdWRtRnNkV1ZQWmlrZ1BUMGdKMloxYm1OMGFXOXVKeUFtSmlBaGFYTlBZbXBsWTNRb2RtRnNJRDBnWm00dVkyRnNiQ2hwZENrcEtTQnlaWFIxY200Z2RtRnNPMXh1SUNCcFppQW9JVk1nSmlZZ2RIbHdaVzltSUNobWJpQTlJR2wwTG5SdlUzUnlhVzVuS1NBOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUNGcGMwOWlhbVZqZENoMllXd2dQU0JtYmk1allXeHNLR2wwS1NrcElISmxkSFZ5YmlCMllXdzdYRzRnSUhSb2NtOTNJRlI1Y0dWRmNuSnZjaWhjSWtOaGJpZDBJR052Ym5abGNuUWdiMkpxWldOMElIUnZJSEJ5YVcxcGRHbDJaU0IyWVd4MVpWd2lLVHRjYm4wN1hHNGlMQ0oyWVhJZ2FXUWdQU0F3TzF4dWRtRnlJSEI0SUQwZ1RXRjBhQzV5WVc1a2IyMG9LVHRjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnS0d0bGVTa2dlMXh1SUNCeVpYUjFjbTRnSjFONWJXSnZiQ2duTG1OdmJtTmhkQ2hyWlhrZ1BUMDlJSFZ1WkdWbWFXNWxaQ0EvSUNjbklEb2dhMlY1TENBbktWOG5MQ0FvS3l0cFpDQXJJSEI0S1M1MGIxTjBjbWx1Wnlnek5pa3BPMXh1ZlR0Y2JpSXNJblpoY2lBa1pYaHdiM0owSUQwZ2NtVnhkV2x5WlNnbkxpOWZaWGh3YjNKMEp5azdYRzUyWVhJZ0pIUmhjMnNnUFNCeVpYRjFhWEpsS0NjdUwxOTBZWE5ySnlrN1hHNGtaWGh3YjNKMEtDUmxlSEJ2Y25RdVJ5QXJJQ1JsZUhCdmNuUXVRaXdnZTF4dUlDQnpaWFJKYlcxbFpHbGhkR1U2SUNSMFlYTnJMbk5sZEN4Y2JpQWdZMnhsWVhKSmJXMWxaR2xoZEdVNklDUjBZWE5yTG1Oc1pXRnlYRzU5S1R0Y2JpSXNJaThxS2x4eVhHNGdLaUJBY0hKbGMyVnlkbVZjY2x4dUlDb2dRMjl3ZVhKcFoyaDBJREl3TVRVdE1qQXhPQ0JKWjI5eUlFSmxlbXR5YjNadWVXbGNjbHh1SUNvZ1FXeHNJSEpwWjJoMGN5QnlaWE5sY25abFpDNGdLRTFKVkNCTWFXTmxibk5sWkNsY2NseHVJQ3BjY2x4dUlDb2dhR1ZzY0dWeUxuUnpJQzBnY0dGeWRDQnZaaUJKYldGblpTQlJkV0Z1ZEdsNllYUnBiMjRnVEdsaWNtRnllVnh5WEc0Z0tpOWNjbHh1YVcxd2IzSjBJQ29nWVhNZ2MyVjBTVzF0WldScFlYUmxJR1p5YjIwZ0oyTnZjbVV0YW5NdlptNHZjMlYwTFdsdGJXVmthV0YwWlNjN1hISmNibWx0Y0c5eWRDQXFJR0Z6SUdScGMzUmhibU5sSUdaeWIyMGdKeTR2WkdsemRHRnVZMlVuTzF4eVhHNXBiWEJ2Y25RZ0tpQmhjeUJwYldGblpTQm1jbTl0SUNjdUwybHRZV2RsSnp0Y2NseHVhVzF3YjNKMElDb2dZWE1nY0dGc1pYUjBaU0JtY205dElDY3VMM0JoYkdWMGRHVW5PMXh5WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWW5WcGJHUlFZV3hsZEhSbFUzbHVZeWhwYldGblpYTXNJSHNnWTI5c2IzSkVhWE4wWVc1alpVWnZjbTExYkdFc0lIQmhiR1YwZEdWUmRXRnVkR2w2WVhScGIyNHNJR052Ykc5eWN5QjlJRDBnZTMwcElIdGNjbHh1SUNBZ0lHTnZibk4wSUdScGMzUmhibU5sUTJGc1kzVnNZWFJ2Y2lBOUlHTnZiRzl5UkdsemRHRnVZMlZHYjNKdGRXeGhWRzlEYjJ4dmNrUnBjM1JoYm1ObEtHTnZiRzl5UkdsemRHRnVZMlZHYjNKdGRXeGhLVHRjY2x4dUlDQWdJR052Ym5OMElIQmhiR1YwZEdWUmRXRnVkR2w2WlhJZ1BTQndZV3hsZEhSbFVYVmhiblJwZW1GMGFXOXVWRzlRWVd4bGRIUmxVWFZoYm5ScGVtVnlLR1JwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaXdnY0dGc1pYUjBaVkYxWVc1MGFYcGhkR2x2Yml3Z1kyOXNiM0p6S1R0Y2NseHVJQ0FnSUdsdFlXZGxjeTVtYjNKRllXTm9LR2x0WVdkbElEMCtJSEJoYkdWMGRHVlJkV0Z1ZEdsNlpYSXVjMkZ0Y0d4bEtHbHRZV2RsS1NrN1hISmNiaUFnSUNCeVpYUjFjbTRnY0dGc1pYUjBaVkYxWVc1MGFYcGxjaTV4ZFdGdWRHbDZaVk41Ym1Nb0tUdGNjbHh1ZlZ4eVhHNWxlSEJ2Y25RZ1lYTjVibU1nWm5WdVkzUnBiMjRnWW5WcGJHUlFZV3hsZEhSbEtHbHRZV2RsY3l3Z2V5QmpiMnh2Y2tScGMzUmhibU5sUm05eWJYVnNZU3dnY0dGc1pYUjBaVkYxWVc1MGFYcGhkR2x2Yml3Z1kyOXNiM0p6TENCdmJsQnliMmR5WlhOeklIMGdQU0I3ZlNrZ2UxeHlYRzRnSUNBZ2NtVjBkWEp1SUc1bGR5QlFjbTl0YVhObEtDaHlaWE52YkhabExDQnlaV3BsWTNRcElEMCtJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JrYVhOMFlXNWpaVU5oYkdOMWJHRjBiM0lnUFNCamIyeHZja1JwYzNSaGJtTmxSbTl5YlhWc1lWUnZRMjlzYjNKRWFYTjBZVzVqWlNoamIyeHZja1JwYzNSaGJtTmxSbTl5YlhWc1lTazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdjR0ZzWlhSMFpWRjFZVzUwYVhwbGNpQTlJSEJoYkdWMGRHVlJkV0Z1ZEdsNllYUnBiMjVVYjFCaGJHVjBkR1ZSZFdGdWRHbDZaWElvWkdsemRHRnVZMlZEWVd4amRXeGhkRzl5TENCd1lXeGxkSFJsVVhWaGJuUnBlbUYwYVc5dUxDQmpiMnh2Y25NcE8xeHlYRzRnSUNBZ0lDQWdJR2x0WVdkbGN5NW1iM0pGWVdOb0tHbHRZV2RsSUQwK0lIQmhiR1YwZEdWUmRXRnVkR2w2WlhJdWMyRnRjR3hsS0dsdFlXZGxLU2s3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJSEJoYkdWMGRHVTdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElIUnBiV1Z5U1dRN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2FYUmxjbUYwYjNJZ1BTQndZV3hsZEhSbFVYVmhiblJwZW1WeUxuRjFZVzUwYVhwbEtDazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdibVY0ZENBOUlDZ3BJRDArSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZEhKNUlIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElISmxjM1ZzZENBOUlHbDBaWEpoZEc5eUxtNWxlSFFvS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2h5WlhOMWJIUXVaRzl1WlNrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGMyOXNkbVVvY0dGc1pYUjBaU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxiSE5sSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2NtVnpkV3gwTG5aaGJIVmxMbkJoYkdWMGRHVXBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEJoYkdWMGRHVWdQU0J5WlhOMWJIUXVkbUZzZFdVdWNHRnNaWFIwWlR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2IyNVFjbTluY21WemN5bGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiMjVRY205bmNtVnpjeWh5WlhOMWJIUXVkbUZzZFdVdWNISnZaM0psYzNNcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhScGJXVnlTV1FnUFNCelpYUkpiVzFsWkdsaGRHVW9ibVY0ZENrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyRjBZMmdnS0dWeWNtOXlLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamJHVmhjbFJwYldWdmRYUW9kR2x0WlhKSlpDazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WldwbFkzUW9aWEp5YjNJcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdmVHRjY2x4dUlDQWdJQ0FnSUNCMGFXMWxja2xrSUQwZ2MyVjBTVzF0WldScFlYUmxLRzVsZUhRcE8xeHlYRzRnSUNBZ2ZTazdYSEpjYm4xY2NseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHRndjR3g1VUdGc1pYUjBaVk41Ym1Nb2FXMWhaMlVzSUhCaGJHVjBkR1VzSUhzZ1kyOXNiM0pFYVhOMFlXNWpaVVp2Y20xMWJHRXNJR2x0WVdkbFVYVmhiblJwZW1GMGFXOXVJSDBnUFNCN2ZTa2dlMXh5WEc0Z0lDQWdZMjl1YzNRZ1pHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUlEMGdZMjlzYjNKRWFYTjBZVzVqWlVadmNtMTFiR0ZVYjBOdmJHOXlSR2x6ZEdGdVkyVW9ZMjlzYjNKRWFYTjBZVzVqWlVadmNtMTFiR0VwTzF4eVhHNGdJQ0FnWTI5dWMzUWdhVzFoWjJWUmRXRnVkR2w2WlhJZ1BTQnBiV0ZuWlZGMVlXNTBhWHBoZEdsdmJsUnZTVzFoWjJWUmRXRnVkR2w2WlhJb1pHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUxDQnBiV0ZuWlZGMVlXNTBhWHBoZEdsdmJpazdYSEpjYmlBZ0lDQnlaWFIxY200Z2FXMWhaMlZSZFdGdWRHbDZaWEl1Y1hWaGJuUnBlbVZUZVc1aktHbHRZV2RsTENCd1lXeGxkSFJsS1R0Y2NseHVmVnh5WEc1bGVIQnZjblFnWVhONWJtTWdablZ1WTNScGIyNGdZWEJ3YkhsUVlXeGxkSFJsS0dsdFlXZGxMQ0J3WVd4bGRIUmxMQ0I3SUdOdmJHOXlSR2x6ZEdGdVkyVkdiM0p0ZFd4aExDQnBiV0ZuWlZGMVlXNTBhWHBoZEdsdmJpd2diMjVRY205bmNtVnpjeUI5SUQwZ2UzMHBJSHRjY2x4dUlDQWdJSEpsZEhWeWJpQnVaWGNnVUhKdmJXbHpaU2dvY21WemIyeDJaU3dnY21WcVpXTjBLU0E5UGlCN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1pHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUlEMGdZMjlzYjNKRWFYTjBZVzVqWlVadmNtMTFiR0ZVYjBOdmJHOXlSR2x6ZEdGdVkyVW9ZMjlzYjNKRWFYTjBZVzVqWlVadmNtMTFiR0VwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdsdFlXZGxVWFZoYm5ScGVtVnlJRDBnYVcxaFoyVlJkV0Z1ZEdsNllYUnBiMjVVYjBsdFlXZGxVWFZoYm5ScGVtVnlLR1JwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaXdnYVcxaFoyVlJkV0Z1ZEdsNllYUnBiMjRwTzF4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0J2ZFhSUWIybHVkRU52Ym5SaGFXNWxjanRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdkR2x0WlhKSlpEdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQnBkR1Z5WVhSdmNpQTlJR2x0WVdkbFVYVmhiblJwZW1WeUxuRjFZVzUwYVhwbEtHbHRZV2RsTENCd1lXeGxkSFJsS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCdVpYaDBJRDBnS0NrZ1BUNGdlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBjbmtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnY21WemRXeDBJRDBnYVhSbGNtRjBiM0l1Ym1WNGRDZ3BPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tISmxjM1ZzZEM1a2IyNWxLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVZ6YjJ4MlpTaHZkWFJRYjJsdWRFTnZiblJoYVc1bGNpazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbGJITmxJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvY21WemRXeDBMblpoYkhWbExuQnZhVzUwUTI5dWRHRnBibVZ5S1Z4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdmRYUlFiMmx1ZEVOdmJuUmhhVzVsY2lBOUlISmxjM1ZzZEM1MllXeDFaUzV3YjJsdWRFTnZiblJoYVc1bGNqdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCcFppQW9iMjVRY205bmNtVnpjeWxjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYjI1UWNtOW5jbVZ6Y3loeVpYTjFiSFF1ZG1Gc2RXVXVjSEp2WjNKbGMzTXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUnBiV1Z5U1dRZ1BTQnpaWFJKYlcxbFpHbGhkR1VvYm1WNGRDazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMkYwWTJnZ0tHVnljbTl5S1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiR1ZoY2xScGJXVnZkWFFvZEdsdFpYSkpaQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpXcGxZM1FvWlhKeWIzSXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnZlR0Y2NseHVJQ0FnSUNBZ0lDQjBhVzFsY2tsa0lEMGdjMlYwU1cxdFpXUnBZWFJsS0c1bGVIUXBPMXh5WEc0Z0lDQWdmU2s3WEhKY2JuMWNjbHh1Wm5WdVkzUnBiMjRnWTI5c2IzSkVhWE4wWVc1alpVWnZjbTExYkdGVWIwTnZiRzl5UkdsemRHRnVZMlVvWTI5c2IzSkVhWE4wWVc1alpVWnZjbTExYkdFZ1BTQW5aWFZqYkdsa1pXRnVMV0owTnpBNUp5a2dlMXh5WEc0Z0lDQWdjM2RwZEdOb0lDaGpiMnh2Y2tScGMzUmhibU5sUm05eWJYVnNZU2tnZTF4eVhHNGdJQ0FnSUNBZ0lHTmhjMlVnSjJOcFpUazBMV2R5WVhCb2FXTXRZWEowY3ljNklISmxkSFZ5YmlCdVpYY2daR2x6ZEdGdVkyVXVRMGxGT1RSSGNtRndhR2xqUVhKMGN5Z3BPMXh5WEc0Z0lDQWdJQ0FnSUdOaGMyVWdKMk5wWlRrMExYUmxlSFJwYkdWekp6b2djbVYwZFhKdUlHNWxkeUJrYVhOMFlXNWpaUzVEU1VVNU5GUmxlSFJwYkdWektDazdYSEpjYmlBZ0lDQWdJQ0FnWTJGelpTQW5ZMmxsWkdVeU1EQXdKem9nY21WMGRYSnVJRzVsZHlCa2FYTjBZVzVqWlM1RFNVVkVSVEl3TURBb0tUdGNjbHh1SUNBZ0lDQWdJQ0JqWVhObElDZGpiMnh2Y2kxdFpYUnlhV01uT2lCeVpYUjFjbTRnYm1WM0lHUnBjM1JoYm1ObExrTk5aWFJ5YVdNb0tUdGNjbHh1SUNBZ0lDQWdJQ0JqWVhObElDZGxkV05zYVdSbFlXNG5PaUJ5WlhSMWNtNGdibVYzSUdScGMzUmhibU5sTGtWMVkyeHBaR1ZoYmlncE8xeHlYRzRnSUNBZ0lDQWdJR05oYzJVZ0oyVjFZMnhwWkdWaGJpMWlkRGN3T1NjNklISmxkSFZ5YmlCdVpYY2daR2x6ZEdGdVkyVXVSWFZqYkdsa1pXRnVRbFEzTURrb0tUdGNjbHh1SUNBZ0lDQWdJQ0JqWVhObElDZGxkV05zYVdSbFlXNHRZblEzTURrdGJtOWhiSEJvWVNjNklISmxkSFZ5YmlCdVpYY2daR2x6ZEdGdVkyVXVSWFZqYkdsa1pXRnVRbFEzTURsT2IwRnNjR2hoS0NrN1hISmNiaUFnSUNBZ0lDQWdZMkZ6WlNBbmJXRnVhR0YwZEdGdUp6b2djbVYwZFhKdUlHNWxkeUJrYVhOMFlXNWpaUzVOWVc1b1lYUjBZVzRvS1R0Y2NseHVJQ0FnSUNBZ0lDQmpZWE5sSUNkdFlXNW9ZWFIwWVc0dFluUTNNRGtuT2lCeVpYUjFjbTRnYm1WM0lHUnBjM1JoYm1ObExrMWhibWhoZEhSaGJrSlVOekE1S0NrN1hISmNiaUFnSUNBZ0lDQWdZMkZ6WlNBbmJXRnVhR0YwZEdGdUxXNXZiVzE1WkdVbk9pQnlaWFIxY200Z2JtVjNJR1JwYzNSaGJtTmxMazFoYm1oaGRIUmhiazV2YlcxNVpHVW9LVHRjY2x4dUlDQWdJQ0FnSUNCallYTmxJQ2R3Ym1keGRXRnVkQ2M2SUhKbGRIVnliaUJ1WlhjZ1pHbHpkR0Z1WTJVdVVFNUhVWFZoYm5Rb0tUdGNjbHh1SUNBZ0lDQWdJQ0JrWldaaGRXeDBPaUIwYUhKdmR5QnVaWGNnUlhKeWIzSW9ZRlZ1YTI1dmQyNGdZMjlzYjNKRWFYTjBZVzVqWlVadmNtMTFiR0VnSkh0amIyeHZja1JwYzNSaGJtTmxSbTl5YlhWc1lYMWdLVHRjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzVtZFc1amRHbHZiaUJwYldGblpWRjFZVzUwYVhwaGRHbHZibFJ2U1cxaFoyVlJkV0Z1ZEdsNlpYSW9aR2x6ZEdGdVkyVkRZV3hqZFd4aGRHOXlMQ0JwYldGblpWRjFZVzUwYVhwaGRHbHZiaUE5SUNkbWJHOTVaQzF6ZEdWcGJtSmxjbWNuS1NCN1hISmNiaUFnSUNCemQybDBZMmdnS0dsdFlXZGxVWFZoYm5ScGVtRjBhVzl1S1NCN1hISmNiaUFnSUNBZ0lDQWdZMkZ6WlNBbmJtVmhjbVZ6ZENjNklISmxkSFZ5YmlCdVpYY2dhVzFoWjJVdVRtVmhjbVZ6ZEVOdmJHOXlLR1JwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaWs3WEhKY2JpQWdJQ0FnSUNBZ1kyRnpaU0FuY21sbGJXVnljMjFoSnpvZ2NtVjBkWEp1SUc1bGR5QnBiV0ZuWlM1RmNuSnZja1JwWm1aMWMybHZibEpwWlcxbGNuTnRZU2hrYVhOMFlXNWpaVU5oYkdOMWJHRjBiM0lwTzF4eVhHNGdJQ0FnSUNBZ0lHTmhjMlVnSjJac2IzbGtMWE4wWldsdVltVnlaeWM2SUhKbGRIVnliaUJ1WlhjZ2FXMWhaMlV1UlhKeWIzSkVhV1ptZFhOcGIyNUJjbkpoZVNoa2FYTjBZVzVqWlVOaGJHTjFiR0YwYjNJc0lHbHRZV2RsTGtWeWNtOXlSR2xtWm5WemFXOXVRWEp5WVhsTFpYSnVaV3d1Um14dmVXUlRkR1ZwYm1KbGNtY3BPMXh5WEc0Z0lDQWdJQ0FnSUdOaGMyVWdKMlpoYkhObExXWnNiM2xrTFhOMFpXbHVZbVZ5WnljNklISmxkSFZ5YmlCdVpYY2dhVzFoWjJVdVJYSnliM0pFYVdabWRYTnBiMjVCY25KaGVTaGthWE4wWVc1alpVTmhiR04xYkdGMGIzSXNJR2x0WVdkbExrVnljbTl5UkdsbVpuVnphVzl1UVhKeVlYbExaWEp1Wld3dVJtRnNjMlZHYkc5NVpGTjBaV2x1WW1WeVp5azdYSEpjYmlBZ0lDQWdJQ0FnWTJGelpTQW5jM1IxWTJ0cEp6b2djbVYwZFhKdUlHNWxkeUJwYldGblpTNUZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVLR1JwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaXdnYVcxaFoyVXVSWEp5YjNKRWFXWm1kWE5wYjI1QmNuSmhlVXRsY201bGJDNVRkSFZqYTJrcE8xeHlYRzRnSUNBZ0lDQWdJR05oYzJVZ0oyRjBhMmx1YzI5dUp6b2djbVYwZFhKdUlHNWxkeUJwYldGblpTNUZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVLR1JwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaXdnYVcxaFoyVXVSWEp5YjNKRWFXWm1kWE5wYjI1QmNuSmhlVXRsY201bGJDNUJkR3RwYm5OdmJpazdYSEpjYmlBZ0lDQWdJQ0FnWTJGelpTQW5hbUZ5ZG1sekp6b2djbVYwZFhKdUlHNWxkeUJwYldGblpTNUZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVLR1JwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaXdnYVcxaFoyVXVSWEp5YjNKRWFXWm1kWE5wYjI1QmNuSmhlVXRsY201bGJDNUtZWEoyYVhNcE8xeHlYRzRnSUNBZ0lDQWdJR05oYzJVZ0oySjFjbXRsY3ljNklISmxkSFZ5YmlCdVpYY2dhVzFoWjJVdVJYSnliM0pFYVdabWRYTnBiMjVCY25KaGVTaGthWE4wWVc1alpVTmhiR04xYkdGMGIzSXNJR2x0WVdkbExrVnljbTl5UkdsbVpuVnphVzl1UVhKeVlYbExaWEp1Wld3dVFuVnlhMlZ6S1R0Y2NseHVJQ0FnSUNBZ0lDQmpZWE5sSUNkemFXVnljbUVuT2lCeVpYUjFjbTRnYm1WM0lHbHRZV2RsTGtWeWNtOXlSR2xtWm5WemFXOXVRWEp5WVhrb1pHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUxDQnBiV0ZuWlM1RmNuSnZja1JwWm1aMWMybHZia0Z5Y21GNVMyVnlibVZzTGxOcFpYSnlZU2s3WEhKY2JpQWdJQ0FnSUNBZ1kyRnpaU0FuZEhkdkxYTnBaWEp5WVNjNklISmxkSFZ5YmlCdVpYY2dhVzFoWjJVdVJYSnliM0pFYVdabWRYTnBiMjVCY25KaGVTaGthWE4wWVc1alpVTmhiR04xYkdGMGIzSXNJR2x0WVdkbExrVnljbTl5UkdsbVpuVnphVzl1UVhKeVlYbExaWEp1Wld3dVZIZHZVMmxsY25KaEtUdGNjbHh1SUNBZ0lDQWdJQ0JqWVhObElDZHphV1Z5Y21FdGJHbDBaU2M2SUhKbGRIVnliaUJ1WlhjZ2FXMWhaMlV1UlhKeWIzSkVhV1ptZFhOcGIyNUJjbkpoZVNoa2FYTjBZVzVqWlVOaGJHTjFiR0YwYjNJc0lHbHRZV2RsTGtWeWNtOXlSR2xtWm5WemFXOXVRWEp5WVhsTFpYSnVaV3d1VTJsbGNuSmhUR2wwWlNrN1hISmNiaUFnSUNBZ0lDQWdaR1ZtWVhWc2REb2dkR2h5YjNjZ2JtVjNJRVZ5Y205eUtHQlZibXR1YjNkdUlHbHRZV2RsVVhWaGJuUnBlbUYwYVc5dUlDUjdhVzFoWjJWUmRXRnVkR2w2WVhScGIyNTlZQ2s3WEhKY2JpQWdJQ0I5WEhKY2JuMWNjbHh1Wm5WdVkzUnBiMjRnY0dGc1pYUjBaVkYxWVc1MGFYcGhkR2x2YmxSdlVHRnNaWFIwWlZGMVlXNTBhWHBsY2loa2FYTjBZVzVqWlVOaGJHTjFiR0YwYjNJc0lIQmhiR1YwZEdWUmRXRnVkR2w2WVhScGIyNGdQU0FuZDNWeGRXRnVkQ2NzSUdOdmJHOXljeUE5SURJMU5pa2dlMXh5WEc0Z0lDQWdjM2RwZEdOb0lDaHdZV3hsZEhSbFVYVmhiblJwZW1GMGFXOXVLU0I3WEhKY2JpQWdJQ0FnSUNBZ1kyRnpaU0FuYm1WMWNYVmhiblFuT2lCeVpYUjFjbTRnYm1WM0lIQmhiR1YwZEdVdVRtVjFVWFZoYm5Rb1pHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUxDQmpiMnh2Y25NcE8xeHlYRzRnSUNBZ0lDQWdJR05oYzJVZ0ozSm5ZbkYxWVc1MEp6b2djbVYwZFhKdUlHNWxkeUJ3WVd4bGRIUmxMbEpIUWxGMVlXNTBLR1JwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaXdnWTI5c2IzSnpLVHRjY2x4dUlDQWdJQ0FnSUNCallYTmxJQ2QzZFhGMVlXNTBKem9nY21WMGRYSnVJRzVsZHlCd1lXeGxkSFJsTGxkMVVYVmhiblFvWkdsemRHRnVZMlZEWVd4amRXeGhkRzl5TENCamIyeHZjbk1wTzF4eVhHNGdJQ0FnSUNBZ0lHTmhjMlVnSjI1bGRYRjFZVzUwTFdac2IyRjBKem9nY21WMGRYSnVJRzVsZHlCd1lXeGxkSFJsTGs1bGRWRjFZVzUwUm14dllYUW9aR2x6ZEdGdVkyVkRZV3hqZFd4aGRHOXlMQ0JqYjJ4dmNuTXBPMXh5WEc0Z0lDQWdJQ0FnSUdSbFptRjFiSFE2SUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhnVlc1cmJtOTNiaUJ3WVd4bGRIUmxVWFZoYm5ScGVtRjBhVzl1SUNSN2NHRnNaWFIwWlZGMVlXNTBhWHBoZEdsdmJuMWdLVHRjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxaVlYTnBZMEZRU1M1cWN5NXRZWEFpTENJdktpcGNjbHh1SUNvZ1FIQnlaWE5sY25abFhISmNiaUFxSUVOdmNIbHlhV2RvZENBeU1ERTFMVEl3TVRnZ1NXZHZjaUJDWlhwcmNtOTJibmxwWEhKY2JpQXFJRUZzYkNCeWFXZG9kSE1nY21WelpYSjJaV1F1SUNoTlNWUWdUR2xqWlc1elpXUXBYSEpjYmlBcVhISmNiaUFxSUdOdmJuTjBZVzUwY3k1MGN5QXRJSEJoY25RZ2IyWWdTVzFoWjJVZ1VYVmhiblJwZW1GMGFXOXVJRXhwWW5KaGNubGNjbHh1SUNvdlhISmNiaThxS2x4eVhHNGdLaUJ6VWtkQ0lDaGlZWE5sWkNCdmJpQkpWRlV0VWlCU1pXTnZiVzFsYm1SaGRHbHZiaUJDVkM0M01Ea3BYSEpjYmlBcUlHaDBkSEE2THk5bGJpNTNhV3RwY0dWa2FXRXViM0puTDNkcGEya3ZVMUpIUWx4eVhHNGdLaTljY2x4dVpYaHdiM0owSUhaaGNpQlpPMXh5WEc0b1puVnVZM1JwYjI0Z0tGa3BJSHRjY2x4dUlDQWdJRmxiV1Z0Y0lsSkZSRndpWFNBOUlEQXVNakV5TmwwZ1BTQmNJbEpGUkZ3aU8xeHlYRzRnSUNBZ1dWdFpXMXdpUjFKRlJVNWNJbDBnUFNBd0xqY3hOVEpkSUQwZ1hDSkhVa1ZGVGx3aU8xeHlYRzRnSUNBZ1dWdFpXMXdpUWt4VlJWd2lYU0E5SURBdU1EY3lNbDBnUFNCY0lrSk1WVVZjSWp0Y2NseHVJQ0FnSUZsYldWdGNJbGRJU1ZSRlhDSmRJRDBnTVYwZ1BTQmNJbGRJU1ZSRlhDSTdYSEpjYm4wcEtGa2dmSHdnS0ZrZ1BTQjdmU2twTzF4eVhHNHZMeUIwYzJ4cGJuUTZaR2x6WVdKc1pTMXVaWGgwTFd4cGJtVTZibUZ0YVc1bkxXTnZiblpsYm5ScGIyNWNjbHh1Wlhod2IzSjBJSFpoY2lCNE8xeHlYRzRvWm5WdVkzUnBiMjRnS0hncElIdGNjbHh1SUNBZ0lIaGJlRnRjSWxKRlJGd2lYU0E5SURBdU5qUmRJRDBnWENKU1JVUmNJanRjY2x4dUlDQWdJSGhiZUZ0Y0lrZFNSVVZPWENKZElEMGdNQzR6WFNBOUlGd2lSMUpGUlU1Y0lqdGNjbHh1SUNBZ0lIaGJlRnRjSWtKTVZVVmNJbDBnUFNBd0xqRTFYU0E5SUZ3aVFreFZSVndpTzF4eVhHNGdJQ0FnZUZ0NFcxd2lWMGhKVkVWY0lsMGdQU0F3TGpNeE1qZGRJRDBnWENKWFNFbFVSVndpTzF4eVhHNTlLU2g0SUh4OElDaDRJRDBnZTMwcEtUdGNjbHh1THk4Z2RITnNhVzUwT21ScGMyRmliR1V0Ym1WNGRDMXNhVzVsT201aGJXbHVaeTFqYjI1MlpXNTBhVzl1WEhKY2JtVjRjRzl5ZENCMllYSWdlVHRjY2x4dUtHWjFibU4wYVc5dUlDaDVLU0I3WEhKY2JpQWdJQ0I1VzNsYlhDSlNSVVJjSWwwZ1BTQXdMak16WFNBOUlGd2lVa1ZFWENJN1hISmNiaUFnSUNCNVczbGJYQ0pIVWtWRlRsd2lYU0E5SURBdU5sMGdQU0JjSWtkU1JVVk9YQ0k3WEhKY2JpQWdJQ0I1VzNsYlhDSkNURlZGWENKZElEMGdNQzR3TmwwZ1BTQmNJa0pNVlVWY0lqdGNjbHh1SUNBZ0lIbGJlVnRjSWxkSVNWUkZYQ0pkSUQwZ01DNHpNamxkSUQwZ1hDSlhTRWxVUlZ3aU8xeHlYRzU5S1NoNUlIeDhJQ2g1SUQwZ2UzMHBLVHRjY2x4dUx5OGpJSE52ZFhKalpVMWhjSEJwYm1kVlVrdzlZblEzTURrdWFuTXViV0Z3SWl3aUx5b3FYSEpjYmlBcUlFQndjbVZ6WlhKMlpWeHlYRzRnS2lCRGIzQjVjbWxuYUhRZ01qQXhOUzB5TURFNElFbG5iM0lnUW1WNmEzSnZkbTU1YVZ4eVhHNGdLaUJCYkd3Z2NtbG5hSFJ6SUhKbGMyVnlkbVZrTGlBb1RVbFVJRXhwWTJWdWMyVmtLVnh5WEc0Z0tseHlYRzRnS2lCamIyNXpkR0Z1ZEhNdWRITWdMU0J3WVhKMElHOW1JRWx0WVdkbElGRjFZVzUwYVhwaGRHbHZiaUJNYVdKeVlYSjVYSEpjYmlBcUwxeHlYRzVwYlhCdmNuUWdLaUJoY3lCaWREY3dPU0JtY205dElDY3VMMkowTnpBNUp6dGNjbHh1Wlhod2IzSjBJSHNnWW5RM01Ea3NJSDA3WEhKY2JpOHZJeUJ6YjNWeVkyVk5ZWEJ3YVc1blZWSk1QV2x1WkdWNExtcHpMbTFoY0NJc0lpOHFLbHh5WEc0Z0tpQkFjSEpsYzJWeWRtVmNjbHh1SUNvZ1EyOXdlWEpwWjJoMElESXdNVFV0TWpBeE9DQkpaMjl5SUVKbGVtdHliM1p1ZVdsY2NseHVJQ29nUVd4c0lISnBaMmgwY3lCeVpYTmxjblpsWkM0Z0tFMUpWQ0JNYVdObGJuTmxaQ2xjY2x4dUlDcGNjbHh1SUNvZ2FYRXVkSE1nTFNCSmJXRm5aU0JSZFdGdWRHbDZZWFJwYjI0Z1RHbGljbUZ5ZVZ4eVhHNGdLaTljY2x4dVpYaHdiM0owSUhzZ2NtZGlNbmg1ZWlCOUlHWnliMjBnSnk0dmNtZGlNbmg1ZWljN1hISmNibVY0Y0c5eWRDQjdJSEpuWWpKb2Myd2dmU0JtY205dElDY3VMM0puWWpKb2Myd25PMXh5WEc1bGVIQnZjblFnZXlCeVoySXliR0ZpSUgwZ1puSnZiU0FuTGk5eVoySXliR0ZpSnp0Y2NseHVaWGh3YjNKMElIc2diR0ZpTW5oNWVpQjlJR1p5YjIwZ0p5NHZiR0ZpTW5oNWVpYzdYSEpjYm1WNGNHOXlkQ0I3SUd4aFlqSnlaMklnZlNCbWNtOXRJQ2N1TDJ4aFlqSnlaMkluTzF4eVhHNWxlSEJ2Y25RZ2V5QjRlWG95YkdGaUlIMGdabkp2YlNBbkxpOTRlWG95YkdGaUp6dGNjbHh1Wlhod2IzSjBJSHNnZUhsNk1uSm5ZaUI5SUdaeWIyMGdKeTR2ZUhsNk1uSm5ZaWM3WEhKY2JpOHZJeUJ6YjNWeVkyVk5ZWEJ3YVc1blZWSk1QV2x1WkdWNExtcHpMbTFoY0NJc0lpOHFLbHh5WEc0Z0tpQkFjSEpsYzJWeWRtVmNjbHh1SUNvZ1EyOXdlWEpwWjJoMElESXdNVFV0TWpBeE9DQkpaMjl5SUVKbGVtdHliM1p1ZVdsY2NseHVJQ29nUVd4c0lISnBaMmgwY3lCeVpYTmxjblpsWkM0Z0tFMUpWQ0JNYVdObGJuTmxaQ2xjY2x4dUlDcGNjbHh1SUNvZ2JHRmlNbkpuWWk1MGN5QXRJSEJoY25RZ2IyWWdTVzFoWjJVZ1VYVmhiblJwZW1GMGFXOXVJRXhwWW5KaGNubGNjbHh1SUNvdlhISmNibWx0Y0c5eWRDQjdJR3hoWWpKNGVYb2dmU0JtY205dElDY3VMMnhoWWpKNGVYb25PMXh5WEc1cGJYQnZjblFnZXlCNGVYb3ljbWRpSUgwZ1puSnZiU0FuTGk5NGVYb3ljbWRpSnp0Y2NseHVMeThnZEhOc2FXNTBPbVJwYzJGaWJHVXRibVY0ZEMxc2FXNWxPbTVoYldsdVp5MWpiMjUyWlc1MGFXOXVYSEpjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJzWVdJeWNtZGlLRXdzSUdFc0lHSXBJSHRjY2x4dUlDQWdJR052Ym5OMElIaDVlaUE5SUd4aFlqSjRlWG9vVEN3Z1lTd2dZaWs3WEhKY2JpQWdJQ0J5WlhSMWNtNGdlSGw2TW5KbllpaDRlWG91ZUN3Z2VIbDZMbmtzSUhoNWVpNTZLVHRjY2x4dWZWeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxc1lXSXljbWRpTG1wekxtMWhjQ0lzSWk4cUtseHlYRzRnS2lCQWNISmxjMlZ5ZG1WY2NseHVJQ29nUTI5d2VYSnBaMmgwSURJd01UVXRNakF4T0NCSloyOXlJRUpsZW10eWIzWnVlV2xjY2x4dUlDb2dRV3hzSUhKcFoyaDBjeUJ5WlhObGNuWmxaQzRnS0UxSlZDQk1hV05sYm5ObFpDbGNjbHh1SUNwY2NseHVJQ29nYkdGaU1uaDVlaTUwY3lBdElIQmhjblFnYjJZZ1NXMWhaMlVnVVhWaGJuUnBlbUYwYVc5dUlFeHBZbkpoY25sY2NseHVJQ292WEhKY2JtTnZibk4wSUhKbFpsZ2dQU0F3TGprMU1EUTNPeUF2THlCeVpXWmZXQ0E5SUNBNU5TNHdORGNnSUNCUFluTmxjblpsY2owZ01zS3dMQ0JKYkd4MWJXbHVZVzUwSUQwZ1JEWTFYSEpjYm1OdmJuTjBJSEpsWmxrZ1BTQXhMakF3TURBd095QXZMeUJ5WldaZldTQTlJREV3TUM0d01EQmNjbHh1WTI5dWMzUWdjbVZtV2lBOUlERXVNRGc0T0RNN0lDOHZJSEpsWmw5YUlEMGdNVEE0TGpnNE0xeHlYRzVtZFc1amRHbHZiaUJ3YVhadmRDaHVLU0I3WEhKY2JpQWdJQ0J5WlhSMWNtNGdiaUErSURBdU1qQTJPRGt6TURNMElEOGdUV0YwYUM1d2IzY29iaXdnTXlrZ09pQW9iaUF0SURFMklDOGdNVEUyS1NBdklEY3VOemczTzF4eVhHNTlYSEpjYmk4dklIUnpiR2x1ZERwa2FYTmhZbXhsTFc1bGVIUXRiR2x1WlRwdVlXMXBibWN0WTI5dWRtVnVkR2x2Ymx4eVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z2JHRmlNbmg1ZWloTUxDQmhMQ0JpS1NCN1hISmNiaUFnSUNCamIyNXpkQ0I1SUQwZ0tFd2dLeUF4TmlrZ0x5QXhNVFk3WEhKY2JpQWdJQ0JqYjI1emRDQjRJRDBnWVNBdklEVXdNQ0FySUhrN1hISmNiaUFnSUNCamIyNXpkQ0I2SUQwZ2VTQXRJR0lnTHlBeU1EQTdYSEpjYmlBZ0lDQnlaWFIxY200Z2UxeHlYRzRnSUNBZ0lDQWdJSGc2SUhKbFpsZ2dLaUJ3YVhadmRDaDRLU3hjY2x4dUlDQWdJQ0FnSUNCNU9pQnlaV1paSUNvZ2NHbDJiM1FvZVNrc1hISmNiaUFnSUNBZ0lDQWdlam9nY21WbVdpQXFJSEJwZG05MEtIb3BMRnh5WEc0Z0lDQWdmVHRjY2x4dWZWeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxc1lXSXllSGw2TG1wekxtMWhjQ0lzSWk4cUtseHlYRzRnS2lCQWNISmxjMlZ5ZG1WY2NseHVJQ29nUTI5d2VYSnBaMmgwSURJd01UVXRNakF4T0NCSloyOXlJRUpsZW10eWIzWnVlV2xjY2x4dUlDb2dRV3hzSUhKcFoyaDBjeUJ5WlhObGNuWmxaQzRnS0UxSlZDQk1hV05sYm5ObFpDbGNjbHh1SUNwY2NseHVJQ29nY21kaU1taHpiQzUwY3lBdElIQmhjblFnYjJZZ1NXMWhaMlVnVVhWaGJuUnBlbUYwYVc5dUlFeHBZbkpoY25sY2NseHVJQ292WEhKY2JtbHRjRzl5ZENCN0lHMXBiak1zSUcxaGVETWdmU0JtY205dElDY3VMaTkxZEdsc2N5OWhjbWwwYUcxbGRHbGpKenRjY2x4dUx5b3FYSEpjYmlBcUlFTmhiR04xYkdGMFpTQklVMHdnWm5KdmJTQlNSMEpjY2x4dUlDb2dTSFZsSUdseklHbHVJR1JsWjNKbFpYTWdXekF1TGpNMk1GMWNjbHh1SUNvZ1RHbG5hSFJ1WlhOek9pQmJNQzR1TVYxY2NseHVJQ29nVTJGMGRYSmhkR2x2YmpvZ1d6QXVMakZkWEhKY2JpQXFJR2gwZEhBNkx5OTNaV0l1WVhKamFHbDJaUzV2Y21jdmQyVmlMekl3TURZd09URTBNRFF3TkRNMkwyaDBkSEE2THk5c2IyTmhiQzUzWVhOd0xuVjNZUzVsWkhVdVlYVXZmbkJpYjNWeWEyVXZZMjlzYjNWeUwyaHpiQzljY2x4dUlDb3ZYSEpjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJ5WjJJeWFITnNLSElzSUdjc0lHSXBJSHRjY2x4dUlDQWdJR052Ym5OMElHMXBiaUE5SUcxcGJqTW9jaXdnWnl3Z1lpazdYSEpjYmlBZ0lDQmpiMjV6ZENCdFlYZ2dQU0J0WVhnektISXNJR2NzSUdJcE8xeHlYRzRnSUNBZ1kyOXVjM1FnWkdWc2RHRWdQU0J0WVhnZ0xTQnRhVzQ3WEhKY2JpQWdJQ0JqYjI1emRDQnNJRDBnS0cxcGJpQXJJRzFoZUNrZ0x5QTFNVEE3WEhKY2JpQWdJQ0JzWlhRZ2N5QTlJREE3WEhKY2JpQWdJQ0JwWmlBb2JDQStJREFnSmlZZ2JDQThJREVwWEhKY2JpQWdJQ0FnSUNBZ2N5QTlJR1JsYkhSaElDOGdLR3dnUENBd0xqVWdQeUFvYldGNElDc2diV2x1S1NBNklDZzFNVEFnTFNCdFlYZ2dMU0J0YVc0cEtUdGNjbHh1SUNBZ0lHeGxkQ0JvSUQwZ01EdGNjbHh1SUNBZ0lHbG1JQ2hrWld4MFlTQStJREFwSUh0Y2NseHVJQ0FnSUNBZ0lDQnBaaUFvYldGNElEMDlQU0J5S1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdnZ1BTQW9aeUF0SUdJcElDOGdaR1ZzZEdFN1hISmNiaUFnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUdWc2MyVWdhV1lnS0cxaGVDQTlQVDBnWnlrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCb0lEMGdLRElnS3lBb1lpQXRJSElwSUM4Z1pHVnNkR0VwTzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0JsYkhObElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2FDQTlJQ2cwSUNzZ0tISWdMU0JuS1NBdklHUmxiSFJoS1R0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnYUNBcVBTQTJNRHRjY2x4dUlDQWdJQ0FnSUNCcFppQW9hQ0E4SURBcFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUdnZ0t6MGdNell3TzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnY21WMGRYSnVJSHNnYUN3Z2N5d2diQ0I5TzF4eVhHNTlYSEpjYmk4dkl5QnpiM1Z5WTJWTllYQndhVzVuVlZKTVBYSm5ZakpvYzJ3dWFuTXViV0Z3SWl3aUx5b3FYSEpjYmlBcUlFQndjbVZ6WlhKMlpWeHlYRzRnS2lCRGIzQjVjbWxuYUhRZ01qQXhOUzB5TURFNElFbG5iM0lnUW1WNmEzSnZkbTU1YVZ4eVhHNGdLaUJCYkd3Z2NtbG5hSFJ6SUhKbGMyVnlkbVZrTGlBb1RVbFVJRXhwWTJWdWMyVmtLVnh5WEc0Z0tseHlYRzRnS2lCeVoySXliR0ZpTG5SeklDMGdjR0Z5ZENCdlppQkpiV0ZuWlNCUmRXRnVkR2w2WVhScGIyNGdUR2xpY21GeWVWeHlYRzRnS2k5Y2NseHVhVzF3YjNKMElIc2djbWRpTW5oNWVpQjlJR1p5YjIwZ0p5NHZjbWRpTW5oNWVpYzdYSEpjYm1sdGNHOXlkQ0I3SUhoNWVqSnNZV0lnZlNCbWNtOXRJQ2N1TDNoNWVqSnNZV0luTzF4eVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z2NtZGlNbXhoWWloeUxDQm5MQ0JpS1NCN1hISmNiaUFnSUNCamIyNXpkQ0I0ZVhvZ1BTQnlaMkl5ZUhsNktISXNJR2NzSUdJcE8xeHlYRzRnSUNBZ2NtVjBkWEp1SUhoNWVqSnNZV0lvZUhsNkxuZ3NJSGg1ZWk1NUxDQjRlWG91ZWlrN1hISmNibjFjY2x4dUx5OGpJSE52ZFhKalpVMWhjSEJwYm1kVlVrdzljbWRpTW14aFlpNXFjeTV0WVhBaUxDSXZLaXBjY2x4dUlDb2dRSEJ5WlhObGNuWmxYSEpjYmlBcUlFTnZjSGx5YVdkb2RDQXlNREUxTFRJd01UZ2dTV2R2Y2lCQ1pYcHJjbTkyYm5scFhISmNiaUFxSUVGc2JDQnlhV2RvZEhNZ2NtVnpaWEoyWldRdUlDaE5TVlFnVEdsalpXNXpaV1FwWEhKY2JpQXFYSEpjYmlBcUlISm5Zako0ZVhvdWRITWdMU0J3WVhKMElHOW1JRWx0WVdkbElGRjFZVzUwYVhwaGRHbHZiaUJNYVdKeVlYSjVYSEpjYmlBcUwxeHlYRzVtZFc1amRHbHZiaUJqYjNKeVpXTjBSMkZ0YldFb2Jpa2dlMXh5WEc0Z0lDQWdjbVYwZFhKdUlHNGdQaUF3TGpBME1EUTFJRDhnVFdGMGFDNXdiM2NvS0c0Z0t5QXdMakExTlNrZ0x5QXhMakExTlN3Z01pNDBLU0E2SUc0Z0x5QXhNaTQ1TWp0Y2NseHVmVnh5WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnY21kaU1uaDVlaWh5TENCbkxDQmlLU0I3WEhKY2JpQWdJQ0F2THlCbllXMXRZU0JqYjNKeVpXTjBhVzl1TENCelpXVWdhSFIwY0hNNkx5OWxiaTUzYVd0cGNHVmthV0V1YjNKbkwzZHBhMmt2VTFKSFFpTlVhR1ZmY21WMlpYSnpaVjkwY21GdWMyWnZjbTFoZEdsdmJseHlYRzRnSUNBZ2NpQTlJR052Y25KbFkzUkhZVzF0WVNoeUlDOGdNalUxS1R0Y2NseHVJQ0FnSUdjZ1BTQmpiM0p5WldOMFIyRnRiV0VvWnlBdklESTFOU2s3WEhKY2JpQWdJQ0JpSUQwZ1kyOXljbVZqZEVkaGJXMWhLR0lnTHlBeU5UVXBPMXh5WEc0Z0lDQWdMeThnVDJKelpYSjJaWEl1SUQwZ01zS3dMQ0JKYkd4MWJXbHVZVzUwSUQwZ1JEWTFYSEpjYmlBZ0lDQnlaWFIxY200Z2UxeHlYRzRnSUNBZ0lDQWdJSGc2SUhJZ0tpQXdMalF4TWpRZ0t5Qm5JQ29nTUM0ek5UYzJJQ3NnWWlBcUlEQXVNVGd3TlN4Y2NseHVJQ0FnSUNBZ0lDQjVPaUJ5SUNvZ01DNHlNVEkySUNzZ1p5QXFJREF1TnpFMU1pQXJJR0lnS2lBd0xqQTNNaklzWEhKY2JpQWdJQ0FnSUNBZ2Vqb2djaUFxSURBdU1ERTVNeUFySUdjZ0tpQXdMakV4T1RJZ0t5QmlJQ29nTUM0NU5UQTFMRnh5WEc0Z0lDQWdmVHRjY2x4dWZWeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxeVoySXllSGw2TG1wekxtMWhjQ0lzSWk4cUtseHlYRzRnS2lCQWNISmxjMlZ5ZG1WY2NseHVJQ29nUTI5d2VYSnBaMmgwSURJd01UVXRNakF4T0NCSloyOXlJRUpsZW10eWIzWnVlV2xjY2x4dUlDb2dRV3hzSUhKcFoyaDBjeUJ5WlhObGNuWmxaQzRnS0UxSlZDQk1hV05sYm5ObFpDbGNjbHh1SUNwY2NseHVJQ29nZUhsNk1teGhZaTUwY3lBdElIQmhjblFnYjJZZ1NXMWhaMlVnVVhWaGJuUnBlbUYwYVc5dUlFeHBZbkpoY25sY2NseHVJQ292WEhKY2JtTnZibk4wSUhKbFpsZ2dQU0F3TGprMU1EUTNPeUF2THlCeVpXWmZXQ0E5SUNBNU5TNHdORGNnSUNCUFluTmxjblpsY2owZ01zS3dMQ0JKYkd4MWJXbHVZVzUwUFNCRU5qVmNjbHh1WTI5dWMzUWdjbVZtV1NBOUlERXVNREF3TURBN0lDOHZJSEpsWmw5WklEMGdNVEF3TGpBd01GeHlYRzVqYjI1emRDQnlaV1phSUQwZ01TNHdPRGc0TXpzZ0x5OGdjbVZtWDFvZ1BTQXhNRGd1T0RnelhISmNibVoxYm1OMGFXOXVJSEJwZG05MEtHNHBJSHRjY2x4dUlDQWdJSEpsZEhWeWJpQnVJRDRnTUM0d01EZzROVFlnUHlCTllYUm9MbkJ2ZHlodUxDQXhJQzhnTXlrZ09pQW9OeTQzT0RjZ0tpQnVJQ3NnTVRZZ0x5QXhNVFlwTzF4eVhHNTlYSEpjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUI0ZVhveWJHRmlLSGdzSUhrc0lIb3BJSHRjY2x4dUlDQWdJSGdnUFNCd2FYWnZkQ2g0SUM4Z2NtVm1XQ2s3WEhKY2JpQWdJQ0I1SUQwZ2NHbDJiM1FvZVNBdklISmxabGtwTzF4eVhHNGdJQ0FnZWlBOUlIQnBkbTkwS0hvZ0x5QnlaV1phS1R0Y2NseHVJQ0FnSUdsbUlDZ29NVEUySUNvZ2VTa2dMU0F4TmlBOElEQXBYSEpjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2Q0ZUhnbktUdGNjbHh1SUNBZ0lISmxkSFZ5YmlCN1hISmNiaUFnSUNBZ0lDQWdURG9nVFdGMGFDNXRZWGdvTUN3Z0tERXhOaUFxSUhrcElDMGdNVFlwTEZ4eVhHNGdJQ0FnSUNBZ0lHRTZJRFV3TUNBcUlDaDRJQzBnZVNrc1hISmNiaUFnSUNBZ0lDQWdZam9nTWpBd0lDb2dLSGtnTFNCNktTeGNjbHh1SUNBZ0lIMDdYSEpjYm4xY2NseHVMeThqSUhOdmRYSmpaVTFoY0hCcGJtZFZVa3c5ZUhsNk1teGhZaTVxY3k1dFlYQWlMQ0l2S2lwY2NseHVJQ29nUUhCeVpYTmxjblpsWEhKY2JpQXFJRU52Y0hseWFXZG9kQ0F5TURFMUxUSXdNVGdnU1dkdmNpQkNaWHByY205MmJubHBYSEpjYmlBcUlFRnNiQ0J5YVdkb2RITWdjbVZ6WlhKMlpXUXVJQ2hOU1ZRZ1RHbGpaVzV6WldRcFhISmNiaUFxWEhKY2JpQXFJSGg1ZWpKeVoySXVkSE1nTFNCd1lYSjBJRzltSUVsdFlXZGxJRkYxWVc1MGFYcGhkR2x2YmlCTWFXSnlZWEo1WEhKY2JpQXFMMXh5WEc1cGJYQnZjblFnZXlCcGJsSmhibWRsTUhSdk1qVTFVbTkxYm1SbFpDQjlJR1p5YjIwZ0p5NHVMM1YwYVd4ekwyRnlhWFJvYldWMGFXTW5PMXh5WEc0dkx5Qm5ZVzF0WVNCamIzSnlaV04wYVc5dUxDQnpaV1VnYUhSMGNITTZMeTlsYmk1M2FXdHBjR1ZrYVdFdWIzSm5MM2RwYTJrdlUxSkhRaU5VYUdWZmNtVjJaWEp6WlY5MGNtRnVjMlp2Y20xaGRHbHZibHh5WEc1bWRXNWpkR2x2YmlCamIzSnlaV04wUjJGdGJXRW9iaWtnZTF4eVhHNGdJQ0FnY21WMGRYSnVJRzRnUGlBd0xqQXdNekV6TURnZ1B5QXhMakExTlNBcUlFMWhkR2d1Y0c5M0tHNHNJREVnTHlBeUxqUXBJQzBnTUM0d05UVWdPaUF4TWk0NU1pQXFJRzQ3WEhKY2JuMWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJSGg1ZWpKeVoySW9lQ3dnZVN3Z2Vpa2dlMXh5WEc0Z0lDQWdMeThnVDJKelpYSjJaWEl1SUQwZ01zS3dMQ0JKYkd4MWJXbHVZVzUwSUQwZ1JEWTFYSEpjYmlBZ0lDQmpiMjV6ZENCeUlEMGdZMjl5Y21WamRFZGhiVzFoS0hnZ0tpQXpMakkwTURZZ0t5QjVJQ29nTFRFdU5UTTNNaUFySUhvZ0tpQXRNQzQwT1RnMktUdGNjbHh1SUNBZ0lHTnZibk4wSUdjZ1BTQmpiM0p5WldOMFIyRnRiV0VvZUNBcUlDMHdMamsyT0RrZ0t5QjVJQ29nTVM0NE56VTRJQ3NnZWlBcUlEQXVNRFF4TlNrN1hISmNiaUFnSUNCamIyNXpkQ0JpSUQwZ1kyOXljbVZqZEVkaGJXMWhLSGdnS2lBd0xqQTFOVGNnS3lCNUlDb2dMVEF1TWpBME1DQXJJSG9nS2lBeExqQTFOekFwTzF4eVhHNGdJQ0FnY21WMGRYSnVJSHRjY2x4dUlDQWdJQ0FnSUNCeU9pQnBibEpoYm1kbE1IUnZNalUxVW05MWJtUmxaQ2h5SUNvZ01qVTFLU3hjY2x4dUlDQWdJQ0FnSUNCbk9pQnBibEpoYm1kbE1IUnZNalUxVW05MWJtUmxaQ2huSUNvZ01qVTFLU3hjY2x4dUlDQWdJQ0FnSUNCaU9pQnBibEpoYm1kbE1IUnZNalUxVW05MWJtUmxaQ2hpSUNvZ01qVTFLU3hjY2x4dUlDQWdJSDA3WEhKY2JuMWNjbHh1THk4aklITnZkWEpqWlUxaGNIQnBibWRWVWt3OWVIbDZNbkpuWWk1cWN5NXRZWEFpTENJdktpcGNjbHh1SUNvZ1FIQnlaWE5sY25abFhISmNiaUFxSUVOdmNIbHlhV2RvZENBeU1ERTFMVEl3TVRnZ1NXZHZjaUJDWlhwcmNtOTJibmxwWEhKY2JpQXFJRUZzYkNCeWFXZG9kSE1nY21WelpYSjJaV1F1SUNoTlNWUWdUR2xqWlc1elpXUXBYSEpjYmlBcVhISmNiaUFxSUdOcFpUazBMblJ6SUMwZ2NHRnlkQ0J2WmlCSmJXRm5aU0JSZFdGdWRHbDZZWFJwYjI0Z1RHbGljbUZ5ZVZ4eVhHNGdLaTljY2x4dWFXMXdiM0owSUhzZ1FXSnpkSEpoWTNSRWFYTjBZVzVqWlVOaGJHTjFiR0YwYjNJZ2ZTQm1jbTl0SUNjdUwyUnBjM1JoYm1ObFEyRnNZM1ZzWVhSdmNpYzdYSEpjYm1sdGNHOXlkQ0I3SUhKbllqSnNZV0lnZlNCbWNtOXRJQ2N1TGk5amIyNTJaWEp6YVc5dUwzSm5ZakpzWVdJbk8xeHlYRzVwYlhCdmNuUWdleUJwYmxKaGJtZGxNSFJ2TWpVMUlIMGdabkp2YlNBbkxpNHZkWFJwYkhNdllYSnBkR2h0WlhScFl5YzdYSEpjYmk4cUtseHlYRzRnS2lCRFNVVTVOQ0J0WlhSb2IyUWdiMllnWkdWc2RHRXRaVnh5WEc0Z0tpQm9kSFJ3T2k4dlpXNHVkMmxyYVhCbFpHbGhMbTl5Wnk5M2FXdHBMME52Ykc5eVgyUnBabVpsY21WdVkyVWpRMGxGT1RSY2NseHVJQ292WEhKY2JtVjRjRzl5ZENCamJHRnpjeUJCWW5OMGNtRmpkRU5KUlRrMElHVjRkR1Z1WkhNZ1FXSnpkSEpoWTNSRWFYTjBZVzVqWlVOaGJHTjFiR0YwYjNJZ2UxeHlYRzRnSUNBZ1kyRnNZM1ZzWVhSbFVtRjNLSEl4TENCbk1Td2dZakVzSUdFeExDQnlNaXdnWnpJc0lHSXlMQ0JoTWlrZ2UxeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHeGhZakVnUFNCeVoySXliR0ZpS0dsdVVtRnVaMlV3ZEc4eU5UVW9jakVnS2lCMGFHbHpMbDkzYUdsMFpWQnZhVzUwTG5JcExDQnBibEpoYm1kbE1IUnZNalUxS0djeElDb2dkR2hwY3k1ZmQyaHBkR1ZRYjJsdWRDNW5LU3dnYVc1U1lXNW5aVEIwYnpJMU5TaGlNU0FxSUhSb2FYTXVYM2RvYVhSbFVHOXBiblF1WWlrcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHeGhZaklnUFNCeVoySXliR0ZpS0dsdVVtRnVaMlV3ZEc4eU5UVW9jaklnS2lCMGFHbHpMbDkzYUdsMFpWQnZhVzUwTG5JcExDQnBibEpoYm1kbE1IUnZNalUxS0djeUlDb2dkR2hwY3k1ZmQyaHBkR1ZRYjJsdWRDNW5LU3dnYVc1U1lXNW5aVEIwYnpJMU5TaGlNaUFxSUhSb2FYTXVYM2RvYVhSbFVHOXBiblF1WWlrcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHUk1JRDBnYkdGaU1TNU1JQzBnYkdGaU1pNU1PMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR1JCSUQwZ2JHRmlNUzVoSUMwZ2JHRmlNaTVoTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdSQ0lEMGdiR0ZpTVM1aUlDMGdiR0ZpTWk1aU8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHTXhJRDBnVFdGMGFDNXpjWEowS0d4aFlqRXVZU0FxSUd4aFlqRXVZU0FySUd4aFlqRXVZaUFxSUd4aFlqRXVZaWs3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWXpJZ1BTQk5ZWFJvTG5OeGNuUW9iR0ZpTWk1aElDb2diR0ZpTWk1aElDc2diR0ZpTWk1aUlDb2diR0ZpTWk1aUtUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQmtReUE5SUdNeElDMGdZekk3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJR1JsYkhSaFNDQTlJR1JCSUNvZ1pFRWdLeUJrUWlBcUlHUkNJQzBnWkVNZ0tpQmtRenRjY2x4dUlDQWdJQ0FnSUNCa1pXeDBZVWdnUFNCa1pXeDBZVWdnUENBd0lEOGdNQ0E2SUUxaGRHZ3VjM0Z5ZENoa1pXeDBZVWdwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdSQmJIQm9ZU0E5SUNoaE1pQXRJR0V4S1NBcUlIUm9hWE11WDNkb2FYUmxVRzlwYm5RdVlTQXFJSFJvYVhNdVgydEJPMXh5WEc0Z0lDQWdJQ0FnSUM4dklGUlBSRTg2SUdGa1pDQmhiSEJvWVNCamFHRnVibVZzSUhOMWNIQnZjblJjY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnVFdGMGFDNXpjWEowS0UxaGRHZ3VjRzkzS0dSTUlDOGdkR2hwY3k1ZlMyd3NJRElwSUN0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnVFdGMGFDNXdiM2NvWkVNZ0x5QW9NUzR3SUNzZ2RHaHBjeTVmU3pFZ0tpQmpNU2tzSURJcElDdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1RXRjBhQzV3YjNjb1pHVnNkR0ZJSUM4Z0tERXVNQ0FySUhSb2FYTXVYMHN5SUNvZ1l6RXBMQ0F5S1NBclhISmNiaUFnSUNBZ0lDQWdJQ0FnSUUxaGRHZ3VjRzkzS0dSQmJIQm9ZU3dnTWlrcE8xeHlYRzRnSUNBZ2ZWeHlYRzU5WEhKY2JtVjRjRzl5ZENCamJHRnpjeUJEU1VVNU5GUmxlSFJwYkdWeklHVjRkR1Z1WkhNZ1FXSnpkSEpoWTNSRFNVVTVOQ0I3WEhKY2JpQWdJQ0JmYzJWMFJHVm1ZWFZzZEhNb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZTMndnUFNBeUxqQTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZTekVnUFNBd0xqQTBPRHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlMTWlBOUlEQXVNREUwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJ0QklEMGdNQzR5TlNBcUlEVXdJQzhnTWpVMU8xeHlYRzRnSUNBZ2ZWeHlYRzU5WEhKY2JtVjRjRzl5ZENCamJHRnpjeUJEU1VVNU5FZHlZWEJvYVdOQmNuUnpJR1Y0ZEdWdVpITWdRV0p6ZEhKaFkzUkRTVVU1TkNCN1hISmNiaUFnSUNCZmMyVjBSR1ZtWVhWc2RITW9LU0I3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmUzJ3Z1BTQXhMakE3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmU3pFZ1BTQXdMakEwTlR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5TE1pQTlJREF1TURFMU8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgydEJJRDBnTUM0eU5TQXFJREV3TUNBdklESTFOVHRjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxamFXVTVOQzVxY3k1dFlYQWlMQ0l2S2lwY2NseHVJQ29nUUhCeVpYTmxjblpsWEhKY2JpQXFJRU52Y0hseWFXZG9kQ0F5TURFMUxUSXdNVGdnU1dkdmNpQkNaWHByY205MmJubHBYSEpjYmlBcUlFRnNiQ0J5YVdkb2RITWdjbVZ6WlhKMlpXUXVJQ2hOU1ZRZ1RHbGpaVzV6WldRcFhISmNiaUFxWEhKY2JpQXFJR05wWldSbE1qQXdNQzUwY3lBdElIQmhjblFnYjJZZ1NXMWhaMlVnVVhWaGJuUnBlbUYwYVc5dUlFeHBZbkpoY25sY2NseHVJQ292WEhKY2JtbHRjRzl5ZENCN0lFRmljM1J5WVdOMFJHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUlIMGdabkp2YlNBbkxpOWthWE4wWVc1alpVTmhiR04xYkdGMGIzSW5PMXh5WEc1cGJYQnZjblFnZXlCeVoySXliR0ZpSUgwZ1puSnZiU0FuTGk0dlkyOXVkbVZ5YzJsdmJpOXlaMkl5YkdGaUp6dGNjbHh1YVcxd2IzSjBJSHNnWkdWbmNtVmxjekp5WVdScFlXNXpMQ0JwYmxKaGJtZGxNSFJ2TWpVMUlIMGdabkp2YlNBbkxpNHZkWFJwYkhNdllYSnBkR2h0WlhScFl5YzdYSEpjYmk4dklIUnpiR2x1ZERwa2FYTmhZbXhsT25aaGNtbGhZbXhsTFc1aGJXVmNjbHh1THk4Z2RITnNhVzUwT21ScGMyRmliR1U2Ym1GdGFXNW5MV052Ym5abGJuUnBiMjVjY2x4dUx5b3FYSEpjYmlBcUlFTkpSVVJGTWpBd01DQmhiR2R2Y21sMGFHMGdMU0JCWkdGd2RHVmtJR1p5YjIwZ1UyaGhjbTFoSUdWMElHRnNKM01nVFVGVVRFRkNJR2x0Y0d4bGJXVnVkR0YwYVc5dUlHRjBYSEpjYmlBcUlHaDBkSEE2THk5M2QzY3VaV05sTG5KdlkyaGxjM1JsY2k1bFpIVXZmbWR6YUdGeWJXRXZZMmxsWkdVeU1EQXdMMXh5WEc0Z0tpOWNjbHh1Wlhod2IzSjBJR05zWVhOeklFTkpSVVJGTWpBd01DQmxlSFJsYm1SeklFRmljM1J5WVdOMFJHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUlIdGNjbHh1SUNBZ0lGOXpaWFJFWldaaGRXeDBjeWdwSUhzZ2ZWeHlYRzRnSUNBZ2MzUmhkR2xqSUY5allXeGpkV3hoZEdWb2NDaGlMQ0JoY0NrZ2UxeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHaHdJRDBnVFdGMGFDNWhkR0Z1TWloaUxDQmhjQ2s3WEhKY2JpQWdJQ0FnSUNBZ2FXWWdLR2h3SUQ0OUlEQXBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCb2NEdGNjbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdhSEFnS3lCRFNVVkVSVEl3TURBdVgyUmxaek0yTUVsdVVtRmtPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdjM1JoZEdsaklGOWpZV3hqZFd4aGRHVlNWQ2hoYUhBc0lHRkRjQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdGRGNGOTBiMTgzSUQwZ1RXRjBhQzV3YjNjb1lVTndMQ0EzTGpBcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElGSmZReUE5SURJdU1DQXFJRTFoZEdndWMzRnlkQ2hoUTNCZmRHOWZOeUF2SUNoaFEzQmZkRzlmTnlBcklFTkpSVVJGTWpBd01DNWZjRzkzTWpWMGJ6Y3BLVHNnTHk4Z01qVmVOMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR1JsYkhSaFgzUm9aWFJoSUQwZ1EwbEZSRVV5TURBd0xsOWtaV2N6TUVsdVVtRmtJQ29nVFdGMGFDNWxlSEFvTFUxaGRHZ3VjRzkzS0NoaGFIQWdMU0JEU1VWRVJUSXdNREF1WDJSbFp6STNOVWx1VW1Ga0tTQXZJRU5KUlVSRk1qQXdNQzVmWkdWbk1qVkpibEpoWkN3Z01pNHdLU2s3WEhKY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUMxTllYUm9Mbk5wYmlneUxqQWdLaUJrWld4MFlWOTBhR1YwWVNrZ0tpQlNYME03WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0J6ZEdGMGFXTWdYMk5oYkdOMWJHRjBaVlFvWVdod0tTQjdYSEpjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJREV1TUNBdElDNHhOeUFxSUUxaGRHZ3VZMjl6S0dGb2NDQXRJRU5KUlVSRk1qQXdNQzVmWkdWbk16QkpibEpoWkNrZ0t5QXVNalFnS2lCTllYUm9MbU52Y3loaGFIQWdLaUF5TGpBcElDc2dMak15SUNvZ1RXRjBhQzVqYjNNb1lXaHdJQ29nTXk0d0lDc2dRMGxGUkVVeU1EQXdMbDlrWldjMlNXNVNZV1FwSUMwZ0xqSWdLaUJOWVhSb0xtTnZjeWhoYUhBZ0tpQTBMakFnTFNCRFNVVkVSVEl3TURBdVgyUmxaell6U1c1U1lXUXBPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdjM1JoZEdsaklGOWpZV3hqZFd4aGRHVmZZV2h3S0VNeGNFTXljQ3dnYUY5aVlYSXNJR2d4Y0N3Z2FESndLU0I3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYUhCVGRXMGdQU0JvTVhBZ0t5Qm9NbkE3WEhKY2JpQWdJQ0FnSUNBZ2FXWWdLRU14Y0VNeWNDQTlQVDBnTUNsY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR2h3VTNWdE8xeHlYRzRnSUNBZ0lDQWdJR2xtSUNob1gySmhjaUE4UFNCRFNVVkVSVEl3TURBdVgyUmxaekU0TUVsdVVtRmtLVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2FIQlRkVzBnTHlBeUxqQTdYSEpjYmlBZ0lDQWdJQ0FnYVdZZ0tHaHdVM1Z0SUR3Z1EwbEZSRVV5TURBd0xsOWtaV2N6TmpCSmJsSmhaQ2xjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlDaG9jRk4xYlNBcklFTkpSVVJGTWpBd01DNWZaR1ZuTXpZd1NXNVNZV1FwSUM4Z01pNHdPMXh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUFvYUhCVGRXMGdMU0JEU1VWRVJUSXdNREF1WDJSbFp6TTJNRWx1VW1Ga0tTQXZJREl1TUR0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhOMFlYUnBZeUJmWTJGc1kzVnNZWFJsWDJSSWNDaERNWEJETW5Bc0lHaGZZbUZ5TENCb01uQXNJR2d4Y0NrZ2UxeHlYRzRnSUNBZ0lDQWdJR3hsZENCa2FIQTdYSEpjYmlBZ0lDQWdJQ0FnYVdZZ0tFTXhjRU15Y0NBOVBUMGdNQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JrYUhBZ1BTQXdPMXh5WEc0Z0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQmxiSE5sSUdsbUlDaG9YMkpoY2lBOFBTQkRTVVZFUlRJd01EQXVYMlJsWnpFNE1FbHVVbUZrS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdSb2NDQTlJR2d5Y0NBdElHZ3hjRHRjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdaV3h6WlNCcFppQW9hREp3SUR3OUlHZ3hjQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JrYUhBZ1BTQm9NbkFnTFNCb01YQWdLeUJEU1VWRVJUSXdNREF1WDJSbFp6TTJNRWx1VW1Ga08xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCbGJITmxJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdaR2h3SUQwZ2FESndJQzBnYURGd0lDMGdRMGxGUkVVeU1EQXdMbDlrWldjek5qQkpibEpoWkR0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJREl1TUNBcUlFMWhkR2d1YzNGeWRDaERNWEJETW5BcElDb2dUV0YwYUM1emFXNG9aR2h3SUM4Z01pNHdLVHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJR05oYkdOMWJHRjBaVkpoZHloeU1Td2daekVzSUdJeExDQmhNU3dnY2pJc0lHY3lMQ0JpTWl3Z1lUSXBJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JzWVdJeElEMGdjbWRpTW14aFlpaHBibEpoYm1kbE1IUnZNalUxS0hJeElDb2dkR2hwY3k1ZmQyaHBkR1ZRYjJsdWRDNXlLU3dnYVc1U1lXNW5aVEIwYnpJMU5TaG5NU0FxSUhSb2FYTXVYM2RvYVhSbFVHOXBiblF1Wnlrc0lHbHVVbUZ1WjJVd2RHOHlOVFVvWWpFZ0tpQjBhR2x6TGw5M2FHbDBaVkJ2YVc1MExtSXBLVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JzWVdJeUlEMGdjbWRpTW14aFlpaHBibEpoYm1kbE1IUnZNalUxS0hJeUlDb2dkR2hwY3k1ZmQyaHBkR1ZRYjJsdWRDNXlLU3dnYVc1U1lXNW5aVEIwYnpJMU5TaG5NaUFxSUhSb2FYTXVYM2RvYVhSbFVHOXBiblF1Wnlrc0lHbHVVbUZ1WjJVd2RHOHlOVFVvWWpJZ0tpQjBhR2x6TGw5M2FHbDBaVkJ2YVc1MExtSXBLVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JrUVNBOUlDaGhNaUF0SUdFeEtTQXFJSFJvYVhNdVgzZG9hWFJsVUc5cGJuUXVZU0FxSUVOSlJVUkZNakF3TUM1ZmEwRTdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdaRVV5SUQwZ2RHaHBjeTVqWVd4amRXeGhkR1ZTWVhkSmJreGhZaWhzWVdJeExDQnNZV0l5S1R0Y2NseHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1RXRjBhQzV6Y1hKMEtHUkZNaUFySUdSQklDb2daRUVwTzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnWTJGc1kzVnNZWFJsVW1GM1NXNU1ZV0lvVEdGaU1Td2dUR0ZpTWlrZ2UxeHlYRzRnSUNBZ0lDQWdJQzh2SUVkbGRDQk1MR0VzWWlCMllXeDFaWE1nWm05eUlHTnZiRzl5SURGY2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCTU1TQTlJRXhoWWpFdVREdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQmhNU0E5SUV4aFlqRXVZVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JpTVNBOUlFeGhZakV1WWp0Y2NseHVJQ0FnSUNBZ0lDQXZMeUJIWlhRZ1RDeGhMR0lnZG1Gc2RXVnpJR1p2Y2lCamIyeHZjaUF5WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnVERJZ1BTQk1ZV0l5TGt3N1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1lUSWdQU0JNWVdJeUxtRTdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZaklnUFNCTVlXSXlMbUk3WEhKY2JpQWdJQ0FnSUNBZ0x5OGdRMkZzWTNWc1lYUmxJRU53Y21sdFpURXNJRU53Y21sdFpUSXNJRU5oWW1KaGNseHlYRzRnSUNBZ0lDQWdJR052Ym5OMElFTXhJRDBnVFdGMGFDNXpjWEowS0dFeElDb2dZVEVnS3lCaU1TQXFJR0l4S1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCRE1pQTlJRTFoZEdndWMzRnlkQ2hoTWlBcUlHRXlJQ3NnWWpJZ0tpQmlNaWs3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnY0c5M1gyRmZRekZmUXpKZmRHOWZOeUE5SUUxaGRHZ3VjRzkzS0NoRE1TQXJJRU15S1NBdklESXVNQ3dnTnk0d0tUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQkhJRDBnTUM0MUlDb2dLREV1TUNBdElFMWhkR2d1YzNGeWRDaHdiM2RmWVY5RE1WOURNbDkwYjE4M0lDOGdLSEJ2ZDE5aFgwTXhYME15WDNSdlh6Y2dLeUJEU1VWRVJUSXdNREF1WDNCdmR6STFkRzgzS1NrcE95QXZMeUF5TlY0M1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1lURndJRDBnS0RFdU1DQXJJRWNwSUNvZ1lURTdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZVEp3SUQwZ0tERXVNQ0FySUVjcElDb2dZVEk3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnUXpGd0lEMGdUV0YwYUM1emNYSjBLR0V4Y0NBcUlHRXhjQ0FySUdJeElDb2dZakVwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUVNeWNDQTlJRTFoZEdndWMzRnlkQ2hoTW5BZ0tpQmhNbkFnS3lCaU1pQXFJR0l5S1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCRE1YQkRNbkFnUFNCRE1YQWdLaUJETW5BN1hISmNiaUFnSUNBZ0lDQWdMeThnUVc1bmJHVnpJR2x1SUVSbFozSmxaUzVjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JvTVhBZ1BTQkRTVVZFUlRJd01EQXVYMk5oYkdOMWJHRjBaV2h3S0dJeExDQmhNWEFwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdneWNDQTlJRU5KUlVSRk1qQXdNQzVmWTJGc1kzVnNZWFJsYUhBb1lqSXNJR0V5Y0NrN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2FGOWlZWElnUFNCTllYUm9MbUZpY3lob01YQWdMU0JvTW5BcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHUk1jQ0E5SUV3eUlDMGdUREU3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWkVOd0lEMGdRekp3SUMwZ1F6RndPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR1JJY0NBOUlFTkpSVVJGTWpBd01DNWZZMkZzWTNWc1lYUmxYMlJJY0NoRE1YQkRNbkFzSUdoZlltRnlMQ0JvTW5Bc0lHZ3hjQ2s3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWVdod0lEMGdRMGxGUkVVeU1EQXdMbDlqWVd4amRXeGhkR1ZmWVdod0tFTXhjRU15Y0N3Z2FGOWlZWElzSUdneGNDd2dhREp3S1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCVUlEMGdRMGxGUkVVeU1EQXdMbDlqWVd4amRXeGhkR1ZVS0dGb2NDazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZVU53SUQwZ0tFTXhjQ0FySUVNeWNDa2dMeUF5TGpBN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1lVeHdYMjFwYm5Welh6VXdYM054ZFdGeVpTQTlJRTFoZEdndWNHOTNLQ2hNTVNBcklFd3lLU0F2SURJdU1DQXRJRFV3TGpBc0lESXVNQ2s3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnVTE5TUlEMGdNUzR3SUNzZ0tDNHdNVFVnS2lCaFRIQmZiV2x1ZFhOZk5UQmZjM0YxWVhKbEtTQXZJRTFoZEdndWMzRnlkQ2d5TUM0d0lDc2dZVXh3WDIxcGJuVnpYelV3WDNOeGRXRnlaU2s3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnVTE5RElEMGdNUzR3SUNzZ0xqQTBOU0FxSUdGRGNEdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQlRYMGdnUFNBeExqQWdLeUF1TURFMUlDb2dWQ0FxSUdGRGNEdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQlNYMVFnUFNCRFNVVkVSVEl3TURBdVgyTmhiR04xYkdGMFpWSlVLR0ZvY0N3Z1lVTndLVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JrVEhCVFRDQTlJR1JNY0NBdklGTmZURHNnTHk4Z1UxOU1JQ29nYTB3c0lIZG9aWEpsSUd0TUlHbHpJREV1TUZ4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdSRGNGTkRJRDBnWkVOd0lDOGdVMTlET3lBdkx5QlRYME1nS2lCclF5d2dkMmhsY21VZ2EwTWdhWE1nTVM0d1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1pFaHdVMGdnUFNCa1NIQWdMeUJUWDBnN0lDOHZJRk5mU0NBcUlHdElMQ0IzYUdWeVpTQnJTQ0JwY3lBeExqQmNjbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdUV0YwYUM1d2IzY29aRXh3VTB3c0lESXBJQ3NnVFdGMGFDNXdiM2NvWkVOd1UwTXNJRElwSUNzZ1RXRjBhQzV3YjNjb1pFaHdVMGdzSURJcElDc2dVbDlVSUNvZ1pFTndVME1nS2lCa1NIQlRTRHRjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzR2S2lwY2NseHVJQ29nVjJWcFoyaDBJR2x1SUdScGMzUmhibU5sT2lBd0xqSTFYSEpjYmlBcUlFMWhlQ0JFWld4MFlVVTZJREV3TUZ4eVhHNGdLaUJOWVhnZ1JHVnNkR0ZCT2lBeU5UVmNjbHh1SUNvdlhISmNia05KUlVSRk1qQXdNQzVmYTBFZ1BTQXdMakkxSUNvZ01UQXdJQzhnTWpVMU8xeHlYRzVEU1VWRVJUSXdNREF1WDNCdmR6STFkRzgzSUQwZ1RXRjBhQzV3YjNjb01qVXNJRGNwTzF4eVhHNURTVVZFUlRJd01EQXVYMlJsWnpNMk1FbHVVbUZrSUQwZ1pHVm5jbVZsY3pKeVlXUnBZVzV6S0RNMk1DazdYSEpjYmtOSlJVUkZNakF3TUM1ZlpHVm5NVGd3U1c1U1lXUWdQU0JrWldkeVpXVnpNbkpoWkdsaGJuTW9NVGd3S1R0Y2NseHVRMGxGUkVVeU1EQXdMbDlrWldjek1FbHVVbUZrSUQwZ1pHVm5jbVZsY3pKeVlXUnBZVzV6S0RNd0tUdGNjbHh1UTBsRlJFVXlNREF3TGw5a1pXYzJTVzVTWVdRZ1BTQmtaV2R5WldWek1uSmhaR2xoYm5Nb05pazdYSEpjYmtOSlJVUkZNakF3TUM1ZlpHVm5Oak5KYmxKaFpDQTlJR1JsWjNKbFpYTXljbUZrYVdGdWN5ZzJNeWs3WEhKY2JrTkpSVVJGTWpBd01DNWZaR1ZuTWpjMVNXNVNZV1FnUFNCa1pXZHlaV1Z6TW5KaFpHbGhibk1vTWpjMUtUdGNjbHh1UTBsRlJFVXlNREF3TGw5a1pXY3lOVWx1VW1Ga0lEMGdaR1ZuY21WbGN6SnlZV1JwWVc1ektESTFLVHRjY2x4dUx5OGpJSE52ZFhKalpVMWhjSEJwYm1kVlVrdzlZMmxsWkdVeU1EQXdMbXB6TG0xaGNDSXNJaThxS2x4eVhHNGdLaUJBY0hKbGMyVnlkbVZjY2x4dUlDb2dRMjl3ZVhKcFoyaDBJREl3TVRVdE1qQXhPQ0JKWjI5eUlFSmxlbXR5YjNadWVXbGNjbHh1SUNvZ1FXeHNJSEpwWjJoMGN5QnlaWE5sY25abFpDNGdLRTFKVkNCTWFXTmxibk5sWkNsY2NseHVJQ3BjY2x4dUlDb2dZMjFsZEhKcFl5NTBjeUF0SUhCaGNuUWdiMllnU1cxaFoyVWdVWFZoYm5ScGVtRjBhVzl1SUV4cFluSmhjbmxjY2x4dUlDb3ZYSEpjYm1sdGNHOXlkQ0I3SUVGaWMzUnlZV04wUkdsemRHRnVZMlZEWVd4amRXeGhkRzl5SUgwZ1puSnZiU0FuTGk5a2FYTjBZVzVqWlVOaGJHTjFiR0YwYjNJbk8xeHlYRzR2S2lwY2NseHVJQ29nVkU5RVR6b2dUbUZ0WlNCcGREb2dhSFIwY0RvdkwzZDNkeTVqYjIxd2RYQm9ZWE5sTG1OdmJTOWpiV1YwY21sakxtaDBiVnh5WEc0Z0tpOWNjbHh1Wlhod2IzSjBJR05zWVhOeklFTk5aWFJ5YVdNZ1pYaDBaVzVrY3lCQlluTjBjbUZqZEVScGMzUmhibU5sUTJGc1kzVnNZWFJ2Y2lCN1hISmNiaUFnSUNCallXeGpkV3hoZEdWU1lYY29jakVzSUdjeExDQmlNU3dnWVRFc0lISXlMQ0JuTWl3Z1lqSXNJR0V5S1NCN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2NtMWxZVzRnUFNBb2NqRWdLeUJ5TWlrZ0x5QXlJQ29nZEdocGN5NWZkMmhwZEdWUWIybHVkQzV5TzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhJZ1BTQW9jakVnTFNCeU1pa2dLaUIwYUdsekxsOTNhR2wwWlZCdmFXNTBMbkk3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWnlBOUlDaG5NU0F0SUdjeUtTQXFJSFJvYVhNdVgzZG9hWFJsVUc5cGJuUXVaenRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JpSUQwZ0tHSXhJQzBnWWpJcElDb2dkR2hwY3k1ZmQyaHBkR1ZRYjJsdWRDNWlPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR1JGSUQwZ0tDZ29LRFV4TWlBcklISnRaV0Z1S1NBcUlISWdLaUJ5S1NBK1BpQTRLU0FySURRZ0tpQm5JQ29nWnlBcklDZ29LRGMyTnlBdElISnRaV0Z1S1NBcUlHSWdLaUJpS1NBK1BpQTRLU2s3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWkVFZ1BTQW9ZVElnTFNCaE1Ta2dLaUIwYUdsekxsOTNhR2wwWlZCdmFXNTBMbUU3WEhKY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUUxaGRHZ3VjM0Z5ZENoa1JTQXJJR1JCSUNvZ1pFRXBPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdYM05sZEVSbFptRjFiSFJ6S0NrZ2V5QjlYSEpjYm4xY2NseHVMeThqSUhOdmRYSmpaVTFoY0hCcGJtZFZVa3c5WTIxbGRISnBZeTVxY3k1dFlYQWlMQ0psZUhCdmNuUWdZMnhoYzNNZ1FXSnpkSEpoWTNSRWFYTjBZVzVqWlVOaGJHTjFiR0YwYjNJZ2UxeHlYRzRnSUNBZ1kyOXVjM1J5ZFdOMGIzSW9LU0I3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmYzJWMFJHVm1ZWFZzZEhNb0tUdGNjbHh1SUNBZ0lDQWdJQ0F2THlCelpYUWdaR1ZtWVhWc2RDQnRZWGhwYldGc0lHTnZiRzl5SUdOdmJYQnZibVZ1ZENCa1pXeDBZWE1nS0RJMU5TQXRJREFnUFNBeU5UVXBYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NXpaWFJYYUdsMFpWQnZhVzUwS0RJMU5Td2dNalUxTENBeU5UVXNJREkxTlNrN1hISmNiaUFnSUNCOVhISmNiaUFnSUNCelpYUlhhR2wwWlZCdmFXNTBLSElzSUdjc0lHSXNJR0VwSUh0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5M2FHbDBaVkJ2YVc1MElEMGdlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlPaUFvY2lBK0lEQXBJRDhnTWpVMUlDOGdjaUE2SURBc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdjNklDaG5JRDRnTUNrZ1B5QXlOVFVnTHlCbklEb2dNQ3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZam9nS0dJZ1BpQXdLU0EvSURJMU5TQXZJR0lnT2lBd0xGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCaE9pQW9ZU0ErSURBcElEOGdNalUxSUM4Z1lTQTZJREFzWEhKY2JpQWdJQ0FnSUNBZ2ZUdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXRZWGhFYVhOMFlXNWpaU0E5SUhSb2FYTXVZMkZzWTNWc1lYUmxVbUYzS0hJc0lHY3NJR0lzSUdFc0lEQXNJREFzSURBc0lEQXBPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdZMkZzWTNWc1lYUmxUbTl5YldGc2FYcGxaQ2hqYjJ4dmNrRXNJR052Ykc5eVFpa2dlMXh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxtTmhiR04xYkdGMFpWSmhkeWhqYjJ4dmNrRXVjaXdnWTI5c2IzSkJMbWNzSUdOdmJHOXlRUzVpTENCamIyeHZja0V1WVN3Z1kyOXNiM0pDTG5Jc0lHTnZiRzl5UWk1bkxDQmpiMnh2Y2tJdVlpd2dZMjlzYjNKQ0xtRXBJQzhnZEdocGN5NWZiV0Y0UkdsemRHRnVZMlU3WEhKY2JpQWdJQ0I5WEhKY2JuMWNjbHh1THk4aklITnZkWEpqWlUxaGNIQnBibWRWVWt3OVpHbHpkR0Z1WTJWRFlXeGpkV3hoZEc5eUxtcHpMbTFoY0NJc0lpOHFLbHh5WEc0Z0tpQkFjSEpsYzJWeWRtVmNjbHh1SUNvZ1EyOXdlWEpwWjJoMElESXdNVFV0TWpBeE9DQkpaMjl5SUVKbGVtdHliM1p1ZVdsY2NseHVJQ29nUVd4c0lISnBaMmgwY3lCeVpYTmxjblpsWkM0Z0tFMUpWQ0JNYVdObGJuTmxaQ2xjY2x4dUlDcGNjbHh1SUNvZ1pYVmpiR2xrWldGdUxuUnpJQzBnY0dGeWRDQnZaaUJKYldGblpTQlJkV0Z1ZEdsNllYUnBiMjRnVEdsaWNtRnllVnh5WEc0Z0tpOWNjbHh1YVcxd2IzSjBJSHNnUVdKemRISmhZM1JFYVhOMFlXNWpaVU5oYkdOMWJHRjBiM0lnZlNCbWNtOXRJQ2N1TDJScGMzUmhibU5sUTJGc1kzVnNZWFJ2Y2ljN1hISmNibWx0Y0c5eWRDQjdJRmtnZlNCbWNtOXRJQ2N1TGk5amIyNXpkR0Z1ZEhNdlluUTNNRGtuTzF4eVhHNHZLaXBjY2x4dUlDb2dSWFZqYkdsa1pXRnVJR052Ykc5eUlHUnBjM1JoYm1ObFhISmNiaUFxTDF4eVhHNWxlSEJ2Y25RZ1kyeGhjM01nUVdKemRISmhZM1JGZFdOc2FXUmxZVzRnWlhoMFpXNWtjeUJCWW5OMGNtRmpkRVJwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaUI3WEhKY2JpQWdJQ0JqWVd4amRXeGhkR1ZTWVhjb2NqRXNJR2N4TENCaU1Td2dZVEVzSUhJeUxDQm5NaXdnWWpJc0lHRXlLU0I3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnWkZJZ1BTQnlNaUF0SUhJeE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHUkhJRDBnWnpJZ0xTQm5NVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JrUWlBOUlHSXlJQzBnWWpFN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ1pFRWdQU0JoTWlBdElHRXhPMXh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJOWVhSb0xuTnhjblFvZEdocGN5NWZhMUlnS2lCa1VpQXFJR1JTSUNzZ2RHaHBjeTVmYTBjZ0tpQmtSeUFxSUdSSElDc2dkR2hwY3k1ZmEwSWdLaUJrUWlBcUlHUkNJQ3NnZEdocGN5NWZhMEVnS2lCa1FTQXFJR1JCS1R0Y2NseHVJQ0FnSUgxY2NseHVmVnh5WEc1bGVIQnZjblFnWTJ4aGMzTWdSWFZqYkdsa1pXRnVJR1Y0ZEdWdVpITWdRV0p6ZEhKaFkzUkZkV05zYVdSbFlXNGdlMXh5WEc0Z0lDQWdYM05sZEVSbFptRjFiSFJ6S0NrZ2UxeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgydFNJRDBnTVR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5clJ5QTlJREU3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmYTBJZ1BTQXhPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMnRCSUQwZ01UdGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNHZLaXBjY2x4dUlDb2dSWFZqYkdsa1pXRnVJR052Ykc5eUlHUnBjM1JoYm1ObElDaFNSMEpSZFdGdWRDQnRiMlJwWm1sallYUnBiMjRnZHlCQmJIQm9ZU2xjY2x4dUlDb3ZYSEpjYm1WNGNHOXlkQ0JqYkdGemN5QkZkV05zYVdSbFlXNUNWRGN3T1NCbGVIUmxibVJ6SUVGaWMzUnlZV04wUlhWamJHbGtaV0Z1SUh0Y2NseHVJQ0FnSUY5elpYUkVaV1poZFd4MGN5Z3BJSHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlyVWlBOUlGa3VVa1ZFTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJ0SElEMGdXUzVIVWtWRlRqdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXJRaUE5SUZrdVFreFZSVHRjY2x4dUlDQWdJQ0FnSUNBdkx5QlVUMFJQT2lCM2FHRjBJR2x6SUhSb1pTQmlaWE4wSUdOdlpXWm1hV05wWlc1MElHSmxiRzkzUDF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJ0QklEMGdNVHRjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzR2S2lwY2NseHVJQ29nUlhWamJHbGtaV0Z1SUdOdmJHOXlJR1JwYzNSaGJtTmxJQ2hTUjBKUmRXRnVkQ0J0YjJScFptbGpZWFJwYjI0Z2R5OXZJRUZzY0doaEtWeHlYRzRnS2k5Y2NseHVaWGh3YjNKMElHTnNZWE56SUVWMVkyeHBaR1ZoYmtKVU56QTVUbTlCYkhCb1lTQmxlSFJsYm1SeklFRmljM1J5WVdOMFJYVmpiR2xrWldGdUlIdGNjbHh1SUNBZ0lGOXpaWFJFWldaaGRXeDBjeWdwSUh0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5clVpQTlJRmt1VWtWRU8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgydEhJRDBnV1M1SFVrVkZUanRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlyUWlBOUlGa3VRa3hWUlR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5clFTQTlJREE3WEhKY2JpQWdJQ0I5WEhKY2JuMWNjbHh1THk4aklITnZkWEpqWlUxaGNIQnBibWRWVWt3OVpYVmpiR2xrWldGdUxtcHpMbTFoY0NJc0lpOHFLbHh5WEc0Z0tpQkFjSEpsYzJWeWRtVmNjbHh1SUNvZ1EyOXdlWEpwWjJoMElESXdNVFV0TWpBeE9DQkpaMjl5SUVKbGVtdHliM1p1ZVdsY2NseHVJQ29nUVd4c0lISnBaMmgwY3lCeVpYTmxjblpsWkM0Z0tFMUpWQ0JNYVdObGJuTmxaQ2xjY2x4dUlDcGNjbHh1SUNvZ2FYRXVkSE1nTFNCSmJXRm5aU0JSZFdGdWRHbDZZWFJwYjI0Z1RHbGljbUZ5ZVZ4eVhHNGdLaTljY2x4dVpYaHdiM0owSUhzZ1FXSnpkSEpoWTNSRWFYTjBZVzVqWlVOaGJHTjFiR0YwYjNJZ2ZTQm1jbTl0SUNjdUwyUnBjM1JoYm1ObFEyRnNZM1ZzWVhSdmNpYzdYSEpjYm1WNGNHOXlkQ0I3SUVOSlJUazBWR1Y0ZEdsc1pYTXNJRU5KUlRrMFIzSmhjR2hwWTBGeWRITWdmU0JtY205dElDY3VMMk5wWlRrMEp6dGNjbHh1Wlhod2IzSjBJSHNnUTBsRlJFVXlNREF3SUgwZ1puSnZiU0FuTGk5amFXVmtaVEl3TURBbk8xeHlYRzVsZUhCdmNuUWdleUJEVFdWMGNtbGpJSDBnWm5KdmJTQW5MaTlqYldWMGNtbGpKenRjY2x4dVpYaHdiM0owSUhzZ1FXSnpkSEpoWTNSRmRXTnNhV1JsWVc0c0lFVjFZMnhwWkdWaGJpd2dSWFZqYkdsa1pXRnVRbFEzTURsT2IwRnNjR2hoTENCRmRXTnNhV1JsWVc1Q1ZEY3dPU0I5SUdaeWIyMGdKeTR2WlhWamJHbGtaV0Z1Snp0Y2NseHVaWGh3YjNKMElIc2dRV0p6ZEhKaFkzUk5ZVzVvWVhSMFlXNHNJRTFoYm1oaGRIUmhiaXdnVFdGdWFHRjBkR0Z1UWxRM01Ea3NJRTFoYm1oaGRIUmhiazV2YlcxNVpHVWdmU0JtY205dElDY3VMMjFoYm1oaGRIUmhiaWM3WEhKY2JtVjRjRzl5ZENCN0lGQk9SMUYxWVc1MElIMGdabkp2YlNBbkxpOXdibWRSZFdGdWRDYzdYSEpjYmk4dkl5QnpiM1Z5WTJWTllYQndhVzVuVlZKTVBXbHVaR1Y0TG1wekxtMWhjQ0lzSWk4cUtseHlYRzRnS2lCQWNISmxjMlZ5ZG1WY2NseHVJQ29nUTI5d2VYSnBaMmgwSURJd01UVXRNakF4T0NCSloyOXlJRUpsZW10eWIzWnVlV2xjY2x4dUlDb2dRV3hzSUhKcFoyaDBjeUJ5WlhObGNuWmxaQzRnS0UxSlZDQk1hV05sYm5ObFpDbGNjbHh1SUNwY2NseHVJQ29nYldGdWFHRjBkR0Z1VG1WMVVYVmhiblF1ZEhNZ0xTQndZWEowSUc5bUlFbHRZV2RsSUZGMVlXNTBhWHBoZEdsdmJpQk1hV0p5WVhKNVhISmNiaUFxTDF4eVhHNXBiWEJ2Y25RZ2V5QkJZbk4wY21GamRFUnBjM1JoYm1ObFEyRnNZM1ZzWVhSdmNpQjlJR1p5YjIwZ0p5NHZaR2x6ZEdGdVkyVkRZV3hqZFd4aGRHOXlKenRjY2x4dWFXMXdiM0owSUhzZ1dTQjlJR1p5YjIwZ0p5NHVMMk52Ym5OMFlXNTBjeTlpZERjd09TYzdYSEpjYmk4cUtseHlYRzRnS2lCTllXNW9ZWFIwWVc0Z1pHbHpkR0Z1WTJVZ0tFNWxkVkYxWVc1MElHMXZaR2xtYVdOaGRHbHZiaWtnTFNCM0wyOGdjMUpIUWlCamIyVm1abWxqYVdWdWRITmNjbHh1SUNvdlhISmNibVY0Y0c5eWRDQmpiR0Z6Y3lCQlluTjBjbUZqZEUxaGJtaGhkSFJoYmlCbGVIUmxibVJ6SUVGaWMzUnlZV04wUkdsemRHRnVZMlZEWVd4amRXeGhkRzl5SUh0Y2NseHVJQ0FnSUdOaGJHTjFiR0YwWlZKaGR5aHlNU3dnWnpFc0lHSXhMQ0JoTVN3Z2NqSXNJR2N5TENCaU1pd2dZVElwSUh0Y2NseHVJQ0FnSUNBZ0lDQnNaWFFnWkZJZ1BTQnlNaUF0SUhJeE8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCa1J5QTlJR2N5SUMwZ1p6RTdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElHUkNJRDBnWWpJZ0xTQmlNVHRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdaRUVnUFNCaE1pQXRJR0V4TzF4eVhHNGdJQ0FnSUNBZ0lHbG1JQ2hrVWlBOElEQXBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHUlNJRDBnTUNBdElHUlNPMXh5WEc0Z0lDQWdJQ0FnSUdsbUlDaGtSeUE4SURBcFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUdSSElEMGdNQ0F0SUdSSE8xeHlYRzRnSUNBZ0lDQWdJR2xtSUNoa1FpQThJREFwWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1JDSUQwZ01DQXRJR1JDTzF4eVhHNGdJQ0FnSUNBZ0lHbG1JQ2hrUVNBOElEQXBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHUkJJRDBnTUNBdElHUkJPMXh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxsOXJVaUFxSUdSU0lDc2dkR2hwY3k1ZmEwY2dLaUJrUnlBcklIUm9hWE11WDJ0Q0lDb2daRUlnS3lCMGFHbHpMbDlyUVNBcUlHUkJPMXh5WEc0Z0lDQWdmVnh5WEc1OVhISmNibVY0Y0c5eWRDQmpiR0Z6Y3lCTllXNW9ZWFIwWVc0Z1pYaDBaVzVrY3lCQlluTjBjbUZqZEUxaGJtaGhkSFJoYmlCN1hISmNiaUFnSUNCZmMyVjBSR1ZtWVhWc2RITW9LU0I3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmYTFJZ1BTQXhPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMnRISUQwZ01UdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXJRaUE5SURFN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmEwRWdQU0F4TzF4eVhHNGdJQ0FnZlZ4eVhHNTlYSEpjYmk4cUtseHlYRzRnS2lCTllXNW9ZWFIwWVc0Z1pHbHpkR0Z1WTJVZ0tFNXZiVzE1WkdVZ2JXOWthV1pwWTJGMGFXOXVLVnh5WEc0Z0tpQm9kSFJ3Y3pvdkwyZHBkR2gxWWk1amIyMHZhV2R2Y2kxaVpYcHJjbTkyYm5rdmFXMWhaMlV0Y1hWaGJuUnBlbUYwYVc5dUwybHpjM1ZsY3k4MEkybHpjM1ZsWTI5dGJXVnVkQzB5TXpVeE5UVXpNakJjY2x4dUlDb3ZYSEpjYm1WNGNHOXlkQ0JqYkdGemN5Qk5ZVzVvWVhSMFlXNU9iMjF0ZVdSbElHVjRkR1Z1WkhNZ1FXSnpkSEpoWTNSTllXNW9ZWFIwWVc0Z2UxeHlYRzRnSUNBZ1gzTmxkRVJsWm1GMWJIUnpLQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJ0U0lEMGdNQzQwT1RnME8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgydEhJRDBnTUM0NE5qSTFPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMnRDSUQwZ01DNHlPVGM1TzF4eVhHNGdJQ0FnSUNBZ0lDOHZJRlJQUkU4NklIZG9ZWFFnYVhNZ2RHaGxJR0psYzNRZ1kyOWxabVpwWTJsbGJuUWdZbVZzYjNjL1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmEwRWdQU0F4TzF4eVhHNGdJQ0FnZlZ4eVhHNTlYSEpjYmk4cUtseHlYRzRnS2lCTllXNW9ZWFIwWVc0Z1pHbHpkR0Z1WTJVZ0tITlNSMElnWTI5bFptWnBZMmxsYm5SektWeHlYRzRnS2k5Y2NseHVaWGh3YjNKMElHTnNZWE56SUUxaGJtaGhkSFJoYmtKVU56QTVJR1Y0ZEdWdVpITWdRV0p6ZEhKaFkzUk5ZVzVvWVhSMFlXNGdlMXh5WEc0Z0lDQWdYM05sZEVSbFptRjFiSFJ6S0NrZ2UxeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgydFNJRDBnV1M1U1JVUTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZhMGNnUFNCWkxrZFNSVVZPTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJ0Q0lEMGdXUzVDVEZWRk8xeHlYRzRnSUNBZ0lDQWdJQzh2SUZSUFJFODZJSGRvWVhRZ2FYTWdkR2hsSUdKbGMzUWdZMjlsWm1acFkybGxiblFnWW1Wc2IzYy9YSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZhMEVnUFNBeE8xeHlYRzRnSUNBZ2ZWeHlYRzU5WEhKY2JpOHZJeUJ6YjNWeVkyVk5ZWEJ3YVc1blZWSk1QVzFoYm1oaGRIUmhiaTVxY3k1dFlYQWlMQ0l2S2lwY2NseHVJQ29nUUhCeVpYTmxjblpsWEhKY2JpQXFJRU52Y0hseWFXZG9kQ0F5TURFMUxUSXdNVGdnU1dkdmNpQkNaWHByY205MmJubHBYSEpjYmlBcUlFRnNiQ0J5YVdkb2RITWdjbVZ6WlhKMlpXUXVJQ2hOU1ZRZ1RHbGpaVzV6WldRcFhISmNiaUFxWEhKY2JpQXFJSEJ1WjFGMVlXNTBMblJ6SUMwZ2NHRnlkQ0J2WmlCSmJXRm5aU0JSZFdGdWRHbDZZWFJwYjI0Z1RHbGljbUZ5ZVZ4eVhHNGdLaTljY2x4dWFXMXdiM0owSUhzZ1FXSnpkSEpoWTNSRWFYTjBZVzVqWlVOaGJHTjFiR0YwYjNJZ2ZTQm1jbTl0SUNjdUwyUnBjM1JoYm1ObFEyRnNZM1ZzWVhSdmNpYzdYSEpjYmk4cUtseHlYRzRnS2lCVVQwUlBPaUJqYUdWamF5QnhkV0ZzYVhSNUlHOW1JSFJvYVhNZ1pHbHpkR0Z1WTJVZ1pYRjFZWFJwYjI1Y2NseHVJQ29nVkU5RVR6b2dZWE5ySUdGMWRHaHZjaUJtYjNJZ2RYTmhaMlVnY21sbmFIUnpYSEpjYmlBcUlIUmhhMlZ1SUdaeWIyMDZYSEpjYmlBcUlIdEFiR2x1YXlCb2RIUndPaTh2YzNSaFkydHZkbVZ5Wm14dmR5NWpiMjB2Y1hWbGMzUnBiMjV6THpRM05UUTFNRFl2WTI5c2IzSXRjMmx0YVd4aGNtbDBlUzFrYVhOMFlXNWpaUzFwYmkxeVoySmhMV052Ykc5eUxYTndZV05sTHpnM09UWTROamNqT0RjNU5qZzJOMzFjY2x4dUlDb2dlMEJzYVc1cklHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOXdiM0p1Wld3dmNHNW5jWFZoYm5RdllteHZZaTlqWXpNNVlqUTNOems1WVRkbVpqSmxaakUzWWpVeU9XWTVOREUxWm1ZMlpUWmlNakV6WWpobUwyeHBZaTl3WVcwdWFDTk1NVFE0ZlZ4eVhHNGdLaTljY2x4dVpYaHdiM0owSUdOc1lYTnpJRkJPUjFGMVlXNTBJR1Y0ZEdWdVpITWdRV0p6ZEhKaFkzUkVhWE4wWVc1alpVTmhiR04xYkdGMGIzSWdlMXh5WEc0Z0lDQWdMeW9xWEhKY2JpQWdJQ0FnS2lCQmRYUm9iM0luY3lCamIyMXRaVzUwYzF4eVhHNGdJQ0FnSUNvZ2NIaGZZaTV5WjJJZ1BTQndlQzV5WjJJZ0t5QXdLaWd4TFhCNExtRXBJQzh2SUdKc1pXNWtJSEI0SUc5dUlHSnNZV05yWEhKY2JpQWdJQ0FnS2lCd2VGOWlMbUVnSUNBOUlIQjRMbUVnSUNBcklERXFLREV0Y0hndVlTbGNjbHh1SUNBZ0lDQXFJSEI0WDNjdWNtZGlJRDBnY0hndWNtZGlJQ3NnTVNvb01TMXdlQzVoS1NBdkx5QmliR1Z1WkNCd2VDQnZiaUIzYUdsMFpWeHlYRzRnSUNBZ0lDb2djSGhmZHk1aElDQWdQU0J3ZUM1aElDQWdLeUF4S2lneExYQjRMbUVwWEhKY2JpQWdJQ0FnS2x4eVhHNGdJQ0FnSUNvZ2NIaGZZaTV5WjJJZ1BTQndlQzV5WjJJZ0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUdScFptWmxjbVZ1WTJVZ2MyRnRaU0JoY3lCcGJpQnZjR0Z4ZFdVZ1VrZENYSEpjYmlBZ0lDQWdLaUJ3ZUY5aUxtRWdJQ0E5SURGY2NseHVJQ0FnSUNBcUlIQjRYM2N1Y21kaUlEMGdjSGd1Y21kaUlDMGdjSGd1WVNBZ0lDQWdJQ0F2THlCa2FXWm1aWEpsYm1ObElITnBiWEJzYVdacFpYTWdkRzhnWm05eWJYVnNZU0JpWld4dmQxeHlYRzRnSUNBZ0lDb2djSGhmZHk1aElDQWdQU0F4WEhKY2JpQWdJQ0FnS2x4eVhHNGdJQ0FnSUNvZ0tIQjRMbkpuWWlBdElIQjRMbUVwSUMwZ0tIQjVMbkpuWWlBdElIQjVMbUVwWEhKY2JpQWdJQ0FnS2lBb2NIZ3VjbWRpSUMwZ2NIa3VjbWRpS1NBcklDaHdlUzVoSUMwZ2NIZ3VZU2xjY2x4dUlDQWdJQ0FxWEhKY2JpQWdJQ0FnS2k5Y2NseHVJQ0FnSUdOaGJHTjFiR0YwWlZKaGR5aHlNU3dnWnpFc0lHSXhMQ0JoTVN3Z2NqSXNJR2N5TENCaU1pd2dZVElwSUh0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCaGJIQm9ZWE1nUFNBb1lUSWdMU0JoTVNrZ0tpQjBhR2x6TGw5M2FHbDBaVkJ2YVc1MExtRTdYSEpjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdVgyTnZiRzl5WkdsbVptVnlaVzVqWlVOb0tISXhJQ29nZEdocGN5NWZkMmhwZEdWUWIybHVkQzV5TENCeU1pQXFJSFJvYVhNdVgzZG9hWFJsVUc5cGJuUXVjaXdnWVd4d2FHRnpLU0FyWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyTnZiRzl5WkdsbVptVnlaVzVqWlVOb0tHY3hJQ29nZEdocGN5NWZkMmhwZEdWUWIybHVkQzVuTENCbk1pQXFJSFJvYVhNdVgzZG9hWFJsVUc5cGJuUXVaeXdnWVd4d2FHRnpLU0FyWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyTnZiRzl5WkdsbVptVnlaVzVqWlVOb0tHSXhJQ29nZEdocGN5NWZkMmhwZEdWUWIybHVkQzVpTENCaU1pQXFJSFJvYVhNdVgzZG9hWFJsVUc5cGJuUXVZaXdnWVd4d2FHRnpLVHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJRjlqYjJ4dmNtUnBabVpsY21WdVkyVkRhQ2g0TENCNUxDQmhiSEJvWVhNcElIdGNjbHh1SUNBZ0lDQWdJQ0F2THlCdFlYaHBiWFZ0SUc5bUlHTm9ZVzV1Wld3Z1lteGxibVJsWkNCdmJpQjNhR2wwWlN3Z1lXNWtJR0pzWlc1a1pXUWdiMjRnWW14aFkydGNjbHh1SUNBZ0lDQWdJQ0F2THlCd2NtVnRkV3gwYVhCc2FXVmtJR0ZzY0doaElHRnVaQ0JpWVdOclozSnZkVzVrY3lBd0x6RWdjMmh2Y25SbGJpQjBhR1VnWm05eWJYVnNZVnh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR0pzWVdOcklEMGdlQ0F0SUhrN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2QyaHBkR1VnUFNCaWJHRmpheUFySUdGc2NHaGhjenRjY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWW14aFkyc2dLaUJpYkdGamF5QXJJSGRvYVhSbElDb2dkMmhwZEdVN1hISmNiaUFnSUNCOVhISmNiaUFnSUNCZmMyVjBSR1ZtWVhWc2RITW9LU0I3SUgxY2NseHVmVnh5WEc0dkx5TWdjMjkxY21ObFRXRndjR2x1WjFWU1REMXdibWRSZFdGdWRDNXFjeTV0WVhBaUxDSXZLaXBjY2x4dUlDb2dRSEJ5WlhObGNuWmxYSEpjYmlBcUlFTnZjSGx5YVdkb2RDQXlNREUxTFRJd01UZ2dTV2R2Y2lCQ1pYcHJjbTkyYm5scFhISmNiaUFxSUVGc2JDQnlhV2RvZEhNZ2NtVnpaWEoyWldRdUlDaE5TVlFnVEdsalpXNXpaV1FwWEhKY2JpQXFYSEpjYmlBcUlHbHhMblJ6SUMwZ1NXMWhaMlVnVVhWaGJuUnBlbUYwYVc5dUlFeHBZbkpoY25sY2NseHVJQ292WEhKY2JtbHRjRzl5ZENBcUlHRnpJR052Ym5OMFlXNTBjeUJtY205dElDY3VMMk52Ym5OMFlXNTBjeWM3WEhKY2JtbHRjRzl5ZENBcUlHRnpJR052Ym5abGNuTnBiMjRnWm5KdmJTQW5MaTlqYjI1MlpYSnphVzl1Snp0Y2NseHVhVzF3YjNKMElDb2dZWE1nWkdsemRHRnVZMlVnWm5KdmJTQW5MaTlrYVhOMFlXNWpaU2M3WEhKY2JtbHRjRzl5ZENBcUlHRnpJSEJoYkdWMGRHVWdabkp2YlNBbkxpOXdZV3hsZEhSbEp6dGNjbHh1YVcxd2IzSjBJQ29nWVhNZ2FXMWhaMlVnWm5KdmJTQW5MaTlwYldGblpTYzdYSEpjYm1sdGNHOXlkQ0FxSUdGeklIRjFZV3hwZEhrZ1puSnZiU0FuTGk5eGRXRnNhWFI1Snp0Y2NseHVhVzF3YjNKMElDb2dZWE1nZFhScGJITWdabkp2YlNBbkxpOTFkR2xzY3ljN1hISmNibVY0Y0c5eWRDQjdJR0oxYVd4a1VHRnNaWFIwWlN3Z1luVnBiR1JRWVd4bGRIUmxVM2x1WXl3Z1lYQndiSGxRWVd4bGRIUmxMQ0JoY0hCc2VWQmhiR1YwZEdWVGVXNWpMQ0I5SUdaeWIyMGdKeTR2WW1GemFXTkJVRWtuTzF4eVhHNWxlSEJ2Y25RZ2V5QmpiMjV6ZEdGdWRITXNJR052Ym5abGNuTnBiMjRzSUdScGMzUmhibU5sTENCd1lXeGxkSFJsTENCcGJXRm5aU3dnY1hWaGJHbDBlU3dnZFhScGJITXNJSDA3WEhKY2JpOHZJeUJ6YjNWeVkyVk5ZWEJ3YVc1blZWSk1QV2x0WVdkbExYRXVhbk11YldGd0lpd2lMeW9xWEhKY2JpQXFJRUJ3Y21WelpYSjJaVnh5WEc0Z0tpQkRiM0I1Y21sbmFIUWdNakF4TlMweU1ERTRJRWxuYjNJZ1FtVjZhM0p2ZG01NWFWeHlYRzRnS2lCQmJHd2djbWxuYUhSeklISmxjMlZ5ZG1Wa0xpQW9UVWxVSUV4cFkyVnVjMlZrS1Z4eVhHNGdLbHh5WEc0Z0tpQmthWFJvWlhKRmNuSnZja1JwWm1aMWMybHZia0Z5Y21GNUxuUnpJQzBnY0dGeWRDQnZaaUJKYldGblpTQlJkV0Z1ZEdsNllYUnBiMjRnVEdsaWNtRnllVnh5WEc0Z0tpOWNjbHh1YVcxd2IzSjBJSHNnUVdKemRISmhZM1JKYldGblpWRjFZVzUwYVhwbGNpQjlJR1p5YjIwZ0p5NHZhVzFoWjJWUmRXRnVkR2w2WlhJbk8xeHlYRzVwYlhCdmNuUWdleUJRYjJsdWRDQjlJR1p5YjIwZ0p5NHVMM1YwYVd4ekwzQnZhVzUwSnp0Y2NseHVhVzF3YjNKMElIc2dhVzVTWVc1blpUQjBiekkxTlZKdmRXNWtaV1FnZlNCbWNtOXRJQ2N1TGk5MWRHbHNjeTloY21sMGFHMWxkR2xqSnp0Y2NseHVhVzF3YjNKMElIc2dVSEp2WjNKbGMzTlVjbUZqYTJWeUlIMGdabkp2YlNBbkxpNHZkWFJwYkhNdmNISnZaM0psYzNOVWNtRmphMlZ5Snp0Y2NseHVMeThnVkU5RVR6b2dhWE1nYVhRZ2RHaGxJR0psYzNRZ2JtRnRaU0JtYjNJZ2RHaHBjeUJsYm5WdElGd2lhMlZ5Ym1Wc1hDSS9YSEpjYm1WNGNHOXlkQ0IyWVhJZ1JYSnliM0pFYVdabWRYTnBiMjVCY25KaGVVdGxjbTVsYkR0Y2NseHVLR1oxYm1OMGFXOXVJQ2hGY25KdmNrUnBabVoxYzJsdmJrRnljbUY1UzJWeWJtVnNLU0I3WEhKY2JpQWdJQ0JGY25KdmNrUnBabVoxYzJsdmJrRnljbUY1UzJWeWJtVnNXMFZ5Y205eVJHbG1ablZ6YVc5dVFYSnlZWGxMWlhKdVpXeGJYQ0pHYkc5NVpGTjBaV2x1WW1WeVoxd2lYU0E5SURCZElEMGdYQ0pHYkc5NVpGTjBaV2x1WW1WeVoxd2lPMXh5WEc0Z0lDQWdSWEp5YjNKRWFXWm1kWE5wYjI1QmNuSmhlVXRsY201bGJGdEZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVTMlZ5Ym1Wc1cxd2lSbUZzYzJWR2JHOTVaRk4wWldsdVltVnlaMXdpWFNBOUlERmRJRDBnWENKR1lXeHpaVVpzYjNsa1UzUmxhVzVpWlhKblhDSTdYSEpjYmlBZ0lDQkZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVTMlZ5Ym1Wc1cwVnljbTl5UkdsbVpuVnphVzl1UVhKeVlYbExaWEp1Wld4YlhDSlRkSFZqYTJsY0lsMGdQU0F5WFNBOUlGd2lVM1IxWTJ0cFhDSTdYSEpjYmlBZ0lDQkZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVTMlZ5Ym1Wc1cwVnljbTl5UkdsbVpuVnphVzl1UVhKeVlYbExaWEp1Wld4YlhDSkJkR3RwYm5OdmJsd2lYU0E5SUROZElEMGdYQ0pCZEd0cGJuTnZibHdpTzF4eVhHNGdJQ0FnUlhKeWIzSkVhV1ptZFhOcGIyNUJjbkpoZVV0bGNtNWxiRnRGY25KdmNrUnBabVoxYzJsdmJrRnljbUY1UzJWeWJtVnNXMXdpU21GeWRtbHpYQ0pkSUQwZ05GMGdQU0JjSWtwaGNuWnBjMXdpTzF4eVhHNGdJQ0FnUlhKeWIzSkVhV1ptZFhOcGIyNUJjbkpoZVV0bGNtNWxiRnRGY25KdmNrUnBabVoxYzJsdmJrRnljbUY1UzJWeWJtVnNXMXdpUW5WeWEyVnpYQ0pkSUQwZ05WMGdQU0JjSWtKMWNtdGxjMXdpTzF4eVhHNGdJQ0FnUlhKeWIzSkVhV1ptZFhOcGIyNUJjbkpoZVV0bGNtNWxiRnRGY25KdmNrUnBabVoxYzJsdmJrRnljbUY1UzJWeWJtVnNXMXdpVTJsbGNuSmhYQ0pkSUQwZ05sMGdQU0JjSWxOcFpYSnlZVndpTzF4eVhHNGdJQ0FnUlhKeWIzSkVhV1ptZFhOcGIyNUJjbkpoZVV0bGNtNWxiRnRGY25KdmNrUnBabVoxYzJsdmJrRnljbUY1UzJWeWJtVnNXMXdpVkhkdlUybGxjbkpoWENKZElEMGdOMTBnUFNCY0lsUjNiMU5wWlhKeVlWd2lPMXh5WEc0Z0lDQWdSWEp5YjNKRWFXWm1kWE5wYjI1QmNuSmhlVXRsY201bGJGdEZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVTMlZ5Ym1Wc1cxd2lVMmxsY25KaFRHbDBaVndpWFNBOUlEaGRJRDBnWENKVGFXVnljbUZNYVhSbFhDSTdYSEpjYm4wcEtFVnljbTl5UkdsbVpuVnphVzl1UVhKeVlYbExaWEp1Wld3Z2ZId2dLRVZ5Y205eVJHbG1ablZ6YVc5dVFYSnlZWGxMWlhKdVpXd2dQU0I3ZlNrcE8xeHlYRzR2THlCb2RIUndPaTh2ZDNkM0xuUmhibTVsY21obGJHeGhibVF1WTI5dEx6UTJOakF2WkdsMGFHVnlhVzVuTFdWc1pYWmxiaTFoYkdkdmNtbDBhRzF6TFhOdmRYSmpaUzFqYjJSbEwxeHlYRzVsZUhCdmNuUWdZMnhoYzNNZ1JYSnliM0pFYVdabWRYTnBiMjVCY25KaGVTQmxlSFJsYm1SeklFRmljM1J5WVdOMFNXMWhaMlZSZFdGdWRHbDZaWElnZTF4eVhHNGdJQ0FnWTI5dWMzUnlkV04wYjNJb1kyOXNiM0pFYVhOMFlXNWpaVU5oYkdOMWJHRjBiM0lzSUd0bGNtNWxiQ3dnYzJWeWNHVnVkR2x1WlNBOUlIUnlkV1VzSUcxcGJtbHRkVzFEYjJ4dmNrUnBjM1JoYm1ObFZHOUVhWFJvWlhJZ1BTQXdMQ0JqWVd4amRXeGhkR1ZGY25KdmNreHBhMlZIU1UxUUlEMGdabUZzYzJVcElIdGNjbHh1SUNBZ0lDQWdJQ0J6ZFhCbGNpZ3BPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYM05sZEV0bGNtNWxiQ2hyWlhKdVpXd3BPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMlJwYzNSaGJtTmxJRDBnWTI5c2IzSkVhWE4wWVc1alpVTmhiR04xYkdGMGIzSTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZiV2x1UTI5c2IzSkVhWE4wWVc1alpTQTlJRzFwYm1sdGRXMURiMnh2Y2tScGMzUmhibU5sVkc5RWFYUm9aWEk3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmYzJWeWNHVnVkR2x1WlNBOUlITmxjbkJsYm5ScGJtVTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZMkZzWTNWc1lYUmxSWEp5YjNKTWFXdGxSMGxOVUNBOUlHTmhiR04xYkdGMFpVVnljbTl5VEdsclpVZEpUVkE3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0F2S2lwY2NseHVJQ0FnSUNBcUlHRmtZWEIwWldRZ1puSnZiU0JvZEhSd09pOHZhbk5pYVc0dVkyOXRMMmxZYjJaSmFta3ZNaTlsWkdsMElHSjVJRkJCUlhwY2NseHVJQ0FnSUNBcUlHWnBlR1ZrSUhabGNuTnBiMjR1SUdsMElHUnZaWE51SjNRZ2RYTmxJR2x0WVdkbElIQnBlR1ZzY3lCaGN5Qmxjbkp2Y2lCemRHOXlZV2RsTENCaGJITnZJR2wwSUdSdlpYTnVKM1FnYUdGMlpTQXdMak1nS3lBd0xqTWdLeUF3TGpNZ0t5QXdMak1nUFNBd0lHVnljbTl5WEhKY2JpQWdJQ0FnS2lCTmRYUmhkR1Z6SUhCdmFXNTBRMjl1ZEdGcGJtVnlYSEpjYmlBZ0lDQWdLaTljY2x4dUlDQWdJQ3B4ZFdGdWRHbDZaU2h3YjJsdWRFTnZiblJoYVc1bGNpd2djR0ZzWlhSMFpTa2dlMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSEJ2YVc1MFFYSnlZWGtnUFNCd2IybHVkRU52Ym5SaGFXNWxjaTVuWlhSUWIybHVkRUZ5Y21GNUtDazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdiM0pwWjJsdVlXeFFiMmx1ZENBOUlHNWxkeUJRYjJsdWRDZ3BPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSGRwWkhSb0lEMGdjRzlwYm5SRGIyNTBZV2x1WlhJdVoyVjBWMmxrZEdnb0tUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQm9aV2xuYUhRZ1BTQndiMmx1ZEVOdmJuUmhhVzVsY2k1blpYUklaV2xuYUhRb0tUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQmxjbkp2Y2t4cGJtVnpJRDBnVzEwN1hISmNiaUFnSUNBZ0lDQWdiR1YwSUdScGNpQTlJREU3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJRzFoZUVWeWNtOXlUR2x1WlhNZ1BTQXhPMXh5WEc0Z0lDQWdJQ0FnSUM4dklHbHVhWFJwWVd3Z1pYSnliM0lnYkdsdVpYTWdLRzUxYldKbGNpQnBjeUIwWVd0bGJpQm1jbTl0SUdScGRHaGxjbWx1WnlCclpYSnVaV3dwWEhKY2JpQWdJQ0FnSUNBZ1ptOXlJQ2hqYjI1emRDQnJaWEp1Wld3Z2IyWWdkR2hwY3k1ZmEyVnlibVZzS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR3RsY201bGJFVnljbTl5VEdsdVpYTWdQU0JyWlhKdVpXeGJNbDBnS3lBeE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9iV0Y0UlhKeWIzSk1hVzVsY3lBOElHdGxjbTVsYkVWeWNtOXlUR2x1WlhNcFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRZWGhGY25KdmNreHBibVZ6SUQwZ2EyVnlibVZzUlhKeWIzSk1hVzVsY3p0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnWm05eUlDaHNaWFFnYVNBOUlEQTdJR2tnUENCdFlYaEZjbkp2Y2t4cGJtVnpPeUJwS3lzcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVmWm1sc2JFVnljbTl5VEdsdVpTaGxjbkp2Y2t4cGJtVnpXMmxkSUQwZ1cxMHNJSGRwWkhSb0tUdGNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnZEhKaFkydGxjaUE5SUc1bGR5QlFjbTluY21WemMxUnlZV05yWlhJb2FHVnBaMmgwTENBNU9TazdYSEpjYmlBZ0lDQWdJQ0FnWm05eUlDaHNaWFFnZVNBOUlEQTdJSGtnUENCb1pXbG5hSFE3SUhrckt5a2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZEhKaFkydGxjaTV6YUc5MWJHUk9iM1JwWm5rb2VTa3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhscFpXeGtJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQndjbTluY21WemN6b2dkSEpoWTJ0bGNpNXdjbTluY21WemN5eGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdMeThnWVd4M1lYbHpJSE5sY25CbGJuUnBibVZjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hSb2FYTXVYM05sY25CbGJuUnBibVVwWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCa2FYSWdQU0JrYVhJZ0tpQXRNVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2JHNXBJRDBnZVNBcUlIZHBaSFJvTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQjRVM1JoY25RZ1BTQmthWElnUFQwOUlERWdQeUF3SURvZ2QybGtkR2dnTFNBeE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0I0Ulc1a0lEMGdaR2x5SUQwOVBTQXhJRDhnZDJsa2RHZ2dPaUF0TVR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z1kzbGpiR2xqSUhOb2FXWjBJSGRwZEdnZ1pYSmhjMmx1WjF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOW1hV3hzUlhKeWIzSk1hVzVsS0dWeWNtOXlUR2x1WlhOYk1GMHNJSGRwWkhSb0tUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdWRTlFVHpvZ2QyaDVJR2wwSUdseklHNWxaV1JsWkNCMGJ5QmpZWE4wSUhSNWNHVnpJR2hsY21VL1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdWeWNtOXlUR2x1WlhNdWNIVnphQ2hsY25KdmNreHBibVZ6TG5Ob2FXWjBLQ2twTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmxjbkp2Y2t4cGJtVWdQU0JsY25KdmNreHBibVZ6V3pCZE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCbWIzSWdLR3hsZENCNElEMGdlRk4wWVhKMExDQnBaSGdnUFNCc2Jta2dLeUI0VTNSaGNuUTdJSGdnSVQwOUlIaEZibVE3SUhnZ0t6MGdaR2x5TENCcFpIZ2dLejBnWkdseUtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F2THlCSmJXRm5aU0J3YVhobGJGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2NHOXBiblFnUFNCd2IybHVkRUZ5Y21GNVcybGtlRjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QnZjbWxuYVc1aGJGQnZhVzUwSUQwZ2JtVjNJRlYwYVd4ekxsQnZhVzUwS0Nrc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCbGNuSnZjaUE5SUdWeWNtOXlUR2x1WlZ0NFhUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzl5YVdkcGJtRnNVRzlwYm5RdVpuSnZiU2h3YjJsdWRDazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmpiM0p5WldOMFpXUlFiMmx1ZENBOUlGQnZhVzUwTG1OeVpXRjBaVUo1VWtkQ1FTaHBibEpoYm1kbE1IUnZNalUxVW05MWJtUmxaQ2h3YjJsdWRDNXlJQ3NnWlhKeWIzSmJNRjBwTENCcGJsSmhibWRsTUhSdk1qVTFVbTkxYm1SbFpDaHdiMmx1ZEM1bklDc2daWEp5YjNKYk1WMHBMQ0JwYmxKaGJtZGxNSFJ2TWpVMVVtOTFibVJsWkNod2IybHVkQzVpSUNzZ1pYSnliM0piTWwwcExDQnBibEpoYm1kbE1IUnZNalUxVW05MWJtUmxaQ2h3YjJsdWRDNWhJQ3NnWlhKeWIzSmJNMTBwS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDOHZJRkpsWkhWalpXUWdjR2w0Wld4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhCaGJHVjBkR1ZRYjJsdWRDQTlJSEJoYkdWMGRHVXVaMlYwVG1WaGNtVnpkRU52Ykc5eUtIUm9hWE11WDJScGMzUmhibU5sTENCamIzSnlaV04wWldSUWIybHVkQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2IybHVkQzVtY205dEtIQmhiR1YwZEdWUWIybHVkQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QmthWFJvWlhKcGJtY2djM1J5Wlc1bmRHaGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoMGFHbHpMbDl0YVc1RGIyeHZja1JwYzNSaGJtTmxLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ1pHbHpkQ0E5SUhSb2FYTXVYMlJwYzNSaGJtTmxMbU5oYkdOMWJHRjBaVTV2Y20xaGJHbDZaV1FvY0c5cGJuUXNJSEJoYkdWMGRHVlFiMmx1ZENrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHUnBjM1FnUENCMGFHbHpMbDl0YVc1RGIyeHZja1JwYzNSaGJtTmxLVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1MGFXNTFaVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDOHZJRU52YlhCdmJtVnVkQ0JrYVhOMFlXNWpaVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHVnlPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHVm5PMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHVmlPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHVmhPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIUm9hWE11WDJOaGJHTjFiR0YwWlVWeWNtOXlUR2xyWlVkSlRWQXBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxjaUE5SUdOdmNuSmxZM1JsWkZCdmFXNTBMbklnTFNCd1lXeGxkSFJsVUc5cGJuUXVjanRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxaeUE5SUdOdmNuSmxZM1JsWkZCdmFXNTBMbWNnTFNCd1lXeGxkSFJsVUc5cGJuUXVaenRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxZaUE5SUdOdmNuSmxZM1JsWkZCdmFXNTBMbUlnTFNCd1lXeGxkSFJsVUc5cGJuUXVZanRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxZU0E5SUdOdmNuSmxZM1JsWkZCdmFXNTBMbUVnTFNCd1lXeGxkSFJsVUc5cGJuUXVZVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHVnNjMlVnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1Z5SUQwZ2IzSnBaMmx1WVd4UWIybHVkQzV5SUMwZ2NHRnNaWFIwWlZCdmFXNTBMbkk3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdaV2NnUFNCdmNtbG5hVzVoYkZCdmFXNTBMbWNnTFNCd1lXeGxkSFJsVUc5cGJuUXVaenRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxZaUE5SUc5eWFXZHBibUZzVUc5cGJuUXVZaUF0SUhCaGJHVjBkR1ZRYjJsdWRDNWlPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHVmhJRDBnYjNKcFoybHVZV3hRYjJsdWRDNWhJQzBnY0dGc1pYUjBaVkJ2YVc1MExtRTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JrVTNSaGNuUWdQU0JrYVhJZ1BUMDlJREVnUHlBd0lEb2dkR2hwY3k1ZmEyVnlibVZzTG14bGJtZDBhQ0F0SURFN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCa1JXNWtJRDBnWkdseUlEMDlQU0F4SUQ4Z2RHaHBjeTVmYTJWeWJtVnNMbXhsYm1kMGFDQTZJQzB4TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJR1JUZEdGeWREc2dhU0FoUFQwZ1pFVnVaRHNnYVNBclBTQmthWElwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQjRNU0E5SUhSb2FYTXVYMnRsY201bGJGdHBYVnN4WFNBcUlHUnBjanRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCNU1TQTlJSFJvYVhNdVgydGxjbTVsYkZ0cFhWc3lYVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZURFZ0t5QjRJRDQ5SURBZ0ppWWdlREVnS3lCNElEd2dkMmxrZEdnZ0ppWWdlVEVnS3lCNUlENDlJREFnSmlZZ2VURWdLeUI1SUR3Z2FHVnBaMmgwS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdRZ1BTQjBhR2x6TGw5clpYSnVaV3hiYVYxYk1GMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHVWdQU0JsY25KdmNreHBibVZ6VzNreFhWdDRNU0FySUhoZE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxXekJkSUQwZ1pWc3dYU0FySUdWeUlDb2daRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWlZzeFhTQTlJR1ZiTVYwZ0t5QmxaeUFxSUdRN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHVmJNbDBnUFNCbFd6SmRJQ3NnWldJZ0tpQmtPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JsV3pOZElEMGdaVnN6WFNBcklHVmhJQ29nWkR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnZVdsbGJHUWdlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQndiMmx1ZEVOdmJuUmhhVzVsY2l4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY0hKdlozSmxjM002SURFd01DeGNjbHh1SUNBZ0lDQWdJQ0I5TzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnWDJacGJHeEZjbkp2Y2t4cGJtVW9aWEp5YjNKTWFXNWxMQ0IzYVdSMGFDa2dlMXh5WEc0Z0lDQWdJQ0FnSUM4dklITm9jbWx1YTF4eVhHNGdJQ0FnSUNBZ0lHbG1JQ2hsY25KdmNreHBibVV1YkdWdVozUm9JRDRnZDJsa2RHZ3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdaWEp5YjNKTWFXNWxMbXhsYm1kMGFDQTlJSGRwWkhSb08xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBdkx5QnlaWFZ6WlNCbGVHbHpkR2x1WnlCaGNuSmhlWE5jY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JzSUQwZ1pYSnliM0pNYVc1bExteGxibWQwYUR0Y2NseHVJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTURzZ2FTQThJR3c3SUdrckt5a2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCbGNuSnZjaUE5SUdWeWNtOXlUR2x1WlZ0cFhUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1pYSnliM0piTUYwZ1BTQmxjbkp2Y2xzeFhTQTlJR1Z5Y205eVd6SmRJRDBnWlhKeWIzSmJNMTBnUFNBd08xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBdkx5QmpjbVZoZEdVZ2JXbHpjMmx1WnlCaGNuSmhlWE5jY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCcElEMGdiRHNnYVNBOElIZHBaSFJvT3lCcEt5c3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdaWEp5YjNKTWFXNWxXMmxkSUQwZ1d6QXVNQ3dnTUM0d0xDQXdMakFzSURBdU1GMDdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnWDNObGRFdGxjbTVsYkNoclpYSnVaV3dwSUh0Y2NseHVJQ0FnSUNBZ0lDQnpkMmwwWTJnZ0tHdGxjbTVsYkNrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCallYTmxJRVZ5Y205eVJHbG1ablZ6YVc5dVFYSnlZWGxMWlhKdVpXd3VSbXh2ZVdSVGRHVnBibUpsY21jNlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5clpYSnVaV3dnUFNCYlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pjZ0x5QXhOaXdnTVN3Z01GMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1d6TWdMeUF4Tml3Z0xURXNJREZkTEZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRnMxSUM4Z01UWXNJREFzSURGZExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUZzeElDOGdNVFlzSURFc0lERmRMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHSnlaV0ZyTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqWVhObElFVnljbTl5UkdsbVpuVnphVzl1UVhKeVlYbExaWEp1Wld3dVJtRnNjMlZHYkc5NVpGTjBaV2x1WW1WeVp6cGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgydGxjbTVsYkNBOUlGdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk15QXZJRGdzSURFc0lEQmRMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGc3pJQzhnT0N3Z01Dd2dNVjBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdXeklnTHlBNExDQXhMQ0F4WFN4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JpY21WaGF6dGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyRnpaU0JGY25KdmNrUnBabVoxYzJsdmJrRnljbUY1UzJWeWJtVnNMbE4wZFdOcmFUcGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgydGxjbTVsYkNBOUlGdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk9DQXZJRFF5TENBeExDQXdYU3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmJOQ0F2SURReUxDQXlMQ0F3WFN4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JiTWlBdklEUXlMQ0F0TWl3Z01WMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1d6UWdMeUEwTWl3Z0xURXNJREZkTEZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRnM0SUM4Z05ESXNJREFzSURGZExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUZzMElDOGdORElzSURFc0lERmRMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGc3lJQzhnTkRJc0lESXNJREZkTEZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRnN4SUM4Z05ESXNJQzB5TENBeVhTeGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk1pQXZJRFF5TENBdE1Td2dNbDBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdXelFnTHlBME1pd2dNQ3dnTWwwc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pJZ0x5QTBNaXdnTVN3Z01sMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1d6RWdMeUEwTWl3Z01pd2dNbDBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCZE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdSWEp5YjNKRWFXWm1kWE5wYjI1QmNuSmhlVXRsY201bGJDNUJkR3RwYm5OdmJqcGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgydGxjbTVsYkNBOUlGdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk1TQXZJRGdzSURFc0lEQmRMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGc3hJQzhnT0N3Z01pd2dNRjBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdXekVnTHlBNExDQXRNU3dnTVYwc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pFZ0x5QTRMQ0F3TENBeFhTeGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk1TQXZJRGdzSURFc0lERmRMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGc3hJQzhnT0N3Z01Dd2dNbDBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCZE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdSWEp5YjNKRWFXWm1kWE5wYjI1QmNuSmhlVXRsY201bGJDNUtZWEoyYVhNNlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5clpYSnVaV3dnUFNCYlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pjZ0x5QTBPQ3dnTVN3Z01GMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1d6VWdMeUEwT0N3Z01pd2dNRjBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdXek1nTHlBME9Dd2dMVElzSURGZExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUZzMUlDOGdORGdzSUMweExDQXhYU3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmJOeUF2SURRNExDQXdMQ0F4WFN4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JiTlNBdklEUTRMQ0F4TENBeFhTeGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk15QXZJRFE0TENBeUxDQXhYU3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmJNU0F2SURRNExDQXRNaXdnTWwwc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pNZ0x5QTBPQ3dnTFRFc0lESmRMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGczFJQzhnTkRnc0lEQXNJREpkTEZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRnN6SUM4Z05EZ3NJREVzSURKZExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUZzeElDOGdORGdzSURJc0lESmRMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHSnlaV0ZyTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqWVhObElFVnljbTl5UkdsbVpuVnphVzl1UVhKeVlYbExaWEp1Wld3dVFuVnlhMlZ6T2x4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVmYTJWeWJtVnNJRDBnVzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRnM0SUM4Z016SXNJREVzSURCZExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUZzMElDOGdNeklzSURJc0lEQmRMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGc3lJQzhnTXpJc0lDMHlMQ0F4WFN4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JiTkNBdklETXlMQ0F0TVN3Z01WMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1d6Z2dMeUF6TWl3Z01Dd2dNVjBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdXelFnTHlBek1pd2dNU3dnTVYwc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pJZ0x5QXpNaXdnTWl3Z01WMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR05oYzJVZ1JYSnliM0pFYVdabWRYTnBiMjVCY25KaGVVdGxjbTVsYkM1VGFXVnljbUU2WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDlyWlhKdVpXd2dQU0JiWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdXelVnTHlBek1pd2dNU3dnTUYwc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pNZ0x5QXpNaXdnTWl3Z01GMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1d6SWdMeUF6TWl3Z0xUSXNJREZkTEZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRnMwSUM4Z016SXNJQzB4TENBeFhTeGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk5TQXZJRE15TENBd0xDQXhYU3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmJOQ0F2SURNeUxDQXhMQ0F4WFN4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JiTWlBdklETXlMQ0F5TENBeFhTeGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk1pQXZJRE15TENBdE1Td2dNbDBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdXek1nTHlBek1pd2dNQ3dnTWwwc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pJZ0x5QXpNaXdnTVN3Z01sMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR05oYzJVZ1JYSnliM0pFYVdabWRYTnBiMjVCY25KaGVVdGxjbTVsYkM1VWQyOVRhV1Z5Y21FNlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5clpYSnVaV3dnUFNCYlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnV3pRZ0x5QXhOaXdnTVN3Z01GMHNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1d6TWdMeUF4Tml3Z01pd2dNRjBzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdXekVnTHlBeE5pd2dMVElzSURGZExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUZzeUlDOGdNVFlzSUMweExDQXhYU3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmJNeUF2SURFMkxDQXdMQ0F4WFN4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JiTWlBdklERTJMQ0F4TENBeFhTeGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCYk1TQXZJREUyTENBeUxDQXhYU3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUYwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmljbVZoYXp0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTJGelpTQkZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVTMlZ5Ym1Wc0xsTnBaWEp5WVV4cGRHVTZYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOXJaWEp1Wld3Z1BTQmJYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1d6SWdMeUEwTENBeExDQXdYU3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmJNU0F2SURRc0lDMHhMQ0F4WFN4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JiTVNBdklEUXNJREFzSURGZExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdYVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmtaV1poZFd4ME9seHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZEZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVPaUIxYm10dWIzZHVJR3RsY201bGJDQTlJQ2NnS3lCclpYSnVaV3dwTzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNHZMeU1nYzI5MWNtTmxUV0Z3Y0dsdVoxVlNURDFoY25KaGVTNXFjeTV0WVhBaUxDSmxlSEJ2Y25RZ1kyeGhjM01nUVdKemRISmhZM1JKYldGblpWRjFZVzUwYVhwbGNpQjdYSEpjYmlBZ0lDQnhkV0Z1ZEdsNlpWTjVibU1vY0c5cGJuUkRiMjUwWVdsdVpYSXNJSEJoYkdWMGRHVXBJSHRjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR052Ym5OMElIWmhiSFZsSUc5bUlIUm9hWE11Y1hWaGJuUnBlbVVvY0c5cGJuUkRiMjUwWVdsdVpYSXNJSEJoYkdWMGRHVXBLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoMllXeDFaUzV3YjJsdWRFTnZiblJoYVc1bGNpa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSFpoYkhWbExuQnZhVzUwUTI5dWRHRnBibVZ5TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpZ25kVzV5WldGamFHRmliR1VuS1R0Y2NseHVJQ0FnSUgxY2NseHVmVnh5WEc0dkx5TWdjMjkxY21ObFRXRndjR2x1WjFWU1REMXBiV0ZuWlZGMVlXNTBhWHBsY2k1cWN5NXRZWEFpTENJdktpcGNjbHh1SUNvZ1FIQnlaWE5sY25abFhISmNiaUFxSUVOdmNIbHlhV2RvZENBeU1ERTFMVEl3TVRnZ1NXZHZjaUJDWlhwcmNtOTJibmxwWEhKY2JpQXFJRUZzYkNCeWFXZG9kSE1nY21WelpYSjJaV1F1SUNoTlNWUWdUR2xqWlc1elpXUXBYSEpjYmlBcVhISmNiaUFxSUdseExuUnpJQzBnU1cxaFoyVWdVWFZoYm5ScGVtRjBhVzl1SUV4cFluSmhjbmxjY2x4dUlDb3ZYSEpjYm1WNGNHOXlkQ0I3SUVGaWMzUnlZV04wU1cxaFoyVlJkV0Z1ZEdsNlpYSWdmU0JtY205dElDY3VMMmx0WVdkbFVYVmhiblJwZW1WeUp6dGNjbHh1Wlhod2IzSjBJSHNnVG1WaGNtVnpkRU52Ykc5eUlIMGdabkp2YlNBbkxpOXVaV0Z5WlhOMFEyOXNiM0luTzF4eVhHNWxlSEJ2Y25RZ2V5QkZjbkp2Y2tScFptWjFjMmx2YmtGeWNtRjVMQ0JGY25KdmNrUnBabVoxYzJsdmJrRnljbUY1UzJWeWJtVnNJSDBnWm5KdmJTQW5MaTloY25KaGVTYzdYSEpjYm1WNGNHOXlkQ0I3SUVWeWNtOXlSR2xtWm5WemFXOXVVbWxsYldWeWMyMWhJSDBnWm5KdmJTQW5MaTl5YVdWdFpYSnpiV0VuTzF4eVhHNHZMeU1nYzI5MWNtTmxUV0Z3Y0dsdVoxVlNURDFwYm1SbGVDNXFjeTV0WVhBaUxDSXZLaXBjY2x4dUlDb2dRSEJ5WlhObGNuWmxYSEpjYmlBcUlFTnZjSGx5YVdkb2RDQXlNREUxTFRJd01UZ2dTV2R2Y2lCQ1pYcHJjbTkyYm5scFhISmNiaUFxSUVGc2JDQnlhV2RvZEhNZ2NtVnpaWEoyWldRdUlDaE5TVlFnVEdsalpXNXpaV1FwWEhKY2JpQXFYSEpjYmlBcUlHNWxZWEpsYzNSRGIyeHZjaTUwY3lBdElIQmhjblFnYjJZZ1NXMWhaMlVnVVhWaGJuUnBlbUYwYVc5dUlFeHBZbkpoY25sY2NseHVJQ292WEhKY2JtbHRjRzl5ZENCN0lFRmljM1J5WVdOMFNXMWhaMlZSZFdGdWRHbDZaWElnZlNCbWNtOXRJQ2N1TDJsdFlXZGxVWFZoYm5ScGVtVnlKenRjY2x4dWFXMXdiM0owSUhzZ1VISnZaM0psYzNOVWNtRmphMlZ5SUgwZ1puSnZiU0FuTGk0dmRYUnBiSE12Y0hKdlozSmxjM05VY21GamEyVnlKenRjY2x4dVpYaHdiM0owSUdOc1lYTnpJRTVsWVhKbGMzUkRiMnh2Y2lCbGVIUmxibVJ6SUVGaWMzUnlZV04wU1cxaFoyVlJkV0Z1ZEdsNlpYSWdlMXh5WEc0Z0lDQWdZMjl1YzNSeWRXTjBiM0lvWTI5c2IzSkVhWE4wWVc1alpVTmhiR04xYkdGMGIzSXBJSHRjY2x4dUlDQWdJQ0FnSUNCemRYQmxjaWdwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJScGMzUmhibU5sSUQwZ1kyOXNiM0pFYVhOMFlXNWpaVU5oYkdOMWJHRjBiM0k3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0F2S2lwY2NseHVJQ0FnSUNBcUlFMTFkR0YwWlhNZ2NHOXBiblJEYjI1MFlXbHVaWEpjY2x4dUlDQWdJQ0FxTDF4eVhHNGdJQ0FnS25GMVlXNTBhWHBsS0hCdmFXNTBRMjl1ZEdGcGJtVnlMQ0J3WVd4bGRIUmxLU0I3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnY0c5cGJuUkJjbkpoZVNBOUlIQnZhVzUwUTI5dWRHRnBibVZ5TG1kbGRGQnZhVzUwUVhKeVlYa29LVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0IzYVdSMGFDQTlJSEJ2YVc1MFEyOXVkR0ZwYm1WeUxtZGxkRmRwWkhSb0tDazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdhR1ZwWjJoMElEMGdjRzlwYm5SRGIyNTBZV2x1WlhJdVoyVjBTR1ZwWjJoMEtDazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdkSEpoWTJ0bGNpQTlJRzVsZHlCUWNtOW5jbVZ6YzFSeVlXTnJaWElvYUdWcFoyaDBMQ0E1T1NrN1hISmNiaUFnSUNBZ0lDQWdabTl5SUNoc1pYUWdlU0E5SURBN0lIa2dQQ0JvWldsbmFIUTdJSGtyS3lrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kSEpoWTJ0bGNpNXphRzkxYkdST2IzUnBabmtvZVNrcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSGxwWld4a0lIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2NtOW5jbVZ6Y3pvZ2RISmhZMnRsY2k1d2NtOW5jbVZ6Y3l4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2VDQTlJREFzSUdsa2VDQTlJSGtnS2lCM2FXUjBhRHNnZUNBOElIZHBaSFJvT3lCNEt5c3NJR2xrZUNzcktTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F2THlCSmJXRm5aU0J3YVhobGJGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2NHOXBiblFnUFNCd2IybHVkRUZ5Y21GNVcybGtlRjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QlNaV1IxWTJWa0lIQnBlR1ZzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2IybHVkQzVtY205dEtIQmhiR1YwZEdVdVoyVjBUbVZoY21WemRFTnZiRzl5S0hSb2FYTXVYMlJwYzNSaGJtTmxMQ0J3YjJsdWRDa3BPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIbHBaV3hrSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY0c5cGJuUkRiMjUwWVdsdVpYSXNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIQnliMmR5WlhOek9pQXhNREFzWEhKY2JpQWdJQ0FnSUNBZ2ZUdGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNHZMeU1nYzI5MWNtTmxUV0Z3Y0dsdVoxVlNURDF1WldGeVpYTjBRMjlzYjNJdWFuTXViV0Z3SWl3aUx5b3FYSEpjYmlBcUlFQndjbVZ6WlhKMlpWeHlYRzRnS2lCTlNWUWdUR2xqWlc1elpWeHlYRzRnS2x4eVhHNGdLaUJEYjNCNWNtbG5hSFFnTWpBeE5TMHlNREU0SUVsbmIzSWdRbVY2YTNKdmRtNTVhVnh5WEc0Z0tseHlYRzRnS2lCUVpYSnRhWE56YVc5dUlHbHpJR2hsY21WaWVTQm5jbUZ1ZEdWa0xDQm1jbVZsSUc5bUlHTm9ZWEpuWlN3Z2RHOGdZVzU1SUhCbGNuTnZiaUJ2WW5SaGFXNXBibWNnWVNCamIzQjVYSEpjYmlBcUlHOW1JSFJvYVhNZ2MyOW1kSGRoY21VZ1lXNWtJR0Z6YzI5amFXRjBaV1FnWkc5amRXMWxiblJoZEdsdmJpQm1hV3hsY3lBb2RHaGxJRndpVTI5bWRIZGhjbVZjSWlrc0lIUnZYSEpjYmlBcUlHUmxZV3dnYVc0Z2RHaGxJRk52Wm5SM1lYSmxJSGRwZEdodmRYUWdjbVZ6ZEhKcFkzUnBiMjRzSUdsdVkyeDFaR2x1WnlCM2FYUm9iM1YwSUd4cGJXbDBZWFJwYjI0Z2RHaGxYSEpjYmlBcUlISnBaMmgwY3lCMGJ5QjFjMlVzSUdOdmNIa3NJRzF2WkdsbWVTd2diV1Z5WjJVc0lIQjFZbXhwYzJnc0lHUnBjM1J5YVdKMWRHVXNJSE4xWW14cFkyVnVjMlVzSUdGdVpDOXZjbHh5WEc0Z0tpQnpaV3hzSUdOdmNHbGxjeUJ2WmlCMGFHVWdVMjltZEhkaGNtVXNJR0Z1WkNCMGJ5QndaWEp0YVhRZ2NHVnljMjl1Y3lCMGJ5QjNhRzl0SUhSb1pTQlRiMlowZDJGeVpTQnBjMXh5WEc0Z0tpQm1kWEp1YVhOb1pXUWdkRzhnWkc4Z2MyOHNJSE4xWW1wbFkzUWdkRzhnZEdobElHWnZiR3h2ZDJsdVp5QmpiMjVrYVhScGIyNXpPbHh5WEc0Z0tseHlYRzRnS2lCVWFHVWdZV0p2ZG1VZ1kyOXdlWEpwWjJoMElHNXZkR2xqWlNCaGJtUWdkR2hwY3lCd1pYSnRhWE56YVc5dUlHNXZkR2xqWlNCemFHRnNiQ0JpWlNCcGJtTnNkV1JsWkNCcGJseHlYRzRnS2lCaGJHd2dZMjl3YVdWeklHOXlJSE4xWW5OMFlXNTBhV0ZzSUhCdmNuUnBiMjV6SUc5bUlIUm9aU0JUYjJaMGQyRnlaUzVjY2x4dUlDcGNjbHh1SUNvZ1ZFaEZJRk5QUmxSWFFWSkZJRWxUSUZCU1QxWkpSRVZFSUZ3aVFWTWdTVk5jSWl3Z1YwbFVTRTlWVkNCWFFWSlNRVTVVV1NCUFJpQkJUbGtnUzBsT1JDd2dSVmhRVWtWVFV5QlBVbHh5WEc0Z0tpQkpUVkJNU1VWRUxDQkpUa05NVlVSSlRrY2dRbFZVSUU1UFZDQk1TVTFKVkVWRUlGUlBJRlJJUlNCWFFWSlNRVTVVU1VWVElFOUdJRTFGVWtOSVFVNVVRVUpKVEVsVVdTeGNjbHh1SUNvZ1JrbFVUa1ZUVXlCR1QxSWdRU0JRUVZKVVNVTlZURUZTSUZCVlVsQlBVMFVnUVU1RUlFNVBUa2xPUmxKSlRrZEZUVVZPVkM0Z1NVNGdUazhnUlZaRlRsUWdVMGhCVEV4Y2NseHVJQ29nVkVoRklFRlZWRWhQVWxNZ1QxSWdRMDlRV1ZKSlIwaFVJRWhQVEVSRlVsTWdRa1VnVEVsQlFreEZJRVpQVWlCQlRsa2dRMHhCU1Uwc0lFUkJUVUZIUlZNZ1QxSWdUMVJJUlZKY2NseHVJQ29nVEVsQlFrbE1TVlJaTENCWFNFVlVTRVZTSUVsT0lFRk9JRUZEVkVsUFRpQlBSaUJEVDA1VVVrRkRWQ3dnVkU5U1ZDQlBVaUJQVkVoRlVsZEpVMFVzSUVGU1NWTkpUa2RjY2x4dUlDb2dSbEpQVFN3Z1QxVlVJRTlHSUU5U0lFbE9JRU5QVGs1RlExUkpUMDRnVjBsVVNDQlVTRVVnVTA5R1ZGZEJVa1VnVDFJZ1ZFaEZJRlZUUlNCUFVpQlBWRWhGVWlCRVJVRk1TVTVIVTF4eVhHNGdLaUJKVGlCVVNFVWdVMDlHVkZkQlVrVXVYSEpjYmlBcVhISmNiaUFxSUhKcFpXMWxjbk50WVM1MGN5QXRJSEJoY25RZ2IyWWdTVzFoWjJVZ1VYVmhiblJwZW1GMGFXOXVJRXhwWW5KaGNubGNjbHh1SUNvdlhISmNibWx0Y0c5eWRDQjdJRUZpYzNSeVlXTjBTVzFoWjJWUmRXRnVkR2w2WlhJZ2ZTQm1jbTl0SUNjdUwybHRZV2RsVVhWaGJuUnBlbVZ5Snp0Y2NseHVhVzF3YjNKMElIc2dhR2xzWW1WeWRFTjFjblpsSUgwZ1puSnZiU0FuTGk5emNHRmpaVVpwYkd4cGJtZERkWEoyWlhNdmFHbHNZbVZ5ZEVOMWNuWmxKenRjY2x4dWFXMXdiM0owSUhzZ1VHOXBiblFnZlNCbWNtOXRJQ2N1TGk5MWRHbHNjeTl3YjJsdWRDYzdYSEpjYm1sdGNHOXlkQ0I3SUdsdVVtRnVaMlV3ZEc4eU5UVlNiM1Z1WkdWa0lIMGdabkp2YlNBbkxpNHZkWFJwYkhNdllYSnBkR2h0WlhScFl5YzdYSEpjYm1WNGNHOXlkQ0JqYkdGemN5QkZjbkp2Y2tScFptWjFjMmx2YmxKcFpXMWxjbk50WVNCbGVIUmxibVJ6SUVGaWMzUnlZV04wU1cxaFoyVlJkV0Z1ZEdsNlpYSWdlMXh5WEc0Z0lDQWdZMjl1YzNSeWRXTjBiM0lvWTI5c2IzSkVhWE4wWVc1alpVTmhiR04xYkdGMGIzSXNJR1Z5Y205eVVYVmxkV1ZUYVhwbElEMGdNVFlzSUdWeWNtOXlVSEp2Y0dGbllYUnBiMjRnUFNBeEtTQjdYSEpjYmlBZ0lDQWdJQ0FnYzNWd1pYSW9LVHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlrYVhOMFlXNWpaU0E5SUdOdmJHOXlSR2x6ZEdGdVkyVkRZV3hqZFd4aGRHOXlPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMlZ5Y205eVVYVmxkV1ZUYVhwbElEMGdaWEp5YjNKUmRXVjFaVk5wZW1VN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmQyVnBaMmgwY3lBOUlFVnljbTl5UkdsbVpuVnphVzl1VW1sbGJXVnljMjFoTGw5amNtVmhkR1ZYWldsbmFIUnpLR1Z5Y205eVVISnZjR0ZuWVhScGIyNHNJR1Z5Y205eVVYVmxkV1ZUYVhwbEtUdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lDOHFLbHh5WEc0Z0lDQWdJQ29nVFhWMFlYUmxjeUJ3YjJsdWRFTnZiblJoYVc1bGNseHlYRzRnSUNBZ0lDb3ZYSEpjYmlBZ0lDQXFjWFZoYm5ScGVtVW9jRzlwYm5SRGIyNTBZV2x1WlhJc0lIQmhiR1YwZEdVcElIdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQndiMmx1ZEVGeWNtRjVJRDBnY0c5cGJuUkRiMjUwWVdsdVpYSXVaMlYwVUc5cGJuUkJjbkpoZVNncE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElIZHBaSFJvSUQwZ2NHOXBiblJEYjI1MFlXbHVaWEl1WjJWMFYybGtkR2dvS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCb1pXbG5hSFFnUFNCd2IybHVkRU52Ym5SaGFXNWxjaTVuWlhSSVpXbG5hSFFvS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCbGNuSnZjbEYxWlhWbElEMGdXMTA3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJR2hsWVdRZ1BTQXdPMXh5WEc0Z0lDQWdJQ0FnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3Z2RHaHBjeTVmWlhKeWIzSlJkV1YxWlZOcGVtVTdJR2tyS3lrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCbGNuSnZjbEYxWlhWbFcybGRJRDBnZXlCeU9pQXdMQ0JuT2lBd0xDQmlPaUF3TENCaE9pQXdJSDA3WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSGxwWld4a0tpQm9hV3hpWlhKMFEzVnlkbVVvZDJsa2RHZ3NJR2hsYVdkb2RDd2dLSGdzSUhrcElEMCtJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2NDQTlJSEJ2YVc1MFFYSnlZWGxiZUNBcklIa2dLaUIzYVdSMGFGMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHeGxkQ0J5SUQwZ2NDNXlPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNaWFFnWnlBOUlIQXVaenRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdiR1YwSUdJZ1BTQndMbUk3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR3hsZENCaElEMGdjQzVoTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0JwSUQwZ01Ec2dhU0E4SUhSb2FYTXVYMlZ5Y205eVVYVmxkV1ZUYVhwbE95QnBLeXNwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhkbGFXZG9kQ0E5SUhSb2FYTXVYM2RsYVdkb2RITmJhVjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JsSUQwZ1pYSnliM0pSZFdWMVpWc29hU0FySUdobFlXUXBJQ1VnZEdocGN5NWZaWEp5YjNKUmRXVjFaVk5wZW1WZE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjaUFyUFNCbExuSWdLaUIzWldsbmFIUTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JuSUNzOUlHVXVaeUFxSUhkbGFXZG9kRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdJZ0t6MGdaUzVpSUNvZ2QyVnBaMmgwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lTQXJQU0JsTG1FZ0tpQjNaV2xuYUhRN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdZMjl5Y21WamRHVmtVRzlwYm5RZ1BTQlFiMmx1ZEM1amNtVmhkR1ZDZVZKSFFrRW9hVzVTWVc1blpUQjBiekkxTlZKdmRXNWtaV1FvY2lrc0lHbHVVbUZ1WjJVd2RHOHlOVFZTYjNWdVpHVmtLR2NwTENCcGJsSmhibWRsTUhSdk1qVTFVbTkxYm1SbFpDaGlLU3dnYVc1U1lXNW5aVEIwYnpJMU5WSnZkVzVrWldRb1lTa3BPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCeGRXRnVkR2w2WldSUWIybHVkQ0E5SUhCaGJHVjBkR1V1WjJWMFRtVmhjbVZ6ZEVOdmJHOXlLSFJvYVhNdVgyUnBjM1JoYm1ObExDQmpiM0p5WldOMFpXUlFiMmx1ZENrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklIVndaR0YwWlNCb1pXRmtJR0Z1WkNCallXeGpkV3hoZEdVZ2RHRnBiRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQm9aV0ZrSUQwZ0tHaGxZV1FnS3lBeEtTQWxJSFJvYVhNdVgyVnljbTl5VVhWbGRXVlRhWHBsTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQjBZV2xzSUQwZ0tHaGxZV1FnS3lCMGFHbHpMbDlsY25KdmNsRjFaWFZsVTJsNlpTQXRJREVwSUNVZ2RHaHBjeTVmWlhKeWIzSlJkV1YxWlZOcGVtVTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJSFZ3WkdGMFpTQmxjbkp2Y2lCM2FYUm9JRzVsZHlCMllXeDFaVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmxjbkp2Y2xGMVpYVmxXM1JoYVd4ZExuSWdQU0J3TG5JZ0xTQnhkV0Z1ZEdsNlpXUlFiMmx1ZEM1eU8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCbGNuSnZjbEYxWlhWbFczUmhhV3hkTG1jZ1BTQndMbWNnTFNCeGRXRnVkR2w2WldSUWIybHVkQzVuTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JsY25KdmNsRjFaWFZsVzNSaGFXeGRMbUlnUFNCd0xtSWdMU0J4ZFdGdWRHbDZaV1JRYjJsdWRDNWlPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmxjbkp2Y2xGMVpYVmxXM1JoYVd4ZExtRWdQU0J3TG1FZ0xTQnhkV0Z1ZEdsNlpXUlFiMmx1ZEM1aE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBdkx5QjFjR1JoZEdVZ2NHOXBiblJjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdjQzVtY205dEtIRjFZVzUwYVhwbFpGQnZhVzUwS1R0Y2NseHVJQ0FnSUNBZ0lDQjlLVHRjY2x4dUlDQWdJQ0FnSUNCNWFXVnNaQ0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSEJ2YVc1MFEyOXVkR0ZwYm1WeUxGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCd2NtOW5jbVZ6Y3pvZ01UQXdMRnh5WEc0Z0lDQWdJQ0FnSUgwN1hISmNiaUFnSUNCOVhISmNiaUFnSUNCemRHRjBhV01nWDJOeVpXRjBaVmRsYVdkb2RITW9aWEp5YjNKUWNtOXdZV2RoZEdsdmJpd2daWEp5YjNKUmRXVjFaVk5wZW1VcElIdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQjNaV2xuYUhSeklEMGdXMTA3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYlhWc2RHbHdiR2xsY2lBOUlFMWhkR2d1Wlhod0tFMWhkR2d1Ykc5bktHVnljbTl5VVhWbGRXVlRhWHBsS1NBdklDaGxjbkp2Y2xGMVpYVmxVMmw2WlNBdElERXBLVHRjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCcElEMGdNQ3dnYm1WNGRDQTlJREU3SUdrZ1BDQmxjbkp2Y2xGMVpYVmxVMmw2WlRzZ2FTc3JLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSGRsYVdkb2RITmJhVjBnUFNBb0tDaHVaWGgwSUNzZ01DNDFLU0I4SURBcElDOGdaWEp5YjNKUmRXVjFaVk5wZW1VcElDb2daWEp5YjNKUWNtOXdZV2RoZEdsdmJqdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2JtVjRkQ0FxUFNCdGRXeDBhWEJzYVdWeU8xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZDJWcFoyaDBjenRjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxeWFXVnRaWEp6YldFdWFuTXViV0Z3SWl3aWFXMXdiM0owSUhzZ1VISnZaM0psYzNOVWNtRmphMlZ5SUgwZ1puSnZiU0FuTGk0dkxpNHZkWFJwYkhNdmNISnZaM0psYzNOVWNtRmphMlZ5Snp0Y2NseHVkbUZ5SUVScGNtVmpkR2x2Ymp0Y2NseHVLR1oxYm1OMGFXOXVJQ2hFYVhKbFkzUnBiMjRwSUh0Y2NseHVJQ0FnSUVScGNtVmpkR2x2Ymx0RWFYSmxZM1JwYjI1YlhDSk9UMDVGWENKZElEMGdNRjBnUFNCY0lrNVBUa1ZjSWp0Y2NseHVJQ0FnSUVScGNtVmpkR2x2Ymx0RWFYSmxZM1JwYjI1YlhDSlZVRndpWFNBOUlERmRJRDBnWENKVlVGd2lPMXh5WEc0Z0lDQWdSR2x5WldOMGFXOXVXMFJwY21WamRHbHZibHRjSWt4RlJsUmNJbDBnUFNBeVhTQTlJRndpVEVWR1ZGd2lPMXh5WEc0Z0lDQWdSR2x5WldOMGFXOXVXMFJwY21WamRHbHZibHRjSWxKSlIwaFVYQ0pkSUQwZ00xMGdQU0JjSWxKSlIwaFVYQ0k3WEhKY2JpQWdJQ0JFYVhKbFkzUnBiMjViUkdseVpXTjBhVzl1VzF3aVJFOVhUbHdpWFNBOUlEUmRJRDBnWENKRVQxZE9YQ0k3WEhKY2JuMHBLRVJwY21WamRHbHZiaUI4ZkNBb1JHbHlaV04wYVc5dUlEMGdlMzBwS1R0Y2NseHVaWGh3YjNKMElHWjFibU4wYVc5dUtpQm9hV3hpWlhKMFEzVnlkbVVvZDJsa2RHZ3NJR2hsYVdkb2RDd2dZMkZzYkdKaFkyc3BJSHRjY2x4dUlDQWdJR052Ym5OMElHMWhlRUp2ZFc1a0lEMGdUV0YwYUM1dFlYZ29kMmxrZEdnc0lHaGxhV2RvZENrN1hISmNiaUFnSUNCamIyNXpkQ0JzWlhabGJDQTlJRTFoZEdndVpteHZiM0lvVFdGMGFDNXNiMmNvYldGNFFtOTFibVFwSUM4Z1RXRjBhQzVzYjJjb01pa2dLeUF4S1R0Y2NseHVJQ0FnSUdOdmJuTjBJSFJ5WVdOclpYSWdQU0J1WlhjZ1VISnZaM0psYzNOVWNtRmphMlZ5S0hkcFpIUm9JQ29nYUdWcFoyaDBMQ0E1T1NrN1hISmNiaUFnSUNCamIyNXpkQ0JrWVhSaElEMGdlMXh5WEc0Z0lDQWdJQ0FnSUhkcFpIUm9MRnh5WEc0Z0lDQWdJQ0FnSUdobGFXZG9kQ3hjY2x4dUlDQWdJQ0FnSUNCc1pYWmxiQ3hjY2x4dUlDQWdJQ0FnSUNCallXeHNZbUZqYXl4Y2NseHVJQ0FnSUNBZ0lDQjBjbUZqYTJWeUxGeHlYRzRnSUNBZ0lDQWdJR2x1WkdWNE9pQXdMRnh5WEc0Z0lDQWdJQ0FnSUhnNklEQXNYSEpjYmlBZ0lDQWdJQ0FnZVRvZ01DeGNjbHh1SUNBZ0lIMDdYSEpjYmlBZ0lDQjVhV1ZzWkNvZ2QyRnNhMGhwYkdKbGNuUW9aR0YwWVN3Z1JHbHlaV04wYVc5dUxsVlFLVHRjY2x4dUlDQWdJSFpwYzJsMEtHUmhkR0VzSUVScGNtVmpkR2x2Ymk1T1QwNUZLVHRjY2x4dWZWeHlYRzVtZFc1amRHbHZiaW9nZDJGc2EwaHBiR0psY25Rb1pHRjBZU3dnWkdseVpXTjBhVzl1S1NCN1hISmNiaUFnSUNCcFppQW9aR0YwWVM1c1pYWmxiQ0E4SURFcFhISmNiaUFnSUNBZ0lDQWdjbVYwZFhKdU8xeHlYRzRnSUNBZ2FXWWdLR1JoZEdFdWRISmhZMnRsY2k1emFHOTFiR1JPYjNScFpua29aR0YwWVM1cGJtUmxlQ2twWEhKY2JpQWdJQ0FnSUNBZ2VXbGxiR1FnZXlCd2NtOW5jbVZ6Y3pvZ1pHRjBZUzUwY21GamEyVnlMbkJ5YjJkeVpYTnpJSDA3WEhKY2JpQWdJQ0JrWVhSaExteGxkbVZzTFMwN1hISmNiaUFnSUNCemQybDBZMmdnS0dScGNtVmpkR2x2YmlrZ2UxeHlYRzRnSUNBZ0lDQWdJR05oYzJVZ1JHbHlaV04wYVc5dUxreEZSbFE2WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSGxwWld4a0tpQjNZV3hyU0dsc1ltVnlkQ2hrWVhSaExDQkVhWEpsWTNScGIyNHVWVkFwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0IyYVhOcGRDaGtZWFJoTENCRWFYSmxZM1JwYjI0dVVrbEhTRlFwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I1YVdWc1pDb2dkMkZzYTBocGJHSmxjblFvWkdGMFlTd2dSR2x5WldOMGFXOXVMa3hGUmxRcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCMmFYTnBkQ2hrWVhSaExDQkVhWEpsWTNScGIyNHVSRTlYVGlrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhscFpXeGtLaUIzWVd4clNHbHNZbVZ5ZENoa1lYUmhMQ0JFYVhKbFkzUnBiMjR1VEVWR1ZDazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIWnBjMmwwS0dSaGRHRXNJRVJwY21WamRHbHZiaTVNUlVaVUtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2VXbGxiR1FxSUhkaGJHdElhV3hpWlhKMEtHUmhkR0VzSUVScGNtVmpkR2x2Ymk1RVQxZE9LVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdZMkZ6WlNCRWFYSmxZM1JwYjI0dVVrbEhTRlE2WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSGxwWld4a0tpQjNZV3hyU0dsc1ltVnlkQ2hrWVhSaExDQkVhWEpsWTNScGIyNHVSRTlYVGlrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhacGMybDBLR1JoZEdFc0lFUnBjbVZqZEdsdmJpNU1SVVpVS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZVdsbGJHUXFJSGRoYkd0SWFXeGlaWEowS0dSaGRHRXNJRVJwY21WamRHbHZiaTVTU1VkSVZDazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIWnBjMmwwS0dSaGRHRXNJRVJwY21WamRHbHZiaTVWVUNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhscFpXeGtLaUIzWVd4clNHbHNZbVZ5ZENoa1lYUmhMQ0JFYVhKbFkzUnBiMjR1VWtsSFNGUXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjJhWE5wZENoa1lYUmhMQ0JFYVhKbFkzUnBiMjR1VWtsSFNGUXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjVhV1ZzWkNvZ2QyRnNhMGhwYkdKbGNuUW9aR0YwWVN3Z1JHbHlaV04wYVc5dUxsVlFLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdZMkZ6WlNCRWFYSmxZM1JwYjI0dVZWQTZYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIbHBaV3hrS2lCM1lXeHJTR2xzWW1WeWRDaGtZWFJoTENCRWFYSmxZM1JwYjI0dVRFVkdWQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFpwYzJsMEtHUmhkR0VzSUVScGNtVmpkR2x2Ymk1RVQxZE9LVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdlV2xsYkdRcUlIZGhiR3RJYVd4aVpYSjBLR1JoZEdFc0lFUnBjbVZqZEdsdmJpNVZVQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFpwYzJsMEtHUmhkR0VzSUVScGNtVmpkR2x2Ymk1U1NVZElWQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSGxwWld4a0tpQjNZV3hyU0dsc1ltVnlkQ2hrWVhSaExDQkVhWEpsWTNScGIyNHVWVkFwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0IyYVhOcGRDaGtZWFJoTENCRWFYSmxZM1JwYjI0dVZWQXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjVhV1ZzWkNvZ2QyRnNhMGhwYkdKbGNuUW9aR0YwWVN3Z1JHbHlaV04wYVc5dUxsSkpSMGhVS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWW5KbFlXczdYSEpjYmlBZ0lDQWdJQ0FnWTJGelpTQkVhWEpsWTNScGIyNHVSRTlYVGpwY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZVdsbGJHUXFJSGRoYkd0SWFXeGlaWEowS0dSaGRHRXNJRVJwY21WamRHbHZiaTVTU1VkSVZDazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIWnBjMmwwS0dSaGRHRXNJRVJwY21WamRHbHZiaTVWVUNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhscFpXeGtLaUIzWVd4clNHbHNZbVZ5ZENoa1lYUmhMQ0JFYVhKbFkzUnBiMjR1UkU5WFRpazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIWnBjMmwwS0dSaGRHRXNJRVJwY21WamRHbHZiaTVNUlVaVUtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2VXbGxiR1FxSUhkaGJHdElhV3hpWlhKMEtHUmhkR0VzSUVScGNtVmpkR2x2Ymk1RVQxZE9LVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkbWx6YVhRb1pHRjBZU3dnUkdseVpXTjBhVzl1TGtSUFYwNHBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjVhV1ZzWkNvZ2QyRnNhMGhwYkdKbGNuUW9aR0YwWVN3Z1JHbHlaV04wYVc5dUxreEZSbFFwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JpY21WaGF6dGNjbHh1SUNBZ0lDQWdJQ0JrWldaaGRXeDBPbHh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmljbVZoYXp0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUdSaGRHRXViR1YyWld3ckt6dGNjbHh1ZlZ4eVhHNW1kVzVqZEdsdmJpQjJhWE5wZENoa1lYUmhMQ0JrYVhKbFkzUnBiMjRwSUh0Y2NseHVJQ0FnSUdsbUlDaGtZWFJoTG5nZ1BqMGdNQ0FtSmlCa1lYUmhMbmdnUENCa1lYUmhMbmRwWkhSb0lDWW1JR1JoZEdFdWVTQStQU0F3SUNZbUlHUmhkR0V1ZVNBOElHUmhkR0V1YUdWcFoyaDBLU0I3WEhKY2JpQWdJQ0FnSUNBZ1pHRjBZUzVqWVd4c1ltRmpheWhrWVhSaExuZ3NJR1JoZEdFdWVTazdYSEpjYmlBZ0lDQWdJQ0FnWkdGMFlTNXBibVJsZUNzck8xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ2MzZHBkR05vSUNoa2FYSmxZM1JwYjI0cElIdGNjbHh1SUNBZ0lDQWdJQ0JqWVhObElFUnBjbVZqZEdsdmJpNU1SVVpVT2x4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JrWVhSaExuZ3RMVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdZMkZ6WlNCRWFYSmxZM1JwYjI0dVVrbEhTRlE2WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1JoZEdFdWVDc3JPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmljbVZoYXp0Y2NseHVJQ0FnSUNBZ0lDQmpZWE5sSUVScGNtVmpkR2x2Ymk1VlVEcGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1pHRjBZUzU1TFMwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh5WEc0Z0lDQWdJQ0FnSUdOaGMyVWdSR2x5WldOMGFXOXVMa1JQVjA0NlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUdSaGRHRXVlU3NyTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JpY21WaGF6dGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNHZMeU1nYzI5MWNtTmxUV0Z3Y0dsdVoxVlNURDFvYVd4aVpYSjBRM1Z5ZG1VdWFuTXViV0Z3SWl3aUx5b3FYSEpjYmlBcUlFQndjbVZ6WlhKMlpWeHlYRzRnS2lCRGIzQjVjbWxuYUhRZ01qQXhOUzB5TURFNElFbG5iM0lnUW1WNmEzSnZkbTU1YVZ4eVhHNGdLaUJCYkd3Z2NtbG5hSFJ6SUhKbGMyVnlkbVZrTGlBb1RVbFVJRXhwWTJWdWMyVmtLVnh5WEc0Z0tseHlYRzRnS2lCcGNTNTBjeUF0SUVsdFlXZGxJRkYxWVc1MGFYcGhkR2x2YmlCTWFXSnlZWEo1WEhKY2JpQXFMMXh5WEc1bGVIQnZjblFnZXlCQlluTjBjbUZqZEZCaGJHVjBkR1ZSZFdGdWRHbDZaWElnZlNCbWNtOXRJQ2N1TDNCaGJHVjBkR1ZSZFdGdWRHbDZaWEluTzF4eVhHNWxlSEJ2Y25RZ2V5Qk9aWFZSZFdGdWRDQjlJR1p5YjIwZ0p5NHZibVYxY1hWaGJuUXZibVYxY1hWaGJuUW5PMXh5WEc1bGVIQnZjblFnZXlCT1pYVlJkV0Z1ZEVac2IyRjBJSDBnWm5KdmJTQW5MaTl1WlhWeGRXRnVkQzl1WlhWeGRXRnVkRVpzYjJGMEp6dGNjbHh1Wlhod2IzSjBJSHNnVWtkQ1VYVmhiblFnZlNCbWNtOXRJQ2N1TDNKblluRjFZVzUwTDNKblluRjFZVzUwSnp0Y2NseHVaWGh3YjNKMElIc2dRMjlzYjNKSWFYTjBiMmR5WVcwZ2ZTQm1jbTl0SUNjdUwzSm5ZbkYxWVc1MEwyTnZiRzl5U0dsemRHOW5jbUZ0Snp0Y2NseHVaWGh3YjNKMElIc2dWM1ZSZFdGdWRDd2dWM1ZEYjJ4dmNrTjFZbVVnZlNCbWNtOXRJQ2N1TDNkMUwzZDFVWFZoYm5Rbk8xeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxcGJtUmxlQzVxY3k1dFlYQWlMQ0l2S2x4eVhHNGdLaUJPWlhWUmRXRnVkQ0JPWlhWeVlXd3RUbVYwSUZGMVlXNTBhWHBoZEdsdmJpQkJiR2R2Y21sMGFHMWNjbHh1SUNvZ0xTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEhKY2JpQXFYSEpjYmlBcUlFTnZjSGx5YVdkb2RDQW9ZeWtnTVRrNU5DQkJiblJvYjI1NUlFUmxhMnRsY2x4eVhHNGdLbHh5WEc0Z0tpQk9SVlZSVlVGT1ZDQk9aWFZ5WVd3dFRtVjBJSEYxWVc1MGFYcGhkR2x2YmlCaGJHZHZjbWwwYUcwZ1lua2dRVzUwYUc5dWVTQkVaV3RyWlhJc0lERTVPVFF1SUZObFpWeHlYRzRnS2lCY0lrdHZhRzl1Wlc0Z2JtVjFjbUZzSUc1bGRIZHZjbXR6SUdadmNpQnZjSFJwYldGc0lHTnZiRzkxY2lCeGRXRnVkR2w2WVhScGIyNWNJaUJwYmlCY0lrNWxkSGR2Y21zNlhISmNiaUFxSUVOdmJYQjFkR0YwYVc5dUlHbHVJRTVsZFhKaGJDQlRlWE4wWlcxelhDSWdWbTlzTGlBMUlDZ3hPVGswS1NCd2NDQXpOVEV0TXpZM0xpQm1iM0lnWVNCa2FYTmpkWE56YVc5dUlHOW1YSEpjYmlBcUlIUm9aU0JoYkdkdmNtbDBhRzB1WEhKY2JpQXFYSEpjYmlBcUlFRnVlU0J3WVhKMGVTQnZZblJoYVc1cGJtY2dZU0JqYjNCNUlHOW1JSFJvWlhObElHWnBiR1Z6SUdaeWIyMGdkR2hsSUdGMWRHaHZjaXdnWkdseVpXTjBiSGtnYjNKY2NseHVJQ29nYVc1a2FYSmxZM1JzZVN3Z2FYTWdaM0poYm5SbFpDd2dabkpsWlNCdlppQmphR0Z5WjJVc0lHRWdablZzYkNCaGJtUWdkVzV5WlhOMGNtbGpkR1ZrSUdseWNtVjJiMk5oWW14bExGeHlYRzRnS2lCM2IzSnNaQzEzYVdSbExDQndZV2xrSUhWd0xDQnliM2xoYkhSNUxXWnlaV1VzSUc1dmJtVjRZMngxYzJsMlpTQnlhV2RvZENCaGJtUWdiR2xqWlc1elpTQjBieUJrWldGc0lHbHVYSEpjYmlBcUlIUm9hWE1nYzI5bWRIZGhjbVVnWVc1a0lHUnZZM1Z0Wlc1MFlYUnBiMjRnWm1sc1pYTWdLSFJvWlNCY0lsTnZablIzWVhKbFhDSXBMQ0JwYm1Oc2RXUnBibWNnZDJsMGFHOTFkRnh5WEc0Z0tpQnNhVzFwZEdGMGFXOXVJSFJvWlNCeWFXZG9kSE1nZEc4Z2RYTmxMQ0JqYjNCNUxDQnRiMlJwWm5rc0lHMWxjbWRsTENCd2RXSnNhWE5vTENCa2FYTjBjbWxpZFhSbExGeHlYRzRnS2lCemRXSnNhV05sYm5ObExDQmhibVF2YjNJZ2MyVnNiQ0JqYjNCcFpYTWdiMllnZEdobElGTnZablIzWVhKbExDQmhibVFnZEc4Z2NHVnliV2wwSUhCbGNuTnZibk1nZDJodlhISmNiaUFxSUhKbFkyVnBkbVVnWTI5d2FXVnpJR1p5YjIwZ1lXNTVJSE4xWTJnZ2NHRnlkSGtnZEc4Z1pHOGdjMjhzSUhkcGRHZ2dkR2hsSUc5dWJIa2djbVZ4ZFdseVpXMWxiblFnWW1WcGJtZGNjbHh1SUNvZ2RHaGhkQ0IwYUdseklHTnZjSGx5YVdkb2RDQnViM1JwWTJVZ2NtVnRZV2x1SUdsdWRHRmpkQzVjY2x4dUlDb3ZYSEpjYmk4cUtseHlYRzRnS2lCQWNISmxjMlZ5ZG1VZ1ZIbHdaVk5qY21sd2RDQndiM0owT2x4eVhHNGdLaUJEYjNCNWNtbG5hSFFnTWpBeE5TMHlNREU0SUVsbmIzSWdRbVY2YTNKdmRtNTVhVnh5WEc0Z0tpQkJiR3dnY21sbmFIUnpJSEpsYzJWeWRtVmtMaUFvVFVsVUlFeHBZMlZ1YzJWa0tWeHlYRzRnS2x4eVhHNGdLaUJ1WlhWeGRXRnVkQzUwY3lBdElIQmhjblFnYjJZZ1NXMWhaMlVnVVhWaGJuUnBlbUYwYVc5dUlFeHBZbkpoY25sY2NseHVJQ292WEhKY2JtbHRjRzl5ZENCN0lGQmhiR1YwZEdVZ2ZTQm1jbTl0SUNjdUxpOHVMaTkxZEdsc2N5OXdZV3hsZEhSbEp6dGNjbHh1YVcxd2IzSjBJSHNnVUc5cGJuUWdmU0JtY205dElDY3VMaTh1TGk5MWRHbHNjeTl3YjJsdWRDYzdYSEpjYm1sdGNHOXlkQ0I3SUVGaWMzUnlZV04wVUdGc1pYUjBaVkYxWVc1MGFYcGxjaUI5SUdaeWIyMGdKeTR1TDNCaGJHVjBkR1ZSZFdGdWRHbDZaWEluTzF4eVhHNXBiWEJ2Y25RZ2V5QlFjbTluY21WemMxUnlZV05yWlhJZ2ZTQm1jbTl0SUNjdUxpOHVMaTkxZEdsc2N5YzdYSEpjYmk4dklHSnBZWE1nWm05eUlHTnZiRzkxY2lCMllXeDFaWE5jY2x4dVkyOXVjM1FnYm1WMGQyOXlhMEpwWVhOVGFHbG1kQ0E5SURNN1hISmNibU5zWVhOeklFNWxkWEp2YmlCN1hISmNiaUFnSUNCamIyNXpkSEoxWTNSdmNpaGtaV1poZFd4MFZtRnNkV1VwSUh0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG5JZ1BTQjBhR2x6TG1jZ1BTQjBhR2x6TG1JZ1BTQjBhR2x6TG1FZ1BTQmtaV1poZFd4MFZtRnNkV1U3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0F2S2lwY2NseHVJQ0FnSUNBcUlGUm9aWEpsSUdseklHRWdabWw0SUdsdUlHOXlhV2RwYm1Gc0lFNUZWVkZWUVU1VUlHSjVJRUZ1ZEdodmJua2dSR1ZyYTJWeUlDaG9kSFJ3T2k4dmJXVnRZbVZ5Y3k1dmVtVnRZV2xzTG1OdmJTNWhkUzkrWkdWcmEyVnlMMDVGVlZGVlFVNVVMa2hVVFV3cFhISmNiaUFnSUNBZ0tpQkFaWGhoYlhCc1pWeHlYRzRnSUNBZ0lDb2djaUE5SUUxaGRHZ3ViV2x1S0RJMU5Td2dLRzVsZFhKdmJpNXlJQ3NnS0RFZ1BEd2dLRzVsZEhkdmNtdENhV0Z6VTJocFpuUWdMU0F4S1NrcElENCtJRzVsZEhkdmNtdENhV0Z6VTJocFpuUXBPMXh5WEc0Z0lDQWdJQ292WEhKY2JpQWdJQ0IwYjFCdmFXNTBLQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCUWIybHVkQzVqY21WaGRHVkNlVkpIUWtFb2RHaHBjeTV5SUQ0K0lHNWxkSGR2Y210Q2FXRnpVMmhwWm5Rc0lIUm9hWE11WnlBK1BpQnVaWFIzYjNKclFtbGhjMU5vYVdaMExDQjBhR2x6TG1JZ1BqNGdibVYwZDI5eWEwSnBZWE5UYUdsbWRDd2dkR2hwY3k1aElENCtJRzVsZEhkdmNtdENhV0Z6VTJocFpuUXBPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdjM1ZpZEhKaFkzUW9jaXdnWnl3Z1lpd2dZU2tnZTF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11Y2lBdFBTQnlJSHdnTUR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG1jZ0xUMGdaeUI4SURBN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1aUlDMDlJR0lnZkNBd08xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVlTQXRQU0JoSUh3Z01EdGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNWxlSEJ2Y25RZ1kyeGhjM01nVG1WMVVYVmhiblFnWlhoMFpXNWtjeUJCWW5OMGNtRmpkRkJoYkdWMGRHVlJkV0Z1ZEdsNlpYSWdlMXh5WEc0Z0lDQWdZMjl1YzNSeWRXTjBiM0lvWTI5c2IzSkVhWE4wWVc1alpVTmhiR04xYkdGMGIzSXNJR052Ykc5eWN5QTlJREkxTmlrZ2UxeHlYRzRnSUNBZ0lDQWdJSE4xY0dWeUtDazdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZaR2x6ZEdGdVkyVWdQU0JqYjJ4dmNrUnBjM1JoYm1ObFEyRnNZM1ZzWVhSdmNqdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXdiMmx1ZEVGeWNtRjVJRDBnVzEwN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmMyRnRjR3hsUm1GamRHOXlJRDBnTVR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5dVpYUjNiM0pyVTJsNlpTQTlJR052Ykc5eWN6dGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOWthWE4wWVc1alpTNXpaWFJYYUdsMFpWQnZhVzUwS0RJMU5TQThQQ0J1WlhSM2IzSnJRbWxoYzFOb2FXWjBMQ0F5TlRVZ1BEd2dibVYwZDI5eWEwSnBZWE5UYUdsbWRDd2dNalUxSUR3OElHNWxkSGR2Y210Q2FXRnpVMmhwWm5Rc0lESTFOU0E4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owS1R0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhOaGJYQnNaU2h3YjJsdWRFTnZiblJoYVc1bGNpa2dlMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYM0J2YVc1MFFYSnlZWGtnUFNCMGFHbHpMbDl3YjJsdWRFRnljbUY1TG1OdmJtTmhkQ2h3YjJsdWRFTnZiblJoYVc1bGNpNW5aWFJRYjJsdWRFRnljbUY1S0NrcE8xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ0tuRjFZVzUwYVhwbEtDa2dlMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMmx1YVhRb0tUdGNjbHh1SUNBZ0lDQWdJQ0I1YVdWc1pDb2dkR2hwY3k1ZmJHVmhjbTRvS1R0Y2NseHVJQ0FnSUNBZ0lDQjVhV1ZzWkNCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhCaGJHVjBkR1U2SUhSb2FYTXVYMkoxYVd4a1VHRnNaWFIwWlNncExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCd2NtOW5jbVZ6Y3pvZ01UQXdMRnh5WEc0Z0lDQWdJQ0FnSUgwN1hISmNiaUFnSUNCOVhISmNiaUFnSUNCZmFXNXBkQ2dwSUh0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5bWNtVnhJRDBnVzEwN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZlltbGhjeUE5SUZ0ZE8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgzSmhaRkJ2ZDJWeUlEMGdXMTA3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmYm1WMGQyOXlheUE5SUZ0ZE8xeHlYRzRnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJR2tnUFNBd095QnBJRHdnZEdocGN5NWZibVYwZDI5eWExTnBlbVU3SUdrckt5a2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5dVpYUjNiM0pyVzJsZElEMGdibVYzSUU1bGRYSnZiaWdvYVNBOFBDQW9ibVYwZDI5eWEwSnBZWE5UYUdsbWRDQXJJRGdwS1NBdklIUm9hWE11WDI1bGRIZHZjbXRUYVhwbElId2dNQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SURFdmRHaHBjeTVmYm1WMGQyOXlhMU5wZW1WY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWZabkpsY1Z0cFhTQTlJRTVsZFZGMVlXNTBMbDlwYm1sMGFXRnNRbWxoY3lBdklIUm9hWE11WDI1bGRIZHZjbXRUYVhwbElId2dNRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZlltbGhjMXRwWFNBOUlEQTdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnTHlvcVhISmNiaUFnSUNBZ0tpQk5ZV2x1SUV4bFlYSnVhVzVuSUV4dmIzQmNjbHh1SUNBZ0lDQXFMMXh5WEc0Z0lDQWdLbDlzWldGeWJpZ3BJSHRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdjMkZ0Y0d4bFJtRmpkRzl5SUQwZ2RHaHBjeTVmYzJGdGNHeGxSbUZqZEc5eU8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElIQnZhVzUwYzA1MWJXSmxjaUE5SUhSb2FYTXVYM0J2YVc1MFFYSnlZWGt1YkdWdVozUm9PMXh5WEc0Z0lDQWdJQ0FnSUdsbUlDaHdiMmx1ZEhOT2RXMWlaWElnUENCT1pYVlJkV0Z1ZEM1ZmJXbHVjR2xqZEhWeVpXSjVkR1Z6S1Z4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J6WVcxd2JHVkdZV04wYjNJZ1BTQXhPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR0ZzY0doaFpHVmpJRDBnTXpBZ0t5QW9jMkZ0Y0d4bFJtRmpkRzl5SUMwZ01Ta2dMeUF6SUh3Z01EdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQndiMmx1ZEhOVWIxTmhiWEJzWlNBOUlIQnZhVzUwYzA1MWJXSmxjaUF2SUhOaGJYQnNaVVpoWTNSdmNpQjhJREE3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJR1JsYkhSaElEMGdjRzlwYm5SelZHOVRZVzF3YkdVZ0x5Qk9aWFZSZFdGdWRDNWZia041WTJ4bGN5QjhJREE3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJR0ZzY0doaElEMGdUbVYxVVhWaGJuUXVYMmx1YVhSQmJIQm9ZVHRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdjbUZrYVhWeklEMGdLSFJvYVhNdVgyNWxkSGR2Y210VGFYcGxJRDQrSURNcElDb2dUbVYxVVhWaGJuUXVYM0poWkdsMWMwSnBZWE03WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJSEpoWkNBOUlISmhaR2wxY3lBK1BpQk9aWFZSZFdGdWRDNWZjbUZrYVhWelFtbGhjMU5vYVdaME8xeHlYRzRnSUNBZ0lDQWdJR2xtSUNoeVlXUWdQRDBnTVNsY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY21Ga0lEMGdNRHRjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCcElEMGdNRHNnYVNBOElISmhaRHNnYVNzcktTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WDNKaFpGQnZkMlZ5VzJsZElEMGdZV3h3YUdFZ0tpQW9LQ2h5WVdRZ0tpQnlZV1FnTFNCcElDb2dhU2tnS2lCT1pYVlJkV0Z1ZEM1ZmNtRmtRbWxoY3lrZ0x5QW9jbUZrSUNvZ2NtRmtLU2tnUGo0K0lEQTdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0J6ZEdWd08xeHlYRzRnSUNBZ0lDQWdJR2xtSUNod2IybHVkSE5PZFcxaVpYSWdQQ0JPWlhWUmRXRnVkQzVmYldsdWNHbGpkSFZ5WldKNWRHVnpLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSE4wWlhBZ1BTQXhPMXh5WEc0Z0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQmxiSE5sSUdsbUlDaHdiMmx1ZEhOT2RXMWlaWElnSlNCT1pYVlJkV0Z1ZEM1ZmNISnBiV1V4SUNFOVBTQXdLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSE4wWlhBZ1BTQk9aWFZSZFdGdWRDNWZjSEpwYldVeE8xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCbGJITmxJR2xtSUNnb2NHOXBiblJ6VG5WdFltVnlJQ1VnVG1WMVVYVmhiblF1WDNCeWFXMWxNaWtnSVQwOUlEQXBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdjM1JsY0NBOUlFNWxkVkYxWVc1MExsOXdjbWx0WlRJN1hISmNiaUFnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUdWc2MyVWdhV1lnS0Nod2IybHVkSE5PZFcxaVpYSWdKU0JPWlhWUmRXRnVkQzVmY0hKcGJXVXpLU0FoUFQwZ01Da2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnpkR1Z3SUQwZ1RtVjFVWFZoYm5RdVgzQnlhVzFsTXp0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnWld4elpTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lITjBaWEFnUFNCT1pYVlJkV0Z1ZEM1ZmNISnBiV1UwTzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQjBjbUZqYTJWeUlEMGdibVYzSUZCeWIyZHlaWE56VkhKaFkydGxjaWh3YjJsdWRITlViMU5oYlhCc1pTd2dPVGtwTzF4eVhHNGdJQ0FnSUNBZ0lHWnZjaUFvYkdWMElHa2dQU0F3TENCd2IybHVkRWx1WkdWNElEMGdNRHNnYVNBOElIQnZhVzUwYzFSdlUyRnRjR3hsT3lrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kSEpoWTJ0bGNpNXphRzkxYkdST2IzUnBabmtvYVNrcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSGxwWld4a0lIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2NtOW5jbVZ6Y3pvZ2RISmhZMnRsY2k1d2NtOW5jbVZ6Y3l4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnY0c5cGJuUWdQU0IwYUdsekxsOXdiMmx1ZEVGeWNtRjVXM0J2YVc1MFNXNWtaWGhkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmlJRDBnY0c5cGJuUXVZaUE4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQm5JRDBnY0c5cGJuUXVaeUE4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnlJRDBnY0c5cGJuUXVjaUE4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmhJRDBnY0c5cGJuUXVZU0E4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnVaWFZ5YjI1SmJtUmxlQ0E5SUhSb2FYTXVYMk52Ym5SbGMzUW9ZaXdnWnl3Z2Npd2dZU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyRnNkR1Z5VTJsdVoyeGxLR0ZzY0doaExDQnVaWFZ5YjI1SmJtUmxlQ3dnWWl3Z1p5d2djaXdnWVNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaHlZV1FnSVQwOUlEQXBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOWhiSFJsY2s1bGFXZG9ZbTkxY2loeVlXUXNJRzVsZFhKdmJrbHVaR1Y0TENCaUxDQm5MQ0J5TENCaEtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0x5b2dZV3gwWlhJZ2JtVnBaMmhpYjNWeWN5QXFMMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQndiMmx1ZEVsdVpHVjRJQ3M5SUhOMFpYQTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2h3YjJsdWRFbHVaR1Y0SUQ0OUlIQnZhVzUwYzA1MWJXSmxjaWxjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhCdmFXNTBTVzVrWlhnZ0xUMGdjRzlwYm5SelRuVnRZbVZ5TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwS3lzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaGtaV3gwWVNBOVBUMGdNQ2xjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdSbGJIUmhJRDBnTVR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHa2dKU0JrWld4MFlTQTlQVDBnTUNrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZV3h3YUdFZ0xUMGdLR0ZzY0doaElDOGdZV3h3YUdGa1pXTXBJSHdnTUR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmhaR2wxY3lBdFBTQW9jbUZrYVhWeklDOGdUbVYxVVhWaGJuUXVYM0poWkdsMWMwUmxZM0psWVhObEtTQjhJREE3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVlXUWdQU0J5WVdScGRYTWdQajRnVG1WMVVYVmhiblF1WDNKaFpHbDFjMEpwWVhOVGFHbG1kRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaHlZV1FnUEQwZ01TbGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVlXUWdQU0F3TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FpQTlJREE3SUdvZ1BDQnlZV1E3SUdvckt5bGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDl5WVdSUWIzZGxjbHRxWFNBOUlHRnNjR2hoSUNvZ0tDZ29jbUZrSUNvZ2NtRmtJQzBnYWlBcUlHb3BJQ29nVG1WMVVYVmhiblF1WDNKaFpFSnBZWE1wSUM4Z0tISmhaQ0FxSUhKaFpDa3BJRDQrUGlBd08xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdYMkoxYVd4a1VHRnNaWFIwWlNncElIdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQndZV3hsZEhSbElEMGdibVYzSUZCaGJHVjBkR1VvS1R0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5dVpYUjNiM0pyTG1admNrVmhZMmdvYm1WMWNtOXVJRDArSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY0dGc1pYUjBaUzVoWkdRb2JtVjFjbTl1TG5SdlVHOXBiblFvS1NrN1hISmNiaUFnSUNBZ0lDQWdmU2s3WEhKY2JpQWdJQ0FnSUNBZ2NHRnNaWFIwWlM1emIzSjBLQ2s3WEhKY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhCaGJHVjBkR1U3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0F2S2lwY2NseHVJQ0FnSUNBcUlFMXZkbVVnWVdScVlXTmxiblFnYm1WMWNtOXVjeUJpZVNCd2NtVmpiMjF3ZFhSbFpDQmhiSEJvWVNvb01TMG9LR2t0YWlsZU1pOWJjbDFlTWlrcElHbHVJSEpoWkhCdmQyVnlXM3hwTFdwOFhWeHlYRzRnSUNBZ0lDb3ZYSEpjYmlBZ0lDQmZZV3gwWlhKT1pXbG5hR0p2ZFhJb2NtRmtMQ0JwTENCaUxDQm5MQ0J5TENCaGJDa2dlMXh5WEc0Z0lDQWdJQ0FnSUd4bGRDQnNieUE5SUdrZ0xTQnlZV1E3WEhKY2JpQWdJQ0FnSUNBZ2FXWWdLR3h2SUR3Z0xURXBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHeHZJRDBnTFRFN1hISmNiaUFnSUNBZ0lDQWdiR1YwSUdocElEMGdhU0FySUhKaFpEdGNjbHh1SUNBZ0lDQWdJQ0JwWmlBb2FHa2dQaUIwYUdsekxsOXVaWFIzYjNKclUybDZaU2xjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdhR2tnUFNCMGFHbHpMbDl1WlhSM2IzSnJVMmw2WlR0Y2NseHVJQ0FnSUNBZ0lDQnNaWFFnYWlBOUlHa2dLeUF4TzF4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0JySUQwZ2FTQXRJREU3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJRzBnUFNBeE8xeHlYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaHFJRHdnYUdrZ2ZId2dheUErSUd4dktTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdFZ1BTQjBhR2x6TGw5eVlXUlFiM2RsY2x0dEt5dGRJQzhnVG1WMVVYVmhiblF1WDJGc2NHaGhVbUZrUW1saGN6dGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR29nUENCb2FTa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdjQ0E5SUhSb2FYTXVYMjVsZEhkdmNtdGJhaXNyWFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIQXVjM1ZpZEhKaFkzUW9ZU0FxSUNod0xuSWdMU0J5S1N3Z1lTQXFJQ2h3TG1jZ0xTQm5LU3dnWVNBcUlDaHdMbUlnTFNCaUtTd2dZU0FxSUNod0xtRWdMU0JoYkNrcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaHJJRDRnYkc4cElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElIQWdQU0IwYUdsekxsOXVaWFIzYjNKclcyc3RMVjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd0xuTjFZblJ5WVdOMEtHRWdLaUFvY0M1eUlDMGdjaWtzSUdFZ0tpQW9jQzVuSUMwZ1p5a3NJR0VnS2lBb2NDNWlJQzBnWWlrc0lHRWdLaUFvY0M1aElDMGdZV3dwS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lDOHFLbHh5WEc0Z0lDQWdJQ29nVFc5MlpTQnVaWFZ5YjI0Z2FTQjBiM2RoY21SeklHSnBZWE5sWkNBb1lpeG5MSElwSUdKNUlHWmhZM1J2Y2lCaGJIQm9ZVnh5WEc0Z0lDQWdJQ292WEhKY2JpQWdJQ0JmWVd4MFpYSlRhVzVuYkdVb1lXeHdhR0VzSUdrc0lHSXNJR2NzSUhJc0lHRXBJSHRjY2x4dUlDQWdJQ0FnSUNCaGJIQm9ZU0F2UFNCT1pYVlJkV0Z1ZEM1ZmFXNXBkRUZzY0doaE8xeHlYRzRnSUNBZ0lDQWdJQzhxSUdGc2RHVnlJR2hwZENCdVpYVnliMjRnS2k5Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCdUlEMGdkR2hwY3k1ZmJtVjBkMjl5YTF0cFhUdGNjbHh1SUNBZ0lDQWdJQ0J1TG5OMVluUnlZV04wS0dGc2NHaGhJQ29nS0c0dWNpQXRJSElwTENCaGJIQm9ZU0FxSUNodUxtY2dMU0JuS1N3Z1lXeHdhR0VnS2lBb2JpNWlJQzBnWWlrc0lHRnNjR2hoSUNvZ0tHNHVZU0F0SUdFcEtUdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lDOHFLbHh5WEc0Z0lDQWdJQ29nVTJWaGNtTm9JR1p2Y2lCaWFXRnpaV1FnUWtkU0lIWmhiSFZsYzF4eVhHNGdJQ0FnSUNvZ1pHVnpZM0pwY0hScGIyNDZYSEpjYmlBZ0lDQWdLaUFnSUNCbWFXNWtjeUJqYkc5elpYTjBJRzVsZFhKdmJpQW9iV2x1SUdScGMzUXBJR0Z1WkNCMWNHUmhkR1Z6SUdaeVpYRmNjbHh1SUNBZ0lDQXFJQ0FnSUdacGJtUnpJR0psYzNRZ2JtVjFjbTl1SUNodGFXNGdaR2x6ZEMxaWFXRnpLU0JoYm1RZ2NtVjBkWEp1Y3lCd2IzTnBkR2x2Ymx4eVhHNGdJQ0FnSUNvZ0lDQWdabTl5SUdaeVpYRjFaVzUwYkhrZ1kyaHZjMlZ1SUc1bGRYSnZibk1zSUdaeVpYRmJhVjBnYVhNZ2FHbG5hQ0JoYm1RZ1ltbGhjMXRwWFNCcGN5QnVaV2RoZEdsMlpWeHlYRzRnSUNBZ0lDb2dJQ0FnWW1saGMxdHBYU0E5SUY5bllXMXRZU29vS0RFdmRHaHBjeTVmYm1WMGQyOXlhMU5wZW1VcExXWnlaWEZiYVYwcFhISmNiaUFnSUNBZ0tseHlYRzRnSUNBZ0lDb2dUM0pwWjJsdVlXd2daR2x6ZEdGdVkyVWdaWEYxWVhScGIyNDZYSEpjYmlBZ0lDQWdLaUFnSUNBZ0lDQWdaR2x6ZENBOUlHRmljeWhrVWlrZ0t5QmhZbk1vWkVjcElDc2dZV0p6S0dSQ0tWeHlYRzRnSUNBZ0lDb3ZYSEpjYmlBZ0lDQmZZMjl1ZEdWemRDaGlMQ0JuTENCeUxDQmhLU0I3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYlhWc2RHbHdiR2xsY2lBOUlDZ3lOVFVnS2lBMEtTQThQQ0J1WlhSM2IzSnJRbWxoYzFOb2FXWjBPMXh5WEc0Z0lDQWdJQ0FnSUd4bGRDQmlaWE4wWkNBOUlING9NU0E4UENBek1TazdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElHSmxjM1JpYVdGelpDQTlJR0psYzNSa08xeHlYRzRnSUNBZ0lDQWdJR3hsZENCaVpYTjBjRzl6SUQwZ0xURTdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElHSmxjM1JpYVdGemNHOXpJRDBnWW1WemRIQnZjenRjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCcElEMGdNRHNnYVNBOElIUm9hWE11WDI1bGRIZHZjbXRUYVhwbE95QnBLeXNwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdiaUE5SUhSb2FYTXVYMjVsZEhkdmNtdGJhVjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHUnBjM1FnUFNCMGFHbHpMbDlrYVhOMFlXNWpaUzVqWVd4amRXeGhkR1ZPYjNKdFlXeHBlbVZrS0c0c0lIc2djaXdnWnl3Z1lpd2dZU0I5S1NBcUlHMTFiSFJwY0d4cFpYSWdmQ0F3TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1pHbHpkQ0E4SUdKbGMzUmtLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaVpYTjBaQ0E5SUdScGMzUTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JpWlhOMGNHOXpJRDBnYVR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmlhV0Z6WkdsemRDQTlJR1JwYzNRZ0xTQW9LSFJvYVhNdVgySnBZWE5iYVYwcElENCtJQ2hPWlhWUmRXRnVkQzVmYVc1cGRHbGhiRUpwWVhOVGFHbG1kQ0F0SUc1bGRIZHZjbXRDYVdGelUyaHBablFwS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHSnBZWE5rYVhOMElEd2dZbVZ6ZEdKcFlYTmtLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaVpYTjBZbWxoYzJRZ1BTQmlhV0Z6WkdsemREdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0psYzNSaWFXRnpjRzl6SUQwZ2FUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JpWlhSaFpuSmxjU0E5SUNoMGFHbHpMbDltY21WeFcybGRJRDQrSUU1bGRWRjFZVzUwTGw5aVpYUmhVMmhwWm5RcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDltY21WeFcybGRJQzA5SUdKbGRHRm1jbVZ4TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOWlhV0Z6VzJsZElDczlJQ2hpWlhSaFpuSmxjU0E4UENCT1pYVlJkV0Z1ZEM1ZloyRnRiV0ZUYUdsbWRDazdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJaeVpYRmJZbVZ6ZEhCdmMxMGdLejBnVG1WMVVYVmhiblF1WDJKbGRHRTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZbWxoYzF0aVpYTjBjRzl6WFNBdFBTQk9aWFZSZFdGdWRDNWZZbVYwWVVkaGJXMWhPMXh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJpWlhOMFltbGhjM0J2Y3p0Y2NseHVJQ0FnSUgxY2NseHVmVnh5WEc0dktseHlYRzRnWm05MWNpQndjbWx0WlhNZ2JtVmhjaUExTURBZ0xTQmhjM04xYldVZ2JtOGdhVzFoWjJVZ2FHRnpJR0VnYkdWdVozUm9JSE52SUd4aGNtZGxYSEpjYmlCMGFHRjBJR2wwSUdseklHUnBkbWx6YVdKc1pTQmllU0JoYkd3Z1ptOTFjaUJ3Y21sdFpYTmNjbHh1SUNvdlhISmNiazVsZFZGMVlXNTBMbDl3Y21sdFpURWdQU0EwT1RrN1hISmNiazVsZFZGMVlXNTBMbDl3Y21sdFpUSWdQU0EwT1RFN1hISmNiazVsZFZGMVlXNTBMbDl3Y21sdFpUTWdQU0EwT0RjN1hISmNiazVsZFZGMVlXNTBMbDl3Y21sdFpUUWdQU0ExTURNN1hISmNiazVsZFZGMVlXNTBMbDl0YVc1d2FXTjBkWEpsWW5sMFpYTWdQU0JPWlhWUmRXRnVkQzVmY0hKcGJXVTBPMXh5WEc0dkx5QnVieTRnYjJZZ2JHVmhjbTVwYm1jZ1kzbGpiR1Z6WEhKY2JrNWxkVkYxWVc1MExsOXVRM2xqYkdWeklEMGdNVEF3TzF4eVhHNHZMeUJrWldaeklHWnZjaUJtY21WeElHRnVaQ0JpYVdGelhISmNiazVsZFZGMVlXNTBMbDlwYm1sMGFXRnNRbWxoYzFOb2FXWjBJRDBnTVRZN1hISmNiaTh2SUdKcFlYTWdabTl5SUdaeVlXTjBhVzl1YzF4eVhHNU9aWFZSZFdGdWRDNWZhVzVwZEdsaGJFSnBZWE1nUFNBb01TQThQQ0JPWlhWUmRXRnVkQzVmYVc1cGRHbGhiRUpwWVhOVGFHbG1kQ2s3WEhKY2JrNWxkVkYxWVc1MExsOW5ZVzF0WVZOb2FXWjBJRDBnTVRBN1hISmNiaTh2SUdkaGJXMWhJRDBnTVRBeU5GeHlYRzR2THlCVVQwUlBPaUIzYUhrZ1oyRnRiV0VnYVhNZ2JtVjJaWElnZFhObFpEOWNjbHh1THk4Z2NISnBkbUYwWlNCemRHRjBhV01nWDJkaGJXMWhJRG9nYm5WdFltVnlJQ0FnSUNBOUlDZ3hJRHc4SUU1bGRWRjFZVzUwTGw5bllXMXRZVk5vYVdaMEtUdGNjbHh1VG1WMVVYVmhiblF1WDJKbGRHRlRhR2xtZENBOUlERXdPMXh5WEc1T1pYVlJkV0Z1ZEM1ZlltVjBZU0E5SUNoT1pYVlJkV0Z1ZEM1ZmFXNXBkR2xoYkVKcFlYTWdQajRnVG1WMVVYVmhiblF1WDJKbGRHRlRhR2xtZENrN1hISmNiaTh2SUdKbGRHRWdQU0F4THpFd01qUmNjbHh1VG1WMVVYVmhiblF1WDJKbGRHRkhZVzF0WVNBOUlDaE9aWFZSZFdGdWRDNWZhVzVwZEdsaGJFSnBZWE1nUER3Z0tFNWxkVkYxWVc1MExsOW5ZVzF0WVZOb2FXWjBJQzBnVG1WMVVYVmhiblF1WDJKbGRHRlRhR2xtZENrcE8xeHlYRzR2S2x4eVhHNGdLaUJtYjNJZ01qVTJJR052YkhNc0lISmhaR2wxY3lCemRHRnlkSE5jY2x4dUlDb3ZYSEpjYms1bGRWRjFZVzUwTGw5eVlXUnBkWE5DYVdGelUyaHBablFnUFNBMk8xeHlYRzR2THlCaGRDQXpNaTR3SUdKcFlYTmxaQ0JpZVNBMklHSnBkSE5jY2x4dVRtVjFVWFZoYm5RdVgzSmhaR2wxYzBKcFlYTWdQU0F4SUR3OElFNWxkVkYxWVc1MExsOXlZV1JwZFhOQ2FXRnpVMmhwWm5RN1hISmNiaTh2SUdGdVpDQmtaV055WldGelpYTWdZbmtnWVNCbVlXTjBiM0lnYjJZZ01TOHpNQ0JsWVdOb0lHTjVZMnhsWEhKY2JrNWxkVkYxWVc1MExsOXlZV1JwZFhORVpXTnlaV0Z6WlNBOUlETXdPMXh5WEc0dktpQmtaV1p6SUdadmNpQmtaV055WldGemFXNW5JR0ZzY0doaElHWmhZM1J2Y2lBcUwxeHlYRzR2THlCaGJIQm9ZU0J6ZEdGeWRITWdZWFFnTVM0d1hISmNiazVsZFZGMVlXNTBMbDloYkhCb1lVSnBZWE5UYUdsbWRDQTlJREV3TzF4eVhHNHZMeUJpYVdGelpXUWdZbmtnTVRBZ1ltbDBjMXh5WEc1T1pYVlJkV0Z1ZEM1ZmFXNXBkRUZzY0doaElEMGdLREVnUER3Z1RtVjFVWFZoYm5RdVgyRnNjR2hoUW1saGMxTm9hV1owS1R0Y2NseHVMeW9nY21Ga1FtbGhjeUJoYm1RZ1lXeHdhR0ZTWVdSQ2FXRnpJSFZ6WldRZ1ptOXlJSEpoWkhCdmQyVnlJR05oYkdOMWJHRjBhVzl1SUNvdlhISmNiazVsZFZGMVlXNTBMbDl5WVdSQ2FXRnpVMmhwWm5RZ1BTQTRPMXh5WEc1T1pYVlJkV0Z1ZEM1ZmNtRmtRbWxoY3lBOUlERWdQRHdnVG1WMVVYVmhiblF1WDNKaFpFSnBZWE5UYUdsbWREdGNjbHh1VG1WMVVYVmhiblF1WDJGc2NHaGhVbUZrUW1saGMxTm9hV1owSUQwZ1RtVjFVWFZoYm5RdVgyRnNjR2hoUW1saGMxTm9hV1owSUNzZ1RtVjFVWFZoYm5RdVgzSmhaRUpwWVhOVGFHbG1kRHRjY2x4dVRtVjFVWFZoYm5RdVgyRnNjR2hoVW1Ga1FtbGhjeUE5SURFZ1BEd2dUbVYxVVhWaGJuUXVYMkZzY0doaFVtRmtRbWxoYzFOb2FXWjBPMXh5WEc0dkx5TWdjMjkxY21ObFRXRndjR2x1WjFWU1REMXVaWFZ4ZFdGdWRDNXFjeTV0WVhBaUxDSXZLbHh5WEc0Z0tpQk9aWFZSZFdGdWRFWnNiMkYwSUU1bGRYSmhiQzFPWlhRZ1VYVmhiblJwZW1GMGFXOXVJRUZzWjI5eWFYUm9iVnh5WEc0Z0tpQXRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMxY2NseHVJQ3BjY2x4dUlDb2dRMjl3ZVhKcFoyaDBJQ2hqS1NBeE9UazBJRUZ1ZEdodmJua2dSR1ZyYTJWeVhISmNiaUFxWEhKY2JpQXFJRTVGVlZGVlFVNVVJRTVsZFhKaGJDMU9aWFFnY1hWaGJuUnBlbUYwYVc5dUlHRnNaMjl5YVhSb2JTQmllU0JCYm5Sb2IyNTVJRVJsYTJ0bGNpd2dNVGs1TkM0Z1UyVmxYSEpjYmlBcUlGd2lTMjlvYjI1bGJpQnVaWFZ5WVd3Z2JtVjBkMjl5YTNNZ1ptOXlJRzl3ZEdsdFlXd2dZMjlzYjNWeUlIRjFZVzUwYVhwaGRHbHZibHdpSUdsdUlGd2lUbVYwZDI5eWF6cGNjbHh1SUNvZ1EyOXRjSFYwWVhScGIyNGdhVzRnVG1WMWNtRnNJRk41YzNSbGJYTmNJaUJXYjJ3dUlEVWdLREU1T1RRcElIQndJRE0xTVMwek5qY3VJR1p2Y2lCaElHUnBjMk4xYzNOcGIyNGdiMlpjY2x4dUlDb2dkR2hsSUdGc1oyOXlhWFJvYlM1Y2NseHVJQ3BjY2x4dUlDb2dRVzU1SUhCaGNuUjVJRzlpZEdGcGJtbHVaeUJoSUdOdmNIa2diMllnZEdobGMyVWdabWxzWlhNZ1puSnZiU0IwYUdVZ1lYVjBhRzl5TENCa2FYSmxZM1JzZVNCdmNseHlYRzRnS2lCcGJtUnBjbVZqZEd4NUxDQnBjeUJuY21GdWRHVmtMQ0JtY21WbElHOW1JR05vWVhKblpTd2dZU0JtZFd4c0lHRnVaQ0IxYm5KbGMzUnlhV04wWldRZ2FYSnlaWFp2WTJGaWJHVXNYSEpjYmlBcUlIZHZjbXhrTFhkcFpHVXNJSEJoYVdRZ2RYQXNJSEp2ZVdGc2RIa3RabkpsWlN3Z2JtOXVaWGhqYkhWemFYWmxJSEpwWjJoMElHRnVaQ0JzYVdObGJuTmxJSFJ2SUdSbFlXd2dhVzVjY2x4dUlDb2dkR2hwY3lCemIyWjBkMkZ5WlNCaGJtUWdaRzlqZFcxbGJuUmhkR2x2YmlCbWFXeGxjeUFvZEdobElGd2lVMjltZEhkaGNtVmNJaWtzSUdsdVkyeDFaR2x1WnlCM2FYUm9iM1YwWEhKY2JpQXFJR3hwYldsMFlYUnBiMjRnZEdobElISnBaMmgwY3lCMGJ5QjFjMlVzSUdOdmNIa3NJRzF2WkdsbWVTd2diV1Z5WjJVc0lIQjFZbXhwYzJnc0lHUnBjM1J5YVdKMWRHVXNYSEpjYmlBcUlITjFZbXhwWTJWdWMyVXNJR0Z1WkM5dmNpQnpaV3hzSUdOdmNHbGxjeUJ2WmlCMGFHVWdVMjltZEhkaGNtVXNJR0Z1WkNCMGJ5QndaWEp0YVhRZ2NHVnljMjl1Y3lCM2FHOWNjbHh1SUNvZ2NtVmpaV2wyWlNCamIzQnBaWE1nWm5KdmJTQmhibmtnYzNWamFDQndZWEowZVNCMGJ5QmtieUJ6Ynl3Z2QybDBhQ0IwYUdVZ2IyNXNlU0J5WlhGMWFYSmxiV1Z1ZENCaVpXbHVaMXh5WEc0Z0tpQjBhR0YwSUhSb2FYTWdZMjl3ZVhKcFoyaDBJRzV2ZEdsalpTQnlaVzFoYVc0Z2FXNTBZV04wTGx4eVhHNGdLaTljY2x4dUx5b3FYSEpjYmlBcUlFQndjbVZ6WlhKMlpTQlVlWEJsVTJOeWFYQjBJSEJ2Y25RNlhISmNiaUFxSUVOdmNIbHlhV2RvZENBeU1ERTFMVEl3TVRnZ1NXZHZjaUJDWlhwcmNtOTJibmxwWEhKY2JpQXFJRUZzYkNCeWFXZG9kSE1nY21WelpYSjJaV1F1SUNoTlNWUWdUR2xqWlc1elpXUXBYSEpjYmlBcVhISmNiaUFxSUc1bGRYRjFZVzUwTG5SeklDMGdjR0Z5ZENCdlppQkpiV0ZuWlNCUmRXRnVkR2w2WVhScGIyNGdUR2xpY21GeWVWeHlYRzRnS2k5Y2NseHVhVzF3YjNKMElIc2dVR0ZzWlhSMFpTQjlJR1p5YjIwZ0p5NHVMeTR1TDNWMGFXeHpMM0JoYkdWMGRHVW5PMXh5WEc1cGJYQnZjblFnZXlCUWIybHVkQ0I5SUdaeWIyMGdKeTR1THk0dUwzVjBhV3h6TDNCdmFXNTBKenRjY2x4dWFXMXdiM0owSUhzZ1FXSnpkSEpoWTNSUVlXeGxkSFJsVVhWaGJuUnBlbVZ5SUgwZ1puSnZiU0FuTGk0dmNHRnNaWFIwWlZGMVlXNTBhWHBsY2ljN1hISmNibWx0Y0c5eWRDQjdJRkJ5YjJkeVpYTnpWSEpoWTJ0bGNpQjlJR1p5YjIwZ0p5NHVMeTR1TDNWMGFXeHpKenRjY2x4dUx5OGdZbWxoY3lCbWIzSWdZMjlzYjNWeUlIWmhiSFZsYzF4eVhHNWpiMjV6ZENCdVpYUjNiM0pyUW1saGMxTm9hV1owSUQwZ016dGNjbHh1WTJ4aGMzTWdUbVYxY205dVJteHZZWFFnZTF4eVhHNGdJQ0FnWTI5dWMzUnlkV04wYjNJb1pHVm1ZWFZzZEZaaGJIVmxLU0I3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTV5SUQwZ2RHaHBjeTVuSUQwZ2RHaHBjeTVpSUQwZ2RHaHBjeTVoSUQwZ1pHVm1ZWFZzZEZaaGJIVmxPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdMeW9xWEhKY2JpQWdJQ0FnS2lCVWFHVnlaU0JwY3lCaElHWnBlQ0JwYmlCdmNtbG5hVzVoYkNCT1JWVlJWVUZPVkNCaWVTQkJiblJvYjI1NUlFUmxhMnRsY2lBb2FIUjBjRG92TDIxbGJXSmxjbk11YjNwbGJXRnBiQzVqYjIwdVlYVXZmbVJsYTJ0bGNpOU9SVlZSVlVGT1ZDNUlWRTFNS1Z4eVhHNGdJQ0FnSUNvZ1FHVjRZVzF3YkdWY2NseHVJQ0FnSUNBcUlISWdQU0JOWVhSb0xtMXBiaWd5TlRVc0lDaHVaWFZ5YjI0dWNpQXJJQ2d4SUR3OElDaHVaWFIzYjNKclFtbGhjMU5vYVdaMElDMGdNU2twS1NBK1BpQnVaWFIzYjNKclFtbGhjMU5vYVdaMEtUdGNjbHh1SUNBZ0lDQXFMMXh5WEc0Z0lDQWdkRzlRYjJsdWRDZ3BJSHRjY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnVUc5cGJuUXVZM0psWVhSbFFubFNSMEpCS0hSb2FYTXVjaUErUGlCdVpYUjNiM0pyUW1saGMxTm9hV1owTENCMGFHbHpMbWNnUGo0Z2JtVjBkMjl5YTBKcFlYTlRhR2xtZEN3Z2RHaHBjeTVpSUQ0K0lHNWxkSGR2Y210Q2FXRnpVMmhwWm5Rc0lIUm9hWE11WVNBK1BpQnVaWFIzYjNKclFtbGhjMU5vYVdaMEtUdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lITjFZblJ5WVdOMEtISXNJR2NzSUdJc0lHRXBJSHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbklnTFQwZ2NqdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxtY2dMVDBnWnp0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG1JZ0xUMGdZanRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbUVnTFQwZ1lUdGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNWxlSEJ2Y25RZ1kyeGhjM01nVG1WMVVYVmhiblJHYkc5aGRDQmxlSFJsYm1SeklFRmljM1J5WVdOMFVHRnNaWFIwWlZGMVlXNTBhWHBsY2lCN1hISmNiaUFnSUNCamIyNXpkSEoxWTNSdmNpaGpiMnh2Y2tScGMzUmhibU5sUTJGc1kzVnNZWFJ2Y2l3Z1kyOXNiM0p6SUQwZ01qVTJLU0I3WEhKY2JpQWdJQ0FnSUNBZ2MzVndaWElvS1R0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5a2FYTjBZVzVqWlNBOUlHTnZiRzl5UkdsemRHRnVZMlZEWVd4amRXeGhkRzl5TzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDNCdmFXNTBRWEp5WVhrZ1BTQmJYVHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDl6WVcxd2JHVkdZV04wYjNJZ1BTQXhPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMjVsZEhkdmNtdFRhWHBsSUQwZ1kyOXNiM0p6TzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJScGMzUmhibU5sTG5ObGRGZG9hWFJsVUc5cGJuUW9NalUxSUR3OElHNWxkSGR2Y210Q2FXRnpVMmhwWm5Rc0lESTFOU0E4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTENBeU5UVWdQRHdnYm1WMGQyOXlhMEpwWVhOVGFHbG1kQ3dnTWpVMUlEdzhJRzVsZEhkdmNtdENhV0Z6VTJocFpuUXBPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdjMkZ0Y0d4bEtIQnZhVzUwUTI5dWRHRnBibVZ5S1NCN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmNHOXBiblJCY25KaGVTQTlJSFJvYVhNdVgzQnZhVzUwUVhKeVlYa3VZMjl1WTJGMEtIQnZhVzUwUTI5dWRHRnBibVZ5TG1kbGRGQnZhVzUwUVhKeVlYa29LU2s3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0FxY1hWaGJuUnBlbVVvS1NCN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmFXNXBkQ2dwTzF4eVhHNGdJQ0FnSUNBZ0lIbHBaV3hrS2lCMGFHbHpMbDlzWldGeWJpZ3BPMXh5WEc0Z0lDQWdJQ0FnSUhscFpXeGtJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdjR0ZzWlhSMFpUb2dkR2hwY3k1ZlluVnBiR1JRWVd4bGRIUmxLQ2tzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSEJ5YjJkeVpYTnpPaUF4TURBc1hISmNiaUFnSUNBZ0lDQWdmVHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJRjlwYm1sMEtDa2dlMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMlp5WlhFZ1BTQmJYVHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlpYVdGeklEMGdXMTA3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmY21Ga1VHOTNaWElnUFNCYlhUdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXVaWFIzYjNKcklEMGdXMTA3WEhKY2JpQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQjBhR2x6TGw5dVpYUjNiM0pyVTJsNlpUc2dhU3NyS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMjVsZEhkdmNtdGJhVjBnUFNCdVpYY2dUbVYxY205dVJteHZZWFFvS0drZ1BEd2dLRzVsZEhkdmNtdENhV0Z6VTJocFpuUWdLeUE0S1NrZ0x5QjBhR2x6TGw5dVpYUjNiM0pyVTJsNlpTazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJREV2ZEdocGN5NWZibVYwZDI5eWExTnBlbVZjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZlpuSmxjVnRwWFNBOUlFNWxkVkYxWVc1MFJteHZZWFF1WDJsdWFYUnBZV3hDYVdGeklDOGdkR2hwY3k1ZmJtVjBkMjl5YTFOcGVtVTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WDJKcFlYTmJhVjBnUFNBd08xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJSDFjY2x4dUlDQWdJQzhxS2x4eVhHNGdJQ0FnSUNvZ1RXRnBiaUJNWldGeWJtbHVaeUJNYjI5d1hISmNiaUFnSUNBZ0tpOWNjbHh1SUNBZ0lDcGZiR1ZoY200b0tTQjdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElITmhiWEJzWlVaaFkzUnZjaUE5SUhSb2FYTXVYM05oYlhCc1pVWmhZM1J2Y2p0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCd2IybHVkSE5PZFcxaVpYSWdQU0IwYUdsekxsOXdiMmx1ZEVGeWNtRjVMbXhsYm1kMGFEdGNjbHh1SUNBZ0lDQWdJQ0JwWmlBb2NHOXBiblJ6VG5WdFltVnlJRHdnVG1WMVVYVmhiblJHYkc5aGRDNWZiV2x1Y0dsamRIVnlaV0o1ZEdWektWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCellXMXdiR1ZHWVdOMGIzSWdQU0F4TzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdGc2NHaGhaR1ZqSUQwZ016QWdLeUFvYzJGdGNHeGxSbUZqZEc5eUlDMGdNU2tnTHlBek8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElIQnZhVzUwYzFSdlUyRnRjR3hsSUQwZ2NHOXBiblJ6VG5WdFltVnlJQzhnYzJGdGNHeGxSbUZqZEc5eU8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCa1pXeDBZU0E5SUhCdmFXNTBjMVJ2VTJGdGNHeGxJQzhnVG1WMVVYVmhiblJHYkc5aGRDNWZia041WTJ4bGN5QjhJREE3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJR0ZzY0doaElEMGdUbVYxVVhWaGJuUkdiRzloZEM1ZmFXNXBkRUZzY0doaE8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCeVlXUnBkWE1nUFNBb2RHaHBjeTVmYm1WMGQyOXlhMU5wZW1VZ1BqNGdNeWtnS2lCT1pYVlJkV0Z1ZEVac2IyRjBMbDl5WVdScGRYTkNhV0Z6TzF4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0J5WVdRZ1BTQnlZV1JwZFhNZ1BqNGdUbVYxVVhWaGJuUkdiRzloZEM1ZmNtRmthWFZ6UW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lHbG1JQ2h5WVdRZ1BEMGdNU2xjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdjbUZrSUQwZ01EdGNjbHh1SUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0JwSUQwZ01Ec2dhU0E4SUhKaFpEc2dhU3NyS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYM0poWkZCdmQyVnlXMmxkSUQwZ1lXeHdhR0VnS2lBb0tDaHlZV1FnS2lCeVlXUWdMU0JwSUNvZ2FTa2dLaUJPWlhWUmRXRnVkRVpzYjJGMExsOXlZV1JDYVdGektTQXZJQ2h5WVdRZ0tpQnlZV1FwS1R0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnYkdWMElITjBaWEE3WEhKY2JpQWdJQ0FnSUNBZ2FXWWdLSEJ2YVc1MGMwNTFiV0psY2lBOElFNWxkVkYxWVc1MFJteHZZWFF1WDIxcGJuQnBZM1IxY21WaWVYUmxjeWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J6ZEdWd0lEMGdNVHRjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdaV3h6WlNCcFppQW9jRzlwYm5SelRuVnRZbVZ5SUNVZ1RtVjFVWFZoYm5SR2JHOWhkQzVmY0hKcGJXVXhJQ0U5UFNBd0tTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lITjBaWEFnUFNCT1pYVlJkV0Z1ZEVac2IyRjBMbDl3Y21sdFpURTdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lHVnNjMlVnYVdZZ0tDaHdiMmx1ZEhOT2RXMWlaWElnSlNCT1pYVlJkV0Z1ZEVac2IyRjBMbDl3Y21sdFpUSXBJQ0U5UFNBd0tTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lITjBaWEFnUFNCT1pYVlJkV0Z1ZEVac2IyRjBMbDl3Y21sdFpUSTdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lHVnNjMlVnYVdZZ0tDaHdiMmx1ZEhOT2RXMWlaWElnSlNCT1pYVlJkV0Z1ZEVac2IyRjBMbDl3Y21sdFpUTXBJQ0U5UFNBd0tTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lITjBaWEFnUFNCT1pYVlJkV0Z1ZEVac2IyRjBMbDl3Y21sdFpUTTdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lHVnNjMlVnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J6ZEdWd0lEMGdUbVYxVVhWaGJuUkdiRzloZEM1ZmNISnBiV1UwTzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQjBjbUZqYTJWeUlEMGdibVYzSUZCeWIyZHlaWE56VkhKaFkydGxjaWh3YjJsdWRITlViMU5oYlhCc1pTd2dPVGtwTzF4eVhHNGdJQ0FnSUNBZ0lHWnZjaUFvYkdWMElHa2dQU0F3TENCd2IybHVkRWx1WkdWNElEMGdNRHNnYVNBOElIQnZhVzUwYzFSdlUyRnRjR3hsT3lrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kSEpoWTJ0bGNpNXphRzkxYkdST2IzUnBabmtvYVNrcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSGxwWld4a0lIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2NtOW5jbVZ6Y3pvZ2RISmhZMnRsY2k1d2NtOW5jbVZ6Y3l4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnY0c5cGJuUWdQU0IwYUdsekxsOXdiMmx1ZEVGeWNtRjVXM0J2YVc1MFNXNWtaWGhkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmlJRDBnY0c5cGJuUXVZaUE4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQm5JRDBnY0c5cGJuUXVaeUE4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnlJRDBnY0c5cGJuUXVjaUE4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmhJRDBnY0c5cGJuUXVZU0E4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnVaWFZ5YjI1SmJtUmxlQ0E5SUhSb2FYTXVYMk52Ym5SbGMzUW9ZaXdnWnl3Z2Npd2dZU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyRnNkR1Z5VTJsdVoyeGxLR0ZzY0doaExDQnVaWFZ5YjI1SmJtUmxlQ3dnWWl3Z1p5d2djaXdnWVNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaHlZV1FnSVQwOUlEQXBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOWhiSFJsY2s1bGFXZG9ZbTkxY2loeVlXUXNJRzVsZFhKdmJrbHVaR1Y0TENCaUxDQm5MQ0J5TENCaEtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0x5b2dZV3gwWlhJZ2JtVnBaMmhpYjNWeWN5QXFMMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQndiMmx1ZEVsdVpHVjRJQ3M5SUhOMFpYQTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2h3YjJsdWRFbHVaR1Y0SUQ0OUlIQnZhVzUwYzA1MWJXSmxjaWxjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhCdmFXNTBTVzVrWlhnZ0xUMGdjRzlwYm5SelRuVnRZbVZ5TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwS3lzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaGtaV3gwWVNBOVBUMGdNQ2xjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdSbGJIUmhJRDBnTVR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHa2dKU0JrWld4MFlTQTlQVDBnTUNrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZV3h3YUdFZ0xUMGdLR0ZzY0doaElDOGdZV3h3YUdGa1pXTXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21Ga2FYVnpJQzA5SUNoeVlXUnBkWE1nTHlCT1pYVlJkV0Z1ZEVac2IyRjBMbDl5WVdScGRYTkVaV055WldGelpTazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WVdRZ1BTQnlZV1JwZFhNZ1BqNGdUbVYxVVhWaGJuUkdiRzloZEM1ZmNtRmthWFZ6UW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSEpoWkNBOFBTQXhLVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmhaQ0E5SURBN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnFJRDBnTURzZ2FpQThJSEpoWkRzZ2Fpc3JLVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WDNKaFpGQnZkMlZ5VzJwZElEMGdZV3h3YUdFZ0tpQW9LQ2h5WVdRZ0tpQnlZV1FnTFNCcUlDb2dhaWtnS2lCT1pYVlJkV0Z1ZEVac2IyRjBMbDl5WVdSQ2FXRnpLU0F2SUNoeVlXUWdLaUJ5WVdRcEtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJSDFjY2x4dUlDQWdJRjlpZFdsc1pGQmhiR1YwZEdVb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdjR0ZzWlhSMFpTQTlJRzVsZHlCUVlXeGxkSFJsS0NrN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmJtVjBkMjl5YXk1bWIzSkZZV05vS0c1bGRYSnZiaUE5UGlCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhCaGJHVjBkR1V1WVdSa0tHNWxkWEp2Ymk1MGIxQnZhVzUwS0NrcE8xeHlYRzRnSUNBZ0lDQWdJSDBwTzF4eVhHNGdJQ0FnSUNBZ0lIQmhiR1YwZEdVdWMyOXlkQ2dwTzF4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCd1lXeGxkSFJsTzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnTHlvcVhISmNiaUFnSUNBZ0tpQk5iM1psSUdGa2FtRmpaVzUwSUc1bGRYSnZibk1nWW5rZ2NISmxZMjl0Y0hWMFpXUWdZV3h3YUdFcUtERXRLQ2hwTFdvcFhqSXZXM0pkWGpJcEtTQnBiaUJ5WVdSd2IzZGxjbHQ4YVMxcWZGMWNjbHh1SUNBZ0lDQXFMMXh5WEc0Z0lDQWdYMkZzZEdWeVRtVnBaMmhpYjNWeUtISmhaQ3dnYVN3Z1lpd2daeXdnY2l3Z1lXd3BJSHRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdiRzhnUFNCcElDMGdjbUZrTzF4eVhHNGdJQ0FnSUNBZ0lHbG1JQ2hzYnlBOElDMHhLVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNieUE5SUMweE8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCb2FTQTlJR2tnS3lCeVlXUTdYSEpjYmlBZ0lDQWdJQ0FnYVdZZ0tHaHBJRDRnZEdocGN5NWZibVYwZDI5eWExTnBlbVVwWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR2hwSUQwZ2RHaHBjeTVmYm1WMGQyOXlhMU5wZW1VN1hISmNiaUFnSUNBZ0lDQWdiR1YwSUdvZ1BTQnBJQ3NnTVR0Y2NseHVJQ0FnSUNBZ0lDQnNaWFFnYXlBOUlHa2dMU0F4TzF4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0J0SUQwZ01UdGNjbHh1SUNBZ0lDQWdJQ0IzYUdsc1pTQW9haUE4SUdocElIeDhJR3NnUGlCc2J5a2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCaElEMGdkR2hwY3k1ZmNtRmtVRzkzWlhKYmJTc3JYU0F2SUU1bGRWRjFZVzUwUm14dllYUXVYMkZzY0doaFVtRmtRbWxoY3p0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHb2dQQ0JvYVNrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2NDQTlJSFJvYVhNdVgyNWxkSGR2Y210YmFpc3JYVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhBdWMzVmlkSEpoWTNRb1lTQXFJQ2h3TG5JZ0xTQnlLU3dnWVNBcUlDaHdMbWNnTFNCbktTd2dZU0FxSUNod0xtSWdMU0JpS1N3Z1lTQXFJQ2h3TG1FZ0xTQmhiQ2twTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNocklENGdiRzhwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhBZ1BTQjBhR2x6TGw5dVpYUjNiM0pyVzJzdExWMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J3TG5OMVluUnlZV04wS0dFZ0tpQW9jQzV5SUMwZ2Npa3NJR0VnS2lBb2NDNW5JQzBnWnlrc0lHRWdLaUFvY0M1aUlDMGdZaWtzSUdFZ0tpQW9jQzVoSUMwZ1lXd3BLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUgxY2NseHVJQ0FnSUM4cUtseHlYRzRnSUNBZ0lDb2dUVzkyWlNCdVpYVnliMjRnYVNCMGIzZGhjbVJ6SUdKcFlYTmxaQ0FvWWl4bkxISXBJR0o1SUdaaFkzUnZjaUJoYkhCb1lWeHlYRzRnSUNBZ0lDb3ZYSEpjYmlBZ0lDQmZZV3gwWlhKVGFXNW5iR1VvWVd4d2FHRXNJR2tzSUdJc0lHY3NJSElzSUdFcElIdGNjbHh1SUNBZ0lDQWdJQ0JoYkhCb1lTQXZQU0JPWlhWUmRXRnVkRVpzYjJGMExsOXBibWwwUVd4d2FHRTdYSEpjYmlBZ0lDQWdJQ0FnTHlvZ1lXeDBaWElnYUdsMElHNWxkWEp2YmlBcUwxeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHNGdQU0IwYUdsekxsOXVaWFIzYjNKclcybGRPMXh5WEc0Z0lDQWdJQ0FnSUc0dWMzVmlkSEpoWTNRb1lXeHdhR0VnS2lBb2JpNXlJQzBnY2lrc0lHRnNjR2hoSUNvZ0tHNHVaeUF0SUdjcExDQmhiSEJvWVNBcUlDaHVMbUlnTFNCaUtTd2dZV3h3YUdFZ0tpQW9iaTVoSUMwZ1lTa3BPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdMeW9xWEhKY2JpQWdJQ0FnS2lCVFpXRnlZMmdnWm05eUlHSnBZWE5sWkNCQ1IxSWdkbUZzZFdWelhISmNiaUFnSUNBZ0tpQmtaWE5qY21sd2RHbHZianBjY2x4dUlDQWdJQ0FxSUNBZ0lHWnBibVJ6SUdOc2IzTmxjM1FnYm1WMWNtOXVJQ2h0YVc0Z1pHbHpkQ2tnWVc1a0lIVndaR0YwWlhNZ1puSmxjVnh5WEc0Z0lDQWdJQ29nSUNBZ1ptbHVaSE1nWW1WemRDQnVaWFZ5YjI0Z0tHMXBiaUJrYVhOMExXSnBZWE1wSUdGdVpDQnlaWFIxY201eklIQnZjMmwwYVc5dVhISmNiaUFnSUNBZ0tpQWdJQ0JtYjNJZ1puSmxjWFZsYm5Sc2VTQmphRzl6Wlc0Z2JtVjFjbTl1Y3l3Z1puSmxjVnRwWFNCcGN5Qm9hV2RvSUdGdVpDQmlhV0Z6VzJsZElHbHpJRzVsWjJGMGFYWmxYSEpjYmlBZ0lDQWdLaUFnSUNCaWFXRnpXMmxkSUQwZ1gyZGhiVzFoS2lnb01TOTBhR2x6TGw5dVpYUjNiM0pyVTJsNlpTa3RabkpsY1Z0cFhTbGNjbHh1SUNBZ0lDQXFYSEpjYmlBZ0lDQWdLaUJQY21sbmFXNWhiQ0JrYVhOMFlXNWpaU0JsY1hWaGRHbHZianBjY2x4dUlDQWdJQ0FxSUNBZ0lDQWdJQ0JrYVhOMElEMGdZV0p6S0dSU0tTQXJJR0ZpY3loa1J5a2dLeUJoWW5Nb1pFSXBYSEpjYmlBZ0lDQWdLaTljY2x4dUlDQWdJRjlqYjI1MFpYTjBLR0lzSUdjc0lISXNJR0ZzS1NCN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2JYVnNkR2x3YkdsbGNpQTlJQ2d5TlRVZ0tpQTBLU0E4UENCdVpYUjNiM0pyUW1saGMxTm9hV1owTzF4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0JpWlhOMFpDQTlJSDRvTVNBOFBDQXpNU2s3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJR0psYzNSaWFXRnpaQ0E5SUdKbGMzUmtPMXh5WEc0Z0lDQWdJQ0FnSUd4bGRDQmlaWE4wY0c5eklEMGdMVEU3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJR0psYzNSaWFXRnpjRzl6SUQwZ1ltVnpkSEJ2Y3p0Y2NseHVJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTURzZ2FTQThJSFJvYVhNdVgyNWxkSGR2Y210VGFYcGxPeUJwS3lzcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnYmlBOUlIUm9hWE11WDI1bGRIZHZjbXRiYVYwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR1JwYzNRZ1BTQjBhR2x6TGw5a2FYTjBZVzVqWlM1allXeGpkV3hoZEdWT2IzSnRZV3hwZW1Wa0tHNHNJSHNnY2l3Z1p5d2dZaXdnWVRvZ1lXd2dmU2tnS2lCdGRXeDBhWEJzYVdWeU8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9aR2x6ZENBOElHSmxjM1JrS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmlaWE4wWkNBOUlHUnBjM1E3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaVpYTjBjRzl6SUQwZ2FUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JpYVdGelpHbHpkQ0E5SUdScGMzUWdMU0FvS0hSb2FYTXVYMkpwWVhOYmFWMHBJRDQrSUNoT1pYVlJkV0Z1ZEVac2IyRjBMbDlwYm1sMGFXRnNRbWxoYzFOb2FXWjBJQzBnYm1WMGQyOXlhMEpwWVhOVGFHbG1kQ2twTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1ltbGhjMlJwYzNRZ1BDQmlaWE4wWW1saGMyUXBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKbGMzUmlhV0Z6WkNBOUlHSnBZWE5rYVhOME8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbVZ6ZEdKcFlYTndiM01nUFNCcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJR0psZEdGbWNtVnhJRDBnS0hSb2FYTXVYMlp5WlhGYmFWMGdQajRnVG1WMVVYVmhiblJHYkc5aGRDNWZZbVYwWVZOb2FXWjBLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZlpuSmxjVnRwWFNBdFBTQmlaWFJoWm5KbGNUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVmWW1saGMxdHBYU0FyUFNBb1ltVjBZV1p5WlhFZ1BEd2dUbVYxVVhWaGJuUkdiRzloZEM1ZloyRnRiV0ZUYUdsbWRDazdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJaeVpYRmJZbVZ6ZEhCdmMxMGdLejBnVG1WMVVYVmhiblJHYkc5aGRDNWZZbVYwWVR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5aWFXRnpXMkpsYzNSd2IzTmRJQzA5SUU1bGRWRjFZVzUwUm14dllYUXVYMkpsZEdGSFlXMXRZVHRjY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWW1WemRHSnBZWE53YjNNN1hISmNiaUFnSUNCOVhISmNibjFjY2x4dUx5cGNjbHh1SUdadmRYSWdjSEpwYldWeklHNWxZWElnTlRBd0lDMGdZWE56ZFcxbElHNXZJR2x0WVdkbElHaGhjeUJoSUd4bGJtZDBhQ0J6YnlCc1lYSm5aVnh5WEc0Z2RHaGhkQ0JwZENCcGN5QmthWFpwYzJsaWJHVWdZbmtnWVd4c0lHWnZkWElnY0hKcGJXVnpYSEpjYmlBcUwxeHlYRzVPWlhWUmRXRnVkRVpzYjJGMExsOXdjbWx0WlRFZ1BTQTBPVGs3WEhKY2JrNWxkVkYxWVc1MFJteHZZWFF1WDNCeWFXMWxNaUE5SURRNU1UdGNjbHh1VG1WMVVYVmhiblJHYkc5aGRDNWZjSEpwYldVeklEMGdORGczTzF4eVhHNU9aWFZSZFdGdWRFWnNiMkYwTGw5d2NtbHRaVFFnUFNBMU1ETTdYSEpjYms1bGRWRjFZVzUwUm14dllYUXVYMjFwYm5CcFkzUjFjbVZpZVhSbGN5QTlJRTVsZFZGMVlXNTBSbXh2WVhRdVgzQnlhVzFsTkR0Y2NseHVMeThnYm04dUlHOW1JR3hsWVhKdWFXNW5JR041WTJ4bGMxeHlYRzVPWlhWUmRXRnVkRVpzYjJGMExsOXVRM2xqYkdWeklEMGdNVEF3TzF4eVhHNHZMeUJrWldaeklHWnZjaUJtY21WeElHRnVaQ0JpYVdGelhISmNiazVsZFZGMVlXNTBSbXh2WVhRdVgybHVhWFJwWVd4Q2FXRnpVMmhwWm5RZ1BTQXhOanRjY2x4dUx5OGdZbWxoY3lCbWIzSWdabkpoWTNScGIyNXpYSEpjYms1bGRWRjFZVzUwUm14dllYUXVYMmx1YVhScFlXeENhV0Z6SUQwZ0tERWdQRHdnVG1WMVVYVmhiblJHYkc5aGRDNWZhVzVwZEdsaGJFSnBZWE5UYUdsbWRDazdYSEpjYms1bGRWRjFZVzUwUm14dllYUXVYMmRoYlcxaFUyaHBablFnUFNBeE1EdGNjbHh1THk4Z1oyRnRiV0VnUFNBeE1ESTBYSEpjYmk4dklGUlBSRTg2SUhkb2VTQm5ZVzF0WVNCcGN5QnVaWFpsY2lCMWMyVmtQMXh5WEc0dkx5QndjbWwyWVhSbElITjBZWFJwWXlCZloyRnRiV0VnT2lCdWRXMWlaWElnSUNBZ0lEMGdLREVnUER3Z1RtVjFVWFZoYm5SR2JHOWhkQzVmWjJGdGJXRlRhR2xtZENrN1hISmNiazVsZFZGMVlXNTBSbXh2WVhRdVgySmxkR0ZUYUdsbWRDQTlJREV3TzF4eVhHNU9aWFZSZFdGdWRFWnNiMkYwTGw5aVpYUmhJRDBnS0U1bGRWRjFZVzUwUm14dllYUXVYMmx1YVhScFlXeENhV0Z6SUQ0K0lFNWxkVkYxWVc1MFJteHZZWFF1WDJKbGRHRlRhR2xtZENrN1hISmNiaTh2SUdKbGRHRWdQU0F4THpFd01qUmNjbHh1VG1WMVVYVmhiblJHYkc5aGRDNWZZbVYwWVVkaGJXMWhJRDBnS0U1bGRWRjFZVzUwUm14dllYUXVYMmx1YVhScFlXeENhV0Z6SUR3OElDaE9aWFZSZFdGdWRFWnNiMkYwTGw5bllXMXRZVk5vYVdaMElDMGdUbVYxVVhWaGJuUkdiRzloZEM1ZlltVjBZVk5vYVdaMEtTazdYSEpjYmk4cVhISmNiaUFxSUdadmNpQXlOVFlnWTI5c2N5d2djbUZrYVhWeklITjBZWEowYzF4eVhHNGdLaTljY2x4dVRtVjFVWFZoYm5SR2JHOWhkQzVmY21Ga2FYVnpRbWxoYzFOb2FXWjBJRDBnTmp0Y2NseHVMeThnWVhRZ016SXVNQ0JpYVdGelpXUWdZbmtnTmlCaWFYUnpYSEpjYms1bGRWRjFZVzUwUm14dllYUXVYM0poWkdsMWMwSnBZWE1nUFNBeElEdzhJRTVsZFZGMVlXNTBSbXh2WVhRdVgzSmhaR2wxYzBKcFlYTlRhR2xtZER0Y2NseHVMeThnWVc1a0lHUmxZM0psWVhObGN5QmllU0JoSUdaaFkzUnZjaUJ2WmlBeEx6TXdJR1ZoWTJnZ1kzbGpiR1ZjY2x4dVRtVjFVWFZoYm5SR2JHOWhkQzVmY21Ga2FYVnpSR1ZqY21WaGMyVWdQU0F6TUR0Y2NseHVMeW9nWkdWbWN5Qm1iM0lnWkdWamNtVmhjMmx1WnlCaGJIQm9ZU0JtWVdOMGIzSWdLaTljY2x4dUx5OGdZV3h3YUdFZ2MzUmhjblJ6SUdGMElERXVNRnh5WEc1T1pYVlJkV0Z1ZEVac2IyRjBMbDloYkhCb1lVSnBZWE5UYUdsbWRDQTlJREV3TzF4eVhHNHZMeUJpYVdGelpXUWdZbmtnTVRBZ1ltbDBjMXh5WEc1T1pYVlJkV0Z1ZEVac2IyRjBMbDlwYm1sMFFXeHdhR0VnUFNBb01TQThQQ0JPWlhWUmRXRnVkRVpzYjJGMExsOWhiSEJvWVVKcFlYTlRhR2xtZENrN1hISmNiaThxSUhKaFpFSnBZWE1nWVc1a0lHRnNjR2hoVW1Ga1FtbGhjeUIxYzJWa0lHWnZjaUJ5WVdSd2IzZGxjaUJqWVd4amRXeGhkR2x2YmlBcUwxeHlYRzVPWlhWUmRXRnVkRVpzYjJGMExsOXlZV1JDYVdGelUyaHBablFnUFNBNE8xeHlYRzVPWlhWUmRXRnVkRVpzYjJGMExsOXlZV1JDYVdGeklEMGdNU0E4UENCT1pYVlJkV0Z1ZEVac2IyRjBMbDl5WVdSQ2FXRnpVMmhwWm5RN1hISmNiazVsZFZGMVlXNTBSbXh2WVhRdVgyRnNjR2hoVW1Ga1FtbGhjMU5vYVdaMElEMGdUbVYxVVhWaGJuUkdiRzloZEM1ZllXeHdhR0ZDYVdGelUyaHBablFnS3lCT1pYVlJkV0Z1ZEVac2IyRjBMbDl5WVdSQ2FXRnpVMmhwWm5RN1hISmNiazVsZFZGMVlXNTBSbXh2WVhRdVgyRnNjR2hoVW1Ga1FtbGhjeUE5SURFZ1BEd2dUbVYxVVhWaGJuUkdiRzloZEM1ZllXeHdhR0ZTWVdSQ2FXRnpVMmhwWm5RN1hISmNiaTh2SXlCemIzVnlZMlZOWVhCd2FXNW5WVkpNUFc1bGRYRjFZVzUwUm14dllYUXVhbk11YldGd0lpd2laWGh3YjNKMElHTnNZWE56SUVGaWMzUnlZV04wVUdGc1pYUjBaVkYxWVc1MGFYcGxjaUI3WEhKY2JpQWdJQ0J4ZFdGdWRHbDZaVk41Ym1Nb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnWm05eUlDaGpiMjV6ZENCMllXeDFaU0J2WmlCMGFHbHpMbkYxWVc1MGFYcGxLQ2twSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIWmhiSFZsTG5CaGJHVjBkR1VwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCMllXeDFaUzV3WVd4bGRIUmxPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnbmRXNXlaV0ZqYUdGaWJHVW5LVHRjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxd1lXeGxkSFJsVVhWaGJuUnBlbVZ5TG1wekxtMWhjQ0lzSWk4cVhISmNiaUFxSUVOdmNIbHlhV2RvZENBb1l5a2dNakF4TlN3Z1RHVnZiaUJUYjNKdmEybHVYSEpjYmlBcUlFRnNiQ0J5YVdkb2RITWdjbVZ6WlhKMlpXUXVJQ2hOU1ZRZ1RHbGpaVzV6WldRcFhISmNiaUFxWEhKY2JpQXFJRU52Ykc5eVNHbHpkRzluY21GdExtcHpJQzBnWVc0Z2FXMWhaMlVnY1hWaGJuUnBlbUYwYVc5dUlHeHBZbHh5WEc0Z0tpOWNjbHh1THlvcVhISmNiaUFxSUVCd2NtVnpaWEoyWlNCVWVYQmxVMk55YVhCMElIQnZjblE2WEhKY2JpQXFJRU52Y0hseWFXZG9kQ0F5TURFMUxUSXdNVGdnU1dkdmNpQkNaWHByY205MmJubHBYSEpjYmlBcUlFRnNiQ0J5YVdkb2RITWdjbVZ6WlhKMlpXUXVJQ2hOU1ZRZ1RHbGpaVzV6WldRcFhISmNiaUFxWEhKY2JpQXFJR052Ykc5eVNHbHpkRzluY21GdExuUnpJQzBnY0dGeWRDQnZaaUJKYldGblpTQlJkV0Z1ZEdsNllYUnBiMjRnVEdsaWNtRnllVnh5WEc0Z0tpOWNjbHh1YVcxd2IzSjBJSHNnU0hWbFUzUmhkR2x6ZEdsamN5QjlJR1p5YjIwZ0p5NHVMeTR1TDNWMGFXeHpMMmgxWlZOMFlYUnBjM1JwWTNNbk8xeHlYRzVwYlhCdmNuUWdleUJ6ZEdGaWJHVlRiM0owSUgwZ1puSnZiU0FuTGk0dkxpNHZkWFJwYkhNdllYSnBkR2h0WlhScFl5YzdYSEpjYm1WNGNHOXlkQ0JqYkdGemN5QkRiMnh2Y2tocGMzUnZaM0poYlNCN1hISmNiaUFnSUNCamIyNXpkSEoxWTNSdmNpaHRaWFJvYjJRc0lHTnZiRzl5Y3lrZ2UxeHlYRzRnSUNBZ0lDQWdJQzh2SURFZ1BTQmllU0JuYkc5aVlXd2djRzl3ZFd4aGRHbHZiaXdnTWlBOUlITjFZbkpsWjJsdmJpQndiM0IxYkdGMGFXOXVJSFJvY21WemFHOXNaRnh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMjFsZEdodlpDQTlJRzFsZEdodlpEdGNjbHh1SUNBZ0lDQWdJQ0F2THlCcFppQStJREFzSUdWdVlXSnNaWE1nYUhWbGN5QnpkR0YwY3lCaGJtUWdiV2x1TFdOdmJHOXlJSEpsZEdWdWRHbHZiaUJ3WlhJZ1ozSnZkWEJjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDl0YVc1SWRXVkRiMnh6SUQwZ1kyOXNiM0p6SUR3OElESTdJQzh2SUc5d2RITXViV2x1U0hWbFEyOXNjeUI4ZkNBd08xeHlYRzRnSUNBZ0lDQWdJQzh2SUNNZ2IyWWdhR2xuYUdWemRDMW1jbVZ4ZFdWdVkza2dZMjlzYjNKeklIUnZJSE4wWVhKMElIZHBkR2dnWm05eUlIQmhiR1YwZEdVZ2NtVmtkV04wYVc5dVhISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmFXNXBkRU52Ykc5eWN5QTlJR052Ykc5eWN5QThQQ0F5TzF4eVhHNGdJQ0FnSUNBZ0lDOHZJRWgxWlZOMFlYUnBjM1JwWTNNZ2FXNXpkR0Z1WTJWY2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5b2RXVlRkR0YwY3lBOUlHNWxkeUJJZFdWVGRHRjBhWE4wYVdOektFTnZiRzl5U0dsemRHOW5jbUZ0TGw5b2RXVkhjbTkxY0hNc0lIUm9hWE11WDIxcGJraDFaVU52YkhNcE8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgyaHBjM1J2WjNKaGJTQTlJRTlpYW1WamRDNWpjbVZoZEdVb2JuVnNiQ2s3SUM4dklIUnpiR2x1ZERwa2FYTmhZbXhsTFd4cGJtVTZibTh0Ym5Wc2JDMXJaWGwzYjNKa1hISmNiaUFnSUNCOVhISmNiaUFnSUNCellXMXdiR1VvY0c5cGJuUkRiMjUwWVdsdVpYSXBJSHRjY2x4dUlDQWdJQ0FnSUNCemQybDBZMmdnS0hSb2FYTXVYMjFsZEdodlpDa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZWE5sSURFNlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5amIyeHZjbE4wWVhSek1VUW9jRzlwYm5SRGIyNTBZV2x1WlhJcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdNanBjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMk52Ykc5eVUzUmhkSE15UkNod2IybHVkRU52Ym5SaGFXNWxjaWs3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaWNtVmhhenRjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNCOVhISmNiaUFnSUNCblpYUkpiWEJ2Y25SaGJtTmxVMjl5ZEdWa1EyOXNiM0p6U1VSWVNUTXlLQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDOHZJRlJQUkU4NklHWnBlQ0IwZVhCcGJtY2dhWE56ZFdVZ2FXNGdjM1JoWW14bFUyOXlkQ0JtZFc1alhISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2MyOXlkR1ZrSUQwZ2MzUmhZbXhsVTI5eWRDaFBZbXBsWTNRdWEyVjVjeWgwYUdsekxsOW9hWE4wYjJkeVlXMHBMQ0FvWVN3Z1lpa2dQVDRnZEdocGN5NWZhR2x6ZEc5bmNtRnRXMkpkSUMwZ2RHaHBjeTVmYUdsemRHOW5jbUZ0VzJGZEtUdGNjbHh1SUNBZ0lDQWdJQ0JwWmlBb2MyOXlkR1ZrTG14bGJtZDBhQ0E5UFQwZ01Da2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z1cxMDdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0JwWkhocE16STdYSEpjYmlBZ0lDQWdJQ0FnYzNkcGRHTm9JQ2gwYUdsekxsOXRaWFJvYjJRcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyRnpaU0F4T2x4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnYVc1cGRHbGhiRU52Ykc5eWMweHBiV2wwSUQwZ1RXRjBhQzV0YVc0b2MyOXlkR1ZrTG14bGJtZDBhQ3dnZEdocGN5NWZhVzVwZEVOdmJHOXljeWs3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JzWVhOMElEMGdjMjl5ZEdWa1cybHVhWFJwWVd4RGIyeHZjbk5NYVcxcGRDQXRJREZkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWm5KbGNTQTlJSFJvYVhNdVgyaHBjM1J2WjNKaGJWdHNZWE4wWFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtlR2t6TWlBOUlITnZjblJsWkM1emJHbGpaU2d3TENCcGJtbDBhV0ZzUTI5c2IzSnpUR2x0YVhRcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnWVdSa0lHRnVlU0JqZFhRZ2IyWm1JR052Ykc5eWN5QjNhWFJvSUhOaGJXVWdabkpsY1NCaGN5QnNZWE4wWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCc1pYUWdjRzl6SUQwZ2FXNXBkR2xoYkVOdmJHOXljMHhwYldsME8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2JHVnVJRDBnYzI5eWRHVmtMbXhsYm1kMGFEdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSGRvYVd4bElDaHdiM01nUENCc1pXNGdKaVlnZEdocGN5NWZhR2x6ZEc5bmNtRnRXM052Y25SbFpGdHdiM05kWFNBOVBUMGdabkpsY1NrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsa2VHa3pNaTV3ZFhOb0tITnZjblJsWkZ0d2IzTXJLMTBwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnYVc1cVpXTjBJRzFwYmlCb2RXVm5jbTkxY0NCamIyeHZjbk5jY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMmgxWlZOMFlYUnpMbWx1YW1WamRFbHVkRzlCY25KaGVTaHBaSGhwTXpJcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdNanBjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsa2VHa3pNaUE5SUhOdmNuUmxaRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmtaV1poZFd4ME9seHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMeThnVkU5RVR6b2djbVYwYUdsdWF5Qmxjbkp2Y25OY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnblNXNWpiM0p5WldOMElHMWxkR2h2WkNjcE8xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBdkx5QnBiblF6TWkxcFpua2dkbUZzZFdWelhISmNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHbGtlR2t6TWk1dFlYQW9ablZ1WTNScGIyNGdLSFlwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJQ3QyTzF4eVhHNGdJQ0FnSUNBZ0lIMHBPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdMeThnWjJ4dlltRnNJSFJ2Y0Mxd2IzQjFiR0YwYVc5dVhISmNiaUFnSUNCZlkyOXNiM0pUZEdGMGN6RkVLSEJ2YVc1MFEyOXVkR0ZwYm1WeUtTQjdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdhR2x6ZEVjZ1BTQjBhR2x6TGw5b2FYTjBiMmR5WVcwN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2NHOXBiblJCY25KaGVTQTlJSEJ2YVc1MFEyOXVkR0ZwYm1WeUxtZGxkRkJ2YVc1MFFYSnlZWGtvS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCc1pXNGdQU0J3YjJsdWRFRnljbUY1TG14bGJtZDBhRHRjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCcElEMGdNRHNnYVNBOElHeGxianNnYVNzcktTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdOdmJDQTlJSEJ2YVc1MFFYSnlZWGxiYVYwdWRXbHVkRE15TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCamIyeHNaV04wSUdoMVpTQnpkR0YwYzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOW9kV1ZUZEdGMGN5NWphR1ZqYXloamIyd3BPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvWTI5c0lHbHVJR2hwYzNSSEtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JvYVhOMFIxdGpiMnhkS3lzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWld4elpTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JvYVhOMFIxdGpiMnhkSUQwZ01UdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJSDFjY2x4dUlDQWdJQzh2SUhCdmNIVnNZWFJwYjI0Z2RHaHlaWE5vYjJ4a0lIZHBkR2hwYmlCemRXSnlaV2RwYjI1elhISmNiaUFnSUNBdkx5QkdTVmhOUlRvZ2RHaHBjeUJqWVc0Z2IzWmxjaTF5WldSMVkyVWdLR1psZHk5dWJ5QmpiMnh2Y25NZ2MyRnRaVDhwTENCdVpXVmtJR0VnZDJGNUlIUnZJR3RsWlhCY2NseHVJQ0FnSUM4dklHbHRjRzl5ZEdGdWRDQmpiMnh2Y25NZ2RHaGhkQ0JrYjI1MElHVjJaWElnY21WaFkyZ2diRzlqWVd3Z2RHaHlaWE5vYjJ4a2N5QW9aM0poWkdsbGJuUnpQeWxjY2x4dUlDQWdJRjlqYjJ4dmNsTjBZWFJ6TWtRb2NHOXBiblJEYjI1MFlXbHVaWElwSUh0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCM2FXUjBhQ0E5SUhCdmFXNTBRMjl1ZEdGcGJtVnlMbWRsZEZkcFpIUm9LQ2s3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYUdWcFoyaDBJRDBnY0c5cGJuUkRiMjUwWVdsdVpYSXVaMlYwU0dWcFoyaDBLQ2s3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnY0c5cGJuUkJjbkpoZVNBOUlIQnZhVzUwUTI5dWRHRnBibVZ5TG1kbGRGQnZhVzUwUVhKeVlYa29LVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JpYjNoWElEMGdRMjlzYjNKSWFYTjBiMmR5WVcwdVgySnZlRk5wZW1WYk1GMDdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZbTk0U0NBOUlFTnZiRzl5U0dsemRHOW5jbUZ0TGw5aWIzaFRhWHBsV3pGZE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHRnlaV0VnUFNCaWIzaFhJQ29nWW05NFNEdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQmliM2hsY3lBOUlIUm9hWE11WDIxaGEyVkNiM2hsY3loM2FXUjBhQ3dnYUdWcFoyaDBMQ0JpYjNoWExDQmliM2hJS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCb2FYTjBSeUE5SUhSb2FYTXVYMmhwYzNSdlozSmhiVHRjY2x4dUlDQWdJQ0FnSUNCaWIzaGxjeTVtYjNKRllXTm9LR0p2ZUNBOVBpQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHeGxkQ0JsWm1aaklEMGdUV0YwYUM1eWIzVnVaQ2dvWW05NExuY2dLaUJpYjNndWFDa2dMeUJoY21WaEtTQXFJRU52Ykc5eVNHbHpkRzluY21GdExsOWliM2hRYVhobGJITTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hsWm1aaklEd2dNaWxjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdWbVptTWdQU0F5TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQm9hWE4wVENBOUlIdDlPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5cGRHVnlZWFJsUW05NEtHSnZlQ3dnZDJsa2RHZ3NJQ2hwS1NBOVBpQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmpiMndnUFNCd2IybHVkRUZ5Y21GNVcybGRMblZwYm5Rek1qdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUdOdmJHeGxZM1FnYUhWbElITjBZWFJ6WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDlvZFdWVGRHRjBjeTVqYUdWamF5aGpiMndwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR052YkNCcGJpQm9hWE4wUnlrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdocGMzUkhXMk52YkYwckt6dGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdWc2MyVWdhV1lnS0dOdmJDQnBiaUJvYVhOMFRDa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2dySzJocGMzUk1XMk52YkYwZ1BqMGdaV1ptWXlrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm9hWE4wUjF0amIyeGRJRDBnYUdsemRFeGJZMjlzWFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxiSE5sSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JvYVhOMFRGdGpiMnhkSUQwZ01UdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdmU2s3WEhKY2JpQWdJQ0FnSUNBZ2ZTazdYSEpjYmlBZ0lDQWdJQ0FnTHk4Z2FXNXFaV04wSUcxcGJpQm9kV1ZuY205MWNDQmpiMnh2Y25OY2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5b2RXVlRkR0YwY3k1cGJtcGxZM1JKYm5SdlJHbGpkR2x2Ym1GeWVTaG9hWE4wUnlrN1hISmNiaUFnSUNCOVhISmNiaUFnSUNBdkx5QnBkR1Z5WVhSbGN5QkFZbUp2ZUNCM2FYUm9hVzRnWVNCd1lYSmxiblFnY21WamRDQnZaaUIzYVdSMGFDQkFkMmxrT3lCallXeHNjeUJBWm00c0lIQmhjM05wYm1jZ2FXNWtaWGdnZDJsMGFHbHVJSEJoY21WdWRGeHlYRzRnSUNBZ1gybDBaWEpoZEdWQ2IzZ29ZbUp2ZUN3Z2QybGtMQ0JtYmlrZ2UxeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHSWdQU0JpWW05NE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHa3dJRDBnWWk1NUlDb2dkMmxrSUNzZ1lpNTRPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR2t4SUQwZ0tHSXVlU0FySUdJdWFDQXRJREVwSUNvZ2QybGtJQ3NnS0dJdWVDQXJJR0l1ZHlBdElERXBPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR2x1WTNJZ1BTQjNhV1FnTFNCaUxuY2dLeUF4TzF4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0JqYm5RZ1BTQXdPMXh5WEc0Z0lDQWdJQ0FnSUd4bGRDQnBJRDBnYVRBN1hISmNiaUFnSUNBZ0lDQWdaRzhnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JtYmk1allXeHNLSFJvYVhNc0lHa3BPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBJQ3M5SUNncksyTnVkQ0FsSUdJdWR5QTlQVDBnTUNrZ1B5QnBibU55SURvZ01UdGNjbHh1SUNBZ0lDQWdJQ0I5SUhkb2FXeGxJQ2hwSUR3OUlHa3hLVHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJQzhxS2x4eVhHNGdJQ0FnSUNvZ0lDQWdjR0Z5ZEdsMGFXOXVjeUJoSUhKbFkzUmhibWRzWlNCdlppQjNhV1IwYUNCNElHaGxhV2RvZENCcGJuUnZYSEpjYmlBZ0lDQWdLaUFnSUNCaGNuSmhlU0J2WmlCaWIzaGxjeUJ6ZEdWd1dDQjRJSE4wWlhCWklDaHZjaUJzWlhOektWeHlYRzRnSUNBZ0lDb3ZYSEpjYmlBZ0lDQmZiV0ZyWlVKdmVHVnpLSGRwWkhSb0xDQm9aV2xuYUhRc0lITjBaWEJZTENCemRHVndXU2tnZTF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhkeVpXMGdQU0IzYVdSMGFDQWxJSE4wWlhCWU8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHaHlaVzBnUFNCb1pXbG5hSFFnSlNCemRHVndXVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0I0Wlc1a0lEMGdkMmxrZEdnZ0xTQjNjbVZ0TzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhsbGJtUWdQU0JvWldsbmFIUWdMU0JvY21WdE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHSnZlR1Z6UVhKeVlYa2dQU0JiWFR0Y2NseHVJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQjVJRDBnTURzZ2VTQThJR2hsYVdkb2REc2dlU0FyUFNCemRHVndXU2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0I0SUQwZ01Ec2dlQ0E4SUhkcFpIUm9PeUI0SUNzOUlITjBaWEJZS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmliM2hsYzBGeWNtRjVMbkIxYzJnb2V5QjRMQ0I1TENCM09pQW9lQ0E5UFQwZ2VHVnVaQ0EvSUhkeVpXMGdPaUJ6ZEdWd1dDa3NJR2c2SUNoNUlEMDlQU0I1Wlc1a0lEOGdhSEpsYlNBNklITjBaWEJaS1NCOUtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWW05NFpYTkJjbkpoZVR0Y2NseHVJQ0FnSUgxY2NseHVmVnh5WEc1RGIyeHZja2hwYzNSdlozSmhiUzVmWW05NFUybDZaU0E5SUZzMk5Dd2dOalJkTzF4eVhHNURiMnh2Y2tocGMzUnZaM0poYlM1ZlltOTRVR2w0Wld4eklEMGdNanRjY2x4dVEyOXNiM0pJYVhOMGIyZHlZVzB1WDJoMVpVZHliM1Z3Y3lBOUlERXdPMXh5WEc0dkx5TWdjMjkxY21ObFRXRndjR2x1WjFWU1REMWpiMnh2Y2tocGMzUnZaM0poYlM1cWN5NXRZWEFpTENJdktseHlYRzRnS2lCRGIzQjVjbWxuYUhRZ0tHTXBJREl3TVRVc0lFeGxiMjRnVTI5eWIydHBibHh5WEc0Z0tpQkJiR3dnY21sbmFIUnpJSEpsYzJWeWRtVmtMaUFvVFVsVUlFeHBZMlZ1YzJWa0tWeHlYRzRnS2x4eVhHNGdLaUJTUjBKUmRXRnVkQzVxY3lBdElHRnVJR2x0WVdkbElIRjFZVzUwYVhwaGRHbHZiaUJzYVdKY2NseHVJQ292WEhKY2JpOHFLbHh5WEc0Z0tpQkFjSEpsYzJWeWRtVWdWSGx3WlZOamNtbHdkQ0J3YjNKME9seHlYRzRnS2lCRGIzQjVjbWxuYUhRZ01qQXhOUzB5TURFNElFbG5iM0lnUW1WNmEzSnZkbTU1YVZ4eVhHNGdLaUJCYkd3Z2NtbG5hSFJ6SUhKbGMyVnlkbVZrTGlBb1RVbFVJRXhwWTJWdWMyVmtLVnh5WEc0Z0tseHlYRzRnS2lCeVoySnhkV0Z1ZEM1MGN5QXRJSEJoY25RZ2IyWWdTVzFoWjJVZ1VYVmhiblJwZW1GMGFXOXVJRXhwWW5KaGNubGNjbHh1SUNvdlhISmNibWx0Y0c5eWRDQjdJRkJoYkdWMGRHVWdmU0JtY205dElDY3VMaTh1TGk5MWRHbHNjeTl3WVd4bGRIUmxKenRjY2x4dWFXMXdiM0owSUhzZ1VHOXBiblFnZlNCbWNtOXRJQ2N1TGk4dUxpOTFkR2xzY3k5d2IybHVkQ2M3WEhKY2JtbHRjRzl5ZENCN0lFTnZiRzl5U0dsemRHOW5jbUZ0SUgwZ1puSnZiU0FuTGk5amIyeHZja2hwYzNSdlozSmhiU2M3WEhKY2JtbHRjRzl5ZENCN0lFRmljM1J5WVdOMFVHRnNaWFIwWlZGMVlXNTBhWHBsY2lCOUlHWnliMjBnSnk0dUwzQmhiR1YwZEdWUmRXRnVkR2w2WlhJbk8xeHlYRzVwYlhCdmNuUWdleUJ6ZEdGaWJHVlRiM0owSUgwZ1puSnZiU0FuTGk0dkxpNHZkWFJwYkhNdllYSnBkR2h0WlhScFl5YzdYSEpjYm1sdGNHOXlkQ0I3SUZCeWIyZHlaWE56VkhKaFkydGxjaUI5SUdaeWIyMGdKeTR1THk0dUwzVjBhV3h6Snp0Y2NseHVZMnhoYzNNZ1VtVnRiM1psWkVOdmJHOXlJSHRjY2x4dUlDQWdJR052Ym5OMGNuVmpkRzl5S0dsdVpHVjRMQ0JqYjJ4dmNpd2daR2x6ZEdGdVkyVXBJSHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbWx1WkdWNElEMGdhVzVrWlhnN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1amIyeHZjaUE5SUdOdmJHOXlPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVaR2x6ZEdGdVkyVWdQU0JrYVhOMFlXNWpaVHRjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzR2THlCVVQwUlBPaUJ0WVd0bElHbHVjSFYwTDI5MWRIQjFkQ0JwYldGblpTQmhibVFnYVc1d2RYUXZiM1YwY0hWMElIQmhiR1YwZEdWeklIZHBkR2dnYVc1emRHRnVZMlZ6SUc5bUlHTnNZWE56SUZCdmFXNTBJRzl1YkhraFhISmNibVY0Y0c5eWRDQmpiR0Z6Y3lCU1IwSlJkV0Z1ZENCbGVIUmxibVJ6SUVGaWMzUnlZV04wVUdGc1pYUjBaVkYxWVc1MGFYcGxjaUI3WEhKY2JpQWdJQ0JqYjI1emRISjFZM1J2Y2loamIyeHZja1JwYzNSaGJtTmxRMkZzWTNWc1lYUnZjaXdnWTI5c2IzSnpJRDBnTWpVMkxDQnRaWFJvYjJRZ1BTQXlLU0I3WEhKY2JpQWdJQ0FnSUNBZ2MzVndaWElvS1R0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5a2FYTjBZVzVqWlNBOUlHTnZiRzl5UkdsemRHRnVZMlZEWVd4amRXeGhkRzl5TzF4eVhHNGdJQ0FnSUNBZ0lDOHZJR1JsYzJseVpXUWdabWx1WVd3Z2NHRnNaWFIwWlNCemFYcGxYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZMjlzYjNKeklEMGdZMjlzYjNKek8xeHlYRzRnSUNBZ0lDQWdJQzh2SUdocGMzUnZaM0poYlNCMGJ5QmhZMk4xYlhWc1lYUmxYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZhR2x6ZEc5bmNtRnRJRDBnYm1WM0lFTnZiRzl5U0dsemRHOW5jbUZ0S0cxbGRHaHZaQ3dnWTI5c2IzSnpLVHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlwYm1sMGFXRnNSR2x6ZEdGdVkyVWdQU0F3TGpBeE8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgyUnBjM1JoYm1ObFNXNWpjbVZ0Wlc1MElEMGdNQzR3TURVN1hISmNiaUFnSUNCOVhISmNiaUFnSUNBdkx5Qm5ZWFJvWlhKeklHaHBjM1J2WjNKaGJTQnBibVp2WEhKY2JpQWdJQ0J6WVcxd2JHVW9hVzFoWjJVcElIdGNjbHh1SUNBZ0lDQWdJQ0F2S2x4eVhHNGdJQ0FnSUNBZ0lDQjJZWElnY0c5cGJuUkJjbkpoZVNBOUlHbHRZV2RsTG1kbGRGQnZhVzUwUVhKeVlYa29LU3dnYldGNElEMGdXekFzSURBc0lEQXNJREJkTENCdGFXNGdQU0JiTWpVMUxDQXlOVFVzSURJMU5Td2dNalUxWFR0Y2NseHVJQ0FnSUZ4eVhHNGdJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JDQTlJSEJ2YVc1MFFYSnlZWGt1YkdWdVozUm9PeUJwSUR3Z2JEc2dhU3NyS1NCN1hISmNiaUFnSUNBZ0lDQWdJSFpoY2lCamIyeHZjaUE5SUhCdmFXNTBRWEp5WVhsYmFWMDdYSEpjYmlBZ0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdOdmJYQnZibVZ1ZEVsdVpHVjRJRDBnTURzZ1kyOXRjRzl1Wlc1MFNXNWtaWGdnUENBME95QmpiMjF3YjI1bGJuUkpibVJsZUNzcktTQjdYSEpjYmlBZ0lDQWdJQ0FnSUdsbUlDaHRZWGhiWTI5dGNHOXVaVzUwU1c1a1pYaGRJRHdnWTI5c2IzSXVjbWRpWVZ0amIyMXdiMjVsYm5SSmJtUmxlRjBwSUcxaGVGdGpiMjF3YjI1bGJuUkpibVJsZUYwZ1BTQmpiMnh2Y2k1eVoySmhXMk52YlhCdmJtVnVkRWx1WkdWNFhUdGNjbHh1SUNBZ0lDQWdJQ0FnYVdZZ0tHMXBibHRqYjIxd2IyNWxiblJKYm1SbGVGMGdQaUJqYjJ4dmNpNXlaMkpoVzJOdmJYQnZibVZ1ZEVsdVpHVjRYU2tnYldsdVcyTnZiWEJ2Ym1WdWRFbHVaR1Y0WFNBOUlHTnZiRzl5TG5KblltRmJZMjl0Y0c5dVpXNTBTVzVrWlhoZE8xeHlYRzRnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnZG1GeUlISmtJRDBnYldGNFd6QmRJQzBnYldsdVd6QmRMQ0JuWkNBOUlHMWhlRnN4WFNBdElHMXBibHN4WFN3Z1ltUWdQU0J0WVhoYk1sMGdMU0J0YVc1Yk1sMHNJR0ZrSUQwZ2JXRjRXek5kSUMwZ2JXbHVXek5kTzF4eVhHNGdJQ0FnSUNBZ0lDQjBhR2x6TGw5a2FYTjBZVzVqWlM1elpYUlhhR2wwWlZCdmFXNTBLSEprTENCblpDd2dZbVFzSUdGa0tUdGNjbHh1SUNBZ0lGeHlYRzRnSUNBZ0lDQWdJQ0IwYUdsekxsOXBibWwwYVdGc1JHbHpkR0Z1WTJVZ1BTQW9UV0YwYUM1emNYSjBLSEprSUNvZ2NtUWdLeUJuWkNBcUlHZGtJQ3NnWW1RZ0tpQmlaQ0FySUdGa0lDb2dZV1FwSUM4Z1RXRjBhQzV6Y1hKMEtESTFOU0FxSURJMU5TQXJJREkxTlNBcUlESTFOU0FySURJMU5TQXFJREkxTlNrcElDb2dNQzR3TVR0Y2NseHVJQ0FnSUNBZ0lDQWdLaTljY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlvYVhOMGIyZHlZVzB1YzJGdGNHeGxLR2x0WVdkbEtUdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lDOHZJSEpsWkhWalpYTWdhR2x6ZEc5bmNtRnRJSFJ2SUhCaGJHVjBkR1VzSUhKbGJXRndjeUFtSUcxbGJXOXBlbVZ6SUhKbFpIVmpaV1FnWTI5c2IzSnpYSEpjYmlBZ0lDQXFjWFZoYm5ScGVtVW9LU0I3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYVdSNGFUTXlJRDBnZEdocGN5NWZhR2x6ZEc5bmNtRnRMbWRsZEVsdGNHOXlkR0Z1WTJWVGIzSjBaV1JEYjJ4dmNuTkpSRmhKTXpJb0tUdGNjbHh1SUNBZ0lDQWdJQ0JwWmlBb2FXUjRhVE15TG14bGJtZDBhQ0E5UFQwZ01Da2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owNXZJR052Ykc5eWN5QnBiaUJwYldGblpTY3BPMXh5WEc0Z0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQjVhV1ZzWkNvZ2RHaHBjeTVmWW5WcGJHUlFZV3hsZEhSbEtHbGtlR2t6TWlrN1hISmNiaUFnSUNCOVhISmNiaUFnSUNBdkx5QnlaV1IxWTJWeklITnBiV2xzWVhJZ1kyOXNiM0p6SUdaeWIyMGdZVzRnYVcxd2IzSjBZVzVqWlMxemIzSjBaV1FnVldsdWRETXlJSEpuWW1FZ1lYSnlZWGxjY2x4dUlDQWdJQ3BmWW5WcGJHUlFZV3hsZEhSbEtHbGtlR2t6TWlrZ2UxeHlYRzRnSUNBZ0lDQWdJQzh2SUhKbFpIVmpaU0JvYVhOMGIyZHlZVzBnZEc4Z1kzSmxZWFJsSUdsdWFYUnBZV3dnY0dGc1pYUjBaVnh5WEc0Z0lDQWdJQ0FnSUM4dklHSjFhV3hrSUdaMWJHd2djbWRpSUhCaGJHVjBkR1ZjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0J3WVd4bGRIUmxJRDBnYm1WM0lGQmhiR1YwZEdVb0tUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQmpiMnh2Y2tGeWNtRjVJRDBnY0dGc1pYUjBaUzVuWlhSUWIybHVkRU52Ym5SaGFXNWxjaWdwTG1kbGRGQnZhVzUwUVhKeVlYa29LVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0IxYzJGblpVRnljbUY1SUQwZ2JtVjNJRUZ5Y21GNUtHbGtlR2t6TWk1c1pXNW5kR2dwT3lBdkx5QjBjMnhwYm5RNlpHbHpZV0pzWlMxc2FXNWxPbkJ5WldabGNpMWhjbkpoZVMxc2FYUmxjbUZzWEhKY2JpQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQnBaSGhwTXpJdWJHVnVaM1JvT3lCcEt5c3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMjlzYjNKQmNuSmhlUzV3ZFhOb0tGQnZhVzUwTG1OeVpXRjBaVUo1VldsdWRETXlLR2xrZUdrek1sdHBYU2twTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0IxYzJGblpVRnljbUY1VzJsZElEMGdNVHRjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2JHVnVJRDBnWTI5c2IzSkJjbkpoZVM1c1pXNW5kR2c3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYldWdFJHbHpkQ0E5SUZ0ZE8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCd1lXeE1aVzRnUFNCc1pXNDdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElIUm9iMnhrSUQwZ2RHaHBjeTVmYVc1cGRHbGhiRVJwYzNSaGJtTmxPMXh5WEc0Z0lDQWdJQ0FnSUM4dklIQmhiR1YwZEdVZ1lXeHlaV0ZrZVNCaGRDQnZjaUJpWld4dmR5QmtaWE5wY21Wa0lHeGxibWQwYUZ4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhSeVlXTnJaWElnUFNCdVpYY2dVSEp2WjNKbGMzTlVjbUZqYTJWeUtIQmhiRXhsYmlBdElIUm9hWE11WDJOdmJHOXljeXdnT1RrcE8xeHlYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaHdZV3hNWlc0Z1BpQjBhR2x6TGw5amIyeHZjbk1wSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYldWdFJHbHpkQzVzWlc1bmRHZ2dQU0F3TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCcGRHVnlZWFJsSUhCaGJHVjBkR1ZjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdabTl5SUNoc1pYUWdhU0E5SURBN0lHa2dQQ0JzWlc0N0lHa3JLeWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSFJ5WVdOclpYSXVjMmh2ZFd4a1RtOTBhV1o1S0d4bGJpQXRJSEJoYkV4bGJpa3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjVhV1ZzWkNCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIQnliMmR5WlhOek9pQjBjbUZqYTJWeUxuQnliMmR5WlhOekxGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2RYTmhaMlZCY25KaGVWdHBYU0E5UFQwZ01DbGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNTBhVzUxWlR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhCNGFTQTlJR052Ykc5eVFYSnlZWGxiYVYwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJwWmlBb0lYQjRhU2tnWTI5dWRHbHVkV1U3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbWIzSWdLR3hsZENCcUlEMGdhU0FySURFN0lHb2dQQ0JzWlc0N0lHb3JLeWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoMWMyRm5aVUZ5Y21GNVcycGRJRDA5UFNBd0tWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjUwYVc1MVpUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0J3ZUdvZ1BTQmpiMnh2Y2tGeWNtRjVXMnBkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUdsbUlDZ2hjSGhxS1NCamIyNTBhVzUxWlR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmthWE4wSUQwZ2RHaHBjeTVmWkdsemRHRnVZMlV1WTJGc1kzVnNZWFJsVG05eWJXRnNhWHBsWkNod2VHa3NJSEI0YWlrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHUnBjM1FnUENCMGFHOXNaQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QnpkRzl5WlNCcGJtUmxlQ3h5WjJJc1pHbHpkRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0WlcxRWFYTjBMbkIxYzJnb2JtVjNJRkpsYlc5MlpXUkRiMnh2Y2locUxDQndlR29zSUdScGMzUXBLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZFhOaFoyVkJjbkpoZVZ0cVhTQTlJREE3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhCaGJFeGxiaTB0TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCd1lXeGxkSFJsSUhKbFpIVmpkR2x2YmlCd1lYTnpYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJR052Ym5OdmJHVXViRzluS0Z3aWNHRnNaWFIwWlNCc1pXNW5kR2c2SUZ3aUlDc2djR0ZzVEdWdUtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdhV1lnY0dGc1pYUjBaU0JwY3lCemRHbHNiQ0J0ZFdOb0lHeGhjbWRsY2lCMGFHRnVJSFJoY21kbGRDd2dhVzVqY21WdFpXNTBJR0o1SUd4aGNtZGxjaUJwYm1sMFJHbHpkRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhRzlzWkNBclBTQW9jR0ZzVEdWdUlENGdkR2hwY3k1ZlkyOXNiM0p6SUNvZ015a2dQeUIwYUdsekxsOXBibWwwYVdGc1JHbHpkR0Z1WTJVZ09pQjBhR2x6TGw5a2FYTjBZVzVqWlVsdVkzSmxiV1Z1ZER0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnTHk4Z2FXWWdjR0ZzWlhSMFpTQnBjeUJ2ZG1WeUxYSmxaSFZqWldRc0lISmxMV0ZrWkNCeVpXMXZkbVZrSUdOdmJHOXljeUIzYVhSb0lHeGhjbWRsYzNRZ1pHbHpkR0Z1WTJWeklHWnliMjBnYkdGemRDQnliM1Z1WkZ4eVhHNGdJQ0FnSUNBZ0lHbG1JQ2h3WVd4TVpXNGdQQ0IwYUdsekxsOWpiMnh2Y25NcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdjMjl5ZENCa1pYTmpaVzVrYVc1blhISmNiaUFnSUNBZ0lDQWdJQ0FnSUhOMFlXSnNaVk52Y25Rb2JXVnRSR2x6ZEN3Z1puVnVZM1JwYjI0Z0tHRXNJR0lwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCaUxtUnBjM1JoYm1ObElDMGdZUzVrYVhOMFlXNWpaVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdmU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR3hsZENCcklEMGdNRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkMmhwYkdVZ0tIQmhiRXhsYmlBOElIUm9hWE11WDJOdmJHOXljeUFtSmlCcklEd2diV1Z0UkdsemRDNXNaVzVuZEdncElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElISmxiVzkyWldSRGIyeHZjaUE5SUcxbGJVUnBjM1JiYTEwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJ5WlMxcGJtcGxZM1FnY21kaUlHbHVkRzhnWm1sdVlXd2djR0ZzWlhSMFpWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkWE5oWjJWQmNuSmhlVnR5WlcxdmRtVmtRMjlzYjNJdWFXNWtaWGhkSUQwZ01UdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEJoYkV4bGJpc3JPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYXlzck8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUd4bGRDQmpiMnh2Y25NZ1BTQmpiMnh2Y2tGeWNtRjVMbXhsYm1kMGFEdGNjbHh1SUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0JqYjJ4dmNrbHVaR1Y0SUQwZ1kyOXNiM0p6SUMwZ01Uc2dZMjlzYjNKSmJtUmxlQ0ErUFNBd095QmpiMnh2Y2tsdVpHVjRMUzBwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIVnpZV2RsUVhKeVlYbGJZMjlzYjNKSmJtUmxlRjBnUFQwOUlEQXBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaGpiMnh2Y2tsdVpHVjRJQ0U5UFNCamIyeHZjbk1nTFNBeEtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXNiM0pCY25KaGVWdGpiMnh2Y2tsdVpHVjRYU0E5SUdOdmJHOXlRWEp5WVhsYlkyOXNiM0p6SUMwZ01WMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdExXTnZiRzl5Y3p0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0JqYjJ4dmNrRnljbUY1TG14bGJtZDBhQ0E5SUdOdmJHOXljenRjY2x4dUlDQWdJQ0FnSUNCd1lXeGxkSFJsTG5OdmNuUW9LVHRjY2x4dUlDQWdJQ0FnSUNCNWFXVnNaQ0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSEJoYkdWMGRHVXNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIQnliMmR5WlhOek9pQXhNREFzWEhKY2JpQWdJQ0FnSUNBZ2ZUdGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNHZMeU1nYzI5MWNtTmxUV0Z3Y0dsdVoxVlNURDF5WjJKeGRXRnVkQzVxY3k1dFlYQWlMQ0l2S2lwY2NseHVJQ29nUUhCeVpYTmxjblpsWEhKY2JpQXFJRU52Y0hseWFXZG9kQ0F5TURFMUxUSXdNVGdnU1dkdmNpQkNaWHByY205MmJubHBYSEpjYmlBcUlFRnNiQ0J5YVdkb2RITWdjbVZ6WlhKMlpXUXVJQ2hOU1ZRZ1RHbGpaVzV6WldRcFhISmNiaUFxWEhKY2JpQXFJSGQxVVhWaGJuUXVkSE1nTFNCd1lYSjBJRzltSUVsdFlXZGxJRkYxWVc1MGFYcGhkR2x2YmlCTWFXSnlZWEo1WEhKY2JpQXFMMXh5WEc1cGJYQnZjblFnZXlCUVlXeGxkSFJsSUgwZ1puSnZiU0FuTGk0dkxpNHZkWFJwYkhNdmNHRnNaWFIwWlNjN1hISmNibWx0Y0c5eWRDQjdJRkJ2YVc1MElIMGdabkp2YlNBbkxpNHZMaTR2ZFhScGJITXZjRzlwYm5Rbk8xeHlYRzVwYlhCdmNuUWdleUJCWW5OMGNtRmpkRkJoYkdWMGRHVlJkV0Z1ZEdsNlpYSWdmU0JtY205dElDY3VMaTl3WVd4bGRIUmxVWFZoYm5ScGVtVnlKenRjY2x4dWFXMXdiM0owSUhzZ1VISnZaM0psYzNOVWNtRmphMlZ5SUgwZ1puSnZiU0FuTGk0dkxpNHZkWFJwYkhNbk8xeHlYRzVtZFc1amRHbHZiaUJqY21WaGRHVkJjbkpoZVRGRUtHUnBiV1Z1YzJsdmJqRXBJSHRjY2x4dUlDQWdJR052Ym5OMElHRWdQU0JiWFR0Y2NseHVJQ0FnSUdadmNpQW9iR1YwSUdzZ1BTQXdPeUJySUR3Z1pHbHRaVzV6YVc5dU1Uc2dheXNyS1NCN1hISmNiaUFnSUNBZ0lDQWdZVnRyWFNBOUlEQTdYSEpjYmlBZ0lDQjlYSEpjYmlBZ0lDQnlaWFIxY200Z1lUdGNjbHh1ZlZ4eVhHNW1kVzVqZEdsdmJpQmpjbVZoZEdWQmNuSmhlVFJFS0dScGJXVnVjMmx2YmpFc0lHUnBiV1Z1YzJsdmJqSXNJR1JwYldWdWMybHZiak1zSUdScGJXVnVjMmx2YmpRcElIdGNjbHh1SUNBZ0lHTnZibk4wSUdFZ1BTQnVaWGNnUVhKeVlYa29aR2x0Wlc1emFXOXVNU2s3WEhKY2JpQWdJQ0JtYjNJZ0tHeGxkQ0JwSUQwZ01Ec2dhU0E4SUdScGJXVnVjMmx2YmpFN0lHa3JLeWtnZTF4eVhHNGdJQ0FnSUNBZ0lHRmJhVjBnUFNCdVpYY2dRWEp5WVhrb1pHbHRaVzV6YVc5dU1pazdYSEpjYmlBZ0lDQWdJQ0FnWm05eUlDaHNaWFFnYWlBOUlEQTdJR29nUENCa2FXMWxibk5wYjI0eU95QnFLeXNwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWVZ0cFhWdHFYU0E5SUc1bGR5QkJjbkpoZVNoa2FXMWxibk5wYjI0ektUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2F5QTlJREE3SUdzZ1BDQmthVzFsYm5OcGIyNHpPeUJyS3lzcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0ZiYVYxYmFsMWJhMTBnUFNCdVpYY2dRWEp5WVhrb1pHbHRaVzV6YVc5dU5DazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0JzSUQwZ01Ec2diQ0E4SUdScGJXVnVjMmx2YmpRN0lHd3JLeWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0ZiYVYxYmFsMWJhMTFiYkYwZ1BTQXdPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ2NtVjBkWEp1SUdFN1hISmNibjFjY2x4dVpuVnVZM1JwYjI0Z1kzSmxZWFJsUVhKeVlYa3pSQ2hrYVcxbGJuTnBiMjR4TENCa2FXMWxibk5wYjI0eUxDQmthVzFsYm5OcGIyNHpLU0I3WEhKY2JpQWdJQ0JqYjI1emRDQmhJRDBnYm1WM0lFRnljbUY1S0dScGJXVnVjMmx2YmpFcE8xeHlYRzRnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQmthVzFsYm5OcGIyNHhPeUJwS3lzcElIdGNjbHh1SUNBZ0lDQWdJQ0JoVzJsZElEMGdibVYzSUVGeWNtRjVLR1JwYldWdWMybHZiaklwTzF4eVhHNGdJQ0FnSUNBZ0lHWnZjaUFvYkdWMElHb2dQU0F3T3lCcUlEd2daR2x0Wlc1emFXOXVNanNnYWlzcktTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHRmJhVjFiYWwwZ1BTQnVaWGNnUVhKeVlYa29aR2x0Wlc1emFXOXVNeWs3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJR3NnUFNBd095QnJJRHdnWkdsdFpXNXphVzl1TXpzZ2F5c3JLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFcybGRXMnBkVzJ0ZElEMGdNRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhKbGRIVnliaUJoTzF4eVhHNTlYSEpjYm1aMWJtTjBhVzl1SUdacGJHeEJjbkpoZVRORUtHRXNJR1JwYldWdWMybHZiakVzSUdScGJXVnVjMmx2YmpJc0lHUnBiV1Z1YzJsdmJqTXNJSFpoYkhWbEtTQjdYSEpjYmlBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTURzZ2FTQThJR1JwYldWdWMybHZiakU3SUdrckt5a2dlMXh5WEc0Z0lDQWdJQ0FnSUdGYmFWMGdQU0JiWFR0Y2NseHVJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnFJRDBnTURzZ2FpQThJR1JwYldWdWMybHZiakk3SUdvckt5a2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmhXMmxkVzJwZElEMGdXMTA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJR3NnUFNBd095QnJJRHdnWkdsdFpXNXphVzl1TXpzZ2F5c3JLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaFcybGRXMnBkVzJ0ZElEMGdkbUZzZFdVN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQjlYSEpjYm4xY2NseHVablZ1WTNScGIyNGdabWxzYkVGeWNtRjVNVVFvWVN3Z1pHbHRaVzV6YVc5dU1Td2dkbUZzZFdVcElIdGNjbHh1SUNBZ0lHWnZjaUFvYkdWMElHa2dQU0F3T3lCcElEd2daR2x0Wlc1emFXOXVNVHNnYVNzcktTQjdYSEpjYmlBZ0lDQWdJQ0FnWVZ0cFhTQTlJSFpoYkhWbE8xeHlYRzRnSUNBZ2ZWeHlYRzU5WEhKY2JtVjRjRzl5ZENCamJHRnpjeUJYZFVOdmJHOXlRM1ZpWlNCN1hISmNibjFjY2x4dVpYaHdiM0owSUdOc1lYTnpJRmQxVVhWaGJuUWdaWGgwWlc1a2N5QkJZbk4wY21GamRGQmhiR1YwZEdWUmRXRnVkR2w2WlhJZ2UxeHlYRzRnSUNBZ1kyOXVjM1J5ZFdOMGIzSW9ZMjlzYjNKRWFYTjBZVzVqWlVOaGJHTjFiR0YwYjNJc0lHTnZiRzl5Y3lBOUlESTFOaXdnYzJsbmJtbG1hV05oYm5SQ2FYUnpVR1Z5UTJoaGJtNWxiQ0E5SURVcElIdGNjbHh1SUNBZ0lDQWdJQ0J6ZFhCbGNpZ3BPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMlJwYzNSaGJtTmxJRDBnWTI5c2IzSkVhWE4wWVc1alpVTmhiR04xYkdGMGIzSTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZjMlYwVVhWaGJHbDBlU2h6YVdkdWFXWnBZMkZ1ZEVKcGRITlFaWEpEYUdGdWJtVnNLVHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlwYm1sMGFXRnNhWHBsS0dOdmJHOXljeWs3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0J6WVcxd2JHVW9hVzFoWjJVcElIdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQndiMmx1ZEVGeWNtRjVJRDBnYVcxaFoyVXVaMlYwVUc5cGJuUkJjbkpoZVNncE8xeHlYRzRnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJR2tnUFNBd0xDQnNJRDBnY0c5cGJuUkJjbkpoZVM1c1pXNW5kR2c3SUdrZ1BDQnNPeUJwS3lzcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVmWVdSa1EyOXNiM0lvY0c5cGJuUkJjbkpoZVZ0cFhTazdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDNCcGVHVnNjeUE5SUhSb2FYTXVYM0JwZUdWc2N5NWpiMjVqWVhRb2NHOXBiblJCY25KaGVTazdYSEpjYmlBZ0lDQjlYSEpjYmlBZ0lDQXFjWFZoYm5ScGVtVW9LU0I3WEhKY2JpQWdJQ0FnSUNBZ2VXbGxiR1FxSUhSb2FYTXVYM0J5WlhCaGNtVlFZV3hsZEhSbEtDazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdjR0ZzWlhSMFpTQTlJRzVsZHlCUVlXeGxkSFJsS0NrN1hISmNiaUFnSUNBZ0lDQWdMeThnWjJWdVpYSmhkR1Z6SUhCaGJHVjBkR1ZjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCd1lXeGxkSFJsU1c1a1pYZ2dQU0F3T3lCd1lXeGxkSFJsU1c1a1pYZ2dQQ0IwYUdsekxsOWpiMnh2Y25NN0lIQmhiR1YwZEdWSmJtUmxlQ3NyS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaDBhR2x6TGw5emRXMXpXM0JoYkdWMGRHVkpibVJsZUYwZ1BpQXdLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0J6ZFcwZ1BTQjBhR2x6TGw5emRXMXpXM0JoYkdWMGRHVkpibVJsZUYwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCeUlEMGdkR2hwY3k1ZmNtVmtjMXR3WVd4bGRIUmxTVzVrWlhoZElDOGdjM1Z0TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWnlBOUlIUm9hWE11WDJkeVpXVnVjMXR3WVd4bGRIUmxTVzVrWlhoZElDOGdjM1Z0TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWWlBOUlIUm9hWE11WDJKc2RXVnpXM0JoYkdWMGRHVkpibVJsZUYwZ0x5QnpkVzA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JoSUQwZ2RHaHBjeTVmWVd4d2FHRnpXM0JoYkdWMGRHVkpibVJsZUYwZ0x5QnpkVzA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JqYjJ4dmNpQTlJRkJ2YVc1MExtTnlaV0YwWlVKNVVrZENRU2h5SUh3Z01Dd2daeUI4SURBc0lHSWdmQ0F3TENCaElId2dNQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCd1lXeGxkSFJsTG1Ga1pDaGpiMnh2Y2lrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnY0dGc1pYUjBaUzV6YjNKMEtDazdYSEpjYmlBZ0lDQWdJQ0FnZVdsbGJHUWdlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQndZV3hsZEhSbExGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCd2NtOW5jbVZ6Y3pvZ01UQXdMRnh5WEc0Z0lDQWdJQ0FnSUgwN1hISmNiaUFnSUNCOVhISmNiaUFnSUNBcVgzQnlaWEJoY21WUVlXeGxkSFJsS0NrZ2UxeHlYRzRnSUNBZ0lDQWdJQzh2SUhCeVpYQnliMk5sYzNNZ2RHaGxJR052Ykc5eWMxeHlYRzRnSUNBZ0lDQWdJSGxwWld4a0tpQjBhR2x6TGw5allXeGpkV3hoZEdWTmIyMWxiblJ6S0NrN1hISmNiaUFnSUNBZ0lDQWdiR1YwSUc1bGVIUWdQU0F3TzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhadmJIVnRaVlpoY21saGJtTmxJRDBnWTNKbFlYUmxRWEp5WVhreFJDaDBhR2x6TGw5amIyeHZjbk1wTzF4eVhHNGdJQ0FnSUNBZ0lDOHZJSEJ5YjJObGMzTmxjeUIwYUdVZ1kzVmlaWE5jY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCamRXSmxTVzVrWlhnZ1BTQXhPeUJqZFdKbFNXNWtaWGdnUENCMGFHbHpMbDlqYjJ4dmNuTTdJQ3NyWTNWaVpVbHVaR1Y0S1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklHbG1JR04xZENCcGN5QndiM056YVdKc1pUc2diV0ZyWlNCcGRGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwY3k1ZlkzVjBLSFJvYVhNdVgyTjFZbVZ6VzI1bGVIUmRMQ0IwYUdsekxsOWpkV0psYzF0amRXSmxTVzVrWlhoZEtTa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZG05c2RXMWxWbUZ5YVdGdVkyVmJibVY0ZEYwZ1BTQjBhR2x6TGw5amRXSmxjMXR1WlhoMFhTNTJiMngxYldVZ1BpQXhJRDhnZEdocGN5NWZZMkZzWTNWc1lYUmxWbUZ5YVdGdVkyVW9kR2hwY3k1ZlkzVmlaWE5iYm1WNGRGMHBJRG9nTUM0d08xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbTlzZFcxbFZtRnlhV0Z1WTJWYlkzVmlaVWx1WkdWNFhTQTlJSFJvYVhNdVgyTjFZbVZ6VzJOMVltVkpibVJsZUYwdWRtOXNkVzFsSUQ0Z01TQS9JSFJvYVhNdVgyTmhiR04xYkdGMFpWWmhjbWxoYm1ObEtIUm9hWE11WDJOMVltVnpXMk4xWW1WSmJtUmxlRjBwSURvZ01DNHdPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHVnNjMlVnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0x5OGdkR2hsSUdOMWRDQjNZWE1nYm05MElIQnZjM05wWW14bExDQnlaWFpsY25RZ2RHaGxJR2x1WkdWNFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjJiMngxYldWV1lYSnBZVzVqWlZ0dVpYaDBYU0E5SURBdU1EdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR04xWW1WSmJtUmxlQzB0TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJRzVsZUhRZ1BTQXdPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNaWFFnZEdWdGNDQTlJSFp2YkhWdFpWWmhjbWxoYm1ObFd6QmRPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnBibVJsZUNBOUlERTdJR2x1WkdWNElEdzlJR04xWW1WSmJtUmxlRHNnS3l0cGJtUmxlQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSFp2YkhWdFpWWmhjbWxoYm1ObFcybHVaR1Y0WFNBK0lIUmxiWEFwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwWlcxd0lEMGdkbTlzZFcxbFZtRnlhV0Z1WTJWYmFXNWtaWGhkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzVsZUhRZ1BTQnBibVJsZUR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR1Z0Y0NBOFBTQXdMakFwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WDJOdmJHOXljeUE5SUdOMVltVkpibVJsZUNBcklERTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JpY21WaGF6dGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JzYjI5cmRYQlNaV1FnUFNCYlhUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQnNiMjlyZFhCSGNtVmxiaUE5SUZ0ZE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHeHZiMnQxY0VKc2RXVWdQU0JiWFR0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCc2IyOXJkWEJCYkhCb1lTQTlJRnRkTzF4eVhHNGdJQ0FnSUNBZ0lDOHZJSEJ5WldOaGJHTjFiR0YwWlhNZ2JHOXZhM1Z3SUhSaFlteGxjMXh5WEc0Z0lDQWdJQ0FnSUdadmNpQW9iR1YwSUdzZ1BTQXdPeUJySUR3Z2RHaHBjeTVmWTI5c2IzSnpPeUFySzJzcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnZDJWcFoyaDBJRDBnVjNWUmRXRnVkQzVmZG05c2RXMWxLSFJvYVhNdVgyTjFZbVZ6VzJ0ZExDQjBhR2x6TGw5M1pXbG5hSFJ6S1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIZGxhV2RvZENBK0lEQXBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUd4dmIydDFjRkpsWkZ0clhTQTlJQ2hYZFZGMVlXNTBMbDkyYjJ4MWJXVW9kR2hwY3k1ZlkzVmlaWE5iYTEwc0lIUm9hWE11WDIxdmJXVnVkSE5TWldRcElDOGdkMlZwWjJoMEtTQjhJREE3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCc2IyOXJkWEJIY21WbGJsdHJYU0E5SUNoWGRWRjFZVzUwTGw5MmIyeDFiV1VvZEdocGN5NWZZM1ZpWlhOYmExMHNJSFJvYVhNdVgyMXZiV1Z1ZEhOSGNtVmxiaWtnTHlCM1pXbG5hSFFwSUh3Z01EdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3h2YjJ0MWNFSnNkV1ZiYTEwZ1BTQW9WM1ZSZFdGdWRDNWZkbTlzZFcxbEtIUm9hWE11WDJOMVltVnpXMnRkTENCMGFHbHpMbDl0YjIxbGJuUnpRbXgxWlNrZ0x5QjNaV2xuYUhRcElId2dNRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUd4dmIydDFjRUZzY0doaFcydGRJRDBnS0ZkMVVYVmhiblF1WDNadmJIVnRaU2gwYUdsekxsOWpkV0psYzF0clhTd2dkR2hwY3k1ZmJXOXRaVzUwYzBGc2NHaGhLU0F2SUhkbGFXZG9kQ2tnZkNBd08xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUdWc2MyVWdlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYkc5dmEzVndVbVZrVzJ0ZElEMGdNRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUd4dmIydDFjRWR5WldWdVcydGRJRDBnTUR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHeHZiMnQxY0VKc2RXVmJhMTBnUFNBd08xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiRzl2YTNWd1FXeHdhR0ZiYTEwZ1BTQXdPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDNKbFpITWdQU0JqY21WaGRHVkJjbkpoZVRGRUtIUm9hWE11WDJOdmJHOXljeUFySURFcE8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgyZHlaV1Z1Y3lBOUlHTnlaV0YwWlVGeWNtRjVNVVFvZEdocGN5NWZZMjlzYjNKeklDc2dNU2s3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmWW14MVpYTWdQU0JqY21WaGRHVkJjbkpoZVRGRUtIUm9hWE11WDJOdmJHOXljeUFySURFcE8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgyRnNjR2hoY3lBOUlHTnlaV0YwWlVGeWNtRjVNVVFvZEdocGN5NWZZMjlzYjNKeklDc2dNU2s3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmYzNWdGN5QTlJR055WldGMFpVRnljbUY1TVVRb2RHaHBjeTVmWTI5c2IzSnpJQ3NnTVNrN1hISmNiaUFnSUNBZ0lDQWdMeThnYzJOaGJuTWdZVzVrSUdGa1pITWdZMjlzYjNKelhISmNiaUFnSUNBZ0lDQWdabTl5SUNoc1pYUWdhVzVrWlhnZ1BTQXdMQ0JzSUQwZ2RHaHBjeTVmY0dsNFpXeHpMbXhsYm1kMGFEc2dhVzVrWlhnZ1BDQnNPeUJwYm1SbGVDc3JLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHTnZiRzl5SUQwZ2RHaHBjeTVmY0dsNFpXeHpXMmx1WkdWNFhUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnYldGMFkyZ2dQU0F0TVR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHSmxjM1JOWVhSamFDQTlJRzFoZEdOb08xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCc1pYUWdZbVZ6ZEVScGMzUmhibU5sSUQwZ1RuVnRZbVZ5TGsxQldGOVdRVXhWUlR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWm05eUlDaHNaWFFnYkc5dmEzVndJRDBnTURzZ2JHOXZhM1Z3SUR3Z2RHaHBjeTVmWTI5c2IzSnpPeUJzYjI5cmRYQXJLeWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWm05MWJtUlNaV1FnUFNCc2IyOXJkWEJTWldSYmJHOXZhM1Z3WFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdadmRXNWtSM0psWlc0Z1BTQnNiMjlyZFhCSGNtVmxibHRzYjI5cmRYQmRPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdabTkxYm1SQ2JIVmxJRDBnYkc5dmEzVndRbXgxWlZ0c2IyOXJkWEJkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWm05MWJtUkJiSEJvWVNBOUlHeHZiMnQxY0VGc2NHaGhXMnh2YjJ0MWNGMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQmthWE4wWVc1alpTQTlJSFJvYVhNdVgyUnBjM1JoYm1ObExtTmhiR04xYkdGMFpWSmhkeWhtYjNWdVpGSmxaQ3dnWm05MWJtUkhjbVZsYml3Z1ptOTFibVJDYkhWbExDQm1iM1Z1WkVGc2NHaGhMQ0JqYjJ4dmNpNXlMQ0JqYjJ4dmNpNW5MQ0JqYjJ4dmNpNWlMQ0JqYjJ4dmNpNWhLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaGthWE4wWVc1alpTQThJR0psYzNSRWFYTjBZVzVqWlNrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKbGMzUkVhWE4wWVc1alpTQTlJR1JwYzNSaGJtTmxPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHSmxjM1JOWVhSamFDQTlJR3h2YjJ0MWNEdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5eVpXUnpXMkpsYzNSTllYUmphRjBnS3owZ1kyOXNiM0l1Y2p0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWZaM0psWlc1elcySmxjM1JOWVhSamFGMGdLejBnWTI5c2IzSXVaenRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZllteDFaWE5iWW1WemRFMWhkR05vWFNBclBTQmpiMnh2Y2k1aU8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDloYkhCb1lYTmJZbVZ6ZEUxaGRHTm9YU0FyUFNCamIyeHZjaTVoTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOXpkVzF6VzJKbGMzUk5ZWFJqYUYwckt6dGNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0JmWVdSa1EyOXNiM0lvWTI5c2IzSXBJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JpYVhSelZHOVNaVzF2ZG1VZ1BTQTRJQzBnZEdocGN5NWZjMmxuYm1sbWFXTmhiblJDYVhSelVHVnlRMmhoYm01bGJEdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQnBibVJsZUZKbFpDQTlJQ2hqYjJ4dmNpNXlJRDQrSUdKcGRITlViMUpsYlc5MlpTa2dLeUF4TzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdsdVpHVjRSM0psWlc0Z1BTQW9ZMjlzYjNJdVp5QStQaUJpYVhSelZHOVNaVzF2ZG1VcElDc2dNVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JwYm1SbGVFSnNkV1VnUFNBb1kyOXNiM0l1WWlBK1BpQmlhWFJ6Vkc5U1pXMXZkbVVwSUNzZ01UdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQnBibVJsZUVGc2NHaGhJRDBnS0dOdmJHOXlMbUVnUGo0Z1ltbDBjMVJ2VW1WdGIzWmxLU0FySURFN1hISmNiaUFnSUNBZ0lDQWdMeThnYVdZb1kyOXNiM0l1WVNBK0lERXdLU0I3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmZDJWcFoyaDBjMXRwYm1SbGVFRnNjR2hoWFZ0cGJtUmxlRkpsWkYxYmFXNWtaWGhIY21WbGJsMWJhVzVrWlhoQ2JIVmxYU3NyTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDIxdmJXVnVkSE5TWldSYmFXNWtaWGhCYkhCb1lWMWJhVzVrWlhoU1pXUmRXMmx1WkdWNFIzSmxaVzVkVzJsdVpHVjRRbXgxWlYwZ0t6MGdZMjlzYjNJdWNqdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXRiMjFsYm5SelIzSmxaVzViYVc1a1pYaEJiSEJvWVYxYmFXNWtaWGhTWldSZFcybHVaR1Y0UjNKbFpXNWRXMmx1WkdWNFFteDFaVjBnS3owZ1kyOXNiM0l1Wnp0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5dGIyMWxiblJ6UW14MVpWdHBibVJsZUVGc2NHaGhYVnRwYm1SbGVGSmxaRjFiYVc1a1pYaEhjbVZsYmwxYmFXNWtaWGhDYkhWbFhTQXJQU0JqYjJ4dmNpNWlPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMjF2YldWdWRITkJiSEJvWVZ0cGJtUmxlRUZzY0doaFhWdHBibVJsZUZKbFpGMWJhVzVrWlhoSGNtVmxibDFiYVc1a1pYaENiSFZsWFNBclBTQmpiMnh2Y2k1aE8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgyMXZiV1Z1ZEhOYmFXNWtaWGhCYkhCb1lWMWJhVzVrWlhoU1pXUmRXMmx1WkdWNFIzSmxaVzVkVzJsdVpHVjRRbXgxWlYwZ0t6MGdkR2hwY3k1ZmRHRmliR1ZiWTI5c2IzSXVjbDBnS3lCMGFHbHpMbDkwWVdKc1pWdGpiMnh2Y2k1blhTQXJJSFJvYVhNdVgzUmhZbXhsVzJOdmJHOXlMbUpkSUNzZ2RHaHBjeTVmZEdGaWJHVmJZMjlzYjNJdVlWMDdYSEpjYmlBZ0lDQWdJQ0FnTHk4Z2ZWeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ0x5b3FYSEpjYmlBZ0lDQWdLaUJEYjI1MlpYSjBjeUIwYUdVZ2FHbHpkRzluY21GdElIUnZJR0VnYzJWeWFXVnpJRzltSUY5dGIyMWxiblJ6TGx4eVhHNGdJQ0FnSUNvdlhISmNiaUFnSUNBcVgyTmhiR04xYkdGMFpVMXZiV1Z1ZEhNb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZWEpsWVNBOUlGdGRPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR0Z5WldGU1pXUWdQU0JiWFR0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCaGNtVmhSM0psWlc0Z1BTQmJYVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JoY21WaFFteDFaU0E5SUZ0ZE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHRnlaV0ZCYkhCb1lTQTlJRnRkTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdGeVpXRXlJRDBnVzEwN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2VHRnlaV0VnUFNCamNtVmhkR1ZCY25KaGVUTkVLSFJvYVhNdVgzTnBaR1ZUYVhwbExDQjBhR2x6TGw5emFXUmxVMmw2WlN3Z2RHaHBjeTVmYzJsa1pWTnBlbVVwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhoaGNtVmhVbVZrSUQwZ1kzSmxZWFJsUVhKeVlYa3pSQ2gwYUdsekxsOXphV1JsVTJsNlpTd2dkR2hwY3k1ZmMybGtaVk5wZW1Vc0lIUm9hWE11WDNOcFpHVlRhWHBsS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCNFlYSmxZVWR5WldWdUlEMGdZM0psWVhSbFFYSnlZWGt6UkNoMGFHbHpMbDl6YVdSbFUybDZaU3dnZEdocGN5NWZjMmxrWlZOcGVtVXNJSFJvYVhNdVgzTnBaR1ZUYVhwbEtUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQjRZWEpsWVVKc2RXVWdQU0JqY21WaGRHVkJjbkpoZVRORUtIUm9hWE11WDNOcFpHVlRhWHBsTENCMGFHbHpMbDl6YVdSbFUybDZaU3dnZEdocGN5NWZjMmxrWlZOcGVtVXBPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSGhoY21WaFFXeHdhR0VnUFNCamNtVmhkR1ZCY25KaGVUTkVLSFJvYVhNdVgzTnBaR1ZUYVhwbExDQjBhR2x6TGw5emFXUmxVMmw2WlN3Z2RHaHBjeTVmYzJsa1pWTnBlbVVwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhoaGNtVmhNaUE5SUdOeVpXRjBaVUZ5Y21GNU0wUW9kR2hwY3k1ZmMybGtaVk5wZW1Vc0lIUm9hWE11WDNOcFpHVlRhWHBsTENCMGFHbHpMbDl6YVdSbFUybDZaU2s3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJSFJ5WVdOclpYSlFjbTluY21WemN5QTlJREE3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnZEhKaFkydGxjaUE5SUc1bGR5QlFjbTluY21WemMxUnlZV05yWlhJb2RHaHBjeTVmWVd4d2FHRk5ZWGhUYVdSbFNXNWtaWGdnS2lCMGFHbHpMbDl0WVhoVGFXUmxTVzVrWlhnc0lEazVLVHRjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCaGJIQm9ZVWx1WkdWNElEMGdNVHNnWVd4d2FHRkpibVJsZUNBOFBTQjBhR2x6TGw5aGJIQm9ZVTFoZUZOcFpHVkpibVJsZURzZ0t5dGhiSEJvWVVsdVpHVjRLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1pwYkd4QmNuSmhlVE5FS0hoaGNtVmhMQ0IwYUdsekxsOXphV1JsVTJsNlpTd2dkR2hwY3k1ZmMybGtaVk5wZW1Vc0lIUm9hWE11WDNOcFpHVlRhWHBsTENBd0tUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1ptbHNiRUZ5Y21GNU0wUW9lR0Z5WldGU1pXUXNJSFJvYVhNdVgzTnBaR1ZUYVhwbExDQjBhR2x6TGw5emFXUmxVMmw2WlN3Z2RHaHBjeTVmYzJsa1pWTnBlbVVzSURBcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCbWFXeHNRWEp5WVhrelJDaDRZWEpsWVVkeVpXVnVMQ0IwYUdsekxsOXphV1JsVTJsNlpTd2dkR2hwY3k1ZmMybGtaVk5wZW1Vc0lIUm9hWE11WDNOcFpHVlRhWHBsTENBd0tUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1ptbHNiRUZ5Y21GNU0wUW9lR0Z5WldGQ2JIVmxMQ0IwYUdsekxsOXphV1JsVTJsNlpTd2dkR2hwY3k1ZmMybGtaVk5wZW1Vc0lIUm9hWE11WDNOcFpHVlRhWHBsTENBd0tUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1ptbHNiRUZ5Y21GNU0wUW9lR0Z5WldGQmJIQm9ZU3dnZEdocGN5NWZjMmxrWlZOcGVtVXNJSFJvYVhNdVgzTnBaR1ZUYVhwbExDQjBhR2x6TGw5emFXUmxVMmw2WlN3Z01DazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHWnBiR3hCY25KaGVUTkVLSGhoY21WaE1pd2dkR2hwY3k1ZmMybGtaVk5wZW1Vc0lIUm9hWE11WDNOcFpHVlRhWHBsTENCMGFHbHpMbDl6YVdSbFUybDZaU3dnTUNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdadmNpQW9iR1YwSUhKbFpFbHVaR1Y0SUQwZ01Uc2djbVZrU1c1a1pYZ2dQRDBnZEdocGN5NWZiV0Y0VTJsa1pVbHVaR1Y0T3lBckszSmxaRWx1WkdWNExDQXJLM1J5WVdOclpYSlFjbTluY21WemN5a2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIUnlZV05yWlhJdWMyaHZkV3hrVG05MGFXWjVLSFJ5WVdOclpYSlFjbTluY21WemN5a3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjVhV1ZzWkNCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIQnliMmR5WlhOek9pQjBjbUZqYTJWeUxuQnliMmR5WlhOekxGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYVd4c1FYSnlZWGt4UkNoaGNtVmhMQ0IwYUdsekxsOXphV1JsVTJsNlpTd2dNQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbWFXeHNRWEp5WVhreFJDaGhjbVZoVW1Wa0xDQjBhR2x6TGw5emFXUmxVMmw2WlN3Z01DazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYVd4c1FYSnlZWGt4UkNoaGNtVmhSM0psWlc0c0lIUm9hWE11WDNOcFpHVlRhWHBsTENBd0tUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1pwYkd4QmNuSmhlVEZFS0dGeVpXRkNiSFZsTENCMGFHbHpMbDl6YVdSbFUybDZaU3dnTUNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1hV3hzUVhKeVlYa3hSQ2hoY21WaFFXeHdhR0VzSUhSb2FYTXVYM05wWkdWVGFYcGxMQ0F3S1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHWnBiR3hCY25KaGVURkVLR0Z5WldFeUxDQjBhR2x6TGw5emFXUmxVMmw2WlN3Z01DazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0JuY21WbGJrbHVaR1Y0SUQwZ01Uc2daM0psWlc1SmJtUmxlQ0E4UFNCMGFHbHpMbDl0WVhoVGFXUmxTVzVrWlhnN0lDc3JaM0psWlc1SmJtUmxlQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3hsZENCc2FXNWxJRDBnTUR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JzWlhRZ2JHbHVaVkpsWkNBOUlEQTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JHVjBJR3hwYm1WSGNtVmxiaUE5SURBN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHeHBibVZDYkhWbElEMGdNRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnNaWFFnYkdsdVpVRnNjR2hoSUQwZ01EdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCc1pYUWdiR2x1WlRJZ1BTQXdMakE3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdabTl5SUNoc1pYUWdZbXgxWlVsdVpHVjRJRDBnTVRzZ1lteDFaVWx1WkdWNElEdzlJSFJvYVhNdVgyMWhlRk5wWkdWSmJtUmxlRHNnS3l0aWJIVmxTVzVrWlhncElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiR2x1WlNBclBTQjBhR2x6TGw5M1pXbG5hSFJ6VzJGc2NHaGhTVzVrWlhoZFczSmxaRWx1WkdWNFhWdG5jbVZsYmtsdVpHVjRYVnRpYkhWbFNXNWtaWGhkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCc2FXNWxVbVZrSUNzOUlIUm9hWE11WDIxdmJXVnVkSE5TWldSYllXeHdhR0ZKYm1SbGVGMWJjbVZrU1c1a1pYaGRXMmR5WldWdVNXNWtaWGhkVzJKc2RXVkpibVJsZUYwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHeHBibVZIY21WbGJpQXJQU0IwYUdsekxsOXRiMjFsYm5SelIzSmxaVzViWVd4d2FHRkpibVJsZUYxYmNtVmtTVzVrWlhoZFcyZHlaV1Z1U1c1a1pYaGRXMkpzZFdWSmJtUmxlRjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUd4cGJtVkNiSFZsSUNzOUlIUm9hWE11WDIxdmJXVnVkSE5DYkhWbFcyRnNjR2hoU1c1a1pYaGRXM0psWkVsdVpHVjRYVnRuY21WbGJrbHVaR1Y0WFZ0aWJIVmxTVzVrWlhoZE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnNhVzVsUVd4d2FHRWdLejBnZEdocGN5NWZiVzl0Wlc1MGMwRnNjR2hoVzJGc2NHaGhTVzVrWlhoZFczSmxaRWx1WkdWNFhWdG5jbVZsYmtsdVpHVjRYVnRpYkhWbFNXNWtaWGhkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCc2FXNWxNaUFyUFNCMGFHbHpMbDl0YjIxbGJuUnpXMkZzY0doaFNXNWtaWGhkVzNKbFpFbHVaR1Y0WFZ0bmNtVmxia2x1WkdWNFhWdGliSFZsU1c1a1pYaGRPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JoY21WaFcySnNkV1ZKYm1SbGVGMGdLejBnYkdsdVpUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZWEpsWVZKbFpGdGliSFZsU1c1a1pYaGRJQ3M5SUd4cGJtVlNaV1E3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdGeVpXRkhjbVZsYmx0aWJIVmxTVzVrWlhoZElDczlJR3hwYm1WSGNtVmxianRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWVhKbFlVSnNkV1ZiWW14MVpVbHVaR1Y0WFNBclBTQnNhVzVsUW14MVpUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZWEpsWVVGc2NHaGhXMkpzZFdWSmJtUmxlRjBnS3owZ2JHbHVaVUZzY0doaE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhjbVZoTWx0aWJIVmxTVzVrWlhoZElDczlJR3hwYm1VeU8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjRZWEpsWVZ0eVpXUkpibVJsZUYxYlozSmxaVzVKYm1SbGVGMWJZbXgxWlVsdVpHVjRYU0E5SUhoaGNtVmhXM0psWkVsdVpHVjRJQzBnTVYxYlozSmxaVzVKYm1SbGVGMWJZbXgxWlVsdVpHVjRYU0FySUdGeVpXRmJZbXgxWlVsdVpHVjRYVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZUdGeVpXRlNaV1JiY21Wa1NXNWtaWGhkVzJkeVpXVnVTVzVrWlhoZFcySnNkV1ZKYm1SbGVGMGdQU0I0WVhKbFlWSmxaRnR5WldSSmJtUmxlQ0F0SURGZFcyZHlaV1Z1U1c1a1pYaGRXMkpzZFdWSmJtUmxlRjBnS3lCaGNtVmhVbVZrVzJKc2RXVkpibVJsZUYwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIaGhjbVZoUjNKbFpXNWJjbVZrU1c1a1pYaGRXMmR5WldWdVNXNWtaWGhkVzJKc2RXVkpibVJsZUYwZ1BTQjRZWEpsWVVkeVpXVnVXM0psWkVsdVpHVjRJQzBnTVYxYlozSmxaVzVKYm1SbGVGMWJZbXgxWlVsdVpHVjRYU0FySUdGeVpXRkhjbVZsYmx0aWJIVmxTVzVrWlhoZE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjRZWEpsWVVKc2RXVmJjbVZrU1c1a1pYaGRXMmR5WldWdVNXNWtaWGhkVzJKc2RXVkpibVJsZUYwZ1BTQjRZWEpsWVVKc2RXVmJjbVZrU1c1a1pYZ2dMU0F4WFZ0bmNtVmxia2x1WkdWNFhWdGliSFZsU1c1a1pYaGRJQ3NnWVhKbFlVSnNkV1ZiWW14MVpVbHVaR1Y0WFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2VHRnlaV0ZCYkhCb1lWdHlaV1JKYm1SbGVGMWJaM0psWlc1SmJtUmxlRjFiWW14MVpVbHVaR1Y0WFNBOUlIaGhjbVZoUVd4d2FHRmJjbVZrU1c1a1pYZ2dMU0F4WFZ0bmNtVmxia2x1WkdWNFhWdGliSFZsU1c1a1pYaGRJQ3NnWVhKbFlVRnNjR2hoVzJKc2RXVkpibVJsZUYwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIaGhjbVZoTWx0eVpXUkpibVJsZUYxYlozSmxaVzVKYm1SbGVGMWJZbXgxWlVsdVpHVjRYU0E5SUhoaGNtVmhNbHR5WldSSmJtUmxlQ0F0SURGZFcyZHlaV1Z1U1c1a1pYaGRXMkpzZFdWSmJtUmxlRjBnS3lCaGNtVmhNbHRpYkhWbFNXNWtaWGhkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDkzWldsbmFIUnpXMkZzY0doaFNXNWtaWGhkVzNKbFpFbHVaR1Y0WFZ0bmNtVmxia2x1WkdWNFhWdGliSFZsU1c1a1pYaGRJRDBnZEdocGN5NWZkMlZwWjJoMGMxdGhiSEJvWVVsdVpHVjRJQzBnTVYxYmNtVmtTVzVrWlhoZFcyZHlaV1Z1U1c1a1pYaGRXMkpzZFdWSmJtUmxlRjBnS3lCNFlYSmxZVnR5WldSSmJtUmxlRjFiWjNKbFpXNUpibVJsZUYxYllteDFaVWx1WkdWNFhUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZmJXOXRaVzUwYzFKbFpGdGhiSEJvWVVsdVpHVjRYVnR5WldSSmJtUmxlRjFiWjNKbFpXNUpibVJsZUYxYllteDFaVWx1WkdWNFhTQTlJSFJvYVhNdVgyMXZiV1Z1ZEhOU1pXUmJZV3h3YUdGSmJtUmxlQ0F0SURGZFczSmxaRWx1WkdWNFhWdG5jbVZsYmtsdVpHVjRYVnRpYkhWbFNXNWtaWGhkSUNzZ2VHRnlaV0ZTWldSYmNtVmtTVzVrWlhoZFcyZHlaV1Z1U1c1a1pYaGRXMkpzZFdWSmJtUmxlRjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMjF2YldWdWRITkhjbVZsYmx0aGJIQm9ZVWx1WkdWNFhWdHlaV1JKYm1SbGVGMWJaM0psWlc1SmJtUmxlRjFiWW14MVpVbHVaR1Y0WFNBOUlIUm9hWE11WDIxdmJXVnVkSE5IY21WbGJsdGhiSEJvWVVsdVpHVjRJQzBnTVYxYmNtVmtTVzVrWlhoZFcyZHlaV1Z1U1c1a1pYaGRXMkpzZFdWSmJtUmxlRjBnS3lCNFlYSmxZVWR5WldWdVczSmxaRWx1WkdWNFhWdG5jbVZsYmtsdVpHVjRYVnRpYkhWbFNXNWtaWGhkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDl0YjIxbGJuUnpRbXgxWlZ0aGJIQm9ZVWx1WkdWNFhWdHlaV1JKYm1SbGVGMWJaM0psWlc1SmJtUmxlRjFiWW14MVpVbHVaR1Y0WFNBOUlIUm9hWE11WDIxdmJXVnVkSE5DYkhWbFcyRnNjR2hoU1c1a1pYZ2dMU0F4WFZ0eVpXUkpibVJsZUYxYlozSmxaVzVKYm1SbGVGMWJZbXgxWlVsdVpHVjRYU0FySUhoaGNtVmhRbXgxWlZ0eVpXUkpibVJsZUYxYlozSmxaVzVKYm1SbGVGMWJZbXgxWlVsdVpHVjRYVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWZiVzl0Wlc1MGMwRnNjR2hoVzJGc2NHaGhTVzVrWlhoZFczSmxaRWx1WkdWNFhWdG5jbVZsYmtsdVpHVjRYVnRpYkhWbFNXNWtaWGhkSUQwZ2RHaHBjeTVmYlc5dFpXNTBjMEZzY0doaFcyRnNjR2hoU1c1a1pYZ2dMU0F4WFZ0eVpXUkpibVJsZUYxYlozSmxaVzVKYm1SbGVGMWJZbXgxWlVsdVpHVjRYU0FySUhoaGNtVmhRV3h3YUdGYmNtVmtTVzVrWlhoZFcyZHlaV1Z1U1c1a1pYaGRXMkpzZFdWSmJtUmxlRjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMjF2YldWdWRITmJZV3h3YUdGSmJtUmxlRjFiY21Wa1NXNWtaWGhkVzJkeVpXVnVTVzVrWlhoZFcySnNkV1ZKYm1SbGVGMGdQU0IwYUdsekxsOXRiMjFsYm5SelcyRnNjR2hoU1c1a1pYZ2dMU0F4WFZ0eVpXUkpibVJsZUYxYlozSmxaVzVKYm1SbGVGMWJZbXgxWlVsdVpHVjRYU0FySUhoaGNtVmhNbHR5WldSSmJtUmxlRjFiWjNKbFpXNUpibVJsZUYxYllteDFaVWx1WkdWNFhUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0F2S2lwY2NseHVJQ0FnSUNBcUlFTnZiWEIxZEdWeklIUm9aU0IyYjJ4MWJXVWdiMllnZEdobElHTjFZbVVnYVc0Z1lTQnpjR1ZqYVdacFl5QnRiMjFsYm5RdVhISmNiaUFnSUNBZ0tpOWNjbHh1SUNBZ0lITjBZWFJwWXlCZmRtOXNkVzFsUm14dllYUW9ZM1ZpWlN3Z2JXOXRaVzUwS1NCN1hISmNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlDaHRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMWhlR2x0ZFcxZFcyTjFZbVV1Y21Wa1RXRjRhVzExYlYxYlkzVmlaUzVuY21WbGJrMWhlR2x0ZFcxZFcyTjFZbVV1WW14MVpVMWhlR2x0ZFcxZElDMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTllYaHBiWFZ0WFZ0amRXSmxMbkpsWkUxaGVHbHRkVzFkVzJOMVltVXVaM0psWlc1TmFXNXBiWFZ0WFZ0amRXSmxMbUpzZFdWTllYaHBiWFZ0WFNBdFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUcxdmJXVnVkRnRqZFdKbExtRnNjR2hoVFdGNGFXMTFiVjFiWTNWaVpTNXlaV1JOYVc1cGJYVnRYVnRqZFdKbExtZHlaV1Z1VFdGNGFXMTFiVjFiWTNWaVpTNWliSFZsVFdGNGFXMTFiVjBnSzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J0YjIxbGJuUmJZM1ZpWlM1aGJIQm9ZVTFoZUdsdGRXMWRXMk4xWW1VdWNtVmtUV2x1YVcxMWJWMWJZM1ZpWlM1bmNtVmxiazFwYm1sdGRXMWRXMk4xWW1VdVlteDFaVTFoZUdsdGRXMWRJQzFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5hVzVwYlhWdFhWdGpkV0psTG5KbFpFMWhlR2x0ZFcxZFcyTjFZbVV1WjNKbFpXNU5ZWGhwYlhWdFhWdGpkV0psTG1Kc2RXVk5ZWGhwYlhWdFhTQXJYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHMXZiV1Z1ZEZ0amRXSmxMbUZzY0doaFRXbHVhVzExYlYxYlkzVmlaUzV5WldSTllYaHBiWFZ0WFZ0amRXSmxMbWR5WldWdVRXbHVhVzExYlYxYlkzVmlaUzVpYkhWbFRXRjRhVzExYlYwZ0sxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCdGIyMWxiblJiWTNWaVpTNWhiSEJvWVUxcGJtbHRkVzFkVzJOMVltVXVjbVZrVFdsdWFXMTFiVjFiWTNWaVpTNW5jbVZsYmsxaGVHbHRkVzFkVzJOMVltVXVZbXgxWlUxaGVHbHRkVzFkSUMxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOYVc1cGJYVnRYVnRqZFdKbExuSmxaRTFwYm1sdGRXMWRXMk4xWW1VdVozSmxaVzVOYVc1cGJYVnRYVnRqZFdKbExtSnNkV1ZOWVhocGJYVnRYU2tnTFZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FvYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOWVhocGJYVnRYVnRqZFdKbExuSmxaRTFoZUdsdGRXMWRXMk4xWW1VdVozSmxaVzVOWVhocGJYVnRYVnRqZFdKbExtSnNkV1ZOYVc1cGJYVnRYU0F0WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdGIyMWxiblJiWTNWaVpTNWhiSEJvWVUxcGJtbHRkVzFkVzJOMVltVXVjbVZrVFdGNGFXMTFiVjFiWTNWaVpTNW5jbVZsYmsxaGVHbHRkVzFkVzJOMVltVXVZbXgxWlUxcGJtbHRkVzFkSUMxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHMXZiV1Z1ZEZ0amRXSmxMbUZzY0doaFRXRjRhVzExYlYxYlkzVmlaUzV5WldSTllYaHBiWFZ0WFZ0amRXSmxMbWR5WldWdVRXbHVhVzExYlYxYlkzVmlaUzVpYkhWbFRXbHVhVzExYlYwZ0sxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5hVzVwYlhWdFhWdGpkV0psTG5KbFpFMWhlR2x0ZFcxZFcyTjFZbVV1WjNKbFpXNU5hVzVwYlhWdFhWdGpkV0psTG1Kc2RXVk5hVzVwYlhWdFhTQXRYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0YjIxbGJuUmJZM1ZpWlM1aGJIQm9ZVTFoZUdsdGRXMWRXMk4xWW1VdWNtVmtUV2x1YVcxMWJWMWJZM1ZpWlM1bmNtVmxiazFoZUdsdGRXMWRXMk4xWW1VdVlteDFaVTFwYm1sdGRXMWRJQ3RjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUcxdmJXVnVkRnRqZFdKbExtRnNjR2hoVFdsdWFXMTFiVjFiWTNWaVpTNXlaV1JOYVc1cGJYVnRYVnRqZFdKbExtZHlaV1Z1VFdGNGFXMTFiVjFiWTNWaVpTNWliSFZsVFdsdWFXMTFiVjBnSzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTllYaHBiWFZ0WFZ0amRXSmxMbkpsWkUxcGJtbHRkVzFkVzJOMVltVXVaM0psWlc1TmFXNXBiWFZ0WFZ0amRXSmxMbUpzZFdWTmFXNXBiWFZ0WFNBdFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMXBibWx0ZFcxZFcyTjFZbVV1Y21Wa1RXbHVhVzExYlYxYlkzVmlaUzVuY21WbGJrMXBibWx0ZFcxZFcyTjFZbVV1WW14MVpVMXBibWx0ZFcxZEtUdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lDOHFLbHh5WEc0Z0lDQWdJQ29nUTI5dGNIVjBaWE1nZEdobElIWnZiSFZ0WlNCdlppQjBhR1VnWTNWaVpTQnBiaUJoSUhOd1pXTnBabWxqSUcxdmJXVnVkQzVjY2x4dUlDQWdJQ0FxTDF4eVhHNGdJQ0FnYzNSaGRHbGpJRjkyYjJ4MWJXVW9ZM1ZpWlN3Z2JXOXRaVzUwS1NCN1hISmNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlGZDFVWFZoYm5RdVgzWnZiSFZ0WlVac2IyRjBLR04xWW1Vc0lHMXZiV1Z1ZENrZ2ZDQXdPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdMeW9xWEhKY2JpQWdJQ0FnS2lCVGNHeHBkSE1nZEdobElHTjFZbVVnYVc0Z1oybDJaVzRnY0c5emFYUnBiMjVkVzJGdVpDQmpiMnh2Y2lCa2FYSmxZM1JwYjI0dVhISmNiaUFnSUNBZ0tpOWNjbHh1SUNBZ0lITjBZWFJwWXlCZmRHOXdLR04xWW1Vc0lHUnBjbVZqZEdsdmJpd2djRzl6YVhScGIyNHNJRzF2YldWdWRDa2dlMXh5WEc0Z0lDQWdJQ0FnSUd4bGRDQnlaWE4xYkhRN1hISmNiaUFnSUNBZ0lDQWdjM2RwZEdOb0lDaGthWEpsWTNScGIyNHBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMkZ6WlNCWGRWRjFZVzUwTGw5aGJIQm9ZVHBjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGMzVnNkQ0E5SUNodGIyMWxiblJiY0c5emFYUnBiMjVkVzJOMVltVXVjbVZrVFdGNGFXMTFiVjFiWTNWaVpTNW5jbVZsYmsxaGVHbHRkVzFkVzJOMVltVXVZbXgxWlUxaGVHbHRkVzFkSUMxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0YjIxbGJuUmJjRzl6YVhScGIyNWRXMk4xWW1VdWNtVmtUV0Y0YVcxMWJWMWJZM1ZpWlM1bmNtVmxiazFwYm1sdGRXMWRXMk4xWW1VdVlteDFaVTFoZUdsdGRXMWRJQzFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRiMjFsYm5SYmNHOXphWFJwYjI1ZFcyTjFZbVV1Y21Wa1RXbHVhVzExYlYxYlkzVmlaUzVuY21WbGJrMWhlR2x0ZFcxZFcyTjFZbVV1WW14MVpVMWhlR2x0ZFcxZElDdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdGIyMWxiblJiY0c5emFYUnBiMjVkVzJOMVltVXVjbVZrVFdsdWFXMTFiVjFiWTNWaVpTNW5jbVZsYmsxcGJtbHRkVzFkVzJOMVltVXVZbXgxWlUxaGVHbHRkVzFkS1NBdFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS0cxdmJXVnVkRnR3YjNOcGRHbHZibDFiWTNWaVpTNXlaV1JOWVhocGJYVnRYVnRqZFdKbExtZHlaV1Z1VFdGNGFXMTFiVjFiWTNWaVpTNWliSFZsVFdsdWFXMTFiVjBnTFZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdGIyMWxiblJiY0c5emFYUnBiMjVkVzJOMVltVXVjbVZrVFdGNGFXMTFiVjFiWTNWaVpTNW5jbVZsYmsxcGJtbHRkVzFkVzJOMVltVXVZbXgxWlUxcGJtbHRkVzFkSUMxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzNCdmMybDBhVzl1WFZ0amRXSmxMbkpsWkUxcGJtbHRkVzFkVzJOMVltVXVaM0psWlc1TllYaHBiWFZ0WFZ0amRXSmxMbUpzZFdWTmFXNXBiWFZ0WFNBclhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHMXZiV1Z1ZEZ0d2IzTnBkR2x2YmwxYlkzVmlaUzV5WldSTmFXNXBiWFZ0WFZ0amRXSmxMbWR5WldWdVRXbHVhVzExYlYxYlkzVmlaUzVpYkhWbFRXbHVhVzExYlYwcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdWM1ZSZFdGdWRDNWZjbVZrT2x4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NtVnpkV3gwSUQwZ0tHMXZiV1Z1ZEZ0amRXSmxMbUZzY0doaFRXRjRhVzExYlYxYmNHOXphWFJwYjI1ZFcyTjFZbVV1WjNKbFpXNU5ZWGhwYlhWdFhWdGpkV0psTG1Kc2RXVk5ZWGhwYlhWdFhTQXRYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTllYaHBiWFZ0WFZ0d2IzTnBkR2x2YmwxYlkzVmlaUzVuY21WbGJrMXBibWx0ZFcxZFcyTjFZbVV1WW14MVpVMWhlR2x0ZFcxZElDMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdGIyMWxiblJiWTNWaVpTNWhiSEJvWVUxcGJtbHRkVzFkVzNCdmMybDBhVzl1WFZ0amRXSmxMbWR5WldWdVRXRjRhVzExYlYxYlkzVmlaUzVpYkhWbFRXRjRhVzExYlYwZ0sxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUcxdmJXVnVkRnRqZFdKbExtRnNjR2hoVFdsdWFXMTFiVjFiY0c5emFYUnBiMjVkVzJOMVltVXVaM0psWlc1TmFXNXBiWFZ0WFZ0amRXSmxMbUpzZFdWTllYaHBiWFZ0WFNrZ0xWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNodGIyMWxiblJiWTNWaVpTNWhiSEJvWVUxaGVHbHRkVzFkVzNCdmMybDBhVzl1WFZ0amRXSmxMbWR5WldWdVRXRjRhVzExYlYxYlkzVmlaUzVpYkhWbFRXbHVhVzExYlYwZ0xWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMWhlR2x0ZFcxZFczQnZjMmwwYVc5dVhWdGpkV0psTG1keVpXVnVUV2x1YVcxMWJWMWJZM1ZpWlM1aWJIVmxUV2x1YVcxMWJWMGdMVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0YjIxbGJuUmJZM1ZpWlM1aGJIQm9ZVTFwYm1sdGRXMWRXM0J2YzJsMGFXOXVYVnRqZFdKbExtZHlaV1Z1VFdGNGFXMTFiVjFiWTNWaVpTNWliSFZsVFdsdWFXMTFiVjBnSzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdGIyMWxiblJiWTNWaVpTNWhiSEJvWVUxcGJtbHRkVzFkVzNCdmMybDBhVzl1WFZ0amRXSmxMbWR5WldWdVRXbHVhVzExYlYxYlkzVmlaUzVpYkhWbFRXbHVhVzExYlYwcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdWM1ZSZFdGdWRDNWZaM0psWlc0NlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRZ1BTQW9iVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5ZWGhwYlhWdFhWdGpkV0psTG5KbFpFMWhlR2x0ZFcxZFczQnZjMmwwYVc5dVhWdGpkV0psTG1Kc2RXVk5ZWGhwYlhWdFhTQXRYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTllYaHBiWFZ0WFZ0amRXSmxMbkpsWkUxcGJtbHRkVzFkVzNCdmMybDBhVzl1WFZ0amRXSmxMbUpzZFdWTllYaHBiWFZ0WFNBdFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOYVc1cGJYVnRYVnRqZFdKbExuSmxaRTFoZUdsdGRXMWRXM0J2YzJsMGFXOXVYVnRqZFdKbExtSnNkV1ZOWVhocGJYVnRYU0FyWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5hVzVwYlhWdFhWdGpkV0psTG5KbFpFMXBibWx0ZFcxZFczQnZjMmwwYVc5dVhWdGpkV0psTG1Kc2RXVk5ZWGhwYlhWdFhTa2dMVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDaHRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMWhlR2x0ZFcxZFcyTjFZbVV1Y21Wa1RXRjRhVzExYlYxYmNHOXphWFJwYjI1ZFcyTjFZbVV1WW14MVpVMXBibWx0ZFcxZElDMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5ZWGhwYlhWdFhWdGpkV0psTG5KbFpFMXBibWx0ZFcxZFczQnZjMmwwYVc5dVhWdGpkV0psTG1Kc2RXVk5hVzVwYlhWdFhTQXRYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzF2YldWdWRGdGpkV0psTG1Gc2NHaGhUV2x1YVcxMWJWMWJZM1ZpWlM1eVpXUk5ZWGhwYlhWdFhWdHdiM05wZEdsdmJsMWJZM1ZpWlM1aWJIVmxUV2x1YVcxMWJWMGdLMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0YjIxbGJuUmJZM1ZpWlM1aGJIQm9ZVTFwYm1sdGRXMWRXMk4xWW1VdWNtVmtUV2x1YVcxMWJWMWJjRzl6YVhScGIyNWRXMk4xWW1VdVlteDFaVTFwYm1sdGRXMWRLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZWE5sSUZkMVVYVmhiblF1WDJKc2RXVTZYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUWdQU0FvYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOWVhocGJYVnRYVnRqZFdKbExuSmxaRTFoZUdsdGRXMWRXMk4xWW1VdVozSmxaVzVOWVhocGJYVnRYVnR3YjNOcGRHbHZibDBnTFZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzF2YldWdWRGdGpkV0psTG1Gc2NHaGhUV0Y0YVcxMWJWMWJZM1ZpWlM1eVpXUk5ZWGhwYlhWdFhWdGpkV0psTG1keVpXVnVUV2x1YVcxMWJWMWJjRzl6YVhScGIyNWRJQzFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMWhlR2x0ZFcxZFcyTjFZbVV1Y21Wa1RXbHVhVzExYlYxYlkzVmlaUzVuY21WbGJrMWhlR2x0ZFcxZFczQnZjMmwwYVc5dVhTQXJYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTllYaHBiWFZ0WFZ0amRXSmxMbkpsWkUxcGJtbHRkVzFkVzJOMVltVXVaM0psWlc1TmFXNXBiWFZ0WFZ0d2IzTnBkR2x2YmwwcElDMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBb2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTmFXNXBiWFZ0WFZ0amRXSmxMbkpsWkUxaGVHbHRkVzFkVzJOMVltVXVaM0psWlc1TllYaHBiWFZ0WFZ0d2IzTnBkR2x2YmwwZ0xWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMXBibWx0ZFcxZFcyTjFZbVV1Y21Wa1RXRjRhVzExYlYxYlkzVmlaUzVuY21WbGJrMXBibWx0ZFcxZFczQnZjMmwwYVc5dVhTQXRYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzF2YldWdWRGdGpkV0psTG1Gc2NHaGhUV2x1YVcxMWJWMWJZM1ZpWlM1eVpXUk5hVzVwYlhWdFhWdGpkV0psTG1keVpXVnVUV0Y0YVcxMWJWMWJjRzl6YVhScGIyNWRJQ3RjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOYVc1cGJYVnRYVnRqZFdKbExuSmxaRTFwYm1sdGRXMWRXMk4xWW1VdVozSmxaVzVOYVc1cGJYVnRYVnR3YjNOcGRHbHZibDBwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1JsWm1GMWJIUTZYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMmx0Y0c5emMybGliR1VuS1R0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSEpsYzNWc2RDQjhJREE3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0F2S2lwY2NseHVJQ0FnSUNBcUlGTndiR2wwY3lCMGFHVWdZM1ZpWlNCcGJpQmhJR2RwZG1WdUlHTnZiRzl5SUdScGNtVmpkR2x2YmlCaGRDQnBkSE1nYldsdWFXMTFiUzVjY2x4dUlDQWdJQ0FxTDF4eVhHNGdJQ0FnYzNSaGRHbGpJRjlpYjNSMGIyMG9ZM1ZpWlN3Z1pHbHlaV04wYVc5dUxDQnRiMjFsYm5RcElIdGNjbHh1SUNBZ0lDQWdJQ0J6ZDJsMFkyZ2dLR1JwY21WamRHbHZiaWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqWVhObElGZDFVWFZoYm5RdVgyRnNjR2hoT2x4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUNndGJXOXRaVzUwVzJOMVltVXVZV3h3YUdGTmFXNXBiWFZ0WFZ0amRXSmxMbkpsWkUxaGVHbHRkVzFkVzJOMVltVXVaM0psWlc1TllYaHBiWFZ0WFZ0amRXSmxMbUpzZFdWTllYaHBiWFZ0WFNBclhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOYVc1cGJYVnRYVnRqZFdKbExuSmxaRTFoZUdsdGRXMWRXMk4xWW1VdVozSmxaVzVOYVc1cGJYVnRYVnRqZFdKbExtSnNkV1ZOWVhocGJYVnRYU0FyWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5hVzVwYlhWdFhWdGpkV0psTG5KbFpFMXBibWx0ZFcxZFcyTjFZbVV1WjNKbFpXNU5ZWGhwYlhWdFhWdGpkV0psTG1Kc2RXVk5ZWGhwYlhWdFhTQXRYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTmFXNXBiWFZ0WFZ0amRXSmxMbkpsWkUxcGJtbHRkVzFkVzJOMVltVXVaM0psWlc1TmFXNXBiWFZ0WFZ0amRXSmxMbUpzZFdWTllYaHBiWFZ0WFNrZ0xWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNndGJXOXRaVzUwVzJOMVltVXVZV3h3YUdGTmFXNXBiWFZ0WFZ0amRXSmxMbkpsWkUxaGVHbHRkVzFkVzJOMVltVXVaM0psWlc1TllYaHBiWFZ0WFZ0amRXSmxMbUpzZFdWTmFXNXBiWFZ0WFNBclhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHMXZiV1Z1ZEZ0amRXSmxMbUZzY0doaFRXbHVhVzExYlYxYlkzVmlaUzV5WldSTllYaHBiWFZ0WFZ0amRXSmxMbWR5WldWdVRXbHVhVzExYlYxYlkzVmlaUzVpYkhWbFRXbHVhVzExYlYwZ0sxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMXBibWx0ZFcxZFcyTjFZbVV1Y21Wa1RXbHVhVzExYlYxYlkzVmlaUzVuY21WbGJrMWhlR2x0ZFcxZFcyTjFZbVV1WW14MVpVMXBibWx0ZFcxZElDMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5hVzVwYlhWdFhWdGpkV0psTG5KbFpFMXBibWx0ZFcxZFcyTjFZbVV1WjNKbFpXNU5hVzVwYlhWdFhWdGpkV0psTG1Kc2RXVk5hVzVwYlhWdFhTazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHTmhjMlVnVjNWUmRXRnVkQzVmY21Wa09seHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlDZ3RiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5ZWGhwYlhWdFhWdGpkV0psTG5KbFpFMXBibWx0ZFcxZFcyTjFZbVV1WjNKbFpXNU5ZWGhwYlhWdFhWdGpkV0psTG1Kc2RXVk5ZWGhwYlhWdFhTQXJYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTllYaHBiWFZ0WFZ0amRXSmxMbkpsWkUxcGJtbHRkVzFkVzJOMVltVXVaM0psWlc1TmFXNXBiWFZ0WFZ0amRXSmxMbUpzZFdWTllYaHBiWFZ0WFNBclhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOYVc1cGJYVnRYVnRqZFdKbExuSmxaRTFwYm1sdGRXMWRXMk4xWW1VdVozSmxaVzVOWVhocGJYVnRYVnRqZFdKbExtSnNkV1ZOWVhocGJYVnRYU0F0WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5hVzVwYlhWdFhWdGpkV0psTG5KbFpFMXBibWx0ZFcxZFcyTjFZbVV1WjNKbFpXNU5hVzVwYlhWdFhWdGpkV0psTG1Kc2RXVk5ZWGhwYlhWdFhTa2dMVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDZ3RiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5ZWGhwYlhWdFhWdGpkV0psTG5KbFpFMXBibWx0ZFcxZFcyTjFZbVV1WjNKbFpXNU5ZWGhwYlhWdFhWdGpkV0psTG1Kc2RXVk5hVzVwYlhWdFhTQXJYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzF2YldWdWRGdGpkV0psTG1Gc2NHaGhUV0Y0YVcxMWJWMWJZM1ZpWlM1eVpXUk5hVzVwYlhWdFhWdGpkV0psTG1keVpXVnVUV2x1YVcxMWJWMWJZM1ZpWlM1aWJIVmxUV2x1YVcxMWJWMGdLMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0YjIxbGJuUmJZM1ZpWlM1aGJIQm9ZVTFwYm1sdGRXMWRXMk4xWW1VdWNtVmtUV2x1YVcxMWJWMWJZM1ZpWlM1bmNtVmxiazFoZUdsdGRXMWRXMk4xWW1VdVlteDFaVTFwYm1sdGRXMWRJQzFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOYVc1cGJYVnRYVnRqZFdKbExuSmxaRTFwYm1sdGRXMWRXMk4xWW1VdVozSmxaVzVOYVc1cGJYVnRYVnRqZFdKbExtSnNkV1ZOYVc1cGJYVnRYU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR05oYzJVZ1YzVlJkV0Z1ZEM1ZlozSmxaVzQ2WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnS0MxdGIyMWxiblJiWTNWaVpTNWhiSEJvWVUxaGVHbHRkVzFkVzJOMVltVXVjbVZrVFdGNGFXMTFiVjFiWTNWaVpTNW5jbVZsYmsxcGJtbHRkVzFkVzJOMVltVXVZbXgxWlUxaGVHbHRkVzFkSUN0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0YjIxbGJuUmJZM1ZpWlM1aGJIQm9ZVTFoZUdsdGRXMWRXMk4xWW1VdWNtVmtUV2x1YVcxMWJWMWJZM1ZpWlM1bmNtVmxiazFwYm1sdGRXMWRXMk4xWW1VdVlteDFaVTFoZUdsdGRXMWRJQ3RjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMXBibWx0ZFcxZFcyTjFZbVV1Y21Wa1RXRjRhVzExYlYxYlkzVmlaUzVuY21WbGJrMXBibWx0ZFcxZFcyTjFZbVV1WW14MVpVMWhlR2x0ZFcxZElDMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdGIyMWxiblJiWTNWaVpTNWhiSEJvWVUxcGJtbHRkVzFkVzJOMVltVXVjbVZrVFdsdWFXMTFiVjFiWTNWaVpTNW5jbVZsYmsxcGJtbHRkVzFkVzJOMVltVXVZbXgxWlUxaGVHbHRkVzFkS1NBdFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnS0MxdGIyMWxiblJiWTNWaVpTNWhiSEJvWVUxaGVHbHRkVzFkVzJOMVltVXVjbVZrVFdGNGFXMTFiVjFiWTNWaVpTNW5jbVZsYmsxcGJtbHRkVzFkVzJOMVltVXVZbXgxWlUxcGJtbHRkVzFkSUN0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTllYaHBiWFZ0WFZ0amRXSmxMbkpsWkUxcGJtbHRkVzFkVzJOMVltVXVaM0psWlc1TmFXNXBiWFZ0WFZ0amRXSmxMbUpzZFdWTmFXNXBiWFZ0WFNBclhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHMXZiV1Z1ZEZ0amRXSmxMbUZzY0doaFRXbHVhVzExYlYxYlkzVmlaUzV5WldSTllYaHBiWFZ0WFZ0amRXSmxMbWR5WldWdVRXbHVhVzExYlYxYlkzVmlaUzVpYkhWbFRXbHVhVzExYlYwZ0xWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnRiMjFsYm5SYlkzVmlaUzVoYkhCb1lVMXBibWx0ZFcxZFcyTjFZbVV1Y21Wa1RXbHVhVzExYlYxYlkzVmlaUzVuY21WbGJrMXBibWx0ZFcxZFcyTjFZbVV1WW14MVpVMXBibWx0ZFcxZEtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyRnpaU0JYZFZGMVlXNTBMbDlpYkhWbE9seHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlDZ3RiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5ZWGhwYlhWdFhWdGpkV0psTG5KbFpFMWhlR2x0ZFcxZFcyTjFZbVV1WjNKbFpXNU5ZWGhwYlhWdFhWdGpkV0psTG1Kc2RXVk5hVzVwYlhWdFhTQXJYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JXOXRaVzUwVzJOMVltVXVZV3h3YUdGTllYaHBiWFZ0WFZ0amRXSmxMbkpsWkUxaGVHbHRkVzFkVzJOMVltVXVaM0psWlc1TmFXNXBiWFZ0WFZ0amRXSmxMbUpzZFdWTmFXNXBiWFZ0WFNBclhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOWVhocGJYVnRYVnRqZFdKbExuSmxaRTFwYm1sdGRXMWRXMk4xWW1VdVozSmxaVzVOWVhocGJYVnRYVnRqZFdKbExtSnNkV1ZOYVc1cGJYVnRYU0F0WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5ZWGhwYlhWdFhWdGpkV0psTG5KbFpFMXBibWx0ZFcxZFcyTjFZbVV1WjNKbFpXNU5hVzVwYlhWdFhWdGpkV0psTG1Kc2RXVk5hVzVwYlhWdFhTa2dMVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDZ3RiVzl0Wlc1MFcyTjFZbVV1WVd4d2FHRk5hVzVwYlhWdFhWdGpkV0psTG5KbFpFMWhlR2x0ZFcxZFcyTjFZbVV1WjNKbFpXNU5ZWGhwYlhWdFhWdGpkV0psTG1Kc2RXVk5hVzVwYlhWdFhTQXJYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzF2YldWdWRGdGpkV0psTG1Gc2NHaGhUV2x1YVcxMWJWMWJZM1ZpWlM1eVpXUk5ZWGhwYlhWdFhWdGpkV0psTG1keVpXVnVUV2x1YVcxMWJWMWJZM1ZpWlM1aWJIVmxUV2x1YVcxMWJWMGdLMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0YjIxbGJuUmJZM1ZpWlM1aGJIQm9ZVTFwYm1sdGRXMWRXMk4xWW1VdWNtVmtUV2x1YVcxMWJWMWJZM1ZpWlM1bmNtVmxiazFoZUdsdGRXMWRXMk4xWW1VdVlteDFaVTFwYm1sdGRXMWRJQzFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYlc5dFpXNTBXMk4xWW1VdVlXeHdhR0ZOYVc1cGJYVnRYVnRqZFdKbExuSmxaRTFwYm1sdGRXMWRXMk4xWW1VdVozSmxaVzVOYVc1cGJYVnRYVnRqZFdKbExtSnNkV1ZOYVc1cGJYVnRYU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1JsWm1GMWJIUTZYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F2THlCVVQwUlBPaUIzYUhrZ2FHVnlaU0JwY3lCeVpYUjFjbTRnTUN3Z1lXNWtJR2x1SUhSb2FYTXVYM1J2Y0NCMGFHVnlaU0JwY3lCdWJ5QmtaV1poZFd4MElHRjBJR0ZzYkNBb2JtOTNJR2wwSUdseklIUm9jbTkzSUdWeWNtOXlLVDljY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUF3TzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lDOHFLbHh5WEc0Z0lDQWdJQ29nUTJGc1kzVnNZWFJsY3lCemRHRjBhWE4wYVdOaGJDQjJZWEpwWVc1alpTQm1iM0lnWVNCbmFYWmxiaUJqZFdKbExseHlYRzRnSUNBZ0lDb3ZYSEpjYmlBZ0lDQmZZMkZzWTNWc1lYUmxWbUZ5YVdGdVkyVW9ZM1ZpWlNrZ2UxeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElIWnZiSFZ0WlZKbFpDQTlJRmQxVVhWaGJuUXVYM1p2YkhWdFpTaGpkV0psTENCMGFHbHpMbDl0YjIxbGJuUnpVbVZrS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCMmIyeDFiV1ZIY21WbGJpQTlJRmQxVVhWaGJuUXVYM1p2YkhWdFpTaGpkV0psTENCMGFHbHpMbDl0YjIxbGJuUnpSM0psWlc0cE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElIWnZiSFZ0WlVKc2RXVWdQU0JYZFZGMVlXNTBMbDkyYjJ4MWJXVW9ZM1ZpWlN3Z2RHaHBjeTVmYlc5dFpXNTBjMEpzZFdVcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElIWnZiSFZ0WlVGc2NHaGhJRDBnVjNWUmRXRnVkQzVmZG05c2RXMWxLR04xWW1Vc0lIUm9hWE11WDIxdmJXVnVkSE5CYkhCb1lTazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdkbTlzZFcxbFRXOXRaVzUwSUQwZ1YzVlJkV0Z1ZEM1ZmRtOXNkVzFsUm14dllYUW9ZM1ZpWlN3Z2RHaHBjeTVmYlc5dFpXNTBjeWs3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnZG05c2RXMWxWMlZwWjJoMElEMGdWM1ZSZFdGdWRDNWZkbTlzZFcxbEtHTjFZbVVzSUhSb2FYTXVYM2RsYVdkb2RITXBPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR1JwYzNSaGJtTmxJRDBnZG05c2RXMWxVbVZrSUNvZ2RtOXNkVzFsVW1Wa0lDc2dkbTlzZFcxbFIzSmxaVzRnS2lCMmIyeDFiV1ZIY21WbGJpQXJJSFp2YkhWdFpVSnNkV1VnS2lCMmIyeDFiV1ZDYkhWbElDc2dkbTlzZFcxbFFXeHdhR0VnS2lCMmIyeDFiV1ZCYkhCb1lUdGNjbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkbTlzZFcxbFRXOXRaVzUwSUMwZ0tHUnBjM1JoYm1ObElDOGdkbTlzZFcxbFYyVnBaMmgwS1R0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUM4cUtseHlYRzRnSUNBZ0lDb2dSbWx1WkhNZ2RHaGxJRzl3ZEdsdFlXd2dLRzFoZUdsdFlXd3BJSEJ2YzJsMGFXOXVJR1p2Y2lCMGFHVWdZM1YwTGx4eVhHNGdJQ0FnSUNvdlhISmNiaUFnSUNCZmJXRjRhVzFwZW1Vb1kzVmlaU3dnWkdseVpXTjBhVzl1TENCbWFYSnpkQ3dnYkdGemRDd2dkMmh2YkdWU1pXUXNJSGRvYjJ4bFIzSmxaVzRzSUhkb2IyeGxRbXgxWlN3Z2QyaHZiR1ZCYkhCb1lTd2dkMmh2YkdWWFpXbG5hSFFwSUh0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCaWIzUjBiMjFTWldRZ1BTQlhkVkYxWVc1MExsOWliM1IwYjIwb1kzVmlaU3dnWkdseVpXTjBhVzl1TENCMGFHbHpMbDl0YjIxbGJuUnpVbVZrS1NCOElEQTdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZbTkwZEc5dFIzSmxaVzRnUFNCWGRWRjFZVzUwTGw5aWIzUjBiMjBvWTNWaVpTd2daR2x5WldOMGFXOXVMQ0IwYUdsekxsOXRiMjFsYm5SelIzSmxaVzRwSUh3Z01EdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQmliM1IwYjIxQ2JIVmxJRDBnVjNWUmRXRnVkQzVmWW05MGRHOXRLR04xWW1Vc0lHUnBjbVZqZEdsdmJpd2dkR2hwY3k1ZmJXOXRaVzUwYzBKc2RXVXBJSHdnTUR0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCaWIzUjBiMjFCYkhCb1lTQTlJRmQxVVhWaGJuUXVYMkp2ZEhSdmJTaGpkV0psTENCa2FYSmxZM1JwYjI0c0lIUm9hWE11WDIxdmJXVnVkSE5CYkhCb1lTa2dmQ0F3TzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdKdmRIUnZiVmRsYVdkb2RDQTlJRmQxVVhWaGJuUXVYMkp2ZEhSdmJTaGpkV0psTENCa2FYSmxZM1JwYjI0c0lIUm9hWE11WDNkbGFXZG9kSE1wSUh3Z01EdGNjbHh1SUNBZ0lDQWdJQ0JzWlhRZ2NtVnpkV3gwSUQwZ01DNHdPMXh5WEc0Z0lDQWdJQ0FnSUd4bGRDQmpkWFJRYjNOcGRHbHZiaUE5SUMweE8xeHlYRzRnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJSEJ2YzJsMGFXOXVJRDBnWm1seWMzUTdJSEJ2YzJsMGFXOXVJRHdnYkdGemREc2dLeXR3YjNOcGRHbHZiaWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCa1pYUmxjbTFwYm1WeklIUm9aU0JqZFdKbElHTjFkQ0JoZENCaElHTmxjblJoYVc0Z2NHOXphWFJwYjI1Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHaGhiR1pTWldRZ1BTQmliM1IwYjIxU1pXUWdLeUJYZFZGMVlXNTBMbDkwYjNBb1kzVmlaU3dnWkdseVpXTjBhVzl1TENCd2IzTnBkR2x2Yml3Z2RHaHBjeTVmYlc5dFpXNTBjMUpsWkNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUd4bGRDQm9ZV3htUjNKbFpXNGdQU0JpYjNSMGIyMUhjbVZsYmlBcklGZDFVWFZoYm5RdVgzUnZjQ2hqZFdKbExDQmthWEpsWTNScGIyNHNJSEJ2YzJsMGFXOXVMQ0IwYUdsekxsOXRiMjFsYm5SelIzSmxaVzRwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JzWlhRZ2FHRnNaa0pzZFdVZ1BTQmliM1IwYjIxQ2JIVmxJQ3NnVjNWUmRXRnVkQzVmZEc5d0tHTjFZbVVzSUdScGNtVmpkR2x2Yml3Z2NHOXphWFJwYjI0c0lIUm9hWE11WDIxdmJXVnVkSE5DYkhWbEtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2JHVjBJR2hoYkdaQmJIQm9ZU0E5SUdKdmRIUnZiVUZzY0doaElDc2dWM1ZSZFdGdWRDNWZkRzl3S0dOMVltVXNJR1JwY21WamRHbHZiaXdnY0c5emFYUnBiMjRzSUhSb2FYTXVYMjF2YldWdWRITkJiSEJvWVNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUd4bGRDQm9ZV3htVjJWcFoyaDBJRDBnWW05MGRHOXRWMlZwWjJoMElDc2dWM1ZSZFdGdWRDNWZkRzl3S0dOMVltVXNJR1JwY21WamRHbHZiaXdnY0c5emFYUnBiMjRzSUhSb2FYTXVYM2RsYVdkb2RITXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUIwYUdVZ1kzVmlaU0JqWVc1dWIzUWdZbVVnWTNWMElHRjBJR0p2ZEhSdmJTQW9kR2hwY3lCM2IzVnNaQ0JzWldGa0lIUnZJR1Z0Y0hSNUlHTjFZbVVwWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNob1lXeG1WMlZwWjJoMElDRTlQU0F3S1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnNaWFFnYUdGc1prUnBjM1JoYm1ObElEMGdhR0ZzWmxKbFpDQXFJR2hoYkdaU1pXUWdLeUJvWVd4bVIzSmxaVzRnS2lCb1lXeG1SM0psWlc0Z0t5Qm9ZV3htUW14MVpTQXFJR2hoYkdaQ2JIVmxJQ3NnYUdGc1prRnNjR2hoSUNvZ2FHRnNaa0ZzY0doaE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiR1YwSUhSbGJYQWdQU0JvWVd4bVJHbHpkR0Z1WTJVZ0x5Qm9ZV3htVjJWcFoyaDBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYUdGc1psSmxaQ0E5SUhkb2IyeGxVbVZrSUMwZ2FHRnNabEpsWkR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHaGhiR1pIY21WbGJpQTlJSGRvYjJ4bFIzSmxaVzRnTFNCb1lXeG1SM0psWlc0N1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm9ZV3htUW14MVpTQTlJSGRvYjJ4bFFteDFaU0F0SUdoaGJHWkNiSFZsTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FHRnNaa0ZzY0doaElEMGdkMmh2YkdWQmJIQm9ZU0F0SUdoaGJHWkJiSEJvWVR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHaGhiR1pYWldsbmFIUWdQU0IzYUc5c1pWZGxhV2RvZENBdElHaGhiR1pYWldsbmFIUTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2FHRnNabGRsYVdkb2RDQWhQVDBnTUNrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdoaGJHWkVhWE4wWVc1alpTQTlJR2hoYkdaU1pXUWdLaUJvWVd4bVVtVmtJQ3NnYUdGc1prZHlaV1Z1SUNvZ2FHRnNaa2R5WldWdUlDc2dhR0ZzWmtKc2RXVWdLaUJvWVd4bVFteDFaU0FySUdoaGJHWkJiSEJvWVNBcUlHaGhiR1pCYkhCb1lUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMFpXMXdJQ3M5SUdoaGJHWkVhWE4wWVc1alpTQXZJR2hoYkdaWFpXbG5hSFE3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hSbGJYQWdQaUJ5WlhOMWJIUXBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBJRDBnZEdWdGNEdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZM1YwVUc5emFYUnBiMjRnUFNCd2IzTnBkR2x2Ymp0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSHNnYldGNE9pQnlaWE4xYkhRc0lIQnZjMmwwYVc5dU9pQmpkWFJRYjNOcGRHbHZiaUI5TzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnTHk4Z1EzVjBjeUJoSUdOMVltVWdkMmwwYUNCaGJtOTBhR1Z5SUc5dVpTNWNjbHh1SUNBZ0lGOWpkWFFvWm1seWMzUXNJSE5sWTI5dVpDa2dlMXh5WEc0Z0lDQWdJQ0FnSUd4bGRDQmthWEpsWTNScGIyNDdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdkMmh2YkdWU1pXUWdQU0JYZFZGMVlXNTBMbDkyYjJ4MWJXVW9abWx5YzNRc0lIUm9hWE11WDIxdmJXVnVkSE5TWldRcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElIZG9iMnhsUjNKbFpXNGdQU0JYZFZGMVlXNTBMbDkyYjJ4MWJXVW9abWx5YzNRc0lIUm9hWE11WDIxdmJXVnVkSE5IY21WbGJpazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdkMmh2YkdWQ2JIVmxJRDBnVjNWUmRXRnVkQzVmZG05c2RXMWxLR1pwY25OMExDQjBhR2x6TGw5dGIyMWxiblJ6UW14MVpTazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdkMmh2YkdWQmJIQm9ZU0E5SUZkMVVYVmhiblF1WDNadmJIVnRaU2htYVhKemRDd2dkR2hwY3k1ZmJXOXRaVzUwYzBGc2NHaGhLVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0IzYUc5c1pWZGxhV2RvZENBOUlGZDFVWFZoYm5RdVgzWnZiSFZ0WlNobWFYSnpkQ3dnZEdocGN5NWZkMlZwWjJoMGN5azdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdjbVZrSUQwZ2RHaHBjeTVmYldGNGFXMXBlbVVvWm1seWMzUXNJRmQxVVhWaGJuUXVYM0psWkN3Z1ptbHljM1F1Y21Wa1RXbHVhVzExYlNBcklERXNJR1pwY25OMExuSmxaRTFoZUdsdGRXMHNJSGRvYjJ4bFVtVmtMQ0IzYUc5c1pVZHlaV1Z1TENCM2FHOXNaVUpzZFdVc0lIZG9iMnhsUVd4d2FHRXNJSGRvYjJ4bFYyVnBaMmgwS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCbmNtVmxiaUE5SUhSb2FYTXVYMjFoZUdsdGFYcGxLR1pwY25OMExDQlhkVkYxWVc1MExsOW5jbVZsYml3Z1ptbHljM1F1WjNKbFpXNU5hVzVwYlhWdElDc2dNU3dnWm1seWMzUXVaM0psWlc1TllYaHBiWFZ0TENCM2FHOXNaVkpsWkN3Z2QyaHZiR1ZIY21WbGJpd2dkMmh2YkdWQ2JIVmxMQ0IzYUc5c1pVRnNjR2hoTENCM2FHOXNaVmRsYVdkb2RDazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZbXgxWlNBOUlIUm9hWE11WDIxaGVHbHRhWHBsS0dacGNuTjBMQ0JYZFZGMVlXNTBMbDlpYkhWbExDQm1hWEp6ZEM1aWJIVmxUV2x1YVcxMWJTQXJJREVzSUdacGNuTjBMbUpzZFdWTllYaHBiWFZ0TENCM2FHOXNaVkpsWkN3Z2QyaHZiR1ZIY21WbGJpd2dkMmh2YkdWQ2JIVmxMQ0IzYUc5c1pVRnNjR2hoTENCM2FHOXNaVmRsYVdkb2RDazdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZV3h3YUdFZ1BTQjBhR2x6TGw5dFlYaHBiV2w2WlNobWFYSnpkQ3dnVjNWUmRXRnVkQzVmWVd4d2FHRXNJR1pwY25OMExtRnNjR2hoVFdsdWFXMTFiU0FySURFc0lHWnBjbk4wTG1Gc2NHaGhUV0Y0YVcxMWJTd2dkMmh2YkdWU1pXUXNJSGRvYjJ4bFIzSmxaVzRzSUhkb2IyeGxRbXgxWlN3Z2QyaHZiR1ZCYkhCb1lTd2dkMmh2YkdWWFpXbG5hSFFwTzF4eVhHNGdJQ0FnSUNBZ0lHbG1JQ2hoYkhCb1lTNXRZWGdnUGowZ2NtVmtMbTFoZUNBbUppQmhiSEJvWVM1dFlYZ2dQajBnWjNKbFpXNHViV0Y0SUNZbUlHRnNjR2hoTG0xaGVDQStQU0JpYkhWbExtMWhlQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JrYVhKbFkzUnBiMjRnUFNCWGRWRjFZVzUwTGw5aGJIQm9ZVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdMeThnWTJGdWJtOTBJSE53YkdsMElHVnRjSFI1SUdOMVltVmNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR0ZzY0doaExuQnZjMmwwYVc5dUlEd2dNQ2xjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ1pXeHpaU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoeVpXUXViV0Y0SUQ0OUlHRnNjR2hoTG0xaGVDQW1KaUJ5WldRdWJXRjRJRDQ5SUdkeVpXVnVMbTFoZUNBbUppQnlaV1F1YldGNElENDlJR0pzZFdVdWJXRjRLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCa2FYSmxZM1JwYjI0Z1BTQlhkVkYxWVc1MExsOXlaV1E3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdaV3h6WlNCcFppQW9aM0psWlc0dWJXRjRJRDQ5SUdGc2NHaGhMbTFoZUNBbUppQm5jbVZsYmk1dFlYZ2dQajBnY21Wa0xtMWhlQ0FtSmlCbmNtVmxiaTV0WVhnZ1BqMGdZbXgxWlM1dFlYZ3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdScGNtVmpkR2x2YmlBOUlGZDFVWFZoYm5RdVgyZHlaV1Z1TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1ZzYzJVZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdaR2x5WldOMGFXOXVJRDBnVjNWUmRXRnVkQzVmWW14MVpUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCelpXTnZibVF1Y21Wa1RXRjRhVzExYlNBOUlHWnBjbk4wTG5KbFpFMWhlR2x0ZFcwN1hISmNiaUFnSUNBZ0lDQWdjMlZqYjI1a0xtZHlaV1Z1VFdGNGFXMTFiU0E5SUdacGNuTjBMbWR5WldWdVRXRjRhVzExYlR0Y2NseHVJQ0FnSUNBZ0lDQnpaV052Ym1RdVlteDFaVTFoZUdsdGRXMGdQU0JtYVhKemRDNWliSFZsVFdGNGFXMTFiVHRjY2x4dUlDQWdJQ0FnSUNCelpXTnZibVF1WVd4d2FHRk5ZWGhwYlhWdElEMGdabWx5YzNRdVlXeHdhR0ZOWVhocGJYVnRPMXh5WEc0Z0lDQWdJQ0FnSUM4dklHTjFkSE1nYVc0Z1lTQmpaWEowWVdsdUlHUnBjbVZqZEdsdmJseHlYRzRnSUNBZ0lDQWdJSE4zYVhSamFDQW9aR2x5WldOMGFXOXVLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR05oYzJVZ1YzVlJkV0Z1ZEM1ZmNtVmtPbHh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJWamIyNWtMbkpsWkUxcGJtbHRkVzBnUFNCbWFYSnpkQzV5WldSTllYaHBiWFZ0SUQwZ2NtVmtMbkJ2YzJsMGFXOXVPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJWamIyNWtMbWR5WldWdVRXbHVhVzExYlNBOUlHWnBjbk4wTG1keVpXVnVUV2x1YVcxMWJUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSE5sWTI5dVpDNWliSFZsVFdsdWFXMTFiU0E5SUdacGNuTjBMbUpzZFdWTmFXNXBiWFZ0TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2MyVmpiMjVrTG1Gc2NHaGhUV2x1YVcxMWJTQTlJR1pwY25OMExtRnNjR2hoVFdsdWFXMTFiVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZWE5sSUZkMVVYVmhiblF1WDJkeVpXVnVPbHh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJWamIyNWtMbWR5WldWdVRXbHVhVzExYlNBOUlHWnBjbk4wTG1keVpXVnVUV0Y0YVcxMWJTQTlJR2R5WldWdUxuQnZjMmwwYVc5dU8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjMlZqYjI1a0xuSmxaRTFwYm1sdGRXMGdQU0JtYVhKemRDNXlaV1JOYVc1cGJYVnRPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJWamIyNWtMbUpzZFdWTmFXNXBiWFZ0SUQwZ1ptbHljM1F1WW14MVpVMXBibWx0ZFcwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnpaV052Ym1RdVlXeHdhR0ZOYVc1cGJYVnRJRDBnWm1seWMzUXVZV3h3YUdGTmFXNXBiWFZ0TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR05oYzJVZ1YzVlJkV0Z1ZEM1ZllteDFaVHBjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhObFkyOXVaQzVpYkhWbFRXbHVhVzExYlNBOUlHWnBjbk4wTG1Kc2RXVk5ZWGhwYlhWdElEMGdZbXgxWlM1d2IzTnBkR2x2Ymp0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lITmxZMjl1WkM1eVpXUk5hVzVwYlhWdElEMGdabWx5YzNRdWNtVmtUV2x1YVcxMWJUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSE5sWTI5dVpDNW5jbVZsYmsxcGJtbHRkVzBnUFNCbWFYSnpkQzVuY21WbGJrMXBibWx0ZFcwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnpaV052Ym1RdVlXeHdhR0ZOYVc1cGJYVnRJRDBnWm1seWMzUXVZV3h3YUdGTmFXNXBiWFZ0TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR05oYzJVZ1YzVlJkV0Z1ZEM1ZllXeHdhR0U2WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCelpXTnZibVF1WVd4d2FHRk5hVzVwYlhWdElEMGdabWx5YzNRdVlXeHdhR0ZOWVhocGJYVnRJRDBnWVd4d2FHRXVjRzl6YVhScGIyNDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J6WldOdmJtUXVZbXgxWlUxcGJtbHRkVzBnUFNCbWFYSnpkQzVpYkhWbFRXbHVhVzExYlR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lITmxZMjl1WkM1eVpXUk5hVzVwYlhWdElEMGdabWx5YzNRdWNtVmtUV2x1YVcxMWJUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSE5sWTI5dVpDNW5jbVZsYmsxcGJtbHRkVzBnUFNCbWFYSnpkQzVuY21WbGJrMXBibWx0ZFcwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmljbVZoYXp0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnTHk4Z1pHVjBaWEp0YVc1bGN5QjBhR1VnZG05c2RXMWxjeUJoWm5SbGNpQmpkWFJjY2x4dUlDQWdJQ0FnSUNCbWFYSnpkQzUyYjJ4MWJXVWdQU0FvWm1seWMzUXVjbVZrVFdGNGFXMTFiU0F0SUdacGNuTjBMbkpsWkUxcGJtbHRkVzBwSUNvZ0tHWnBjbk4wTG1keVpXVnVUV0Y0YVcxMWJTQXRJR1pwY25OMExtZHlaV1Z1VFdsdWFXMTFiU2tnS2lBb1ptbHljM1F1WW14MVpVMWhlR2x0ZFcwZ0xTQm1hWEp6ZEM1aWJIVmxUV2x1YVcxMWJTa2dLaUFvWm1seWMzUXVZV3h3YUdGTllYaHBiWFZ0SUMwZ1ptbHljM1F1WVd4d2FHRk5hVzVwYlhWdEtUdGNjbHh1SUNBZ0lDQWdJQ0J6WldOdmJtUXVkbTlzZFcxbElEMGdLSE5sWTI5dVpDNXlaV1JOWVhocGJYVnRJQzBnYzJWamIyNWtMbkpsWkUxcGJtbHRkVzBwSUNvZ0tITmxZMjl1WkM1bmNtVmxiazFoZUdsdGRXMGdMU0J6WldOdmJtUXVaM0psWlc1TmFXNXBiWFZ0S1NBcUlDaHpaV052Ym1RdVlteDFaVTFoZUdsdGRXMGdMU0J6WldOdmJtUXVZbXgxWlUxcGJtbHRkVzBwSUNvZ0tITmxZMjl1WkM1aGJIQm9ZVTFoZUdsdGRXMGdMU0J6WldOdmJtUXVZV3h3YUdGTmFXNXBiWFZ0S1R0Y2NseHVJQ0FnSUNBZ0lDQXZMeUIwYUdVZ1kzVjBJSGRoY3lCemRXTmpaWE56Wm5Wc1hISmNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0JmYVc1cGRHbGhiR2w2WlNoamIyeHZjbk1wSUh0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5amIyeHZjbk1nUFNCamIyeHZjbk03WEhKY2JpQWdJQ0FnSUNBZ0x5OGdZM0psWVhSbGN5QmhiR3dnZEdobElGOWpkV0psYzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJOMVltVnpJRDBnVzEwN1hISmNiaUFnSUNBZ0lDQWdMeThnYVc1cGRHbGhiR2w2WlhNZ1lXeHNJSFJvWlNCZlkzVmlaWE5jY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCamRXSmxTVzVrWlhnZ1BTQXdPeUJqZFdKbFNXNWtaWGdnUENCamIyeHZjbk03SUdOMVltVkpibVJsZUNzcktTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WDJOMVltVnpXMk4xWW1WSmJtUmxlRjBnUFNCdVpYY2dWM1ZEYjJ4dmNrTjFZbVVvS1R0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnTHk4Z2NtVnpaWFJ6SUhSb1pTQnlaV1psY21WdVkyVWdiV2x1YVcxMWJYTmNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOWpkV0psYzFzd1hTNXlaV1JOYVc1cGJYVnRJRDBnTUR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5amRXSmxjMXN3WFM1bmNtVmxiazFwYm1sdGRXMGdQU0F3TzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJOMVltVnpXekJkTG1Kc2RXVk5hVzVwYlhWdElEMGdNRHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDlqZFdKbGMxc3dYUzVoYkhCb1lVMXBibWx0ZFcwZ1BTQXdPMXh5WEc0Z0lDQWdJQ0FnSUM4dklISmxjMlYwY3lCMGFHVWdjbVZtWlhKbGJtTmxJRzFoZUdsdGRXMXpYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZM1ZpWlhOYk1GMHVjbVZrVFdGNGFXMTFiU0E5SUhSb2FYTXVYMjFoZUZOcFpHVkpibVJsZUR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5amRXSmxjMXN3WFM1bmNtVmxiazFoZUdsdGRXMGdQU0IwYUdsekxsOXRZWGhUYVdSbFNXNWtaWGc3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmWTNWaVpYTmJNRjB1WW14MVpVMWhlR2x0ZFcwZ1BTQjBhR2x6TGw5dFlYaFRhV1JsU1c1a1pYZzdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZM1ZpWlhOYk1GMHVZV3h3YUdGTllYaHBiWFZ0SUQwZ2RHaHBjeTVmWVd4d2FHRk5ZWGhUYVdSbFNXNWtaWGc3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmZDJWcFoyaDBjeUE5SUdOeVpXRjBaVUZ5Y21GNU5FUW9kR2hwY3k1ZllXeHdhR0ZUYVdSbFUybDZaU3dnZEdocGN5NWZjMmxrWlZOcGVtVXNJSFJvYVhNdVgzTnBaR1ZUYVhwbExDQjBhR2x6TGw5emFXUmxVMmw2WlNrN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmJXOXRaVzUwYzFKbFpDQTlJR055WldGMFpVRnljbUY1TkVRb2RHaHBjeTVmWVd4d2FHRlRhV1JsVTJsNlpTd2dkR2hwY3k1ZmMybGtaVk5wZW1Vc0lIUm9hWE11WDNOcFpHVlRhWHBsTENCMGFHbHpMbDl6YVdSbFUybDZaU2s3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmYlc5dFpXNTBjMGR5WldWdUlEMGdZM0psWVhSbFFYSnlZWGswUkNoMGFHbHpMbDloYkhCb1lWTnBaR1ZUYVhwbExDQjBhR2x6TGw5emFXUmxVMmw2WlN3Z2RHaHBjeTVmYzJsa1pWTnBlbVVzSUhSb2FYTXVYM05wWkdWVGFYcGxLVHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDl0YjIxbGJuUnpRbXgxWlNBOUlHTnlaV0YwWlVGeWNtRjVORVFvZEdocGN5NWZZV3h3YUdGVGFXUmxVMmw2WlN3Z2RHaHBjeTVmYzJsa1pWTnBlbVVzSUhSb2FYTXVYM05wWkdWVGFYcGxMQ0IwYUdsekxsOXphV1JsVTJsNlpTazdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZiVzl0Wlc1MGMwRnNjR2hoSUQwZ1kzSmxZWFJsUVhKeVlYazBSQ2gwYUdsekxsOWhiSEJvWVZOcFpHVlRhWHBsTENCMGFHbHpMbDl6YVdSbFUybDZaU3dnZEdocGN5NWZjMmxrWlZOcGVtVXNJSFJvYVhNdVgzTnBaR1ZUYVhwbEtUdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXRiMjFsYm5SeklEMGdZM0psWVhSbFFYSnlZWGswUkNoMGFHbHpMbDloYkhCb1lWTnBaR1ZUYVhwbExDQjBhR2x6TGw5emFXUmxVMmw2WlN3Z2RHaHBjeTVmYzJsa1pWTnBlbVVzSUhSb2FYTXVYM05wWkdWVGFYcGxLVHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDkwWVdKc1pTQTlJRnRkTzF4eVhHNGdJQ0FnSUNBZ0lHWnZjaUFvYkdWMElIUmhZbXhsU1c1a1pYZ2dQU0F3T3lCMFlXSnNaVWx1WkdWNElEd2dNalUyT3lBckszUmhZbXhsU1c1a1pYZ3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZmRHRmliR1ZiZEdGaWJHVkpibVJsZUYwZ1BTQjBZV0pzWlVsdVpHVjRJQ29nZEdGaWJHVkpibVJsZUR0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZjR2w0Wld4eklEMGdXMTA3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0JmYzJWMFVYVmhiR2wwZVNoemFXZHVhV1pwWTJGdWRFSnBkSE5RWlhKRGFHRnVibVZzSUQwZ05Ta2dlMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYM05wWjI1cFptbGpZVzUwUW1sMGMxQmxja05vWVc1dVpXd2dQU0J6YVdkdWFXWnBZMkZ1ZEVKcGRITlFaWEpEYUdGdWJtVnNPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMjFoZUZOcFpHVkpibVJsZUNBOUlERWdQRHdnZEdocGN5NWZjMmxuYm1sbWFXTmhiblJDYVhSelVHVnlRMmhoYm01bGJEdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOWhiSEJvWVUxaGVGTnBaR1ZKYm1SbGVDQTlJSFJvYVhNdVgyMWhlRk5wWkdWSmJtUmxlRHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbDl6YVdSbFUybDZaU0E5SUhSb2FYTXVYMjFoZUZOcFpHVkpibVJsZUNBcklERTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZV3h3YUdGVGFXUmxVMmw2WlNBOUlIUm9hWE11WDJGc2NHaGhUV0Y0VTJsa1pVbHVaR1Y0SUNzZ01UdGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNVhkVkYxWVc1MExsOWhiSEJvWVNBOUlETTdYSEpjYmxkMVVYVmhiblF1WDNKbFpDQTlJREk3WEhKY2JsZDFVWFZoYm5RdVgyZHlaV1Z1SUQwZ01UdGNjbHh1VjNWUmRXRnVkQzVmWW14MVpTQTlJREE3WEhKY2JpOHZJeUJ6YjNWeVkyVk5ZWEJ3YVc1blZWSk1QWGQxVVhWaGJuUXVhbk11YldGd0lpd2lMeW9xWEhKY2JpQXFJRUJ3Y21WelpYSjJaVnh5WEc0Z0tpQkRiM0I1Y21sbmFIUWdNakF4TlMweU1ERTRJRWxuYjNJZ1FtVjZhM0p2ZG01NWFWeHlYRzRnS2lCQmJHd2djbWxuYUhSeklISmxjMlZ5ZG1Wa0xpQW9UVWxVSUV4cFkyVnVjMlZrS1Z4eVhHNGdLbHh5WEc0Z0tpQnBjUzUwY3lBdElFbHRZV2RsSUZGMVlXNTBhWHBoZEdsdmJpQk1hV0p5WVhKNVhISmNiaUFxTDF4eVhHNWxlSEJ2Y25RZ2V5QnpjMmx0SUgwZ1puSnZiU0FuTGk5emMybHRKenRjY2x4dUx5OGpJSE52ZFhKalpVMWhjSEJwYm1kVlVrdzlhVzVrWlhndWFuTXViV0Z3SWl3aWFXMXdiM0owSUhzZ1dTQjlJR1p5YjIwZ0p5NHVMMk52Ym5OMFlXNTBjeTlpZERjd09TYzdYSEpjYmk4dklHSmhjMlZrSUc5dUlHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOXlhSGx6TFdVdmMzUnlkV04wZFhKaGJDMXphVzFwYkdGeWFYUjVYSEpjYmk4dklHaDBkSEE2THk5bGJpNTNhV3RwY0dWa2FXRXViM0puTDNkcGEya3ZVM1J5ZFdOMGRYSmhiRjl6YVcxcGJHRnlhWFI1WEhKY2JtTnZibk4wSUVzeElEMGdNQzR3TVRzZ0x5OGdkSE5zYVc1ME9tUnBjMkZpYkdVdGJHbHVaVHB1WVcxcGJtY3RZMjl1ZG1WdWRHbHZibHh5WEc1amIyNXpkQ0JMTWlBOUlEQXVNRE03SUM4dklIUnpiR2x1ZERwa2FYTmhZbXhsTFd4cGJtVTZibUZ0YVc1bkxXTnZiblpsYm5ScGIyNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJSE56YVcwb2FXMWhaMlV4TENCcGJXRm5aVElwSUh0Y2NseHVJQ0FnSUdsbUlDaHBiV0ZuWlRFdVoyVjBTR1ZwWjJoMEtDa2dJVDA5SUdsdFlXZGxNaTVuWlhSSVpXbG5hSFFvS1NCOGZDQnBiV0ZuWlRFdVoyVjBWMmxrZEdnb0tTQWhQVDBnYVcxaFoyVXlMbWRsZEZkcFpIUm9LQ2twSUh0Y2NseHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owbHRZV2RsY3lCb1lYWmxJR1JwWm1abGNtVnVkQ0J6YVhwbGN5RW5LVHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJR052Ym5OMElHSnBkSE5RWlhKRGIyMXdiMjVsYm5RZ1BTQTRPMXh5WEc0Z0lDQWdZMjl1YzNRZ1RDQTlJQ2d4SUR3OElHSnBkSE5RWlhKRGIyMXdiMjVsYm5RcElDMGdNVHNnTHk4Z2RITnNhVzUwT21ScGMyRmliR1V0YkdsdVpUcHVZVzFwYm1jdFkyOXVkbVZ1ZEdsdmJseHlYRzRnSUNBZ1kyOXVjM1FnWXpFZ1BTQk5ZWFJvTG5CdmR5Z29TekVnS2lCTUtTd2dNaWs3WEhKY2JpQWdJQ0JqYjI1emRDQmpNaUE5SUUxaGRHZ3VjRzkzS0NoTE1pQXFJRXdwTENBeUtUdGNjbHh1SUNBZ0lHeGxkQ0J1ZFcxWGFXNWtiM2R6SUQwZ01EdGNjbHh1SUNBZ0lHeGxkQ0J0YzNOcGJTQTlJREF1TUR0Y2NseHVJQ0FnSUM4dklHTmhiR04xYkdGMFpTQnpjMmx0SUdadmNpQmxZV05vSUhkcGJtUnZkMXh5WEc0Z0lDQWdhWFJsY21GMFpTaHBiV0ZuWlRFc0lHbHRZV2RsTWl3Z0tHeDFiV0ZXWVd4MVpYTXhMQ0JzZFcxaFZtRnNkV1Z6TWl3Z1lYWmxjbUZuWlV4MWJXRldZV3gxWlRFc0lHRjJaWEpoWjJWTWRXMWhWbUZzZFdVeUtTQTlQaUI3WEhKY2JpQWdJQ0FnSUNBZ0x5OGdZMkZzWTNWc1lYUmxJSFpoY21saGJtTmxJR0Z1WkNCamIzWmhjbWxoYm1ObFhISmNiaUFnSUNBZ0lDQWdiR1YwSUhOcFozaDVJRDBnTUM0d08xeHlYRzRnSUNBZ0lDQWdJR3hsZENCemFXZHpjWGdnUFNBd0xqQTdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElITnBaM054ZVNBOUlEQXVNRHRjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCcElEMGdNRHNnYVNBOElHeDFiV0ZXWVd4MVpYTXhMbXhsYm1kMGFEc2dhU3NyS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhOcFozTnhlQ0FyUFNCTllYUm9MbkJ2ZHlnb2JIVnRZVlpoYkhWbGN6RmJhVjBnTFNCaGRtVnlZV2RsVEhWdFlWWmhiSFZsTVNrc0lESXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnphV2R6Y1hrZ0t6MGdUV0YwYUM1d2IzY29LR3gxYldGV1lXeDFaWE15VzJsZElDMGdZWFpsY21GblpVeDFiV0ZXWVd4MVpUSXBMQ0F5S1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYzJsbmVIa2dLejBnS0d4MWJXRldZV3gxWlhNeFcybGRJQzBnWVhabGNtRm5aVXgxYldGV1lXeDFaVEVwSUNvZ0tHeDFiV0ZXWVd4MVpYTXlXMmxkSUMwZ1lYWmxjbUZuWlV4MWJXRldZV3gxWlRJcE8xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0J1ZFcxUWFYaGxiSE5KYmxkcGJpQTlJR3gxYldGV1lXeDFaWE14TG14bGJtZDBhQ0F0SURFN1hISmNiaUFnSUNBZ0lDQWdjMmxuYzNGNElDODlJRzUxYlZCcGVHVnNjMGx1VjJsdU8xeHlYRzRnSUNBZ0lDQWdJSE5wWjNOeGVTQXZQU0J1ZFcxUWFYaGxiSE5KYmxkcGJqdGNjbHh1SUNBZ0lDQWdJQ0J6YVdkNGVTQXZQU0J1ZFcxUWFYaGxiSE5KYmxkcGJqdGNjbHh1SUNBZ0lDQWdJQ0F2THlCd1pYSm1iM0p0SUhOemFXMGdZMkZzWTNWc1lYUnBiMjRnYjI0Z2QybHVaRzkzWEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnYm5WdFpYSmhkRzl5SUQwZ0tESWdLaUJoZG1WeVlXZGxUSFZ0WVZaaGJIVmxNU0FxSUdGMlpYSmhaMlZNZFcxaFZtRnNkV1V5SUNzZ1l6RXBJQ29nS0RJZ0tpQnphV2Q0ZVNBcklHTXlLVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JrWlc1dmJXbHVZWFJ2Y2lBOUlDaE5ZWFJvTG5CdmR5aGhkbVZ5WVdkbFRIVnRZVlpoYkhWbE1Td2dNaWtnS3lCTllYUm9MbkJ2ZHloaGRtVnlZV2RsVEhWdFlWWmhiSFZsTWl3Z01pa2dLeUJqTVNrZ0tpQW9jMmxuYzNGNElDc2djMmxuYzNGNUlDc2dZeklwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhOemFXMGdQU0J1ZFcxbGNtRjBiM0lnTHlCa1pXNXZiV2x1WVhSdmNqdGNjbHh1SUNBZ0lDQWdJQ0J0YzNOcGJTQXJQU0J6YzJsdE8xeHlYRzRnSUNBZ0lDQWdJRzUxYlZkcGJtUnZkM01yS3p0Y2NseHVJQ0FnSUgwcE8xeHlYRzRnSUNBZ2NtVjBkWEp1SUcxemMybHRJQzhnYm5WdFYybHVaRzkzY3p0Y2NseHVmVnh5WEc1bWRXNWpkR2x2YmlCcGRHVnlZWFJsS0dsdFlXZGxNU3dnYVcxaFoyVXlMQ0JqWVd4c1ltRmpheWtnZTF4eVhHNGdJQ0FnWTI5dWMzUWdkMmx1Wkc5M1UybDZaU0E5SURnN1hISmNiaUFnSUNCamIyNXpkQ0IzYVdSMGFDQTlJR2x0WVdkbE1TNW5aWFJYYVdSMGFDZ3BPMXh5WEc0Z0lDQWdZMjl1YzNRZ2FHVnBaMmgwSUQwZ2FXMWhaMlV4TG1kbGRFaGxhV2RvZENncE8xeHlYRzRnSUNBZ1ptOXlJQ2hzWlhRZ2VTQTlJREE3SUhrZ1BDQm9aV2xuYUhRN0lIa2dLejBnZDJsdVpHOTNVMmw2WlNrZ2UxeHlYRzRnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJSGdnUFNBd095QjRJRHdnZDJsa2RHZzdJSGdnS3owZ2QybHVaRzkzVTJsNlpTa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJoZG05cFpDQnZkWFF0YjJZdGQybGtkR2d2YUdWcFoyaDBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUhkcGJtUnZkMWRwWkhSb0lEMGdUV0YwYUM1dGFXNG9kMmx1Wkc5M1UybDZaU3dnZDJsa2RHZ2dMU0I0S1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdkMmx1Wkc5M1NHVnBaMmgwSUQwZ1RXRjBhQzV0YVc0b2QybHVaRzkzVTJsNlpTd2dhR1ZwWjJoMElDMGdlU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHeDFiV0ZXWVd4MVpYTXhJRDBnWTJGc1kzVnNZWFJsVEhWdFlWWmhiSFZsYzBadmNsZHBibVJ2ZHlocGJXRm5aVEVzSUhnc0lIa3NJSGRwYm1SdmQxZHBaSFJvTENCM2FXNWtiM2RJWldsbmFIUXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCc2RXMWhWbUZzZFdWek1pQTlJR05oYkdOMWJHRjBaVXgxYldGV1lXeDFaWE5HYjNKWGFXNWtiM2NvYVcxaFoyVXlMQ0I0TENCNUxDQjNhVzVrYjNkWGFXUjBhQ3dnZDJsdVpHOTNTR1ZwWjJoMEtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWVhabGNtRm5aVXgxYldFeElEMGdZMkZzWTNWc1lYUmxRWFpsY21GblpVeDFiV0VvYkhWdFlWWmhiSFZsY3pFcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JoZG1WeVlXZGxUSFZ0WVRJZ1BTQmpZV3hqZFd4aGRHVkJkbVZ5WVdkbFRIVnRZU2hzZFcxaFZtRnNkV1Z6TWlrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGJHeGlZV05yS0d4MWJXRldZV3gxWlhNeExDQnNkVzFoVm1Gc2RXVnpNaXdnWVhabGNtRm5aVXgxYldFeExDQmhkbVZ5WVdkbFRIVnRZVElwTzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNW1kVzVqZEdsdmJpQmpZV3hqZFd4aGRHVk1kVzFoVm1Gc2RXVnpSbTl5VjJsdVpHOTNLR2x0WVdkbExDQjRMQ0I1TENCM2FXUjBhQ3dnYUdWcFoyaDBLU0I3WEhKY2JpQWdJQ0JqYjI1emRDQndiMmx1ZEVGeWNtRjVJRDBnYVcxaFoyVXVaMlYwVUc5cGJuUkJjbkpoZVNncE8xeHlYRzRnSUNBZ1kyOXVjM1FnYkhWdFlWWmhiSFZsY3lBOUlGdGRPMXh5WEc0Z0lDQWdiR1YwSUdOdmRXNTBaWElnUFNBd08xeHlYRzRnSUNBZ1ptOXlJQ2hzWlhRZ2FpQTlJSGs3SUdvZ1BDQjVJQ3NnYUdWcFoyaDBPeUJxS3lzcElIdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQnZabVp6WlhRZ1BTQnFJQ29nYVcxaFoyVXVaMlYwVjJsa2RHZ29LVHRjY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR3hsZENCcElEMGdlRHNnYVNBOElIZ2dLeUIzYVdSMGFEc2dhU3NyS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTjBJSEJ2YVc1MElEMGdjRzlwYm5SQmNuSmhlVnR2Wm1aelpYUWdLeUJwWFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYkhWdFlWWmhiSFZsYzF0amIzVnVkR1Z5WFNBOUlIQnZhVzUwTG5JZ0tpQlpMbEpGUkNBcklIQnZhVzUwTG1jZ0tpQlpMa2RTUlVWT0lDc2djRzlwYm5RdVlpQXFJRmt1UWt4VlJUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOTFiblJsY2lzck8xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJSDFjY2x4dUlDQWdJSEpsZEhWeWJpQnNkVzFoVm1Gc2RXVnpPMXh5WEc1OVhISmNibVoxYm1OMGFXOXVJR05oYkdOMWJHRjBaVUYyWlhKaFoyVk1kVzFoS0d4MWJXRldZV3gxWlhNcElIdGNjbHh1SUNBZ0lHeGxkQ0J6ZFcxTWRXMWhJRDBnTUM0d08xeHlYRzRnSUNBZ1ptOXlJQ2hqYjI1emRDQnNkVzFoSUc5bUlHeDFiV0ZXWVd4MVpYTXBJSHRjY2x4dUlDQWdJQ0FnSUNCemRXMU1kVzFoSUNzOUlHeDFiV0U3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0J5WlhSMWNtNGdjM1Z0VEhWdFlTQXZJR3gxYldGV1lXeDFaWE11YkdWdVozUm9PMXh5WEc1OVhISmNiaTh2SXlCemIzVnlZMlZOWVhCd2FXNW5WVkpNUFhOemFXMHVhbk11YldGd0lpd2laWGh3YjNKMElHWjFibU4wYVc5dUlHUmxaM0psWlhNeWNtRmthV0Z1Y3lodUtTQjdYSEpjYmlBZ0lDQnlaWFIxY200Z2JpQXFJQ2hOWVhSb0xsQkpJQzhnTVRnd0tUdGNjbHh1ZlZ4eVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z2JXRjRNeWhoTENCaUxDQmpLU0I3WEhKY2JpQWdJQ0JzWlhRZ2JTQTlJR0U3WEhKY2JpQWdJQ0JwWmlBb2JTQThJR0lwWEhKY2JpQWdJQ0FnSUNBZ2JTQTlJR0k3WEhKY2JpQWdJQ0JwWmlBb2JTQThJR01wWEhKY2JpQWdJQ0FnSUNBZ2JTQTlJR003WEhKY2JpQWdJQ0J5WlhSMWNtNGdiVHRjY2x4dWZWeHlYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdiV2x1TXloaExDQmlMQ0JqS1NCN1hISmNiaUFnSUNCc1pYUWdiU0E5SUdFN1hISmNiaUFnSUNCcFppQW9iU0ErSUdJcFhISmNiaUFnSUNBZ0lDQWdiU0E5SUdJN1hISmNiaUFnSUNCcFppQW9iU0ErSUdNcFhISmNiaUFnSUNBZ0lDQWdiU0E5SUdNN1hISmNiaUFnSUNCeVpYUjFjbTRnYlR0Y2NseHVmVnh5WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnYVc1MFNXNVNZVzVuWlNoMllXeDFaU3dnYkc5M0xDQm9hV2RvS1NCN1hISmNiaUFnSUNCcFppQW9kbUZzZFdVZ1BpQm9hV2RvS1Z4eVhHNGdJQ0FnSUNBZ0lIWmhiSFZsSUQwZ2FHbG5hRHRjY2x4dUlDQWdJR2xtSUNoMllXeDFaU0E4SUd4dmR5bGNjbHh1SUNBZ0lDQWdJQ0IyWVd4MVpTQTlJR3h2ZHp0Y2NseHVJQ0FnSUhKbGRIVnliaUIyWVd4MVpTQjhJREE3WEhKY2JuMWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJR2x1VW1GdVoyVXdkRzh5TlRWU2IzVnVaR1ZrS0c0cElIdGNjbHh1SUNBZ0lHNGdQU0JOWVhSb0xuSnZkVzVrS0c0cE8xeHlYRzRnSUNBZ2FXWWdLRzRnUGlBeU5UVXBYSEpjYmlBZ0lDQWdJQ0FnYmlBOUlESTFOVHRjY2x4dUlDQWdJR1ZzYzJVZ2FXWWdLRzRnUENBd0tWeHlYRzRnSUNBZ0lDQWdJRzRnUFNBd08xeHlYRzRnSUNBZ2NtVjBkWEp1SUc0N1hISmNibjFjY2x4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdsdVVtRnVaMlV3ZEc4eU5UVW9iaWtnZTF4eVhHNGdJQ0FnYVdZZ0tHNGdQaUF5TlRVcFhISmNiaUFnSUNBZ0lDQWdiaUE5SURJMU5UdGNjbHh1SUNBZ0lHVnNjMlVnYVdZZ0tHNGdQQ0F3S1Z4eVhHNGdJQ0FnSUNBZ0lHNGdQU0F3TzF4eVhHNGdJQ0FnY21WMGRYSnVJRzQ3WEhKY2JuMWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJSE4wWVdKc1pWTnZjblFvWVhKeVlYbFViMU52Y25Rc0lHTmhiR3hpWVdOcktTQjdYSEpjYmlBZ0lDQmpiMjV6ZENCMGVYQmxJRDBnZEhsd1pXOW1JR0Z5Y21GNVZHOVRiM0owV3pCZE8xeHlYRzRnSUNBZ2JHVjBJSE52Y25SbFpEdGNjbHh1SUNBZ0lHbG1JQ2gwZVhCbElEMDlQU0FuYm5WdFltVnlKeUI4ZkNCMGVYQmxJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHOXlaQ0E5SUU5aWFtVmpkQzVqY21WaGRHVW9iblZzYkNrN0lDOHZJSFJ6YkdsdWREcGthWE5oWW14bExXeHBibVU2Ym04dGJuVnNiQzFyWlhsM2IzSmtYSEpjYmlBZ0lDQWdJQ0FnWm05eUlDaHNaWFFnYVNBOUlEQXNJR3dnUFNCaGNuSmhlVlJ2VTI5eWRDNXNaVzVuZEdnN0lHa2dQQ0JzT3lCcEt5c3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2RtRnNJRDBnWVhKeVlYbFViMU52Y25SYmFWMDdJQzh2SUhSemJHbHVkRHBrYVhOaFlteGxMV3hwYm1VNmJtOHRZVzU1WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNodmNtUmJkbUZzWFNCOGZDQnZjbVJiZG1Gc1hTQTlQVDBnTUNsY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZiblJwYm5WbE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCdmNtUmJkbUZzWFNBOUlHazdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lITnZjblJsWkNBOUlHRnljbUY1Vkc5VGIzSjBMbk52Y25Rb1puVnVZM1JwYjI0Z0tHRXNJR0lwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR05oYkd4aVlXTnJLR0VzSUdJcElIeDhJRzl5WkZ0aFhTQXRJRzl5WkZ0aVhUdGNjbHh1SUNBZ0lDQWdJQ0I5S1R0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUdWc2MyVWdlMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJRzl5WkRJZ1BTQmhjbkpoZVZSdlUyOXlkQzV6YkdsalpTZ3dLVHRjY2x4dUlDQWdJQ0FnSUNCemIzSjBaV1FnUFNCaGNuSmhlVlJ2VTI5eWRDNXpiM0owS0daMWJtTjBhVzl1SUNoaExDQmlLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQmpZV3hzWW1GamF5aGhMQ0JpS1NCOGZDQnZjbVF5TG1sdVpHVjRUMllvWVNrZ0xTQnZjbVF5TG1sdVpHVjRUMllvWWlrN1hISmNiaUFnSUNBZ0lDQWdmU2s3WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0J5WlhSMWNtNGdjMjl5ZEdWa08xeHlYRzU5WEhKY2JpOHZJeUJ6YjNWeVkyVk5ZWEJ3YVc1blZWSk1QV0Z5YVhSb2JXVjBhV011YW5NdWJXRndJaXdpTHlvcVhISmNiaUFxSUVCd2NtVnpaWEoyWlZ4eVhHNGdLaUJEYjNCNWNtbG5hSFFnTWpBeE5TMHlNREU0SUVsbmIzSWdRbVY2YTNKdmRtNTVhVnh5WEc0Z0tpQkJiR3dnY21sbmFIUnpJSEpsYzJWeWRtVmtMaUFvVFVsVUlFeHBZMlZ1YzJWa0tWeHlYRzRnS2x4eVhHNGdLaUJvZFdWVGRHRjBhWE4wYVdOekxuUnpJQzBnY0dGeWRDQnZaaUJKYldGblpTQlJkV0Z1ZEdsNllYUnBiMjRnVEdsaWNtRnllVnh5WEc0Z0tpOWNjbHh1YVcxd2IzSjBJSHNnY21kaU1taHpiQ0I5SUdaeWIyMGdKeTR1TDJOdmJuWmxjbk5wYjI0dmNtZGlNbWh6YkNjN1hISmNibWx0Y0c5eWRDQjdJR2gxWlVkeWIzVndJSDBnWm5KdmJTQW5MaTl3WVd4bGRIUmxKenRjY2x4dVkyeGhjM01nU0hWbFIzSnZkWEFnZTF4eVhHNGdJQ0FnWTI5dWMzUnlkV04wYjNJb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NXVkVzBnUFNBd08xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVkyOXNjeUE5SUZ0ZE8xeHlYRzRnSUNBZ2ZWeHlYRzU5WEhKY2JtVjRjRzl5ZENCamJHRnpjeUJJZFdWVGRHRjBhWE4wYVdOeklIdGNjbHh1SUNBZ0lHTnZibk4wY25WamRHOXlLRzUxYlVkeWIzVndjeXdnYldsdVEyOXNjeWtnZTF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDI1MWJVZHliM1Z3Y3lBOUlHNTFiVWR5YjNWd2N6dGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXRhVzVEYjJ4eklEMGdiV2x1UTI5c2N6dGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXpkR0YwY3lBOUlGdGRPMXh5WEc0Z0lDQWdJQ0FnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3OUlHNTFiVWR5YjNWd2N6c2dhU3NyS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYM04wWVhSelcybGRJRDBnYm1WM0lFaDFaVWR5YjNWd0tDazdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJkeWIzVndjMFoxYkd3Z1BTQXdPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdZMmhsWTJzb2FUTXlLU0I3WEhKY2JpQWdJQ0FnSUNBZ2FXWWdLSFJvYVhNdVgyZHliM1Z3YzBaMWJHd2dQVDA5SUhSb2FYTXVYMjUxYlVkeWIzVndjeUFySURFcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVqYUdWamF5QTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZlR0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdjaUE5SUNocE16SWdKaUF3ZUdabUtUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQm5JRDBnS0drek1pQStQajRnT0NrZ0ppQXdlR1ptTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdJZ1BTQW9hVE15SUQ0K1BpQXhOaWtnSmlBd2VHWm1PMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR2huSUQwZ0tISWdQVDA5SUdjZ0ppWWdaeUE5UFQwZ1lpa2dQeUF3SURvZ01TQXJJR2gxWlVkeWIzVndLSEpuWWpKb2Myd29jaXdnWnl3Z1lpa3VhQ3dnZEdocGN5NWZiblZ0UjNKdmRYQnpLVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JuY2lBOUlIUm9hWE11WDNOMFlYUnpXMmhuWFR0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCdGFXNGdQU0IwYUdsekxsOXRhVzVEYjJ4ek8xeHlYRzRnSUNBZ0lDQWdJR2R5TG01MWJTc3JPMXh5WEc0Z0lDQWdJQ0FnSUdsbUlDaG5jaTV1ZFcwZ1BpQnRhVzRwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVPMXh5WEc0Z0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQnBaaUFvWjNJdWJuVnRJRDA5UFNCdGFXNHBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZlozSnZkWEJ6Um5Wc2JDc3JPMXh5WEc0Z0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQnBaaUFvWjNJdWJuVnRJRHc5SUcxcGJpa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5emRHRjBjMXRvWjEwdVkyOXNjeTV3ZFhOb0tHa3pNaWs3WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ2FXNXFaV04wU1c1MGIwUnBZM1JwYjI1aGNua29hR2x6ZEVjcElIdGNjbHh1SUNBZ0lDQWdJQ0JtYjNJZ0tHeGxkQ0JwSUQwZ01Ec2dhU0E4UFNCMGFHbHpMbDl1ZFcxSGNtOTFjSE03SUdrckt5a2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NWZjM1JoZEhOYmFWMHViblZ0SUR3OUlIUm9hWE11WDIxcGJrTnZiSE1wSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WDNOMFlYUnpXMmxkTG1OdmJITXVabTl5UldGamFDZ29ZMjlzS1NBOVBpQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLQ0ZvYVhOMFIxdGpiMnhkS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHaHBjM1JIVzJOdmJGMGdQU0F4TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxiSE5sSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FHbHpkRWRiWTI5c1hTc3JPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ2FXNXFaV04wU1c1MGIwRnljbUY1S0docGMzUkhLU0I3WEhKY2JpQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BEMGdkR2hwY3k1ZmJuVnRSM0p2ZFhCek95QnBLeXNwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIUm9hWE11WDNOMFlYUnpXMmxkTG01MWJTQThQU0IwYUdsekxsOXRhVzVEYjJ4ektTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOXpkR0YwYzF0cFhTNWpiMnh6TG1admNrVmhZMmdvS0dOdmJDa2dQVDRnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNob2FYTjBSeTVwYm1SbGVFOW1LR052YkNrZ1BUMDlJQzB4S1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHaHBjM1JITG5CMWMyZ29ZMjlzS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOUtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJSDFjY2x4dWZWeHlYRzR2THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxb2RXVlRkR0YwYVhOMGFXTnpMbXB6TG0xaGNDSXNJaThxS2x4eVhHNGdLaUJBY0hKbGMyVnlkbVZjY2x4dUlDb2dRMjl3ZVhKcFoyaDBJREl3TVRVdE1qQXhPQ0JKWjI5eUlFSmxlbXR5YjNadWVXbGNjbHh1SUNvZ1FXeHNJSEpwWjJoMGN5QnlaWE5sY25abFpDNGdLRTFKVkNCTWFXTmxibk5sWkNsY2NseHVJQ3BjY2x4dUlDb2dhWEV1ZEhNZ0xTQkpiV0ZuWlNCUmRXRnVkR2w2WVhScGIyNGdUR2xpY21GeWVWeHlYRzRnS2k5Y2NseHVhVzF3YjNKMElDb2dZWE1nWVhKcGRHaHRaWFJwWXlCbWNtOXRJQ2N1TDJGeWFYUm9iV1YwYVdNbk8xeHlYRzVwYlhCdmNuUWdleUJJZFdWVGRHRjBhWE4wYVdOeklIMGdabkp2YlNBbkxpOW9kV1ZUZEdGMGFYTjBhV056Snp0Y2NseHVhVzF3YjNKMElIc2dVR0ZzWlhSMFpTQjlJR1p5YjIwZ0p5NHZjR0ZzWlhSMFpTYzdYSEpjYm1sdGNHOXlkQ0I3SUZCdmFXNTBJSDBnWm5KdmJTQW5MaTl3YjJsdWRDYzdYSEpjYm1sdGNHOXlkQ0I3SUZCdmFXNTBRMjl1ZEdGcGJtVnlJSDBnWm5KdmJTQW5MaTl3YjJsdWRFTnZiblJoYVc1bGNpYzdYSEpjYm1sdGNHOXlkQ0I3SUZCeWIyZHlaWE56VkhKaFkydGxjaUI5SUdaeWIyMGdKeTR2Y0hKdlozSmxjM05VY21GamEyVnlKenRjY2x4dVpYaHdiM0owSUhzZ1VHOXBiblFzSUZCdmFXNTBRMjl1ZEdGcGJtVnlMQ0JRWVd4bGRIUmxMQ0JJZFdWVGRHRjBhWE4wYVdOekxDQlFjbTluY21WemMxUnlZV05yWlhJc0lHRnlhWFJvYldWMGFXTXNJSDA3WEhKY2JpOHZJeUJ6YjNWeVkyVk5ZWEJ3YVc1blZWSk1QV2x1WkdWNExtcHpMbTFoY0NJc0lpOHFLbHh5WEc0Z0tpQkFjSEpsYzJWeWRtVmNjbHh1SUNvZ1EyOXdlWEpwWjJoMElESXdNVFV0TWpBeE9DQkpaMjl5SUVKbGVtdHliM1p1ZVdsY2NseHVJQ29nUVd4c0lISnBaMmgwY3lCeVpYTmxjblpsWkM0Z0tFMUpWQ0JNYVdObGJuTmxaQ2xjY2x4dUlDcGNjbHh1SUNvZ2NHRnNaWFIwWlM1MGN5QXRJSEJoY25RZ2IyWWdTVzFoWjJVZ1VYVmhiblJwZW1GMGFXOXVJRXhwWW5KaGNubGNjbHh1SUNvdlhISmNibWx0Y0c5eWRDQjdJRkJ2YVc1MFEyOXVkR0ZwYm1WeUlIMGdabkp2YlNBbkxpOXdiMmx1ZEVOdmJuUmhhVzVsY2ljN1hISmNibWx0Y0c5eWRDQjdJSEpuWWpKb2Myd2dmU0JtY205dElDY3VMaTlqYjI1MlpYSnphVzl1TDNKbllqSm9jMnduTzF4eVhHNHZMeUJVVDBSUE9pQnRZV3RsSUhCaGJHVjBkR1ZCY25KaGVTQjJhV0VnY0c5cGJuUkRiMjUwWVdsdVpYSXNJSE52TENCbGVIQnZjblFnZDJsc2JDQmlaU0JoZG1GcGJHRmliR1VnZG1saElIQnZhVzUwUTI5dWRHRnBibVZ5TG1WNGNHOXlkRmhZV0Z4eVhHNWpiMjV6ZENCb2RXVkhjbTkxY0hNZ1BTQXhNRHRjY2x4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdoMVpVZHliM1Z3S0doMVpTd2djMlZuYldWdWRITk9kVzFpWlhJcElIdGNjbHh1SUNBZ0lHTnZibk4wSUcxaGVFaDFaU0E5SURNMk1EdGNjbHh1SUNBZ0lHTnZibk4wSUhObFp5QTlJRzFoZUVoMVpTQXZJSE5sWjIxbGJuUnpUblZ0WW1WeU8xeHlYRzRnSUNBZ1kyOXVjM1FnYUdGc1ppQTlJSE5sWnlBdklESTdYSEpjYmlBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTVN3Z2JXbGtJRDBnYzJWbklDMGdhR0ZzWmpzZ2FTQThJSE5sWjIxbGJuUnpUblZ0WW1WeU95QnBLeXNzSUcxcFpDQXJQU0J6WldjcElIdGNjbHh1SUNBZ0lDQWdJQ0JwWmlBb2FIVmxJRDQ5SUcxcFpDQW1KaUJvZFdVZ1BDQnRhV1FnS3lCelpXY3BYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCcE8xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ2NtVjBkWEp1SURBN1hISmNibjFjY2x4dVpYaHdiM0owSUdOc1lYTnpJRkJoYkdWMGRHVWdlMXh5WEc0Z0lDQWdZMjl1YzNSeWRXTjBiM0lvS1NCN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmNHOXBiblJCY25KaGVTQTlJRnRkTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJrek1tbGtlQ0E5SUh0OU8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgzQnZhVzUwUTI5dWRHRnBibVZ5SUQwZ2JtVjNJRkJ2YVc1MFEyOXVkR0ZwYm1WeUtDazdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZjRzlwYm5SRGIyNTBZV2x1WlhJdWMyVjBTR1ZwWjJoMEtERXBPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYM0J2YVc1MFFYSnlZWGtnUFNCMGFHbHpMbDl3YjJsdWRFTnZiblJoYVc1bGNpNW5aWFJRYjJsdWRFRnljbUY1S0NrN1hISmNiaUFnSUNCOVhISmNiaUFnSUNCaFpHUW9ZMjlzYjNJcElIdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxsOXdiMmx1ZEVGeWNtRjVMbkIxYzJnb1kyOXNiM0lwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDNCdmFXNTBRMjl1ZEdGcGJtVnlMbk5sZEZkcFpIUm9LSFJvYVhNdVgzQnZhVzUwUVhKeVlYa3ViR1Z1WjNSb0tUdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lHaGhjeWhqYjJ4dmNpa2dlMXh5WEc0Z0lDQWdJQ0FnSUdadmNpQW9iR1YwSUdrZ1BTQjBhR2x6TGw5d2IybHVkRUZ5Y21GNUxteGxibWQwYUNBdElERTdJR2tnUGowZ01Ec2dhUzB0S1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaGpiMnh2Y2k1MWFXNTBNeklnUFQwOUlIUm9hWE11WDNCdmFXNTBRWEp5WVhsYmFWMHVkV2x1ZERNeUtWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUM4dklGUlBWRkpaT2lCMWMyVWdTRlZUVENBdElHaDBkSEE2THk5aWIzSnZibWx1WlM1amIyMHZhSFZ6YkM4Z2FIUjBjRG92TDNkM2R5NW9kWE5zTFdOdmJHOXljeTV2Y21jdklHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOW9kWE5zTFdOdmJHOXljeTlvZFhOc1hISmNiaUFnSUNCblpYUk9aV0Z5WlhOMFEyOXNiM0lvWTI5c2IzSkVhWE4wWVc1alpVTmhiR04xYkdGMGIzSXNJR052Ykc5eUtTQjdYSEpjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdVgzQnZhVzUwUVhKeVlYbGJkR2hwY3k1ZloyVjBUbVZoY21WemRFbHVaR1Y0S0dOdmJHOXlSR2x6ZEdGdVkyVkRZV3hqZFd4aGRHOXlMQ0JqYjJ4dmNpa2dmQ0F3WFR0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUdkbGRGQnZhVzUwUTI5dWRHRnBibVZ5S0NrZ2UxeHlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TGw5d2IybHVkRU52Ym5SaGFXNWxjanRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJQzh2SUZSUFZGSlpPaUIxYzJVZ1NGVlRUQ0F0SUdoMGRIQTZMeTlpYjNKdmJtbHVaUzVqYjIwdmFIVnpiQzljY2x4dUlDQWdJQzhxWEhKY2JpQWdJQ0FnY0hWaWJHbGpJRzVsWVhKbGMzUkpibVJsZUVKNVZXbHVkRE15S0drek1pa2dlMXh5WEc0Z0lDQWdJSFpoY2lCcFpIZ2dPaUJ1ZFcxaVpYSWdQU0IwYUdsekxsOXVaV0Z5WlhOMFVHOXBiblJHY205dFEyRmphR1VvWENKY0lpQXJJR2t6TWlrN1hISmNiaUFnSUNBZ2FXWWdLR2xrZUNBK1BTQXdLU0J5WlhSMWNtNGdhV1I0TzF4eVhHNGdJRnh5WEc0Z0lDQWdJSFpoY2lCdGFXNGdQU0F4TURBd0xGeHlYRzRnSUNBZ0lISm5ZaUE5SUZ0Y2NseHVJQ0FnSUNBb2FUTXlJQ1lnTUhobVppa3NYSEpjYmlBZ0lDQWdLR2t6TWlBK1BqNGdPQ2tnSmlBd2VHWm1MRnh5WEc0Z0lDQWdJQ2hwTXpJZ1BqNCtJREUyS1NBbUlEQjRabVlzWEhKY2JpQWdJQ0FnS0drek1pQStQajRnTWpRcElDWWdNSGhtWmx4eVhHNGdJQ0FnSUYwc1hISmNiaUFnSUNBZ2JHVnVJRDBnZEdocGN5NWZjRzlwYm5SQmNuSmhlUzVzWlc1bmRHZzdYSEpjYmlBZ1hISmNiaUFnSUNBZ2FXUjRJRDBnTUR0Y2NseHVJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxianNnYVNzcktTQjdYSEpjYmlBZ0lDQWdkbUZ5SUdScGMzUWdQU0JWZEdsc2N5NWthWE4wUlhWamJHbGtaV0Z1S0hKbllpd2dkR2hwY3k1ZmNHOXBiblJCY25KaGVWdHBYUzV5WjJKaEtUdGNjbHh1SUNCY2NseHVJQ0FnSUNCcFppQW9aR2x6ZENBOElHMXBiaWtnZTF4eVhHNGdJQ0FnSUcxcGJpQTlJR1JwYzNRN1hISmNiaUFnSUNBZ2FXUjRJRDBnYVR0Y2NseHVJQ0FnSUNCOVhISmNiaUFnSUNBZ2ZWeHlYRzRnSUZ4eVhHNGdJQ0FnSUhSb2FYTXVYMmt6TW1sa2VGdHBNekpkSUQwZ2FXUjRPMXh5WEc0Z0lDQWdJSEpsZEhWeWJpQnBaSGc3WEhKY2JpQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNvdlhISmNiaUFnSUNCZmJtVmhjbVZ6ZEZCdmFXNTBSbkp2YlVOaFkyaGxLR3RsZVNrZ2UxeHlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBlWEJsYjJZZ2RHaHBjeTVmYVRNeWFXUjRXMnRsZVYwZ1BUMDlJQ2R1ZFcxaVpYSW5JRDhnZEdocGN5NWZhVE15YVdSNFcydGxlVjBnT2lBdE1UdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lGOW5aWFJPWldGeVpYTjBTVzVrWlhnb1kyOXNiM0pFYVhOMFlXNWpaVU5oYkdOMWJHRjBiM0lzSUhCdmFXNTBLU0I3WEhKY2JpQWdJQ0FnSUNBZ2JHVjBJR2xrZUNBOUlIUm9hWE11WDI1bFlYSmxjM1JRYjJsdWRFWnliMjFEWVdOb1pTZ25KeUFySUhCdmFXNTBMblZwYm5Rek1pazdYSEpjYmlBZ0lDQWdJQ0FnYVdZZ0tHbGtlQ0ErUFNBd0tWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYVdSNE8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCdGFXNXBiV0ZzUkdsemRHRnVZMlVnUFNCT2RXMWlaWEl1VFVGWVgxWkJURlZGTzF4eVhHNGdJQ0FnSUNBZ0lHbGtlQ0E5SURBN1hISmNiaUFnSUNBZ0lDQWdabTl5SUNoc1pYUWdhU0E5SURBc0lHd2dQU0IwYUdsekxsOXdiMmx1ZEVGeWNtRjVMbXhsYm1kMGFEc2dhU0E4SUd3N0lHa3JLeWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQndJRDBnZEdocGN5NWZjRzlwYm5SQmNuSmhlVnRwWFR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdaR2x6ZEdGdVkyVWdQU0JqYjJ4dmNrUnBjM1JoYm1ObFEyRnNZM1ZzWVhSdmNpNWpZV3hqZFd4aGRHVlNZWGNvY0c5cGJuUXVjaXdnY0c5cGJuUXVaeXdnY0c5cGJuUXVZaXdnY0c5cGJuUXVZU3dnY0M1eUxDQndMbWNzSUhBdVlpd2djQzVoS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHUnBjM1JoYm1ObElEd2diV2x1YVcxaGJFUnBjM1JoYm1ObEtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J0YVc1cGJXRnNSR2x6ZEdGdVkyVWdQU0JrYVhOMFlXNWpaVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsa2VDQTlJR2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmFUTXlhV1I0VzNCdmFXNTBMblZwYm5Rek1sMGdQU0JwWkhnN1hISmNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHbGtlRHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJQzhxWEhKY2JpQWdJQ0FnY0hWaWJHbGpJSEpsWkhWalpTaG9hWE4wYjJkeVlXMGdPaUJEYjJ4dmNraHBjM1J2WjNKaGJTd2dZMjlzYjNKeklEb2diblZ0WW1WeUtTQjdYSEpjYmlBZ0lDQWdhV1lnS0hSb2FYTXVYM0J2YVc1MFFYSnlZWGt1YkdWdVozUm9JRDRnWTI5c2IzSnpLU0I3WEhKY2JpQWdJQ0FnZG1GeUlHbGtlR2t6TWlBOUlHaHBjM1J2WjNKaGJTNW5aWFJKYlhCdmNuUmhibU5sVTI5eWRHVmtRMjlzYjNKelNVUllTVE15S0NrN1hISmNiaUFnWEhKY2JpQWdJQ0FnTHk4Z2NYVmhiblJwZW1VZ2FHbHpkRzluY21GdElIUnZJR1Y0YVhOMGFXNW5JSEJoYkdWMGRHVmNjbHh1SUNBZ0lDQjJZWElnYTJWbGNDQTlJRnRkTENCMWJtbHhkV1ZEYjJ4dmNuTWdQU0F3TENCcFpIZ3NJSEJ5ZFc1bFpDQTlJR1poYkhObE8xeHlYRzRnSUZ4eVhHNGdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdMQ0JzWlc0Z1BTQnBaSGhwTXpJdWJHVnVaM1JvT3lCcElEd2diR1Z1T3lCcEt5c3BJSHRjY2x4dUlDQWdJQ0F2THlCd1lXeGxkSFJsSUd4bGJtZDBhQ0J5WldGamFHVmtMQ0IxYm5ObGRDQmhiR3dnY21WdFlXbHVhVzVuSUdOdmJHOXljeUFvYzNCaGNuTmxJSEJoYkdWMGRHVXBYSEpjYmlBZ0lDQWdhV1lnS0hWdWFYRjFaVU52Ykc5eWN5QStQU0JqYjJ4dmNuTXBJSHRjY2x4dUlDQWdJQ0IwYUdsekxuQnlkVzVsVUdGc0tHdGxaWEFwTzF4eVhHNGdJQ0FnSUhCeWRXNWxaQ0E5SUhSeWRXVTdYSEpjYmlBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ2ZTQmxiSE5sSUh0Y2NseHVJQ0FnSUNCcFpIZ2dQU0IwYUdsekxtNWxZWEpsYzNSSmJtUmxlRUo1VldsdWRETXlLR2xrZUdrek1sdHBYU2s3WEhKY2JpQWdJQ0FnYVdZZ0tHdGxaWEF1YVc1a1pYaFBaaWhwWkhncElEd2dNQ2tnZTF4eVhHNGdJQ0FnSUd0bFpYQXVjSFZ6YUNocFpIZ3BPMXh5WEc0Z0lDQWdJSFZ1YVhGMVpVTnZiRzl5Y3lzck8xeHlYRzRnSUNBZ0lIMWNjbHh1SUNBZ0lDQjlYSEpjYmlBZ0lDQWdmVnh5WEc0Z0lGeHlYRzRnSUNBZ0lHbG1JQ2doY0hKMWJtVmtLU0I3WEhKY2JpQWdJQ0FnZEdocGN5NXdjblZ1WlZCaGJDaHJaV1Z3S1R0Y2NseHVJQ0FnSUNCOVhISmNiaUFnSUNBZ2ZWeHlYRzRnSUNBZ0lIMWNjbHh1SUNCY2NseHVJQ0FnSUNBdkx5QlVUMFJQT2lCamFHVmpheUIxYzJGblpTd2dibTkwSUhSbGMzUmxaQ0ZjY2x4dUlDQWdJQ0J3ZFdKc2FXTWdjSEoxYm1WUVlXd29hMlZsY0NBNklHNTFiV0psY2x0ZEtTQjdYSEpjYmlBZ0lDQWdkbUZ5SUdOdmJHOXljeUE5SUhSb2FYTXVYM0J2YVc1MFFYSnlZWGt1YkdWdVozUm9PMXh5WEc0Z0lDQWdJR1p2Y2lBb2RtRnlJR052Ykc5eVNXNWtaWGdnUFNCamIyeHZjbk1nTFNBeE95QmpiMnh2Y2tsdVpHVjRJRDQ5SURBN0lHTnZiRzl5U1c1a1pYZ3RMU2tnZTF4eVhHNGdJQ0FnSUdsbUlDaHJaV1Z3TG1sdVpHVjRUMllvWTI5c2IzSkpibVJsZUNrZ1BDQXdLU0I3WEhKY2JpQWdYSEpjYmlBZ0lDQWdhV1lvWTI5c2IzSkpibVJsZUNBcklERWdQQ0JqYjJ4dmNuTXBJSHRjY2x4dUlDQWdJQ0IwYUdsekxsOXdiMmx1ZEVGeWNtRjVXeUJqYjJ4dmNrbHVaR1Y0SUYwZ1BTQjBhR2x6TGw5d2IybHVkRUZ5Y21GNUlGc2dZMjlzYjNKeklDMGdNU0JkTzF4eVhHNGdJQ0FnSUgxY2NseHVJQ0FnSUNBdExXTnZiRzl5Y3p0Y2NseHVJQ0FnSUNBdkwzUm9hWE11WDNCdmFXNTBRWEp5WVhsYlkyOXNiM0pKYm1SbGVGMGdQU0J1ZFd4c08xeHlYRzRnSUNBZ0lIMWNjbHh1SUNBZ0lDQjlYSEpjYmlBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWENKamIyeHZjbk1nY0hKMWJtVmtPaUJjSWlBcklDaDBhR2x6TGw5d2IybHVkRUZ5Y21GNUxteGxibWQwYUNBdElHTnZiRzl5Y3lrcE8xeHlYRzRnSUNBZ0lIUm9hWE11WDNCdmFXNTBRWEp5WVhrdWJHVnVaM1JvSUQwZ1kyOXNiM0p6TzF4eVhHNGdJQ0FnSUhSb2FYTXVYMmt6TW1sa2VDQTlJSHQ5TzF4eVhHNGdJQ0FnSUgxY2NseHVJQ0FnSUNBcUwxeHlYRzRnSUNBZ0x5OGdWRTlFVHpvZ1ozSnZkWEFnZG1WeWVTQnNiM2NnYkhWdElHRnVaQ0IyWlhKNUlHaHBaMmdnYkhWdElHTnZiRzl5YzF4eVhHNGdJQ0FnTHk4Z1ZFOUVUem9nY0dGemN5QmpkWE4wYjIwZ2MyOXlkQ0J2Y21SbGNseHlYRzRnSUNBZ0x5OGdWRTlFVHpvZ2MyOXlkQ0JqY21sMFpYSnBZU0JtZFc1amRHbHZiaUJ6YUc5MWJHUWdZbVVnY0d4aFkyVmtJSFJ2SUVoMVpWTjBZWFJ6SUdOc1lYTnpYSEpjYmlBZ0lDQnpiM0owS0NrZ2UxeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgya3pNbWxrZUNBOUlIdDlPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYM0J2YVc1MFFYSnlZWGt1YzI5eWRDZ29ZU3dnWWlrZ1BUNGdlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6ZENCb2MyeEJJRDBnY21kaU1taHpiQ2hoTG5Jc0lHRXVaeXdnWVM1aUtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnYUhOc1FpQTlJSEpuWWpKb2Myd29ZaTV5TENCaUxtY3NJR0l1WWlrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklITnZjblFnWVd4c0lHZHlZWGx6SUNzZ2QyaHBkR1Z6SUhSdloyVjBhR1Z5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHaDFaVUVnUFNBb1lTNXlJRDA5UFNCaExtY2dKaVlnWVM1bklEMDlQU0JoTG1JcElEOGdNQ0E2SURFZ0t5Qm9kV1ZIY205MWNDaG9jMnhCTG1nc0lHaDFaVWR5YjNWd2N5azdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk4wSUdoMVpVSWdQU0FvWWk1eUlEMDlQU0JpTG1jZ0ppWWdZaTVuSUQwOVBTQmlMbUlwSUQ4Z01DQTZJREVnS3lCb2RXVkhjbTkxY0Nob2MyeENMbWdzSUdoMVpVZHliM1Z3Y3lrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUM4cVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNCMllYSWdhSFZsUVNBOUlDaGhMbklnUFQwOUlHRXVaeUFtSmlCaExtY2dQVDA5SUdFdVlpa2dQeUF3SURvZ01TQXJJRlYwYVd4ekxtaDFaVWR5YjNWd0tHaHpiRUV1YUN3Z2FIVmxSM0p2ZFhCektUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUJvZFdWQ0lEMGdLR0l1Y2lBOVBUMGdZaTVuSUNZbUlHSXVaeUE5UFQwZ1lpNWlLU0EvSURBZ09pQXhJQ3NnVlhScGJITXVhSFZsUjNKdmRYQW9hSE5zUWk1b0xDQm9kV1ZIY205MWNITXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdLaTljY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ2FIVmxSR2xtWmlBOUlHaDFaVUlnTFNCb2RXVkJPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvYUhWbFJHbG1aaWxjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUF0YUhWbFJHbG1aanRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdMeXBjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCc2RXMUVhV1ptSUQwZ1ZYUnBiSE11YkhWdFIzSnZkWEFvSzJoemJFSXViQzUwYjBacGVHVmtLRElwS1NBdElGVjBhV3h6TG14MWJVZHliM1Z3S0N0b2MyeEJMbXd1ZEc5R2FYaGxaQ2d5S1NrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNCcFppQW9iSFZ0UkdsbVppa2djbVYwZFhKdUlDMXNkVzFFYVdabU8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0tpOWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnYkVFZ1BTQmhMbWRsZEV4MWJXbHViM05wZEhrb2RISjFaU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHeENJRDBnWWk1blpYUk1kVzFwYm05emFYUjVLSFJ5ZFdVcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9iRUlnTFNCc1FTQWhQVDBnTUNsY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCc1FpQXRJR3hCTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnpZWFJFYVdabUlEMGdLQ2hvYzJ4Q0xuTWdLaUF4TURBcElId2dNQ2tnTFNBb0tHaHpiRUV1Y3lBcUlERXdNQ2tnZkNBd0tUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSE5oZEVScFptWXBYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdMWE5oZEVScFptWTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlBd08xeHlYRzRnSUNBZ0lDQWdJSDBwTzF4eVhHNGdJQ0FnZlZ4eVhHNTlYSEpjYmk4dkl5QnpiM1Z5WTJWTllYQndhVzVuVlZKTVBYQmhiR1YwZEdVdWFuTXViV0Z3SWl3aUx5b3FYSEpjYmlBcUlFQndjbVZ6WlhKMlpWeHlYRzRnS2lCRGIzQjVjbWxuYUhRZ01qQXhOUzB5TURFNElFbG5iM0lnUW1WNmEzSnZkbTU1YVZ4eVhHNGdLaUJCYkd3Z2NtbG5hSFJ6SUhKbGMyVnlkbVZrTGlBb1RVbFVJRXhwWTJWdWMyVmtLVnh5WEc0Z0tseHlYRzRnS2lCd2IybHVkQzUwY3lBdElIQmhjblFnYjJZZ1NXMWhaMlVnVVhWaGJuUnBlbUYwYVc5dUlFeHBZbkpoY25sY2NseHVJQ292WEhKY2JtbHRjRzl5ZENCN0lGa2dmU0JtY205dElDY3VMaTlqYjI1emRHRnVkSE12WW5RM01Ea25PMXh5WEc0dktpcGNjbHh1SUNvZ2RqZ2diM0IwYVcxcGVtVmtJR05zWVhOelhISmNiaUFxSURFcElGd2lZMjl1YzNSeWRXTjBiM0pjSWlCemFHOTFiR1FnYUdGMlpTQnBibWwwYVdGc2FYcGhkR2x2YmlCM2FYUm9JSGR2Y25OMElIUjVjR1Z6WEhKY2JpQXFJRElwSUZ3aWMyVjBYQ0lnYzJodmRXeGtJR2hoZG1VZ2ZEQWdMeUErUGo0Z01GeHlYRzRnS2k5Y2NseHVaWGh3YjNKMElHTnNZWE56SUZCdmFXNTBJSHRjY2x4dUlDQWdJQzh2SUV4aFlpQTZJSHNnVENBNklHNTFiV0psY2pzZ1lTQTZJRzUxYldKbGNqc2dZaUE2SUc1MWJXSmxjaUI5TzF4eVhHNGdJQ0FnYzNSaGRHbGpJR055WldGMFpVSjVVWFZoWkhKMWNHeGxkQ2h4ZFdGa2NuVndiR1YwS1NCN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2NHOXBiblFnUFNCdVpYY2dVRzlwYm5Rb0tUdGNjbHh1SUNBZ0lDQWdJQ0J3YjJsdWRDNXlJRDBnY1hWaFpISjFjR3hsZEZzd1hTQjhJREE3WEhKY2JpQWdJQ0FnSUNBZ2NHOXBiblF1WnlBOUlIRjFZV1J5ZFhCc1pYUmJNVjBnZkNBd08xeHlYRzRnSUNBZ0lDQWdJSEJ2YVc1MExtSWdQU0J4ZFdGa2NuVndiR1YwV3pKZElId2dNRHRjY2x4dUlDQWdJQ0FnSUNCd2IybHVkQzVoSUQwZ2NYVmhaSEoxY0d4bGRGc3pYU0I4SURBN1hISmNiaUFnSUNBZ0lDQWdjRzlwYm5RdVgyeHZZV1JWU1U1VU16SW9LVHRjY2x4dUlDQWdJQ0FnSUNCd2IybHVkQzVmYkc5aFpGRjFZV1J5ZFhCc1pYUW9LVHRjY2x4dUlDQWdJQ0FnSUNBdkx5QndiMmx1ZEM1ZmJHOWhaRXhoWWlncE8xeHlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQndiMmx1ZER0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhOMFlYUnBZeUJqY21WaGRHVkNlVkpIUWtFb2NtVmtMQ0JuY21WbGJpd2dZbXgxWlN3Z1lXeHdhR0VwSUh0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCd2IybHVkQ0E5SUc1bGR5QlFiMmx1ZENncE8xeHlYRzRnSUNBZ0lDQWdJSEJ2YVc1MExuSWdQU0J5WldRZ2ZDQXdPMXh5WEc0Z0lDQWdJQ0FnSUhCdmFXNTBMbWNnUFNCbmNtVmxiaUI4SURBN1hISmNiaUFnSUNBZ0lDQWdjRzlwYm5RdVlpQTlJR0pzZFdVZ2ZDQXdPMXh5WEc0Z0lDQWdJQ0FnSUhCdmFXNTBMbUVnUFNCaGJIQm9ZU0I4SURBN1hISmNiaUFnSUNBZ0lDQWdjRzlwYm5RdVgyeHZZV1JWU1U1VU16SW9LVHRjY2x4dUlDQWdJQ0FnSUNCd2IybHVkQzVmYkc5aFpGRjFZV1J5ZFhCc1pYUW9LVHRjY2x4dUlDQWdJQ0FnSUNBdkx5QndiMmx1ZEM1ZmJHOWhaRXhoWWlncE8xeHlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQndiMmx1ZER0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhOMFlYUnBZeUJqY21WaGRHVkNlVlZwYm5Rek1paDFhVzUwTXpJcElIdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQndiMmx1ZENBOUlHNWxkeUJRYjJsdWRDZ3BPMXh5WEc0Z0lDQWdJQ0FnSUhCdmFXNTBMblZwYm5Rek1pQTlJSFZwYm5Rek1pQStQajRnTUR0Y2NseHVJQ0FnSUNBZ0lDQndiMmx1ZEM1ZmJHOWhaRkpIUWtFb0tUdGNjbHh1SUNBZ0lDQWdJQ0J3YjJsdWRDNWZiRzloWkZGMVlXUnlkWEJzWlhRb0tUdGNjbHh1SUNBZ0lDQWdJQ0F2THlCd2IybHVkQzVmYkc5aFpFeGhZaWdwTzF4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCd2IybHVkRHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJR052Ym5OMGNuVmpkRzl5S0NrZ2UxeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdWRXbHVkRE15SUQwZ0xURWdQajQrSURBN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1eUlEMGdkR2hwY3k1bklEMGdkR2hwY3k1aUlEMGdkR2hwY3k1aElEMGdNRHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbkpuWW1FZ1BTQnVaWGNnUVhKeVlYa29OQ2s3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTV5WjJKaFd6QmRJRDBnTUR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG5KblltRmJNVjBnUFNBd08xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdWNtZGlZVnN5WFNBOUlEQTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NXlaMkpoV3pOZElEMGdNRHRjY2x4dUlDQWdJQ0FnSUNBdktseHlYRzRnSUNBZ0lDQWdJQ0IwYUdsekxreGhZaUE5SUh0Y2NseHVJQ0FnSUNBZ0lDQWdUQ0E2SURBdU1DeGNjbHh1SUNBZ0lDQWdJQ0FnWVNBNklEQXVNQ3hjY2x4dUlDQWdJQ0FnSUNBZ1lpQTZJREF1TUZ4eVhHNGdJQ0FnSUNBZ0lDQjlPMXh5WEc0Z0lDQWdJQ0FnSUNBcUwxeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ1puSnZiU2h3YjJsdWRDa2dlMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjaUE5SUhCdmFXNTBMbkk3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVuSUQwZ2NHOXBiblF1Wnp0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG1JZ1BTQndiMmx1ZEM1aU8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVlTQTlJSEJ2YVc1MExtRTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NTFhVzUwTXpJZ1BTQndiMmx1ZEM1MWFXNTBNekk3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTV5WjJKaFd6QmRJRDBnY0c5cGJuUXVjanRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbkpuWW1GYk1WMGdQU0J3YjJsdWRDNW5PMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjbWRpWVZzeVhTQTlJSEJ2YVc1MExtSTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NXlaMkpoV3pOZElEMGdjRzlwYm5RdVlUdGNjbHh1SUNBZ0lDQWdJQ0F2S2x4eVhHNGdJQ0FnSUNBZ0lDQjBhR2x6TGt4aFlpNU1JRDBnY0c5cGJuUXVUR0ZpTGt3N1hISmNiaUFnSUNBZ0lDQWdJSFJvYVhNdVRHRmlMbUVnUFNCd2IybHVkQzVNWVdJdVlUdGNjbHh1SUNBZ0lDQWdJQ0FnZEdocGN5NU1ZV0l1WWlBOUlIQnZhVzUwTGt4aFlpNWlPMXh5WEc0Z0lDQWdJQ0FnSUNBcUwxeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ0x5cGNjbHh1SUNBZ0lDQXFJRlJQUkU4NlhISmNiaUFnSUNBZ1RIVnRhVzVoYm1ObElHWnliMjBnVWtkQ09seHlYRzRnSUZ4eVhHNGdJQ0FnSUV4MWJXbHVZVzVqWlNBb2MzUmhibVJoY21RZ1ptOXlJR05sY25SaGFXNGdZMjlzYjNWeUlITndZV05sY3lrNklDZ3dMakl4TWpZcVVpQXJJREF1TnpFMU1pcEhJQ3NnTUM0d056SXlLa0lwSUZzeFhWeHlYRzRnSUNBZ0lFeDFiV2x1WVc1alpTQW9jR1Z5WTJWcGRtVmtJRzl3ZEdsdmJpQXhLVG9nS0RBdU1qazVLbElnS3lBd0xqVTROeXBISUNzZ01DNHhNVFFxUWlrZ1d6SmRYSEpjYmlBZ0lDQWdUSFZ0YVc1aGJtTmxJQ2h3WlhKalpXbDJaV1FnYjNCMGFXOXVJRElzSUhOc2IzZGxjaUIwYnlCallXeGpkV3hoZEdVcE9pQWdjM0Z5ZENnZ01DNHlOREVxVWw0eUlDc2dNQzQyT1RFcVIxNHlJQ3NnTUM0d05qZ3FRbDR5SUNrZ1B5QnpjWEowS0NBd0xqSTVPU3BTWGpJZ0t5QXdMalU0TnlwSFhqSWdLeUF3TGpFeE5DcENYaklnS1NBb2RHaGhibXR6SUhSdklFQk5ZWFIwYUdWM1NHVnlZbk4wS1NCYmFIUjBjRG92TDJGc2FXVnVjbmxrWlhKbWJHVjRMbU52YlM5b2MzQXVhSFJ0YkYxY2NseHVJQ0FnSUNBcUwxeHlYRzRnSUNBZ1oyVjBUSFZ0YVc1dmMybDBlU2gxYzJWQmJIQm9ZVU5vWVc1dVpXd3BJSHRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdjaUE5SUhSb2FYTXVjanRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdaeUE5SUhSb2FYTXVaenRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdZaUE5SUhSb2FYTXVZanRjY2x4dUlDQWdJQ0FnSUNCcFppQW9kWE5sUVd4d2FHRkRhR0Z1Ym1Wc0tTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lISWdQU0JOWVhSb0xtMXBiaWd5TlRVc0lESTFOU0F0SUhSb2FYTXVZU0FySUhSb2FYTXVZU0FxSUhJZ0x5QXlOVFVwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JuSUQwZ1RXRjBhQzV0YVc0b01qVTFMQ0F5TlRVZ0xTQjBhR2x6TG1FZ0t5QjBhR2x6TG1FZ0tpQm5JQzhnTWpVMUtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1lpQTlJRTFoZEdndWJXbHVLREkxTlN3Z01qVTFJQzBnZEdocGN5NWhJQ3NnZEdocGN5NWhJQ29nWWlBdklESTFOU2s3WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJQzh2SUhaaGNpQnNkVzFoSUQwZ2RHaHBjeTV5SUNvZ1VHOXBiblF1WDFKRlJGOURUMFZHUmtsRFNVVk9WQ0FySUhSb2FYTXVaeUFxSUZCdmFXNTBMbDlIVWtWRlRsOURUMFZHUmtsRFNVVk9WQ0FySUhSb2FYTXVZaUFxSUZCdmFXNTBMbDlDVEZWRlgwTlBSVVpHU1VOSlJVNVVPMXh5WEc0Z0lDQWdJQ0FnSUM4cVhISmNiaUFnSUNBZ0lDQWdJR2xtS0hWelpVRnNjR2hoUTJoaGJtNWxiQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQnNkVzFoSUQwZ0tHeDFiV0VnS2lBb01qVTFJQzBnZEdocGN5NWhLU2tnTHlBeU5UVTdYSEpjYmlBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQWdLaTljY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnY2lBcUlGa3VVa1ZFSUNzZ1p5QXFJRmt1UjFKRlJVNGdLeUJpSUNvZ1dTNUNURlZGTzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnWDJ4dllXUlZTVTVVTXpJb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NTFhVzUwTXpJZ1BTQW9kR2hwY3k1aElEdzhJREkwSUh3Z2RHaHBjeTVpSUR3OElERTJJSHdnZEdocGN5NW5JRHc4SURnZ2ZDQjBhR2x6TG5JcElENCtQaUF3TzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnWDJ4dllXUlNSMEpCS0NrZ2UxeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdWNpQTlJSFJvYVhNdWRXbHVkRE15SUNZZ01IaG1aanRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbWNnUFNBb2RHaHBjeTUxYVc1ME16SWdQajQrSURncElDWWdNSGhtWmp0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG1JZ1BTQW9kR2hwY3k1MWFXNTBNeklnUGo0K0lERTJLU0FtSURCNFptWTdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWhJRDBnS0hSb2FYTXVkV2x1ZERNeUlENCtQaUF5TkNrZ0ppQXdlR1ptTzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnWDJ4dllXUlJkV0ZrY25Wd2JHVjBLQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11Y21kaVlWc3dYU0E5SUhSb2FYTXVjanRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbkpuWW1GYk1WMGdQU0IwYUdsekxtYzdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NXlaMkpoV3pKZElEMGdkR2hwY3k1aU8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdWNtZGlZVnN6WFNBOUlIUm9hWE11WVR0Y2NseHVJQ0FnSUNBZ0lDQXZLbHh5WEc0Z0lDQWdJQ0FnSUNCMllYSWdlSGw2SUQwZ2NtZGlNbmg1ZWloMGFHbHpMbklzSUhSb2FYTXVaeXdnZEdocGN5NWlLVHRjY2x4dUlDQWdJQ0FnSUNBZ2RtRnlJR3hoWWlBOUlIaDVlakpzWVdJb2VIbDZMbmdzSUhoNWVpNTVMQ0I0ZVhvdWVpazdYSEpjYmlBZ0lDQWdJQ0FnSUhSb2FYTXViR0ZpTG13Z1BTQnNZV0l1YkR0Y2NseHVJQ0FnSUNBZ0lDQWdkR2hwY3k1c1lXSXVZU0E5SUd4aFlpNWhPMXh5WEc0Z0lDQWdJQ0FnSUNCMGFHbHpMbXhoWWk1aUlEMGdiR0ZpTG1JN1hISmNiaUFnSUNBZ0lDQWdJQ292WEhKY2JpQWdJQ0I5WEhKY2JuMWNjbHh1THk4aklITnZkWEpqWlUxaGNIQnBibWRWVWt3OWNHOXBiblF1YW5NdWJXRndJaXdpTHlvcVhISmNiaUFxSUVCd2NtVnpaWEoyWlZ4eVhHNGdLaUJEYjNCNWNtbG5hSFFnTWpBeE5TMHlNREU0SUVsbmIzSWdRbVY2YTNKdmRtNTVhVnh5WEc0Z0tpQkJiR3dnY21sbmFIUnpJSEpsYzJWeWRtVmtMaUFvVFVsVUlFeHBZMlZ1YzJWa0tWeHlYRzRnS2x4eVhHNGdLaUJ3YjJsdWRFTnZiblJoYVc1bGNpNTBjeUF0SUhCaGNuUWdiMllnU1cxaFoyVWdVWFZoYm5ScGVtRjBhVzl1SUV4cFluSmhjbmxjY2x4dUlDb3ZYSEpjYm1sdGNHOXlkQ0I3SUZCdmFXNTBJSDBnWm5KdmJTQW5MaTl3YjJsdWRDYzdYSEpjYmk4cUtseHlYRzRnS2lCMk9DQnZjSFJwYldsNllYUnBiMjV6SUdSdmJtVXVYSEpjYmlBcUlHWnliMjFZV0ZnZ2JXVjBhRzlrY3lCaGNtVWdjM1JoZEdsaklIUnZJRzF2ZG1VZ2IzVjBJSEJ2YkhsdGIzSndhR2xqSUdOdlpHVWdabkp2YlNCamJHRnpjeUJwYm5OMFlXNWpaU0JwZEhObGJHWXVYSEpjYmlBcUwxeHlYRzVsZUhCdmNuUWdZMnhoYzNNZ1VHOXBiblJEYjI1MFlXbHVaWElnZTF4eVhHNGdJQ0FnWTI5dWMzUnlkV04wYjNJb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZkMmxrZEdnZ1BTQXdPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMmhsYVdkb2RDQTlJREE3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVmY0c5cGJuUkJjbkpoZVNBOUlGdGRPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdaMlYwVjJsa2RHZ29LU0I3WEhKY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVYM2RwWkhSb08xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ1oyVjBTR1ZwWjJoMEtDa2dlMXh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxsOW9aV2xuYUhRN1hISmNiaUFnSUNCOVhISmNiaUFnSUNCelpYUlhhV1IwYUNoM2FXUjBhQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDNkcFpIUm9JRDBnZDJsa2RHZzdYSEpjYmlBZ0lDQjlYSEpjYmlBZ0lDQnpaWFJJWldsbmFIUW9hR1ZwWjJoMEtTQjdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZhR1ZwWjJoMElEMGdhR1ZwWjJoME8xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ1oyVjBVRzlwYm5SQmNuSmhlU2dwSUh0Y2NseHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTVmY0c5cGJuUkJjbkpoZVR0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUdOc2IyNWxLQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUdOc2IyNWxJRDBnYm1WM0lGQnZhVzUwUTI5dWRHRnBibVZ5S0NrN1hISmNiaUFnSUNBZ0lDQWdZMnh2Ym1VdVgzZHBaSFJvSUQwZ2RHaHBjeTVmZDJsa2RHZzdYSEpjYmlBZ0lDQWdJQ0FnWTJ4dmJtVXVYMmhsYVdkb2RDQTlJSFJvYVhNdVgyaGxhV2RvZER0Y2NseHVJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTUN3Z2JDQTlJSFJvYVhNdVgzQnZhVzUwUVhKeVlYa3ViR1Z1WjNSb095QnBJRHdnYkRzZ2FTc3JLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR05zYjI1bExsOXdiMmx1ZEVGeWNtRjVXMmxkSUQwZ1VHOXBiblF1WTNKbFlYUmxRbmxWYVc1ME16SW9kR2hwY3k1ZmNHOXBiblJCY25KaGVWdHBYUzUxYVc1ME16SWdmQ0F3S1RzZ0x5OGdYQ0o4SURCY0lpQnBjeUJoWkdSbFpDQm1iM0lnZGpnZ2IzQjBhVzFwZW1GMGFXOXVYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCamJHOXVaVHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJSFJ2VldsdWRETXlRWEp5WVhrb0tTQjdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdiQ0E5SUhSb2FYTXVYM0J2YVc1MFFYSnlZWGt1YkdWdVozUm9PMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSFZwYm5Rek1rRnljbUY1SUQwZ2JtVjNJRlZwYm5Rek1rRnljbUY1S0d3cE8xeHlYRzRnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJR2tnUFNBd095QnBJRHdnYkRzZ2FTc3JLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFZwYm5Rek1rRnljbUY1VzJsZElEMGdkR2hwY3k1ZmNHOXBiblJCY25KaGVWdHBYUzUxYVc1ME16STdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMWFXNTBNekpCY25KaGVUdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lIUnZWV2x1ZERoQmNuSmhlU2dwSUh0Y2NseHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2JtVjNJRlZwYm5RNFFYSnlZWGtvZEdocGN5NTBiMVZwYm5Rek1rRnljbUY1S0NrdVluVm1abVZ5S1R0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhOMFlYUnBZeUJtY205dFNGUk5URWx0WVdkbFJXeGxiV1Z1ZENocGJXY3BJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0IzYVdSMGFDQTlJR2x0Wnk1dVlYUjFjbUZzVjJsa2RHZzdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdhR1ZwWjJoMElEMGdhVzFuTG01aGRIVnlZV3hJWldsbmFIUTdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdZMkZ1ZG1GeklEMGdaRzlqZFcxbGJuUXVZM0psWVhSbFJXeGxiV1Z1ZENnblkyRnVkbUZ6SnlrN1hISmNiaUFnSUNBZ0lDQWdZMkZ1ZG1GekxuZHBaSFJvSUQwZ2QybGtkR2c3WEhKY2JpQWdJQ0FnSUNBZ1kyRnVkbUZ6TG1obGFXZG9kQ0E5SUdobGFXZG9kRHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JqZEhnZ1BTQmpZVzUyWVhNdVoyVjBRMjl1ZEdWNGRDZ25NbVFuS1RzZ0x5OGdkSE5zYVc1ME9tUnBjMkZpYkdVdGJHbHVaVHB1YnkxdWIyNHRiblZzYkMxaGMzTmxjblJwYjI1Y2NseHVJQ0FnSUNBZ0lDQmpkSGd1WkhKaGQwbHRZV2RsS0dsdFp5d2dNQ3dnTUN3Z2QybGtkR2dzSUdobGFXZG9kQ3dnTUN3Z01Dd2dkMmxrZEdnc0lHaGxhV2RvZENrN1hISmNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlGQnZhVzUwUTI5dWRHRnBibVZ5TG1aeWIyMUlWRTFNUTJGdWRtRnpSV3hsYldWdWRDaGpZVzUyWVhNcE8xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ2MzUmhkR2xqSUdaeWIyMUlWRTFNUTJGdWRtRnpSV3hsYldWdWRDaGpZVzUyWVhNcElIdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emRDQjNhV1IwYUNBOUlHTmhiblpoY3k1M2FXUjBhRHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JvWldsbmFIUWdQU0JqWVc1MllYTXVhR1ZwWjJoME8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHTjBlQ0E5SUdOaGJuWmhjeTVuWlhSRGIyNTBaWGgwS0NjeVpDY3BPeUF2THlCMGMyeHBiblE2WkdsellXSnNaUzFzYVc1bE9tNXZMVzV2YmkxdWRXeHNMV0Z6YzJWeWRHbHZibHh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR2x0WjBSaGRHRWdQU0JqZEhndVoyVjBTVzFoWjJWRVlYUmhLREFzSURBc0lIZHBaSFJvTENCb1pXbG5hSFFwTzF4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCUWIybHVkRU52Ym5SaGFXNWxjaTVtY205dFNXMWhaMlZFWVhSaEtHbHRaMFJoZEdFcE8xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ2MzUmhkR2xqSUdaeWIyMUpiV0ZuWlVSaGRHRW9hVzFoWjJWRVlYUmhLU0I3WEhKY2JpQWdJQ0FnSUNBZ1kyOXVjM1FnZDJsa2RHZ2dQU0JwYldGblpVUmhkR0V1ZDJsa2RHZzdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdhR1ZwWjJoMElEMGdhVzFoWjJWRVlYUmhMbWhsYVdkb2REdGNjbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdVRzlwYm5SRGIyNTBZV2x1WlhJdVpuSnZiVlZwYm5RNFFYSnlZWGtvYVcxaFoyVkVZWFJoTG1SaGRHRXNJSGRwWkhSb0xDQm9aV2xuYUhRcE8xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ2MzUmhkR2xqSUdaeWIyMVZhVzUwT0VGeWNtRjVLSFZwYm5RNFFYSnlZWGtzSUhkcFpIUm9MQ0JvWldsbmFIUXBJSHRjY2x4dUlDQWdJQ0FnSUNCemQybDBZMmdnS0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWN1WTJGc2JDaDFhVzUwT0VGeWNtRjVLU2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqWVhObElDZGJiMkpxWldOMElGVnBiblE0UTJ4aGJYQmxaRUZ5Y21GNVhTYzZYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHTmhjMlVnSjF0dlltcGxZM1FnVldsdWREaEJjbkpoZVYwbk9seHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdSbFptRjFiSFE2WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMWFXNTBPRUZ5Y21GNUlEMGdibVYzSUZWcGJuUTRRWEp5WVhrb2RXbHVkRGhCY25KaGVTazdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhWcGJuUXpNa0Z5Y21GNUlEMGdibVYzSUZWcGJuUXpNa0Z5Y21GNUtIVnBiblE0UVhKeVlYa3VZblZtWm1WeUtUdGNjbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdVRzlwYm5SRGIyNTBZV2x1WlhJdVpuSnZiVlZwYm5Rek1rRnljbUY1S0hWcGJuUXpNa0Z5Y21GNUxDQjNhV1IwYUN3Z2FHVnBaMmgwS1R0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhOMFlYUnBZeUJtY205dFZXbHVkRE15UVhKeVlYa29kV2x1ZERNeVFYSnlZWGtzSUhkcFpIUm9MQ0JvWldsbmFIUXBJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JqYjI1MFlXbHVaWElnUFNCdVpYY2dVRzlwYm5SRGIyNTBZV2x1WlhJb0tUdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1MFlXbHVaWEl1WDNkcFpIUm9JRDBnZDJsa2RHZzdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWRHRnBibVZ5TGw5b1pXbG5hSFFnUFNCb1pXbG5hSFE3WEhKY2JpQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREFzSUd3Z1BTQjFhVzUwTXpKQmNuSmhlUzVzWlc1bmRHZzdJR2tnUENCc095QnBLeXNwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWRHRnBibVZ5TGw5d2IybHVkRUZ5Y21GNVcybGRJRDBnVUc5cGJuUXVZM0psWVhSbFFubFZhVzUwTXpJb2RXbHVkRE15UVhKeVlYbGJhVjBnZkNBd0tUc2dMeThnWENKOElEQmNJaUJwY3lCaFpHUmxaQ0JtYjNJZ2RqZ2diM0IwYVcxcGVtRjBhVzl1WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmpiMjUwWVdsdVpYSTdYSEpjYmlBZ0lDQjlYSEpjYmlBZ0lDQnpkR0YwYVdNZ1puSnZiVUoxWm1abGNpaGlkV1ptWlhJc0lIZHBaSFJvTENCb1pXbG5hSFFwSUh0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCMWFXNTBNekpCY25KaGVTQTlJRzVsZHlCVmFXNTBNekpCY25KaGVTaGlkV1ptWlhJdVluVm1abVZ5TENCaWRXWm1aWEl1WW5sMFpVOW1abk5sZEN3Z1luVm1abVZ5TG1KNWRHVk1aVzVuZEdnZ0x5QlZhVzUwTXpKQmNuSmhlUzVDV1ZSRlUxOVFSVkpmUlV4RlRVVk9WQ2s3WEhKY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUZCdmFXNTBRMjl1ZEdGcGJtVnlMbVp5YjIxVmFXNTBNekpCY25KaGVTaDFhVzUwTXpKQmNuSmhlU3dnZDJsa2RHZ3NJR2hsYVdkb2RDazdYSEpjYmlBZ0lDQjlYSEpjYm4xY2NseHVMeThqSUhOdmRYSmpaVTFoY0hCcGJtZFZVa3c5Y0c5cGJuUkRiMjUwWVdsdVpYSXVhbk11YldGd0lpd2laWGh3YjNKMElHTnNZWE56SUZCeWIyZHlaWE56VkhKaFkydGxjaUI3WEhKY2JpQWdJQ0JqYjI1emRISjFZM1J2Y2loMllXeDFaVkpoYm1kbExDQndjbTluY21WemMxSmhibWRsS1NCN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZmNtRnVaMlVnUFNCMllXeDFaVkpoYm1kbE8xeHlYRzRnSUNBZ0lDQWdJSFJvYVhNdVgzQnliMmR5WlhOelVtRnVaMlVnUFNCd2NtOW5jbVZ6YzFKaGJtZGxPMXh5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYM04wWlhBZ1BTQk5ZWFJvTG0xaGVDZ3hMQ0IwYUdsekxsOXlZVzVuWlNBdklDaFFjbTluY21WemMxUnlZV05yWlhJdWMzUmxjSE1nS3lBeEtTQjhJREFwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJ4aGMzUWdQU0F0ZEdocGN5NWZjM1JsY0R0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG5CeWIyZHlaWE56SUQwZ01EdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lITm9iM1ZzWkU1dmRHbG1lU2hqZFhKeVpXNTBLU0I3WEhKY2JpQWdJQ0FnSUNBZ2FXWWdLR04xY25KbGJuUWdMU0IwYUdsekxsOXNZWE4wSUQ0OUlIUm9hWE11WDNOMFpYQXBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZmJHRnpkQ0E5SUdOMWNuSmxiblE3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWNISnZaM0psYzNNZ1BTQk5ZWFJvTG0xcGJpaDBhR2x6TGw5d2NtOW5jbVZ6YzFKaGJtZGxJQ29nZEdocGN5NWZiR0Z6ZENBdklIUm9hWE11WDNKaGJtZGxMQ0IwYUdsekxsOXdjbTluY21WemMxSmhibWRsS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSFJ5ZFdVN1hISmNiaUFnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNVFjbTluY21WemMxUnlZV05yWlhJdWMzUmxjSE1nUFNBeE1EQTdYSEpjYmk4dkl5QnpiM1Z5WTJWTllYQndhVzVuVlZKTVBYQnliMmR5WlhOelZISmhZMnRsY2k1cWN5NXRZWEFpTENKcGJYQnZjblFnZXlCaGNIQnNlVkJoYkdWMGRHVlRlVzVqTENCaWRXbHNaRkJoYkdWMGRHVlRlVzVqTENCMWRHbHNjeUI5SUdaeWIyMGdKMmx0WVdkbExYRW5YRzVjYmk4cUtseHVJQ29nVTJWaGNtTm9aWE1nWm05eUlHRnVJSFZ1ZFhObFpDQmpiMnh2ZFhJZ2FXNGdkR2hsSUdsdFlXZGxJR1JoZEdFZ2MyOGdhWFFnWTJGdUlHSmxJSFZ6WldRZ1lYTWdZU0IxYm1seGRXVWdZMjlzYjNWeVhHNGdLaUJtYjNJZ2RISmhibk53WVhKbGJuUWdjR2w0Wld4ekxpQkNkV2xzWkhNZ2RYQWdZU0J6WlhRZ2IyWWdZV3hzSUd0dWIzZHVJR052Ykc5MWNuTWdkR2hsYmlCelpXRnlZMmhsY3lCbWNtOXRYRzRnS2lBd2VEQXdNREF3TUNCMGJ5QXdlRVpHUmtaR1JpQm1iM0lnWVNCamIyeHZkWElnYm05MElHbHVJSFJvWlNCelpYUXVJRlJvWlhrbmNtVWdhWE1nY0hKdlltRmliSGtnWVNCdGRXTm9JRzF2Y21VZ1pXWm1aV05wWlc1MFhHNGdLaUIzWVhrZ2IyWWdaRzlwYm1jZ2RHaHBjeTRnVkdobGNtVWdhWE1nWVd4emJ5QmhJSEJ2YzNOcFltbHNkSGtnWVd4c0lHTnZiRzkxY25NZ1lYSmxJSFZ6WldRc0lHSjFkQ0IwYUdGMEozTWdjSEp2WW1GaWJIbGNiaUFxSUdwMWMzUWdZU0IwWlhOMElHbHRZV2RsTGx4dUlDb2dRSEJoY21GdElIc3FmU0JrWVhSaFhHNGdLaUJBY0dGeVlXMGdleXA5SUhkcFpIUm9YRzRnS2lCQWNHRnlZVzBnZXlwOUlHaGxhV2RvZEZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJ6WldGeVkyaEdiM0pWYm5WelpXUkRiMnh2ZFhJb1pHRjBZU3dnZDJsa2RHZ3NJR2hsYVdkb2RDa2dlMXh1SUNCc1pYUWdhU0E5SURCY2JpQWdZMjl1YzNRZ2JHVnVaM1JvSUQwZ2QybGtkR2dnS2lCb1pXbG5hSFFnS2lBMFhHNGdJR052Ym5OMElHdHViM2R1UTI5c2IzVnljeUE5SUc1bGR5QlRaWFFvS1Z4dVhHNGdJSGRvYVd4bElDaHBJRHdnYkdWdVozUm9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2NpQTlJR1JoZEdGYmFTc3JYVnh1SUNBZ0lHTnZibk4wSUdjZ1BTQmtZWFJoVzJrcksxMWNiaUFnSUNCamIyNXpkQ0JpSUQwZ1pHRjBZVnRwS3l0ZFhHNGdJQ0FnYVNzcklDOHZJR1J2YmlkMElIUnlZV05ySUhSb1pTQjBjbUZ1YzNCaGNtVnVZM2tnYUdWeVpTQnFkWE4wSUhSb1pTQnlaMklnZG1Gc2RXVnpYRzRnSUNBZ1kyOXVjM1FnY0dsNFpXeERiMnh2ZFhJZ1BTQW9jaUE4UENBeE5pa2dmQ0FvWnlBOFBDQTRLU0I4SUdKY2JpQWdJQ0JyYm05M2JrTnZiRzkxY25NdVlXUmtLSEJwZUdWc1EyOXNiM1Z5S1Z4dUlDQjlYRzVjYmlBZ2JHVjBJSFZ1ZFhObFpFTnZiRzkxY2lBOUlEQjRNREJjYmlBZ2QyaHBiR1VnS0hWdWRYTmxaRU52Ykc5MWNpQThJREI0Wm1abVptWm1LU0I3WEc0Z0lDQWdhV1lnS0NGcmJtOTNia052Ykc5MWNuTXVhR0Z6S0hWdWRYTmxaRU52Ykc5MWNpa3BJR0p5WldGclhHNGdJQ0FnZFc1MWMyVmtRMjlzYjNWeUt5dGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjFiblZ6WldSRGIyeHZkWEpjYm4xY2JseHVablZ1WTNScGIyNGdaR0YwWVZSdlVrZENRVTV2Y20xaGJHbDZaV1FvWEc0Z0lHUmhkR0VzWEc0Z0lIZHBaSFJvTEZ4dUlDQm9aV2xuYUhRc1hHNGdJSFZ1ZFhObFpFTnZiRzkxY2l4Y2JpQWdkSEpoYm5Od1lYSmxibU41UTNWMFQyWm1JRDBnTUM0M1hHNHBJSHRjYmlBZ2JHVjBJR2tnUFNBd1hHNGdJR052Ym5OMElHeGxibWQwYUNBOUlIZHBaSFJvSUNvZ2FHVnBaMmgwSUNvZ05GeHVJQ0JqYjI1emRDQnlaMkpoSUQwZ1cxMWNiaUFnWTI5dWMzUWdkSEpoYm5Od1lYSmxibU41UTNWMFQyWm1WbUZzZFdVZ1BTQk5ZWFJvTG5SeWRXNWpLREkxTlNBcUlIUnlZVzV6Y0dGeVpXNWplVU4xZEU5bVppbGNiaUFnYkdWMElHaGhjMVJ5WVc1emNHRnlaVzVqZVNBOUlHWmhiSE5sWEc1Y2JpQWdZMjl1YzNRZ2RXNTFjMlZrUTI5c2IzVnlVaUE5SUNoMWJuVnpaV1JEYjJ4dmRYSWdKaUF3ZUdabU1EQXdNQ2tnUGo0Z01UWmNiaUFnWTI5dWMzUWdkVzUxYzJWa1EyOXNiM1Z5UnlBOUlDaDFiblZ6WldSRGIyeHZkWElnSmlBd2VEQXdabVl3TUNrZ1BqNGdPRnh1SUNCamIyNXpkQ0IxYm5WelpXUkRiMnh2ZFhKQ0lEMGdkVzUxYzJWa1EyOXNiM1Z5SUNZZ01IZ3dNREF3Wm1aY2JseHVJQ0IzYUdsc1pTQW9hU0E4SUd4bGJtZDBhQ2tnZTF4dUlDQWdJR052Ym5OMElISWdQU0JrWVhSaFcya3JLMTFjYmlBZ0lDQmpiMjV6ZENCbklEMGdaR0YwWVZ0cEt5dGRYRzRnSUNBZ1kyOXVjM1FnWWlBOUlHUmhkR0ZiYVNzclhWeHVJQ0FnSUd4bGRDQmhJRDBnWkdGMFlWdHBLeXRkWEc0Z0lDQWdZU0E5SUdFZ1BqMGdkSEpoYm5Od1lYSmxibU41UTNWMFQyWm1WbUZzZFdVZ1B5QXdlR1ptSURvZ01IZ3dNRnh1WEc0Z0lDQWdhV1lnS0hWdWRYTmxaRU52Ykc5MWNpQWhQVDBnZFc1a1pXWnBibVZrSUNZbUlHRWdQVDA5SURBcElIdGNiaUFnSUNBZ0lISm5ZbUV1Y0hWemFDaDFiblZ6WldSRGIyeHZkWEpTS1Z4dUlDQWdJQ0FnY21kaVlTNXdkWE5vS0hWdWRYTmxaRU52Ykc5MWNrY3BYRzRnSUNBZ0lDQnlaMkpoTG5CMWMyZ29kVzUxYzJWa1EyOXNiM1Z5UWlsY2JpQWdJQ0FnSUhKblltRXVjSFZ6YUNnd2VEQXdLVnh1SUNBZ0lDQWdhR0Z6VkhKaGJuTndZWEpsYm1ONUlEMGdkSEoxWlZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaMkpoTG5CMWMyZ29jaWxjYmlBZ0lDQWdJSEpuWW1FdWNIVnphQ2huS1Z4dUlDQWdJQ0FnY21kaVlTNXdkWE5vS0dJcFhHNGdJQ0FnSUNCeVoySmhMbkIxYzJnb01IaG1aaWxjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdleUJ5WjJKaExDQm9ZWE5VY21GdWMzQmhjbVZ1WTNrZ2ZWeHVmVnh1WEc0dktpcGNiaUFxSUZSaGEyVnpJR0Z1SUdGeWNtRjVJRzltSUhCdmFXNTBjeUJtY205dElHbHRZV2RsTFhFZ1lXNWtJR052Ym5abGNuUnpJSFJvWlcwZ2RHOGdZVzRnWVhKeVlYa2diMllnYzI5eWRHVmtJSEpuWWlCMllXeDFaWE5jYmlBcUlFQndZWEpoYlNCN1FYSnlZWGxiVUc5cGJuUnpYWDBnY0c5cGJuUnpYRzRnS2lCeVpYUjFjbTV6SUh0QmNuSmhlWDFjYmlBcUwxeHVablZ1WTNScGIyNGdjRzlwYm5SelZHOVNaMklvY0c5cGJuUnpLU0I3WEc0Z0lISmxkSFZ5YmlCd2IybHVkSE11YldGd0tIQnZhVzUwSUQwK0lDaHdiMmx1ZEM1eUlEdzhJREUyS1NCOElDaHdiMmx1ZEM1bklEdzhJRGdwSUh3Z2NHOXBiblF1WWlsY2JuMWNibHh1THlvcVhHNGdLaUJBY0dGeVlXMGdlMVZwYm5Rek1rRnljbUY1ZlNCd2FYaGxiSE5jYmlBcUlFQndZWEpoYlNCN1ZXbHVkRE15UVhKeVlYbDlJSEJoYkdWMGRHVmNiaUFxSUVCeVpYUjFjbTV6SUh0VmFXNTBPRUZ5Y21GNWZWeHVJQ292WEc1bWRXNWpkR2x2YmlCcGJtUmxlRkJwZUdWc2MxZHBkR2hRWVd4bGRIUmxLSEJwZUdWc2N5d2djR0ZzWlhSMFpTa2dlMXh1SUNCeVpYUjFjbTRnVldsdWREaEJjbkpoZVM1bWNtOXRLSEJwZUdWc2N5NXRZWEFvY0dsNFpXd2dQVDRnY0dGc1pYUjBaUzVwYm1SbGVFOW1LSEJwZUdWc0tTa3BYRzU5WEc1Y2JtWjFibU4wYVc5dUlIQnliMk5sYzNOR2NtRnRaVmRwZEdoUmRXRnVkR2w2WlhJb1hHNGdJR2x0WVdkbFJHRjBZU3hjYmlBZ2QybGtkR2dzWEc0Z0lHaGxhV2RvZEN4Y2JpQWdkSEpoYm5Od1lYSmxibU41UTNWMFQyWm1MRnh1SUNCa2FYUm9aWEpwYm1kY2Jpa2dlMXh1SUNCamIyNXpkQ0IxYm5WelpXUkRiMnh2ZFhJZ1BTQnpaV0Z5WTJoR2IzSlZiblZ6WldSRGIyeHZkWElvYVcxaFoyVkVZWFJoTENCM2FXUjBhQ3dnYUdWcFoyaDBLVnh1SUNCamIyNXpkQ0I3SUhKblltRXNJR2hoYzFSeVlXNXpjR0Z5Wlc1amVTQjlJRDBnWkdGMFlWUnZVa2RDUVU1dmNtMWhiR2w2WldRb1hHNGdJQ0FnYVcxaFoyVkVZWFJoTEZ4dUlDQWdJSGRwWkhSb0xGeHVJQ0FnSUdobGFXZG9kQ3hjYmlBZ0lDQjFiblZ6WldSRGIyeHZkWElzWEc0Z0lDQWdkSEpoYm5Od1lYSmxibU41UTNWMFQyWm1YRzRnSUNsY2JseHVJQ0JqYjI1emRDQndiMmx1ZEVOdmJuUmhhVzVsY2lBOUlIVjBhV3h6TGxCdmFXNTBRMjl1ZEdGcGJtVnlMbVp5YjIxVmFXNTBPRUZ5Y21GNUtGeHVJQ0FnSUc1bGR5QlZhVzUwT0VGeWNtRjVLSEpuWW1FcExGeHVJQ0FnSUhkcFpIUm9MRnh1SUNBZ0lHaGxhV2RvZEZ4dUlDQXBYRzRnSUdOdmJuTjBJSEJoYkdWMGRHVWdQU0JpZFdsc1pGQmhiR1YwZEdWVGVXNWpLRnR3YjJsdWRFTnZiblJoYVc1bGNsMHNJSHRjYmlBZ0lDQndZV3hsZEhSbFVYVmhiblJwZW1GMGFXOXVPaUFuY21kaWNYVmhiblFuTEZ4dUlDQWdJR052Ykc5eWN6b2dhR0Z6VkhKaGJuTndZWEpsYm1ONUlDWW1JSFZ1ZFhObFpFTnZiRzkxY2lBL0lESTFOU0E2SURJMU5pd2dMeThnYkdWaGRtVWdiMjVsSUdadmNpQjBjbUZ1YzNCaGNtVnVZM2xjYmlBZ2ZTbGNiaUFnYVdZZ0tHaGhjMVJ5WVc1emNHRnlaVzVqZVNBbUppQjFiblZ6WldSRGIyeHZkWElwSUh0Y2JpQWdJQ0J3WVd4bGRIUmxMbUZrWkNoMWRHbHNjeTVRYjJsdWRDNWpjbVZoZEdWQ2VWVnBiblF6TWloMWJuVnpaV1JEYjJ4dmRYSXBLVnh1SUNCOVhHNGdJR052Ym5OMElHOTFkRkJ2YVc1MFEyOXVkR0ZwYm1WeUlEMGdZWEJ3YkhsUVlXeGxkSFJsVTNsdVl5aHdiMmx1ZEVOdmJuUmhhVzVsY2l3Z2NHRnNaWFIwWlN3Z2UxeHVJQ0FnSUdsdFlXZGxVWFZoYm5ScGVtRjBhVzl1T2lCa2FYUm9aWEpwYm1jc1hHNGdJSDBwWEc0Z0lHTnZibk4wSUhCaGJHVjBkR1ZTWjJKQmNuSmhlU0E5SUhCdmFXNTBjMVJ2VW1kaUtGeHVJQ0FnSUhCaGJHVjBkR1V1WjJWMFVHOXBiblJEYjI1MFlXbHVaWElvS1M1blpYUlFiMmx1ZEVGeWNtRjVLQ2xjYmlBZ0tWeHVJQ0J3WVd4bGRIUmxVbWRpUVhKeVlYa3VjMjl5ZENnb1lTd2dZaWtnUFQ0Z1lTQXRJR0lwWEc0Z0lHTnZibk4wSUhSeVlXNXpjR0Z5Wlc1amVVbHVaR1Y0SUQwZ2NHRnNaWFIwWlZKbllrRnljbUY1TG1sdVpHVjRUMllvZFc1MWMyVmtRMjlzYjNWeUtWeHVYRzRnSUdOdmJuTjBJR2x1WkdWNFpXUlFhWGhsYkhNZ1BTQnBibVJsZUZCcGVHVnNjMWRwZEdoUVlXeGxkSFJsS0Z4dUlDQWdJSEJ2YVc1MGMxUnZVbWRpS0c5MWRGQnZhVzUwUTI5dWRHRnBibVZ5TG1kbGRGQnZhVzUwUVhKeVlYa29LU2tzWEc0Z0lDQWdjR0ZzWlhSMFpWSm5Za0Z5Y21GNVhHNGdJQ2xjYmx4dUlDQnlaWFIxY200Z2UxeHVJQ0FnSUhCcGVHVnNjem9nYVc1a1pYaGxaRkJwZUdWc2N5eGNiaUFnSUNCd1lXeGxkSFJsT2lCQmNuSmhlUzVtY205dEtIQmhiR1YwZEdWU1oySkJjbkpoZVNrc1hHNGdJQ0FnZEhKaGJuTndZWEpsYm1ONVNXNWtaWGc2SUhSeVlXNXpjR0Z5Wlc1amVVbHVaR1Y0SUQ0Z0xURWdQeUIwY21GdWMzQmhjbVZ1WTNsSmJtUmxlQ0E2SUhWdVpHVm1hVzVsWkN4Y2JpQWdmVnh1ZlZ4dVhHNHZMeUIrZm41Y2JseHVablZ1WTNScGIyNGdjblZ1S0daeVlXMWxLU0I3WEc0Z0lHTnZibk4wSUhzZ2QybGtkR2dzSUdobGFXZG9kQ3dnWkdGMFlTd2daR2wwYUdWeWFXNW5MQ0IwY21GdWMzQmhjbVZ1WTNsRGRYUlBabVlnZlNBOUlHWnlZVzFsWEc1Y2JpQWdjbVYwZFhKdUlIQnliMk5sYzNOR2NtRnRaVmRwZEdoUmRXRnVkR2w2WlhJb1hHNGdJQ0FnWkdGMFlTeGNiaUFnSUNCM2FXUjBhQ3hjYmlBZ0lDQm9aV2xuYUhRc1hHNGdJQ0FnZEhKaGJuTndZWEpsYm1ONVEzVjBUMlptTEZ4dUlDQWdJR1JwZEdobGNtbHVaMXh1SUNBcFhHNTlYRzVjYm5ObGJHWXViMjV0WlhOellXZGxJRDBnWm5WdVkzUnBiMjRvWlhZcElIdGNiaUFnZG1GeUlHUmhkR0VnUFNCbGRpNWtZWFJoWEc0Z0lIWmhjaUJ5WlhOd2IyNXpaU0E5SUhKMWJpaGtZWFJoS1Z4dUlDQndiM04wVFdWemMyRm5aU2h5WlhOd2IyNXpaU2xjYm4xY2JpSmRMQ0p6YjNWeVkyVlNiMjkwSWpvaUluMD1cIiwgbnVsbCk7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=